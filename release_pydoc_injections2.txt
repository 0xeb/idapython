Help on function auto_apply_tail in module ida_auto:

auto_apply_tail(*args)
    Plan to apply the tail_ea chunk to the parent
    
    auto_apply_tail(tail_ea, parent_ea)
        @param tail_ea: linear address of start of tail (C++: ea_t)
        @param parent_ea: linear address within parent. If BADADDR,
                          automatically try to find parent via xrefs. (C++:
                          ea_t)

Help on function auto_apply_type in module ida_auto:

auto_apply_type(*args)
    Plan to apply the callee's type to the calling point.
    
    auto_apply_type(caller, callee)
        @param caller (C++: ea_t)
        @param callee (C++: ea_t)

Help on function auto_cancel in module ida_auto:

auto_cancel(*args)
    Remove an address range (ea1..ea2) from queues 'AU_CODE' , 'AU_PROC' ,
    'AU_USED' . To remove an address range from other queues use
    'auto_unmark()' function. 'ea1' may be higher than 'ea2', the kernel
    will swap them in this case. 'ea2' doesn't belong to the range.
    
    auto_cancel(ea1, ea2)
        @param ea1 (C++: ea_t)
        @param ea2 (C++: ea_t)

Help on class auto_display_t in module ida_auto:

class auto_display_t(__builtin__.object)
 |  Proxy of C++ auto_display_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> auto_display_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      auto_display_t_ea_get(self) -> ea_t
 |  
 |  state
 |      auto_display_t_state_get(self) -> idastate_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      auto_display_t_type_get(self) -> atype_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_auto_display_t>
 |      delete_auto_display_t(self)

Help on function auto_get in module ida_auto:

auto_get(*args)
    Retrieve an address from queues regarding their priority. Returns
    'BADADDR' if no addresses not lower than 'lowEA' and less than
    'highEA' are found in the queues. Otherwise *type will have queue
    type.
    
    auto_get(type, lowEA, highEA) -> ea_t
        @param type (C++: atype_t  *)
        @param lowEA (C++: ea_t)
        @param highEA (C++: ea_t)

Help on function auto_is_ok in module ida_auto:

auto_is_ok(*args)
    Are all queues empty? (i.e. has autoanalysis finished?).

Help on function auto_make_code in module ida_auto:

auto_make_code(*args)
    Plan to make code.
    
    auto_make_code(ea)
        @param ea (C++: ea_t)

Help on function auto_make_proc in module ida_auto:

auto_make_proc(*args)
    Plan to make code&function.
    
    auto_make_proc(ea)
        @param ea (C++: ea_t)

Help on function auto_make_step in module ida_auto:

auto_make_step(*args)
    Analyze one address in the specified range and return true.
    
    auto_make_step(ea1, ea2) -> bool
        @param ea1 (C++: ea_t)
        @param ea2 (C++: ea_t)
        @return: if processed anything. false means that there is nothing to
                 process in the specified range.

Help on function auto_mark in module ida_auto:

auto_mark(*args)
    Put single address into a queue. Queues keep addresses sorted.
    
    auto_mark(ea, type)
        @param ea (C++: ea_t)
        @param type (C++: atype_t)

Help on function auto_mark_range in module ida_auto:

auto_mark_range(*args)
    Put range of addresses into a queue. 'start' may be higher than 'end',
    the kernel will swap them in this case. 'end' doesn't belong to the
    range.
    
    auto_mark_range(start, end, type)
        @param start (C++: ea_t)
        @param end (C++: ea_t)
        @param type (C++: atype_t)

Help on function auto_recreate_insn in module ida_auto:

auto_recreate_insn(*args)
    Try to create instruction
    
    auto_recreate_insn(ea) -> int
        @param ea: linear address of callee (C++: ea_t)
        @return: the length of the instruction or 0

Help on function auto_unmark in module ida_auto:

auto_unmark(*args)
    Remove range of addresses from a queue. 'start' may be higher than
    'end', the kernel will swap them in this case. 'end' doesn't belong to
    the range.
    
    auto_unmark(start, end, type)
        @param start (C++: ea_t)
        @param end (C++: ea_t)
        @param type (C++: atype_t)

Help on function auto_wait in module ida_auto:

auto_wait(*args)
    Process everything in the queues and return true.

Help on function auto_wait_range in module ida_auto:

auto_wait_range(*args)
    Process everything in the specified range and return true.
    
    auto_wait_range(ea1, ea2) -> ssize_t
        @param ea1 (C++: ea_t)
        @param ea2 (C++: ea_t)
        @return: number of autoanalysis steps made. -1 if the user clicked
                 cancel. (the wait box must be displayed by the caller if
                 desired)

Help on function enable_auto in module ida_auto:

enable_auto(*args)
    Temporarily enable/disable autoanalyzer. Not user-facing, but rather
    because IDA sometimes need to turn AA on/off regardless of
    inf.s_genflags:INFFL_AUTO
    
    enable_auto(enable) -> bool
        @param enable (C++: bool)
        @return: old state

Help on function get_auto_display in module ida_auto:

get_auto_display(*args)
    Get structure which holds the autoanalysis indicator contents.
    
    get_auto_display(auto_display) -> bool
        @param auto_display (C++: auto_display_t  *)

Help on function get_auto_state in module ida_auto:

get_auto_state(*args)
    Get current state of autoanalyzer. If auto_state == 'AU_NONE' , IDA is
    currently not running the analysis (it could be temporarily
    interrupted to perform the user's requests, for example).

Help on function is_auto_enabled in module ida_auto:

is_auto_enabled(*args)
    Get autoanalyzer state.

Help on function may_create_stkvars in module ida_auto:

may_create_stkvars(*args)
    Is it allowed to create stack variables automatically?. This function
    should be used by IDP modules before creating stack vars.

Help on function may_trace_sp in module ida_auto:

may_trace_sp(*args)
    Is it allowed to trace stack pointer automatically?. This function
    should be used by IDP modules before tracing sp.

Help on function peek_auto_queue in module ida_auto:

peek_auto_queue(*args)
    Peek into a queue 'type' for an address not lower than 'low_ea'. Do
    not remove address from the queue.
    
    peek_auto_queue(low_ea, type) -> ea_t
        @param low_ea (C++: ea_t)
        @param type (C++: atype_t)
        @return: the address or  BADADDR

Help on function plan_and_wait in module ida_auto:

plan_and_wait(*args)
    Analyze the specified range. Try to create instructions where
    possible. Make the final pass over the specified range if specified.
    This function doesn't return until the range is analyzed.
    
    plan_and_wait(ea1, ea2, final_pass=True) -> int
        @param ea1 (C++: ea_t)
        @param ea2 (C++: ea_t)
        @param final_pass (C++: bool)
        @retval: 1 - ok
        @retval: 0 - Ctrl-Break was pressed

Help on function plan_ea in module ida_auto:

plan_ea(*args)
    Plan to perform reanalysis.
    
    plan_ea(ea)
        @param ea (C++: ea_t)

Help on function plan_range in module ida_auto:

plan_range(*args)
    Plan to perform reanalysis.
    
    plan_range(sEA, eEA)
        @param sEA (C++: ea_t)
        @param eEA (C++: ea_t)

Help on function reanalyze_callers in module ida_auto:

reanalyze_callers(*args)
    Plan to reanalyze callers of the specified address. This function will
    add to 'AU_USED' queue all instructions that call (not jump to) the
    specified address.
    
    reanalyze_callers(ea, noret)
        @param ea: linear address of callee (C++: ea_t)
        @param noret: !=0: the callee doesn't return, mark to undefine
                      subsequent instructions in the caller. 0: do nothing.
                      (C++: bool)

Help on function revert_ida_decisions in module ida_auto:

revert_ida_decisions(*args)
    Delete all analysis info that IDA generated for for the given range.
    
    revert_ida_decisions(ea1, ea2)
        @param ea1 (C++: ea_t)
        @param ea2 (C++: ea_t)

Help on function set_auto_state in module ida_auto:

set_auto_state(*args)
    Set current state of autoanalyzer.
    
    set_auto_state(new_state) -> atype_t
        @param new_state: new state of autoanalyzer (C++: atype_t)
        @return: previous state

Help on function set_ida_state in module ida_auto:

set_ida_state(*args)
    Change IDA status indicator value
    
    set_ida_state(st) -> idastate_t
        @param st: - new indicator status (C++: idastate_t)
        @return: old indicator status

Help on function show_addr in module ida_auto:

show_addr(*args)
    Show an address on the autoanalysis indicator. The address is
    displayed in the form " @:12345678".
    
    show_addr(ea)
        @param ea: - linear address to display (C++: ea_t)

Help on function show_auto in module ida_auto:

show_auto(*args)
    Change autoanalysis indicator value.
    
    show_auto(ea, type=AU_NONE)
        @param ea: linear address being analyzed (C++: ea_t)
        @param type: autoanalysis type (see  Autoanalysis queues ) (C++:
                     atype_t)

Help on class bitrange_t in module ida_bitrange:

class bitrange_t(__builtin__.object)
 |  Proxy of C++ bitrange_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: bitrange_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: bitrange_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: bitrange_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, bit_ofs=0, size_in_bits=0) -> bitrange_t
 |          bit_ofs: uint16
 |          size_in_bits: uint16
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: bitrange_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: bitrange_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: bitrange_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args)
 |      __str__(self) -> qstring
 |  
 |  apply_mask(self, *args)
 |      Apply mask to a bitrange
 |      
 |      apply_mask(self, subrange) -> bool
 |          @param subrange: range  inside  the main bitrange to keep After this
 |                           operation the main bitrange will be truncated to have
 |                           only the bits that are specified by subrange.
 |                           Example: [off=8,nbits=4], subrange[off=1,nbits=2] =>
 |                           [off=9,nbits=2] (C++: const  bitrange_t  &)
 |          @return: success
 |  
 |  bitoff(self, *args)
 |      Get offset of 1st bit.
 |  
 |  bitsize(self, *args)
 |      Get size of the value in bits.
 |  
 |  bytesize(self, *args)
 |      Size of the value in bytes.
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: bitrange_t const &
 |  
 |  create_union(self, *args)
 |      Create union of 2 ranges including the hole between them.
 |      
 |      create_union(self, r)
 |          @param r (C++: const  bitrange_t  &)
 |  
 |  empty(self, *args)
 |      Is the bitrange empty?
 |  
 |  extract(self, *args)
 |      extract(self, src, is_mf) -> bool
 |          src: void const *
 |          is_mf: bool
 |  
 |  has_common(self, *args)
 |      Does have common bits with another bitrange?
 |      
 |      has_common(self, r) -> bool
 |          @param r (C++: const  bitrange_t  &)
 |  
 |  init(self, *args)
 |      Initialize offset and size to given values.
 |      
 |      init(self, bit_ofs, size_in_bits)
 |          @param bit_ofs (C++: uint16)
 |          @param size_in_bits (C++: uint16)
 |  
 |  inject(self, *args)
 |      inject(self, dst, src, is_mf) -> bool
 |          dst: void *
 |          src: bytevec_t const &
 |          is_mf: bool
 |  
 |  intersect(self, *args)
 |      Intersect two ranges.
 |      
 |      intersect(self, r)
 |          @param r (C++: const  bitrange_t  &)
 |  
 |  mask64(self, *args)
 |      Convert to mask of 64 bits.
 |  
 |  reset(self, *args)
 |      Make the bitrange empty.
 |  
 |  shift_down(self, *args)
 |      Shift range down (left)
 |      
 |      shift_down(self, cnt)
 |          @param cnt (C++: uint)
 |  
 |  shift_up(self, *args)
 |      Shift range up (right)
 |      
 |      shift_up(self, cnt)
 |          @param cnt (C++: uint)
 |  
 |  sub(self, *args)
 |      Subtract a bitrange.
 |      
 |      sub(self, r) -> bool
 |          @param r (C++: const  bitrange_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_bitrange_t>
 |      delete_bitrange_t(self)

Help on function __walk_types_and_formats in module ida_bytes:

__walk_types_and_formats(formats, type_action, format_action, installing)
    # -----------------------------------------------------------------------

Help on function add_byte in module ida_bytes:

add_byte(*args)
    Add a value to one byte of the program. This function works for wide
    byte processors too.
    
    add_byte(ea, value)
        @param ea: linear address (C++: ea_t)
        @param value: byte value (C++: uint32)

Help on function add_dword in module ida_bytes:

add_dword(*args)
    Add a value to one dword of the program. This function works for wide
    byte processors too. This function takes into account order of bytes
    specified in \inf{is_be()}this function works incorrectly if
    \ph{nbits} > 16
    
    add_dword(ea, value)
        @param ea: linear address (C++: ea_t)
        @param value: byte value (C++: uint64)

Help on function add_hidden_range in module ida_bytes:

add_hidden_range(*args)
    Mark a range of addresses as hidden. The range will be created in the
    invisible state with the default color
    
    add_hidden_range(ea1, ea2, description, header, footer, color) -> bool
        @param ea1: linear address of start of the address range (C++: ea_t)
        @param ea2: linear address of end of the address range (C++: ea_t)
        @param description: range parameters (C++: const char *)
        @param header: range parameters (C++: const char *)
        @param footer: range parameters (C++: const char *)
        @param color (C++: bgcolor_t)
        @return: success

Help on function add_mapping in module ida_bytes:

add_mapping(*args)
    IDA supports memory mapping. References to the addresses from the
    mapped range use data and meta-data from the mapping range.You should
    set flag PR2_MAPPING in ph.flag2 to use memory mapping Add memory
    mapping range.
    
    add_mapping(_from, to, size) -> bool
        @param _from: start of the mapped range (nonexistent address) (C++:
                      ea_t)
        @param to: start of the mapping range (existent address) (C++: ea_t)
        @param size: size of the range (C++: asize_t)
        @return: success

Help on function add_qword in module ida_bytes:

add_qword(*args)
    Add a value to one qword of the program. This function does not work
    for wide byte processors. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    add_qword(ea, value)
        @param ea: linear address (C++: ea_t)
        @param value: byte value (C++: uint64)

Help on function add_word in module ida_bytes:

add_word(*args)
    Add a value to one word of the program. This function works for wide
    byte processors too. This function takes into account order of bytes
    specified in \inf{is_be()}
    
    add_word(ea, value)
        @param ea: linear address (C++: ea_t)
        @param value: byte value (C++: uint64)

Help on function align_flag in module ida_bytes:

align_flag(*args)
    Get a flags_t representing an alignment directive.

Help on function append_cmt in module ida_bytes:

append_cmt(*args)
    Append to an indented comment. Creates a new comment if none exists.
    Appends a newline character and the specified string otherwise.
    
    append_cmt(ea, str, rptble) -> bool
        @param ea: linear address (C++: ea_t)
        @param str: comment string to append (C++: const char *)
        @param rptble: append to repeatable comment? (C++: bool)
        @return: success

Help on function attach_custom_data_format in module ida_bytes:

attach_custom_data_format(*args)
    Attach the data format to the data type.
    
    attach_custom_data_format(dtid, dfid) -> bool
        @param dtid: data type id that can use the data format. 0 means all
                     standard data types. Such data formats can be applied to
                     any data item or instruction operands. For instruction
                     operands, the  data_format_t::value_size  check is not
                     performed by the kernel. (C++: int)
        @param dfid: data format id (C++: int)
        @retval: true - ok
        @retval: false - no such  dtid , or no such  dfid , or the data format
                         has already been attached to the data type

Help on function bin_flag in module ida_bytes:

bin_flag(*args)
    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'

Help on function bin_search in module ida_bytes:

bin_search(*args)
    bin_search(start_ea, end_ea, image, imask, step, flags) -> ea_t
        start_ea: ea_t
        end_ea: ea_t
        image: bytevec_t const &
        imask: bytevec_t const &
        step: int
        flags: int

Help on function byte_flag in module ida_bytes:

byte_flag(*args)
    Get a flags_t representing a byte.

Help on function bytesize in module ida_bytes:

bytesize(*args)
    Get number of bytes required to store a byte at the given address.
    
    bytesize(ea) -> int
        @param ea (C++: ea_t)

Help on function calc_def_align in module ida_bytes:

calc_def_align(*args)
    Calculate default alignment.
    
    calc_def_align(ea, mina, maxa) -> int
        @param ea (C++: ea_t)
        @param mina (C++: int)
        @param maxa (C++: int)

Help on function calc_dflags in module ida_bytes:

calc_dflags(*args)
    calc_dflags(f, force) -> flags_t
        @param f (C++: flags_t)
        @param force (C++: bool)

Help on function calc_max_align in module ida_bytes:

calc_max_align(*args)
    Returns: 0..32.
    
    calc_max_align(endea) -> int
        @param endea (C++: ea_t)

Help on function calc_max_item_end in module ida_bytes:

calc_max_item_end(*args)
    Calculate maximal reasonable end address of a new item. This function
    will limit the item with the current segment bounds.
    
    calc_max_item_end(ea, how=15) -> ea_t
        @param ea: linear address (C++: ea_t)
        @param how: when to stop the search. A combination of  Item end search
                    flags (C++: int)
        @return: end of new item. If it is not possible to create an item, it
                 will return 'ea'.

Help on function calc_min_align in module ida_bytes:

calc_min_align(*args)
    Returns: 1..32.
    
    calc_min_align(length) -> int
        @param length (C++: asize_t)

Help on function can_define_item in module ida_bytes:

can_define_item(*args)
    Can define item (instruction/data) of the specified 'length', starting
    at 'ea'?if there is an item starting at 'ea', this function ignores
    itthis function converts to unexplored all encountered data items with
    fixup information. Should be fixed in the future.a new item would
    cross segment boundariesa new item would overlap with existing items
    (except items specified by 'flags')
    
    can_define_item(ea, length, flags) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param flags: if not 0, then the kernel will ignore the data types
                      specified by the flags and destroy them. For example:
                      1000 dw 5                  1002 db 5 ; undef
                      1003 db 5 ; undef                  1004 dw 5
                      1006 dd 5                    can_define_item(1000, 6, 0)
                      - false because of dw at 1004    can_define_item(1000,
                      6, word_flag()) - true, word at 1004 is destroyed (C++:
                      flags_t)
        @return: 1-yes, 0-no

Help on function change_storage_type in module ida_bytes:

change_storage_type(*args)
    Change flag storage type for address range.
    
    change_storage_type(start_ea, end_ea, stt) -> error_t
        @param start_ea: should be lower than end_ea. (C++: ea_t)
        @param end_ea: does not belong to the range. (C++: ea_t)
        @param stt: storage_type_t (C++: storage_type_t)
        @return: error code

Help on function char_flag in module ida_bytes:

char_flag(*args)
    see 'Bits: instruction operand types'

Help on function chunk_size in module ida_bytes:

chunk_size(*args)
    Get size of the contiguous address block containing 'ea'.
    
    chunk_size(ea) -> asize_t
        @param ea (C++: ea_t)
        @return: 0 if 'ea' doesn't belong to the program.

Help on function chunk_start in module ida_bytes:

chunk_start(*args)
    Get start of the contiguous address block containing 'ea'.
    
    chunk_start(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if 'ea' doesn't belong to the program.

Help on function clr_lzero in module ida_bytes:

clr_lzero(*args)
    Clear lzero bit.
    
    clr_lzero(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function clr_op_type in module ida_bytes:

clr_op_type(*args)
    Remove operand representation information. (set operand representation
    to be 'undefined')
    
    clr_op_type(ea, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: success

Help on function code_flag in module ida_bytes:

code_flag(*args)
    'FF_CODE'

Help on function create_16bit_data in module ida_bytes:

create_16bit_data(*args)
    Convert to 16-bit quantity (take byte size into account)
    
    create_16bit_data(ea, length) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)

Help on function create_32bit_data in module ida_bytes:

create_32bit_data(*args)
    Convert to 32-bit quantity (take byte size into account)
    
    create_32bit_data(ea, length) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)

Help on function create_align in module ida_bytes:

create_align(*args)
    Alignment: 0 or 2..32. If it is 0, is will be calculated.
    
    create_align(ea, length, alignment) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param alignment (C++: int)

Help on function create_byte in module ida_bytes:

create_byte(*args)
    Convert to byte.
    
    create_byte(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function create_custdata in module ida_bytes:

create_custdata(*args)
    Convert to custom data type.
    
    create_custdata(ea, length, dtid, fid, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param dtid (C++: int)
        @param fid (C++: int)
        @param force (C++: bool)

Help on function create_data in module ida_bytes:

create_data(*args)
    Convert to data (byte, word, dword, etc). This function may be used to
    create arrays.
    
    create_data(ea, dataflag, size, tid) -> bool
        @param ea: linear address (C++: ea_t)
        @param dataflag: type of data. Value of function  byte_flag() ,
                         word_flag() , etc. (C++: flags_t)
        @param size: size of array in bytes. should be divisible by the size
                     of one item of the specified type. for variable sized
                     items it can be specified as 0, and the kernel will try
                     to calculate the size. (C++: asize_t)
        @param tid: type id. If the specified type is a structure, then tid is
                    structure id. Otherwise should be  BADNODE . (C++: tid_t)
        @return: success

Help on function create_double in module ida_bytes:

create_double(*args)
    Convert to double.
    
    create_double(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function create_dword in module ida_bytes:

create_dword(*args)
    Convert to dword.
    
    create_dword(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function create_float in module ida_bytes:

create_float(*args)
    Convert to float.
    
    create_float(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function create_oword in module ida_bytes:

create_oword(*args)
    Convert to octaword/xmm word.
    
    create_oword(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function create_packed_real in module ida_bytes:

create_packed_real(*args)
    Convert to packed decimal real.
    
    create_packed_real(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function create_qword in module ida_bytes:

create_qword(*args)
    Convert to quadword.
    
    create_qword(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function create_strlit in module ida_bytes:

create_strlit(*args)
    Convert to string literal and give a meaningful name. 'start' may be
    higher than 'end', the kernel will swap them in this case
    
    create_strlit(start, len, strtype) -> bool
        @param start: starting address (C++: ea_t)
        @param len: length of the string in bytes. if 0, then
                    get_max_strlit_length()  will be used to determine the
                    length (C++: size_t)
        @param strtype: string type. one of  String type codes (C++: int32)
        @return: success

Help on function create_struct in module ida_bytes:

create_struct(*args)
    Convert to struct.
    
    create_struct(ea, length, tid, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param tid (C++: tid_t)
        @param force (C++: bool)

Help on function create_tbyte in module ida_bytes:

create_tbyte(*args)
    Convert to tbyte.
    
    create_tbyte(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function create_word in module ida_bytes:

create_word(*args)
    Convert to word.
    
    create_word(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function create_yword in module ida_bytes:

create_yword(*args)
    Convert to ymm word.
    
    create_yword(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function create_zword in module ida_bytes:

create_zword(*args)
    Convert to zmm word.
    
    create_zword(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)

Help on function cust_flag in module ida_bytes:

cust_flag(*args)
    Get a flags_t representing custom type data.

Help on function custfmt_flag in module ida_bytes:

custfmt_flag(*args)
    see 'Bits: instruction operand types'

Help on class data_format_t in module ida_bytes:

class data_format_t(__builtin__.object)
 |  Proxy of C++ data_format_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |  
 |  __real__init__ = __init__(self, *args)
 |      __init__(self, _self, name, value_size=0, menu_name=None, props=0, hotkey=None, text_width=0) -> data_format_t
 |          self: PyObject *
 |          name: char const *
 |          value_size: asize_t
 |          menu_name: char const *
 |          props: int
 |          hotkey: char const *
 |          text_width: int32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _data_format_t__get_id = __get_id(self, *args)
 |      __get_id(self) -> int
 |  
 |  is_present_in_menus(self, *args)
 |      Should this format be shown in UI menus
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hotkey
 |      data_format_t_hotkey_get(self) -> char const *
 |  
 |  id
 |      __get_id(self) -> int
 |  
 |  menu_name
 |      data_format_t_menu_name_get(self) -> char const *
 |  
 |  name
 |      data_format_t_name_get(self) -> char const *
 |  
 |  props
 |      data_format_t_props_get(self) -> int
 |  
 |  text_width
 |      data_format_t_text_width_get(self) -> int32
 |  
 |  thisown
 |      The membership flag
 |  
 |  value_size
 |      data_format_t_value_size_get(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_data_format_t>
 |      delete_data_format_t(self)

Help on class data_type_t in module ida_bytes:

class data_type_t(__builtin__.object)
 |  Proxy of C++ data_type_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |  
 |  __real__init__ = __init__(self, *args)
 |      __init__(self, _self, name, value_size=0, menu_name=None, hotkey=None, asm_keyword=None, props=0) -> data_type_t
 |          self: PyObject *
 |          name: char const *
 |          value_size: asize_t
 |          menu_name: char const *
 |          hotkey: char const *
 |          asm_keyword: char const *
 |          props: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _data_type_t__get_id = __get_id(self, *args)
 |      __get_id(self) -> int
 |  
 |  is_present_in_menus(self, *args)
 |      Should this type be shown in UI menus
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  asm_keyword
 |      data_type_t_asm_keyword_get(self) -> char const *
 |  
 |  hotkey
 |      data_type_t_hotkey_get(self) -> char const *
 |  
 |  id
 |      __get_id(self) -> int
 |  
 |  menu_name
 |      data_type_t_menu_name_get(self) -> char const *
 |  
 |  name
 |      data_type_t_name_get(self) -> char const *
 |  
 |  props
 |      data_type_t_props_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  value_size
 |      data_type_t_value_size_get(self) -> asize_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_data_type_t>
 |      delete_data_type_t(self)

Help on function dec_flag in module ida_bytes:

dec_flag(*args)
    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'

Help on function del_hidden_range in module ida_bytes:

del_hidden_range(*args)
    Delete hidden range.
    
    del_hidden_range(ea) -> bool
        @param ea: any address in the hidden range (C++: ea_t)
        @return: success

Help on function del_items in module ida_bytes:

del_items(*args)
    Convert item (instruction/data) to unexplored bytes. The whole item
    (including the head and tail bytes) will be destroyed. It is allowed
    to pass any address in the item to this function
    
    del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool
        @param ea: any address within the first item to delete (C++: ea_t)
        @param flags: combination of  Unexplored byte conversion flags (C++:
                      int)
        @param nbytes: number of bytes in the range to be undefined (C++:
                       asize_t)
        @param may_destroy: optional routine invoked before deleting a head
                            item. If callback returns false then item has not
                            to be deleted and operation fails (C++:
                            may_destroy_cb_t  *)
        @return: true on sucessful operation, otherwise false

Help on function del_mapping in module ida_bytes:

del_mapping(*args)
    Delete memory mapping range.
    
    del_mapping(ea)
        @param ea: any address in the mapped range (C++: ea_t)

Help on function del_value in module ida_bytes:

del_value(*args)
    Delete byte value from flags. The corresponding byte becomes
    uninitialized.
    
    del_value(ea)
        @param ea (C++: ea_t)

Help on function detach_custom_data_format in module ida_bytes:

detach_custom_data_format(*args)
    Detach the data format from the data type. Unregistering a custom data
    type detaches all attached data formats, no need to detach them
    explicitly. You still need unregister them. Unregistering a custom
    data format detaches it from all attached data types.
    
    detach_custom_data_format(dtid, dfid) -> bool
        @param dtid: data type id to detach data format from (C++: int)
        @param dfid: data format id to detach (C++: int)
        @retval: true - ok
        @retval: false - no such  dtid , or no such  dfid , or the data format
                         was not attached to the data type

Help on function disable_flags in module ida_bytes:

disable_flags(*args)
    Deallocate flags for address range. Exit with an error message if not
    enough disk space (this may occur too).
    
    disable_flags(start_ea, end_ea) -> error_t
        @param start_ea: should be lower than end_ea. (C++: ea_t)
        @param end_ea: does not belong to the range. (C++: ea_t)
        @return: 0 if ok, otherwise return error code

Help on function double_flag in module ida_bytes:

double_flag(*args)
    Get a flags_t representing a double.

Help on function dword_flag in module ida_bytes:

dword_flag(*args)
    Get a flags_t representing a double word.

Help on function enable_flags in module ida_bytes:

enable_flags(*args)
    Allocate flags for address range. This function does not change the
    storage type of existing ranges. Exit with an error message if not
    enough disk space.
    
    enable_flags(start_ea, end_ea, stt) -> error_t
        @param start_ea: should be lower than end_ea. (C++: ea_t)
        @param end_ea: does not belong to the range. (C++: ea_t)
        @param stt: storage_type_t (C++: storage_type_t)
        @return: 0 if ok, otherwise an error code

Help on function enum_flag in module ida_bytes:

enum_flag(*args)
    see 'Bits: instruction operand types'

Help on function equal_bytes in module ida_bytes:

equal_bytes(*args)
    Compare 'len' bytes of the program starting from 'ea' with 'image'.
    
    equal_bytes(ea, image, mask, len, sense_case) -> bool
        @param ea: linear address (C++: ea_t)
        @param image: bytes to compare with (C++: const  uchar  *)
        @param mask: array of 1/0 bytes, it's length is 'len'. 1 means to
                     perform the comparison of the corresponding byte. 0 means
                     not to perform. if mask == nullptr, then all bytes of
                     'image' will be compared. if mask ==  SKIP_FF_MASK  then
                     0xFF bytes will be skipped (C++: const  uchar  *)
        @param len: length of block to compare in bytes. (C++: size_t)
        @param sense_case: case-sensitive comparison? (C++: bool)
        @retval: 1 - equal
        @retval: 0 - not equal

Help on function f_has_cmt in module ida_bytes:

f_has_cmt(*args)
    f_has_cmt(f, arg2) -> bool
        @param f (C++: flags_t)
        arg2: void *

Help on function f_has_dummy_name in module ida_bytes:

f_has_dummy_name(*args)
    Does the current byte have dummy (auto-generated, with special prefix)
    name?
    
    f_has_dummy_name(f, arg2) -> bool
        @param f (C++: flags_t)
        arg2: void *

Help on function f_has_extra_cmts in module ida_bytes:

f_has_extra_cmts(*args)
    f_has_extra_cmts(f, arg2) -> bool
        @param f (C++: flags_t)
        arg2: void *

Help on function f_has_name in module ida_bytes:

f_has_name(*args)
    Does the current byte have non-trivial (non-dummy) name?
    
    f_has_name(f, arg2) -> bool
        @param f (C++: flags_t)
        arg2: void *

Help on function f_has_user_name in module ida_bytes:

f_has_user_name(*args)
    Does the current byte have user-specified name?
    
    f_has_user_name(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_has_xref in module ida_bytes:

f_has_xref(*args)
    Does the current byte have cross-references to it?
    
    f_has_xref(f, arg2) -> bool
        @param f (C++: flags_t)
        arg2: void *

Help on function f_is_align in module ida_bytes:

f_is_align(*args)
    See 'is_align()'
    
    f_is_align(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_byte in module ida_bytes:

f_is_byte(*args)
    See 'is_byte()'
    
    f_is_byte(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_code in module ida_bytes:

f_is_code(*args)
    Does flag denote start of an instruction?
    
    f_is_code(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_custom in module ida_bytes:

f_is_custom(*args)
    See 'is_custom()'
    
    f_is_custom(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_data in module ida_bytes:

f_is_data(*args)
    Does flag denote start of data?
    
    f_is_data(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_double in module ida_bytes:

f_is_double(*args)
    See 'is_double()'
    
    f_is_double(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_dword in module ida_bytes:

f_is_dword(*args)
    See 'is_dword()'
    
    f_is_dword(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_float in module ida_bytes:

f_is_float(*args)
    See 'is_float()'
    
    f_is_float(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_head in module ida_bytes:

f_is_head(*args)
    Does flag denote start of instruction OR data?
    
    f_is_head(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_not_tail in module ida_bytes:

f_is_not_tail(*args)
    Does flag denote tail byte?
    
    f_is_not_tail(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_oword in module ida_bytes:

f_is_oword(*args)
    See 'is_oword()'
    
    f_is_oword(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_pack_real in module ida_bytes:

f_is_pack_real(*args)
    See 'is_pack_real()'
    
    f_is_pack_real(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_qword in module ida_bytes:

f_is_qword(*args)
    See 'is_qword()'
    
    f_is_qword(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_strlit in module ida_bytes:

f_is_strlit(*args)
    See 'is_strlit()'
    
    f_is_strlit(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_struct in module ida_bytes:

f_is_struct(*args)
    See 'is_struct()'
    
    f_is_struct(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_tail in module ida_bytes:

f_is_tail(*args)
    Does flag denote tail byte?
    
    f_is_tail(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_tbyte in module ida_bytes:

f_is_tbyte(*args)
    See 'is_tbyte()'
    
    f_is_tbyte(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_word in module ida_bytes:

f_is_word(*args)
    See 'is_word()'
    
    f_is_word(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function f_is_yword in module ida_bytes:

f_is_yword(*args)
    See 'is_yword()'
    
    f_is_yword(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *

Help on function find_byte in module ida_bytes:

find_byte(*args)
    Find forward a byte with the specified value (only 8-bit value from
    the database). example: ea=4 size=3 will inspect addresses 4, 5, and 6
    
    find_byte(sEA, size, value, bin_search_flags) -> ea_t
        @param sEA: linear address (C++: ea_t)
        @param size: number of bytes to inspect (C++: asize_t)
        @param value: value to find (C++: uchar)
        @param bin_search_flags: combination of  Search flags (C++: int)
        @return: address of byte or  BADADDR

Help on function find_byter in module ida_bytes:

find_byter(*args)
    Find reverse a byte with the specified value (only 8-bit value from
    the database). example: ea=4 size=3 will inspect addresses 6, 5, and 4
    
    find_byter(sEA, size, value, bin_search_flags) -> ea_t
        @param sEA: the lower address of the search range (C++: ea_t)
        @param size: number of bytes to inspect (C++: asize_t)
        @param value: value to find (C++: uchar)
        @param bin_search_flags: combination of  Search flags (C++: int)
        @return: address of byte or  BADADDR

Help on function find_custom_data_format in module ida_bytes:

find_custom_data_format(*args)
    Get id of a custom data format.
    
    find_custom_data_format(name) -> int
        @param name: name of the custom data format (C++: const char *)
        @return: id or -1

Help on function find_custom_data_type in module ida_bytes:

find_custom_data_type(*args)
    Get id of a custom data type.
    
    find_custom_data_type(name) -> int
        @param name: name of the custom data type (C++: const char *)
        @return: id or -1

Help on function float_flag in module ida_bytes:

float_flag(*args)
    Get a flags_t representing a float.

Help on function flt_flag in module ida_bytes:

flt_flag(*args)
    see 'Bits: instruction operand types'

Help on function free_chunk in module ida_bytes:

free_chunk(*args)
    Search for a hole in the addressing space of the program.
    
    free_chunk(bottom, size, step) -> ea_t
        @param bottom: address to start searching (C++: ea_t)
        @param size: size of desired block (C++: asize_t)
        @param step: bit mask for the start of hole (0xF would align hole to a
                     paragraph). if 'step' is negative, the bottom address
                     with be aligned. otherwise the kernel will try to use it
                     as is and align it only when the hole is too small. (C++:
                     int32)
        @return: start of the hole or  BADADDR

Help on function get_16bit in module ida_bytes:

get_16bit(*args)
    Get 16bits of the program at 'ea'.
    
    get_16bit(ea) -> uint32
        @param ea (C++: ea_t)
        @return: 1 byte (getFullByte()) if the current processor has 16-bit
                 byte, otherwise return  get_word()

Help on function get_32bit in module ida_bytes:

get_32bit(*args)
    Get not more than 32bits of the program at 'ea'.
    
    get_32bit(ea) -> uint32
        @param ea (C++: ea_t)
        @return: 32 bit value, depending on \ph{nbits}:   if ( nbits <= 8 )
                 return get_dword(ea);   if ( nbits <= 16) return
                 get_wide_word(ea);   return get_wide_byte(ea);

Help on function get_64bit in module ida_bytes:

get_64bit(*args)
    Get not more than 64bits of the program at 'ea'.
    
    get_64bit(ea) -> uint64
        @param ea (C++: ea_t)
        @return: 64 bit value, depending on \ph{nbits}:   if ( nbits <= 8 )
                 return get_qword(ea);   if ( nbits <= 16) return
                 get_wide_dword(ea);   return get_wide_byte(ea);

Help on function get_8bit in module ida_bytes:

get_8bit(*args)
    get_8bit(ea, v, nbit) -> PyObject *
        @param ea (C++: ea_t *)
        @param v (C++: uint32  *)
        @param nbit (C++: int *)

Help on function get_byte in module ida_bytes:

get_byte(*args)
    Get one byte (8-bit) of the program at 'ea'. This function works only
    for 8bit byte processors.
    
    get_byte(ea) -> uchar
        @param ea (C++: ea_t)

Help on function get_bytes in module ida_bytes:

get_bytes(*args)
    get_bytes(ea, size, gmb_flags=0x01) -> PyObject *
    Get the specified number of bytes of the program.
    @param ea: program address
    @param size: number of bytes to return
    @return: the bytes (as a str), or None in case of failure

Help on function get_bytes_and_mask in module ida_bytes:

get_bytes_and_mask(*args)
    get_bytes_and_mask(ea, size, gmb_flags=0x01) -> PyObject *
    Get the specified number of bytes of the program, and a bitmask
    specifying what bytes are defined and what bytes are not.
    @param ea: program address
    @param size: number of bytes to return
    @return: a tuple (bytes, mask), or None in case of failure.
             Both 'bytes' and 'mask' are 'str' instances.

Help on function get_cmt in module ida_bytes:

get_cmt(*args)
    Get an indented comment.
    
    get_cmt(ea, rptble) -> str
        @param ea: linear address. may point to tail byte, the function will
                   find start of the item (C++: ea_t)
        @param rptble: get repeatable comment? (C++: bool)
        @return: size of comment or -1

Help on function get_custom_data_format in module ida_bytes:

get_custom_data_format(*args)
    Get definition of a registered custom data format.
    
    get_custom_data_format(dfid) -> data_format_t
        @param dfid: data format id (C++: int)
        @return: data format definition or nullptr

Help on function get_custom_data_formats in module ida_bytes:

get_custom_data_formats(*args)
    Get list of attached custom data formats for the specified data type.
    
    get_custom_data_formats(out, dtid) -> int
        @param out: buffer for the output. may be nullptr (C++: intvec_t  *)
        @param dtid: data type id (C++: int)
        @return: number of returned custom data formats. if error, returns -1

Help on function get_custom_data_type in module ida_bytes:

get_custom_data_type(*args)
    Get definition of a registered custom data type.
    
    get_custom_data_type(dtid) -> data_type_t
        @param dtid: data type id (C++: int)
        @return: data type definition or nullptr

Help on function get_custom_data_types in module ida_bytes:

get_custom_data_types(*args)
    Get list of registered custom data type ids.
    
    get_custom_data_types(out, min_size=0, max_size=BADADDR) -> int
        @param out: buffer for the output. may be nullptr (C++: intvec_t  *)
        @param min_size: minimum value size (C++: asize_t)
        @param max_size: maximum value size (C++: asize_t)
        @return: number of custom data types with the specified size limits

Help on function get_data_elsize in module ida_bytes:

get_data_elsize(*args)
    Get size of data type specified in flags 'F'.
    
    get_data_elsize(ea, F, ti=None) -> asize_t
        @param ea: linear address of the item (C++: ea_t)
        @param F: flags (C++: flags_t)
        @param ti: additional information about the data type. For example, if
                   the current item is a structure instance, then ti->tid is
                   structure id. Otherwise is ignored (may be nullptr). If
                   specified as nullptr, will be automatically retrieved from
                   the database (C++: const  opinfo_t  *)
        @return: byte : 1   word : 2   etc...

Help on function get_data_value in module ida_bytes:

get_data_value(*args)
    Get the value at of the item at 'ea'. This function works with
    entities up to sizeof(ea_t) (bytes, word, etc)
    
    get_data_value(v, ea, size) -> bool
        @param v: pointer to the result. may be nullptr (C++: uval_t  *)
        @param ea: linear address (C++: ea_t)
        @param size: size of data to read. If 0, then the item type at 'ea'
                     will be used (C++: asize_t)
        @return: success

Help on function get_db_byte in module ida_bytes:

get_db_byte(*args)
    Get one byte (8-bit) of the program at 'ea' from the database. Works
    even if the debugger is active. See also 'get_dbg_byte()' to read the
    process memory directly. This function works only for 8bit byte
    processors.
    
    get_db_byte(ea) -> uchar
        @param ea (C++: ea_t)

Help on function get_default_radix in module ida_bytes:

get_default_radix(*args)
    Get default base of number for the current processor.

Help on function get_dword in module ida_bytes:

get_dword(*args)
    Get one dword (32-bit) of the program at 'ea'. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    works only for 8bit byte processors.
    
    get_dword(ea) -> uint32
        @param ea (C++: ea_t)

Help on function get_enum_id in module ida_bytes:

get_enum_id(*args)
    Get enum id of 'enum' operand.
    
    get_enum_id(ea, n) -> enum_t
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: id of enum or  BADNODE

Help on function get_first_hidden_range in module ida_bytes:

get_first_hidden_range(*args)
    Get pointer to the first hidden range.

Help on function get_flags in module ida_bytes:

get_flags(*args)
    get flags with 'FF_IVL' & 'MS_VAL' . It is much slower under remote
    debugging because the kernel needs to read the process memory.
    
    get_flags(ea) -> flags_t
        @param ea (C++: ea_t)

Help on function get_flags_by_size in module ida_bytes:

get_flags_by_size(*args)
    Get flags from size (in bytes). Supported sizes: 1, 2, 4, 8, 16, 32.
    For other sizes returns 0
    
    get_flags_by_size(size) -> flags_t
        @param size (C++: size_t)

Help on function get_flags_ex in module ida_bytes:

get_flags_ex(*args)
    Get flags for the specified address, extended form.
    
    get_flags_ex(ea, how) -> flags_t
        @param ea (C++: ea_t)
        @param how (C++: int)

Help on function get_forced_operand in module ida_bytes:

get_forced_operand(*args)
    Get forced operand.
    
    get_forced_operand(ea, n) -> str
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, 2) (C++: int)
        @return: size of forced operand or -1

Help on function get_full_data_elsize in module ida_bytes:

get_full_data_elsize(*args)
    Get full size of data type specified in flags 'F'. takes into account
    processors with wide bytes e.g. returns 2 for a byte element with
    16-bit bytes
    
    get_full_data_elsize(ea, F, ti=None) -> asize_t
        @param ea (C++: ea_t)
        @param F (C++: flags_t)
        @param ti (C++: const  opinfo_t  *)

Help on function get_full_flags in module ida_bytes:

get_full_flags(*args)
    Get flags value for address 'ea'.
    
    get_full_flags(ea) -> flags_t
        @param ea (C++: ea_t)
        @return: 0 if address is not present in the program

Help on function get_hidden_range in module ida_bytes:

get_hidden_range(*args)
    Get pointer to hidden range structure, in: linear address.
    
    get_hidden_range(ea) -> hidden_range_t
        @param ea: any address in the hidden range (C++: ea_t)

Help on function get_hidden_range_num in module ida_bytes:

get_hidden_range_num(*args)
    Get number of a hidden range.
    
    get_hidden_range_num(ea) -> int
        @param ea: any address in the hidden range (C++: ea_t)
        @return: number of hidden range (0.. get_hidden_range_qty() -1)

Help on function get_hidden_range_qty in module ida_bytes:

get_hidden_range_qty(*args)
    Get number of hidden ranges.

Help on function get_item_end in module ida_bytes:

get_item_end(*args)
    Get the end address of the item at 'ea'. The returned address doesn't
    belong to the current item. Unexplored bytes are counted as 1 byte
    entities.
    
    get_item_end(ea) -> ea_t
        @param ea (C++: ea_t)

Help on function get_item_flag in module ida_bytes:

get_item_flag(*args)
    Get flag of the item at 'ea' even if it is a tail byte of some array
    or structure. This function is used to get flags of structure members
    or array elements.
    
    get_item_flag(_from, n, ea, appzero) -> flags_t
        @param _from: linear address of the instruction which refers to 'ea'
                      (C++: ea_t)
        @param n: number of operand which refers to 'ea' (C++: int)
        @param ea: the referenced address (C++: ea_t)
        @param appzero: append a struct field name if the field offset is
                        zero? meaningful only if the name refers to a
                        structure. (C++: bool)
        @return: flags or 0 (if failed)

Help on function get_item_head in module ida_bytes:

get_item_head(*args)
    Get the start address of the item at 'ea'. If there is no current
    item, then 'ea' will be returned (see definition at the end of
    'bytes.hpp' source)
    
    get_item_head(ea) -> ea_t
        @param ea (C++: ea_t)

Help on function get_item_size in module ida_bytes:

get_item_size(*args)
    Get size of item (instruction/data) in bytes. Unexplored bytes have
    length of 1 byte. This function never returns 0.
    
    get_item_size(ea) -> asize_t
        @param ea (C++: ea_t)

Help on function get_last_hidden_range in module ida_bytes:

get_last_hidden_range(*args)
    Get pointer to the last hidden range.

Help on function get_manual_insn in module ida_bytes:

get_manual_insn(*args)
    Retrieve the user-specified string for the manual instruction.
    
    get_manual_insn(ea) -> str
        @param ea: linear address of the instruction or data item (C++: ea_t)
        @return: size of manual instruction or -1

Help on function get_mapping in module ida_bytes:

get_mapping(*args)
    Get memory mapping range by its number.
    
    get_mapping(n) -> bool
        @param n: number of mapping range (0.. get_mappings_qty() -1) (C++:
                  size_t)
        @return: false if the specified range doesn't exist, otherwise returns
                 from ,  to ,  size

Help on function get_mappings_qty in module ida_bytes:

get_mappings_qty(*args)
    Get number of mappings.

Help on function get_max_strlit_length in module ida_bytes:

get_max_strlit_length(*args)
    Determine maximum length of string literal.If the string literal has a
    length prefix (e.g., STRTYPE_LEN2 has a two-byte length prefix), the
    length of that prefix (i.e., 2) will be part of the returned value.
    
    get_max_strlit_length(ea, strtype, options=0) -> size_t
        @param ea: starting address (C++: ea_t)
        @param strtype: string type. one of  String type codes (C++: int32)
        @param options: combination of  string literal length options (C++:
                        int)
        @return: length of the string in octets (octet==8bit)

Help on function get_next_hidden_range in module ida_bytes:

get_next_hidden_range(*args)
    Get pointer to next hidden range.
    
    get_next_hidden_range(ea) -> hidden_range_t
        @param ea: any address in the program (C++: ea_t)
        @return: ptr to hidden range or nullptr if next hidden range doesn't
                 exist

Help on function get_octet in module ida_bytes:

get_octet(*args)
    Get 8 bits of the program at 'ea'. The main usage of this function is
    to iterate range of bytes. Here is an example:
    
    uint64 v;
    int nbit = 0;
    for ( ... ) {
      uchar byte = get_octet(&ea, &v, &nbit);
      ...
    }
    
    'ea' is incremented each time when a new byte is read. In the above
    example, it will be incremented in the first loop iteration.
    
    get_octet(ea, v, nbit) -> PyObject *
        @param ea (C++: ea_t *)
        @param v (C++: uint64  *)
        @param nbit (C++: int *)

Help on function get_opinfo in module ida_bytes:

get_opinfo(*args)
    Get additional information about an operand representation.
    
    get_opinfo(buf, ea, n, flags) -> opinfo_t
        @param buf: buffer to receive the result. may not be nullptr (C++:
                    opinfo_t  *)
        @param ea: linear address of item (C++: ea_t)
        @param n: number of operand, 0 or 1 (C++: int)
        @param flags: flags of the item (C++: flags_t)
        @return: nullptr if no additional representation information

Help on function get_optype_flags0 in module ida_bytes:

get_optype_flags0(*args)
    Get flags for first operand.
    
    get_optype_flags0(F) -> flags_t
        @param F (C++: flags_t)

Help on function get_optype_flags1 in module ida_bytes:

get_optype_flags1(*args)
    Get flags for second operand.
    
    get_optype_flags1(F) -> flags_t
        @param F (C++: flags_t)

Help on function get_original_byte in module ida_bytes:

get_original_byte(*args)
    Get original byte value (that was before patching). This function
    works for wide byte processors too.
    
    get_original_byte(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_original_dword in module ida_bytes:

get_original_dword(*args)
    Get original dword (that was before patching) This function works for
    wide byte processors too. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    get_original_dword(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_original_qword in module ida_bytes:

get_original_qword(*args)
    Get original qword value (that was before patching) This function
    DOESN'T work for wide byte processors too. This function takes into
    account order of bytes specified in \inf{is_be()}
    
    get_original_qword(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_original_word in module ida_bytes:

get_original_word(*args)
    Get original word value (that was before patching). This function
    works for wide byte processors too. This function takes into account
    order of bytes specified in \inf{is_be()}
    
    get_original_word(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_predef_insn_cmt in module ida_bytes:

get_predef_insn_cmt(*args)
    Get predefined comment.
    
    get_predef_insn_cmt(ins) -> str
        @param ins: current instruction information  - an ida_ua.insn_t, or an
                    address (C++: const insn_t &)
        @return: size of comment or -1

Help on function get_prev_hidden_range in module ida_bytes:

get_prev_hidden_range(*args)
    Get pointer to previous hidden range.
    
    get_prev_hidden_range(ea) -> hidden_range_t
        @param ea: any address in the program (C++: ea_t)
        @return: ptr to hidden range or nullptr if previous hidden range
                 doesn't exist

Help on function get_qword in module ida_bytes:

get_qword(*args)
    Get one qword (64-bit) of the program at 'ea'. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    works only for 8bit byte processors.
    
    get_qword(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_radix in module ida_bytes:

get_radix(*args)
    Get radix of the operand, in: flags. If the operand is not a number,
    returns 'get_default_radix()'
    
    get_radix(F, n) -> int
        @param F: flags (C++: flags_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: 2, 8, 10, 16

Help on function get_strlit_contents in module ida_bytes:

get_strlit_contents(*args)
    get_strlit_contents(ea, py_len, type, flags=0) -> PyObject *
    Get bytes contents at location, possibly converted.
    It works even if the string has not been created in the database yet.
    
    Note that this will <b>always</b> return a simple string of bytes
    (i.e., a 'str' instance), and not a string of unicode characters.
    
    If you want auto-conversion to unicode strings (that is: real strings),
    you should probably be using the idautils.Strings class.
    
    @param ea: linear address of the string
    @param len: length of the string in bytes (including terminating 0)
    @param type: type of the string. Represents both the character encoding,
                 <u>and</u> the 'type' of string at the given location.
    @param flags: combination of STRCONV_..., to perform output conversion.
    @return: a bytes-filled str object.

Help on function get_stroff_path in module ida_bytes:

get_stroff_path(*args)
    Get struct path of operand.
    
    get_stroff_path(path, delta, ea, n) -> int
        @param path: buffer for structure path (strpath). see  nalt.hpp  for
                     more info. (C++: tid_t  *)
        @param delta: struct offset delta (C++: adiff_t *)
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: length of strpath

Help on function get_wide_byte in module ida_bytes:

get_wide_byte(*args)
    Get one wide byte of the program at 'ea'. Some processors may access
    more than 8bit quantity at an address. These processors have 32-bit
    byte organization from the IDA's point of view.
    
    get_wide_byte(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_wide_dword in module ida_bytes:

get_wide_dword(*args)
    Get two wide words (4 'bytes') of the program at 'ea'. Some processors
    may access more than 8bit quantity at an address. These processors
    have 32-bit byte organization from the IDA's point of view. This
    function takes into account order of bytes specified in
    \inf{is_be()}this function works incorrectly if \ph{nbits} > 16
    
    get_wide_dword(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_wide_word in module ida_bytes:

get_wide_word(*args)
    Get one wide word (2 'byte') of the program at 'ea'. Some processors
    may access more than 8bit quantity at an address. These processors
    have 32-bit byte organization from the IDA's point of view. This
    function takes into account order of bytes specified in \inf{is_be()}
    
    get_wide_word(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_word in module ida_bytes:

get_word(*args)
    Get one word (16-bit) of the program at 'ea'. This function takes into
    account order of bytes specified in \inf{is_be()} This function works
    only for 8bit byte processors.
    
    get_word(ea) -> ushort
        @param ea (C++: ea_t)

Help on function get_zero_ranges in module ida_bytes:

get_zero_ranges(*args)
    Return set of ranges with zero initialized bytes. The returned set
    includes only big zero initialized ranges (at least >1KB). Some zero
    initialized byte ranges may be not included. Only zero bytes that use
    the sparse storage method (STT_MM) are reported.
    
    get_zero_ranges(zranges, range) -> bool
        @param zranges: pointer to the return value. cannot be nullptr (C++:
                        rangeset_t  *)
        @param range: the range of addresses to verify. can be nullptr - means
                      all ranges (C++: const  range_t  *)
        @return: true if the result is a non-empty set

Help on function getn_hidden_range in module ida_bytes:

getn_hidden_range(*args)
    Get pointer to hidden range structure, in: number of hidden range.
    
    getn_hidden_range(n) -> hidden_range_t
        @param n: number of hidden range, is in range 0..
                  get_hidden_range_qty() -1 (C++: int)

Help on function has_any_name in module ida_bytes:

has_any_name(*args)
    Does the current byte have any name?
    
    has_any_name(F) -> bool
        @param F (C++: flags_t)

Help on function has_auto_name in module ida_bytes:

has_auto_name(*args)
    Does the current byte have auto-generated (no special prefix) name?
    
    has_auto_name(F) -> bool
        @param F (C++: flags_t)

Help on function has_cmt in module ida_bytes:

has_cmt(*args)
    Does the current byte have an indented comment?
    
    has_cmt(F) -> bool
        @param F (C++: flags_t)

Help on function has_dummy_name in module ida_bytes:

has_dummy_name(*args)
    Does the current byte have dummy (auto-generated, with special prefix)
    name?
    
    has_dummy_name(F) -> bool
        @param F (C++: flags_t)

Help on function has_extra_cmts in module ida_bytes:

has_extra_cmts(*args)
    Does the current byte have additional anterior or posterior lines?
    
    has_extra_cmts(F) -> bool
        @param F (C++: flags_t)

Help on function has_immd in module ida_bytes:

has_immd(*args)
    Has immediate value?
    
    has_immd(F) -> bool
        @param F (C++: flags_t)

Help on function has_name in module ida_bytes:

has_name(*args)
    Does the current byte have non-trivial (non-dummy) name?
    
    has_name(F) -> bool
        @param F (C++: flags_t)

Help on function has_user_name in module ida_bytes:

has_user_name(*args)
    Does the current byte have user-specified name?
    
    has_user_name(F) -> bool
        @param F (C++: flags_t)

Help on function has_value in module ida_bytes:

has_value(*args)
    Do flags contain byte value?
    
    has_value(F) -> bool
        @param F (C++: flags_t)

Help on function has_xref in module ida_bytes:

has_xref(*args)
    Does the current byte have cross-references to it?
    
    has_xref(F) -> bool
        @param F (C++: flags_t)

Help on function hex_flag in module ida_bytes:

hex_flag(*args)
    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'

Help on class hidden_range_t in module ida_bytes:

class hidden_range_t(ida_range.range_t)
 |  Proxy of C++ hidden_range_t class.
 |  
 |  Method resolution order:
 |      hidden_range_t
 |      ida_range.range_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hidden_range_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  color
 |      hidden_range_t_color_get(self) -> bgcolor_t
 |  
 |  description
 |      hidden_range_t_description_get(self) -> char *
 |  
 |  footer
 |      hidden_range_t_footer_get(self) -> char *
 |  
 |  header
 |      hidden_range_t_header_get(self) -> char *
 |  
 |  thisown
 |      The membership flag
 |  
 |  visible
 |      hidden_range_t_visible_get(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_hidden_range_t>
 |      delete_hidden_range_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: range_t const &
 |  
 |  _print(self, *args)
 |      _print(self) -> size_t
 |  
 |  clear(self, *args)
 |      Set 'start_ea' , 'end_ea' to 0.
 |  
 |  compare(self, *args)
 |      Compare two 'range_t' instances, based on the start_ea.
 |      
 |      compare(self, r) -> int
 |          @param r (C++: const  range_t  &)
 |  
 |  contains(self, *args)
 |      Is 'ea' in the address range?
 |      
 |      contains(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |      
 |      
 |      contains(self, r) -> bool
 |          r: range_t const &
 |  
 |  empty(self, *args)
 |      Is the size of the 'range_t' <= 0?
 |  
 |  extend(self, *args)
 |      Ensure that the 'range_t' includes 'ea'.
 |      
 |      extend(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  intersect(self, *args)
 |      Assign the 'range_t' to the intersection between the 'range_t' and
 |      'r'.
 |      
 |      intersect(self, r)
 |          @param r (C++: const  range_t  &)
 |  
 |  overlaps(self, *args)
 |      Is there an ea in 'r' that is also in this 'range_t' ?
 |      
 |      overlaps(self, r) -> bool
 |          @param r (C++: const  range_t  &)
 |  
 |  size(self, *args)
 |      Get 'end_ea' - 'start_ea' .
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t

Help on function is_align in module ida_bytes:

is_align(*args)
    'FF_ALIGN'
    
    is_align(F) -> bool
        @param F (C++: flags_t)

Help on function is_attached_custom_data_format in module ida_bytes:

is_attached_custom_data_format(*args)
    is_attached_custom_data_format(dtid, dfid) -> bool
        @param dtid (C++: int)
        @param dfid (C++: int)

Help on function is_bnot in module ida_bytes:

is_bnot(*args)
    Should we negate the operand?. \ash{a_bnot} should be defined in the
    idp module in order to work with this function
    
    is_bnot(ea, F, n) -> bool
        @param ea (C++: ea_t)
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_byte in module ida_bytes:

is_byte(*args)
    'FF_BYTE'
    
    is_byte(F) -> bool
        @param F (C++: flags_t)

Help on function is_char in module ida_bytes:

is_char(*args)
    is character constant?
    
    is_char(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_char0 in module ida_bytes:

is_char0(*args)
    Is the first operand character constant? (example: push 'a')
    
    is_char0(F) -> bool
        @param F (C++: flags_t)

Help on function is_char1 in module ida_bytes:

is_char1(*args)
    Is the second operand character constant? (example: mov al, 'a')
    
    is_char1(F) -> bool
        @param F (C++: flags_t)

Help on function is_code in module ida_bytes:

is_code(*args)
    Does flag denote start of an instruction?
    
    is_code(F) -> bool
        @param F (C++: flags_t)

Help on function is_custfmt in module ida_bytes:

is_custfmt(*args)
    is custom data format?
    
    is_custfmt(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_custfmt0 in module ida_bytes:

is_custfmt0(*args)
    Does the first operand use a custom data representation?
    
    is_custfmt0(F) -> bool
        @param F (C++: flags_t)

Help on function is_custfmt1 in module ida_bytes:

is_custfmt1(*args)
    Does the second operand use a custom data representation?
    
    is_custfmt1(F) -> bool
        @param F (C++: flags_t)

Help on function is_custom in module ida_bytes:

is_custom(*args)
    'FF_CUSTOM'
    
    is_custom(F) -> bool
        @param F (C++: flags_t)

Help on function is_data in module ida_bytes:

is_data(*args)
    Does flag denote start of data?
    
    is_data(F) -> bool
        @param F (C++: flags_t)

Help on function is_defarg in module ida_bytes:

is_defarg(*args)
    is defined?
    
    is_defarg(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_defarg0 in module ida_bytes:

is_defarg0(*args)
    Is the first operand defined? Initially operand has no defined
    representation.
    
    is_defarg0(F) -> bool
        @param F (C++: flags_t)

Help on function is_defarg1 in module ida_bytes:

is_defarg1(*args)
    Is the second operand defined? Initially operand has no defined
    representation.
    
    is_defarg1(F) -> bool
        @param F (C++: flags_t)

Help on function is_double in module ida_bytes:

is_double(*args)
    'FF_DOUBLE'
    
    is_double(F) -> bool
        @param F (C++: flags_t)

Help on function is_dword in module ida_bytes:

is_dword(*args)
    'FF_DWORD'
    
    is_dword(F) -> bool
        @param F (C++: flags_t)

Help on function is_enum in module ida_bytes:

is_enum(*args)
    is enum?
    
    is_enum(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_enum0 in module ida_bytes:

is_enum0(*args)
    Is the first operand a symbolic constant (enum member)?
    
    is_enum0(F) -> bool
        @param F (C++: flags_t)

Help on function is_enum1 in module ida_bytes:

is_enum1(*args)
    Is the second operand a symbolic constant (enum member)?
    
    is_enum1(F) -> bool
        @param F (C++: flags_t)

Help on function is_float in module ida_bytes:

is_float(*args)
    'FF_FLOAT'
    
    is_float(F) -> bool
        @param F (C++: flags_t)

Help on function is_float0 in module ida_bytes:

is_float0(*args)
    Is the first operand a floating point number?
    
    is_float0(F) -> bool
        @param F (C++: flags_t)

Help on function is_float1 in module ida_bytes:

is_float1(*args)
    Is the second operand a floating point number?
    
    is_float1(F) -> bool
        @param F (C++: flags_t)

Help on function is_flow in module ida_bytes:

is_flow(*args)
    Does the previous instruction exist and pass execution flow to the
    current byte?
    
    is_flow(F) -> bool
        @param F (C++: flags_t)

Help on function is_fltnum in module ida_bytes:

is_fltnum(*args)
    is floating point number?
    
    is_fltnum(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_forced_operand in module ida_bytes:

is_forced_operand(*args)
    Is operand manually defined?.
    
    is_forced_operand(ea, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, 2) (C++: int)

Help on function is_func in module ida_bytes:

is_func(*args)
    Is function start?
    
    is_func(F) -> bool
        @param F (C++: flags_t)

Help on function is_head in module ida_bytes:

is_head(*args)
    Does flag denote start of instruction OR data?
    
    is_head(F) -> bool
        @param F (C++: flags_t)

Help on function is_invsign in module ida_bytes:

is_invsign(*args)
    Should sign of n-th operand inverted during output?. allowed values of
    n: 0-first operand, 1-other operands
    
    is_invsign(ea, F, n) -> bool
        @param ea (C++: ea_t)
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_loaded in module ida_bytes:

is_loaded(*args)
    Does the specified address have a byte value (is initialized?)
    
    is_loaded(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_lzero in module ida_bytes:

is_lzero(*args)
    Display leading zeroes in operands. The global switch for the leading
    zeroes is in \inf{s_genflags} The leading zeroes doesn't work if the
    octal numbers start with 0 Display leading zeroes? (takes into account
    \inf{s_genflags})
    
    is_lzero(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function is_manual in module ida_bytes:

is_manual(*args)
    is forced operand? (use 'is_forced_operand()' )
    
    is_manual(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_manual_insn in module ida_bytes:

is_manual_insn(*args)
    Is the instruction overridden?
    
    is_manual_insn(ea) -> bool
        @param ea: linear address of the instruction or data item (C++: ea_t)

Help on function is_mapped in module ida_bytes:

is_mapped(*args)
    Is the specified address 'ea' present in the program?
    
    is_mapped(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_not_tail in module ida_bytes:

is_not_tail(*args)
    Does flag denote tail byte?
    
    is_not_tail(F) -> bool
        @param F (C++: flags_t)

Help on function is_numop in module ida_bytes:

is_numop(*args)
    is number (bin, oct, dec, hex)?
    
    is_numop(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_numop0 in module ida_bytes:

is_numop0(*args)
    Is the first operand a number (i.e. binary, octal, decimal or hex?)
    
    is_numop0(F) -> bool
        @param F (C++: flags_t)

Help on function is_numop1 in module ida_bytes:

is_numop1(*args)
    Is the second operand a number (i.e. binary, octal, decimal or hex?)
    
    is_numop1(F) -> bool
        @param F (C++: flags_t)

Help on function is_off in module ida_bytes:

is_off(*args)
    is offset?
    
    is_off(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_off0 in module ida_bytes:

is_off0(*args)
    Is the first operand offset? (example: push offset xxx)
    
    is_off0(F) -> bool
        @param F (C++: flags_t)

Help on function is_off1 in module ida_bytes:

is_off1(*args)
    Is the second operand offset? (example: mov ax, offset xxx)
    
    is_off1(F) -> bool
        @param F (C++: flags_t)

Help on function is_oword in module ida_bytes:

is_oword(*args)
    'FF_OWORD'
    
    is_oword(F) -> bool
        @param F (C++: flags_t)

Help on function is_pack_real in module ida_bytes:

is_pack_real(*args)
    'FF_PACKREAL'
    
    is_pack_real(F) -> bool
        @param F (C++: flags_t)

Help on function is_qword in module ida_bytes:

is_qword(*args)
    'FF_QWORD'
    
    is_qword(F) -> bool
        @param F (C++: flags_t)

Help on function is_same_data_type in module ida_bytes:

is_same_data_type(*args)
    Do the given flags specify the same data type?
    
    is_same_data_type(F1, F2) -> bool
        @param F1 (C++: flags_t)
        @param F2 (C++: flags_t)

Help on function is_seg in module ida_bytes:

is_seg(*args)
    is segment?
    
    is_seg(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_seg0 in module ida_bytes:

is_seg0(*args)
    Is the first operand segment selector? (example: push seg seg001)
    
    is_seg0(F) -> bool
        @param F (C++: flags_t)

Help on function is_seg1 in module ida_bytes:

is_seg1(*args)
    Is the second operand segment selector? (example: mov dx, seg dseg)
    
    is_seg1(F) -> bool
        @param F (C++: flags_t)

Help on function is_stkvar in module ida_bytes:

is_stkvar(*args)
    is stack variable?
    
    is_stkvar(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_stkvar0 in module ida_bytes:

is_stkvar0(*args)
    Is the first operand a stack variable?
    
    is_stkvar0(F) -> bool
        @param F (C++: flags_t)

Help on function is_stkvar1 in module ida_bytes:

is_stkvar1(*args)
    Is the second operand a stack variable?
    
    is_stkvar1(F) -> bool
        @param F (C++: flags_t)

Help on function is_strlit in module ida_bytes:

is_strlit(*args)
    'FF_STRLIT'
    
    is_strlit(F) -> bool
        @param F (C++: flags_t)

Help on function is_stroff in module ida_bytes:

is_stroff(*args)
    is struct offset?
    
    is_stroff(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_stroff0 in module ida_bytes:

is_stroff0(*args)
    Is the first operand an offset within a struct?
    
    is_stroff0(F) -> bool
        @param F (C++: flags_t)

Help on function is_stroff1 in module ida_bytes:

is_stroff1(*args)
    Is the second operand an offset within a struct?
    
    is_stroff1(F) -> bool
        @param F (C++: flags_t)

Help on function is_struct in module ida_bytes:

is_struct(*args)
    'FF_STRUCT'
    
    is_struct(F) -> bool
        @param F (C++: flags_t)

Help on function is_suspop in module ida_bytes:

is_suspop(*args)
    is suspicious operand?
    
    is_suspop(ea, F, n) -> bool
        @param ea (C++: ea_t)
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function is_tail in module ida_bytes:

is_tail(*args)
    Does flag denote tail byte?
    
    is_tail(F) -> bool
        @param F (C++: flags_t)

Help on function is_tbyte in module ida_bytes:

is_tbyte(*args)
    'FF_TBYTE'
    
    is_tbyte(F) -> bool
        @param F (C++: flags_t)

Help on function is_unknown in module ida_bytes:

is_unknown(*args)
    Does flag denote unexplored byte?
    
    is_unknown(F) -> bool
        @param F (C++: flags_t)

Help on function is_varsize_item in module ida_bytes:

is_varsize_item(*args)
    Is the item at 'ea' variable size?.
    
    is_varsize_item(ea, F, ti=None, itemsize=None) -> int
        @param ea: linear address of the item (C++: ea_t)
        @param F: flags (C++: flags_t)
        @param ti: additional information about the data type. For example, if
                   the current item is a structure instance, then ti->tid is
                   structure id. Otherwise is ignored (may be nullptr). If
                   specified as nullptr, will be automatically retrieved from
                   the database (C++: const  opinfo_t  *)
        @param itemsize: if not nullptr and the item is varsize, itemsize will
                         contain the calculated item size (for struct types,
                         the minimal size is returned) (C++: asize_t *)
        @retval: 1 - varsize item
        @retval: 0 - fixed item
        @retval: -1 - error (bad data definition)

Help on function is_word in module ida_bytes:

is_word(*args)
    'FF_WORD'
    
    is_word(F) -> bool
        @param F (C++: flags_t)

Help on function is_yword in module ida_bytes:

is_yword(*args)
    'FF_YWORD'
    
    is_yword(F) -> bool
        @param F (C++: flags_t)

Help on function is_zword in module ida_bytes:

is_zword(*args)
    'FF_ZWORD'
    
    is_zword(F) -> bool
        @param F (C++: flags_t)

Help on function leading_zero_important in module ida_bytes:

leading_zero_important(*args)
    Check if leading zeroes are important.
    
    leading_zero_important(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function nbits in module ida_bytes:

nbits(*args)
    Get number of bits in a byte at the given address.
    
    nbits(ea) -> int
        @param ea (C++: ea_t)
        @return: \ph{dnbits()} if the address doesn't belong to a segment,
                 otherwise the result depends on the segment type

Help on function next_addr in module ida_bytes:

next_addr(*args)
    Get next address in the program (i.e. next address which has flags).
    
    next_addr(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if no such address exist.

Help on function next_chunk in module ida_bytes:

next_chunk(*args)
    Get the first address of next contiguous chunk in the program.
    
    next_chunk(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if next chunk doesn't exist.

Help on function next_head in module ida_bytes:

next_head(*args)
    Get start of next defined item.
    
    next_head(ea, maxea) -> ea_t
        @param ea: begin search at this address (C++: ea_t)
        @param maxea: not included in the search range (C++: ea_t)
        @return: BADADDR  if none exists.

Help on function next_inited in module ida_bytes:

next_inited(*args)
    Find the next initialized address.
    
    next_inited(ea, maxea) -> ea_t
        @param ea (C++: ea_t)
        @param maxea (C++: ea_t)

Help on function next_not_tail in module ida_bytes:

next_not_tail(*args)
    Get address of next non-tail byte.
    
    next_not_tail(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if none exists.

Help on function next_that in module ida_bytes:

next_that(*args)
    next_that(ea, maxea, callable) -> ea_t
    Find next address with a flag satisfying the function 'testf'.
    Start searching from address 'ea'+1 and inspect bytes up to 'maxea'.
    maxea is not included in the search range.
    
    @param callable: a Python callable with the following prototype:
                     callable(flags). Return True to stop enumeration.
    @return: the found address or BADADDR.

Help on function next_unknown in module ida_bytes:

next_unknown(*args)
    Similar to 'next_that()' , but will find the next address that is
    unexplored.
    
    next_unknown(ea, maxea) -> ea_t
        @param ea (C++: ea_t)
        @param maxea (C++: ea_t)

Help on function num_flag in module ida_bytes:

num_flag(*args)
    Get number of default base (bin, oct, dec, hex)

Help on function oct_flag in module ida_bytes:

oct_flag(*args)
    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'

Help on function off_flag in module ida_bytes:

off_flag(*args)
    see 'Bits: instruction operand types'

Help on function op_adds_xrefs in module ida_bytes:

op_adds_xrefs(*args)
    Should processor module create xrefs from the operand?. Currently
    'offset' and 'structure offset' operands create xrefs
    
    op_adds_xrefs(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)

Help on function op_bin in module ida_bytes:

op_bin(*args)
    set op type to 'bin_flag()'
    
    op_bin(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_chr in module ida_bytes:

op_chr(*args)
    set op type to 'char_flag()'
    
    op_chr(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_custfmt in module ida_bytes:

op_custfmt(*args)
    Set custom data format for operand (fid-custom data format id)
    
    op_custfmt(ea, n, fid) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param fid (C++: int)

Help on function op_dec in module ida_bytes:

op_dec(*args)
    set op type to 'dec_flag()'
    
    op_dec(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_enum in module ida_bytes:

op_enum(*args)
    Set operand representation to be 'enum_t'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    op_enum(ea, n, id, serial) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @param id: id of enum (C++: enum_t)
        @param serial: the serial number of the constant in the enumeration,
                       usually 0. the serial numbers are used if the
                       enumeration contains several constants with the same
                       value (C++: uchar)
        @return: success

Help on function op_flt in module ida_bytes:

op_flt(*args)
    set op type to 'flt_flag()'
    
    op_flt(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_hex in module ida_bytes:

op_hex(*args)
    set op type to 'hex_flag()'
    
    op_hex(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_num in module ida_bytes:

op_num(*args)
    set op type to 'num_flag()'
    
    op_num(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_oct in module ida_bytes:

op_oct(*args)
    set op type to 'oct_flag()'
    
    op_oct(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_seg in module ida_bytes:

op_seg(*args)
    Set operand representation to be 'segment'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    op_seg(ea, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: success

Help on function op_stkvar in module ida_bytes:

op_stkvar(*args)
    Set operand representation to be 'stack variable'. Should be applied
    to an instruction within a function. Should be applied after creating
    a stack var using 'insn_t::create_stkvar()' .
    
    op_stkvar(ea, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: success

Help on function op_stroff in module ida_bytes:

op_stroff(*args)
    Set operand representation to be 'struct offset'. If applied to
    unexplored bytes, converts them to 16/32bit word data
    
    op_stroff(insn, n, path, path_len, delta) -> bool
        @param insn: the instruction  - an ida_ua.insn_t, or an address (C++:
                     const insn_t &)
        @param n: number of operand (0, 1, -1) (C++: int)
        @param path: structure path (strpath). see  nalt.hpp  for more info.
                     (C++: const  tid_t  *)
        @param path_len: length of the structure path (C++: int)
        @param delta: struct offset delta. usually 0. denotes the difference
                      between the structure base and the pointer into the
                      structure. (C++: adiff_t)
        @return: success
    
    Example:
    Python> 
    Python> ins = ida_ua.insn_t()
    Python> if ida_ua.decode_insn(ins, some_address):
    Python>     path_len = 1
    Python>     path = ida_pro.tid_array(path_len)
    Python>     path[0] = ida_struct.get_struc_id("my_stucture_t")
    Python>     ida_bytes.op_stroff(ins, 0, path.cast(), path_len, 0)
    Python>

Help on function oword_flag in module ida_bytes:

oword_flag(*args)
    Get a flags_t representing a octaword.

Help on function packreal_flag in module ida_bytes:

packreal_flag(*args)
    Get a flags_t representing a packed decimal real.

Help on function patch_byte in module ida_bytes:

patch_byte(*args)
    Patch a byte of the program. The original value of the byte is saved
    and can be obtained by 'get_original_byte()' . This function works for
    wide byte processors too.
    
    patch_byte(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.

Help on function patch_bytes in module ida_bytes:

patch_bytes(*args)
    Patch the specified number of bytes of the program. Original values of
    bytes are saved and are available with get_original...() functions.
    See also 'put_bytes()' .
    
    patch_bytes(ea, buf)
        @param ea: linear address (C++: ea_t)
        @param buf: buffer with new values of bytes (C++: const void *)

Help on function patch_dword in module ida_bytes:

patch_dword(*args)
    Patch a dword of the program. The original value of the dword is saved
    and can be obtained by 'get_original_dword()' . This function DOESN'T
    work for wide byte processors. This function takes into account order
    of bytes specified in \inf{is_be()}
    
    patch_dword(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.

Help on function patch_qword in module ida_bytes:

patch_qword(*args)
    Patch a qword of the program. The original value of the qword is saved
    and can be obtained by 'get_original_qword()' . This function DOESN'T
    work for wide byte processors. This function takes into account order
    of bytes specified in \inf{is_be()}
    
    patch_qword(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.

Help on function patch_word in module ida_bytes:

patch_word(*args)
    Patch a word of the program. The original value of the word is saved
    and can be obtained by 'get_original_word()' . This function works for
    wide byte processors too. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    patch_word(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.

Help on function prev_addr in module ida_bytes:

prev_addr(*args)
    Get previous address in the program.
    
    prev_addr(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if no such address exist.

Help on function prev_chunk in module ida_bytes:

prev_chunk(*args)
    Get the last address of previous contiguous chunk in the program.
    
    prev_chunk(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if previous chunk doesn't exist.

Help on function prev_head in module ida_bytes:

prev_head(*args)
    Get start of previous defined item.
    
    prev_head(ea, minea) -> ea_t
        @param ea: begin search at this address (C++: ea_t)
        @param minea: included in the search range (C++: ea_t)
        @return: BADADDR  if none exists.

Help on function prev_inited in module ida_bytes:

prev_inited(*args)
    Find the previous initialized address.
    
    prev_inited(ea, minea) -> ea_t
        @param ea (C++: ea_t)
        @param minea (C++: ea_t)

Help on function prev_not_tail in module ida_bytes:

prev_not_tail(*args)
    Get address of previous non-tail byte.
    
    prev_not_tail(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if none exists.

Help on function prev_that in module ida_bytes:

prev_that(*args)
    Find previous address with a flag satisfying the function 'testf'.do
    not pass 'is_unknown()' to this function to find unexplored bytes It
    will fail under the debugger. To find unexplored bytes, use
    'prev_unknown()' .
    
    prev_that(ea, minea, callable) -> ea_t
        @param ea: start searching from this address - 1. (C++: ea_t)
        @param minea: included in the search range. (C++: ea_t)
        callable: PyObject *
        @return: the found address or  BADADDR .

Help on function prev_unknown in module ida_bytes:

prev_unknown(*args)
    Similar to 'prev_that()' , but will find the previous address that is
    unexplored.
    
    prev_unknown(ea, minea) -> ea_t
        @param ea (C++: ea_t)
        @param minea (C++: ea_t)

Help on function print_strlit_type in module ida_bytes:

print_strlit_type(*args)
    Get string type information: the string type name (possibly decorated
    with hotkey markers), and the tooltip.
    
    print_strlit_type(strtype, flags=0) -> PyObject *
        @param strtype: the string type (C++: int32)
        @param flags: or'ed PSTF_* constants (C++: int)
        @return: length of generated text

Help on function put_byte in module ida_bytes:

put_byte(*args)
    Set value of one byte of the program. This function modifies the
    database. If the debugger is active then the debugged process memory
    is patched too.The original value of the byte is completely lost and
    can't be recovered by the 'get_original_byte()' function. See also
    'put_dbg_byte()' to write to the process memory directly when the
    debugger is active. This function can handle wide byte processors.
    
    put_byte(ea, x) -> bool
        @param ea: linear address (C++: ea_t)
        @param x: byte value (C++: uint64)
        @return: true if the database has been modified

Help on function put_bytes in module ida_bytes:

put_bytes(*args)
    Modify the specified number of bytes of the program. This function
    does not save the original values of bytes. See also 'patch_bytes()' .
    
    put_bytes(ea, buf)
        @param ea: linear address (C++: ea_t)
        @param buf: buffer with new values of bytes (C++: const void *)

Help on function put_dword in module ida_bytes:

put_dword(*args)
    Set value of one dword of the program. This function takes into
    account order of bytes specified in \inf{is_be()} This function works
    for wide byte processors too.the original value of the dword is
    completely lost and can't be recovered by the 'get_original_dword()'
    function.
    
    put_dword(ea, x)
        @param ea: linear address (C++: ea_t)
        @param x: dword value (C++: uint64)

Help on function put_qword in module ida_bytes:

put_qword(*args)
    Set value of one qword (8 bytes) of the program. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    DOESN'T works for wide byte processors.
    
    put_qword(ea, x)
        @param ea: linear address (C++: ea_t)
        @param x: qword value (C++: uint64)

Help on function put_word in module ida_bytes:

put_word(*args)
    Set value of one word of the program. This function takes into account
    order of bytes specified in \inf{is_be()} This function works for wide
    byte processors too.The original value of the word is completely lost
    and can't be recovered by the 'get_original_word()' function. ea -
    linear address x - word value
    
    put_word(ea, x)
        @param ea (C++: ea_t)
        @param x (C++: uint64)

Help on function qword_flag in module ida_bytes:

qword_flag(*args)
    Get a flags_t representing a quad word.

Help on function register_custom_data_format in module ida_bytes:

register_custom_data_format(*args)
    register_custom_data_format(py_df) -> int
    Registers a custom data format with a given data type.
    @param df: an instance of data_format_t
    @return:
        < 0 if failed to register
        > 0 data format id

Help on function register_custom_data_type in module ida_bytes:

register_custom_data_type(*args)
    register_custom_data_type(py_dt) -> int
    Registers a custom data type.
    @param dt: an instance of the data_type_t class
    @return:
        < 0 if failed to register
        > 0 data type id

Help on function register_data_types_and_formats in module ida_bytes:

register_data_types_and_formats(formats)
    Registers multiple data types and formats at once.
    To register one type/format at a time use register_custom_data_type/register_custom_data_format
    
    It employs a special table of types and formats described below:
    
    The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
    If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
    many_formats = [
      (pascal_data_type(), pascal_data_format()),
      (simplevm_data_type(), simplevm_data_format()),
      (makedword_data_format(),),
      (simplevm_data_format(),)
    ]
    The first two tuples describe data types and their associated formats.
    The last two tuples describe two data formats to be used with built-in data types.
    The data format may be attached to several data types. The id of the
    data format is stored in the first data_format_t object. For example:
    assert many_formats[1][1] != -1
    assert many_formats[2][0] != -1
    assert many_formats[3][0] == -1

Help on function revert_byte in module ida_bytes:

revert_byte(*args)
    Revert patched byte
    
    revert_byte(ea) -> bool
        @param ea (C++: ea_t)
        @retval: true - byte was patched before and reverted now

Help on function seg_flag in module ida_bytes:

seg_flag(*args)
    see 'Bits: instruction operand types'

Help on function set_cmt in module ida_bytes:

set_cmt(*args)
    Set an indented comment.
    
    set_cmt(ea, comm, rptble) -> bool
        @param ea: linear address (C++: ea_t)
        @param comm: comment string   nullptr: do nothing (return 0)   "" :
                     delete comment (C++: const char *)
        @param rptble: is repeatable? (C++: bool)
        @return: success

Help on function set_forced_operand in module ida_bytes:

set_forced_operand(*args)
    Set forced operand.
    
    set_forced_operand(ea, n, op) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, 2) (C++: int)
        @param op: text of operand   nullptr: do nothing (return 0)   "" :
                   delete forced operand (C++: const char *)
        @return: success

Help on function set_immd in module ida_bytes:

set_immd(*args)
    Set 'has immediate operand' flag. Returns true if the 'FF_IMMD' bit
    was not set and now is set
    
    set_immd(ea) -> bool
        @param ea (C++: ea_t)

Help on function set_lzero in module ida_bytes:

set_lzero(*args)
    Set toggle lzero bit.
    
    set_lzero(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function set_manual_insn in module ida_bytes:

set_manual_insn(*args)
    Set manual instruction string.
    
    set_manual_insn(ea, manual_insn)
        @param ea: linear address of the instruction or data item (C++: ea_t)
        @param manual_insn: "" - delete manual string. nullptr - do nothing
                            (C++: const char *)

Help on function set_op_type in module ida_bytes:

set_op_type(*args)
    (internal function) change representation of operand(s).
    
    set_op_type(ea, type, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param type: new flag value (should be obtained from  char_flag() ,
                     num_flag()  and similar functions) (C++: flags_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed (applied to a tail byte)

Help on function set_opinfo in module ida_bytes:

set_opinfo(*args)
    Set additional information about an operand representation. This
    function is a low level one. Only the kernel should use it.
    
    set_opinfo(ea, n, flag, ti, suppress_events=False) -> bool
        @param ea: linear address of the item (C++: ea_t)
        @param n: number of operand, 0 or 1 (C++: int)
        @param flag: flags of the item (C++: flags_t)
        @param ti: additional representation information (C++: const  opinfo_t
                   *)
        @param suppress_events: do not generate changing_op_type and
                                op_type_changed events (C++: bool)
        @return: success

Help on function stkvar_flag in module ida_bytes:

stkvar_flag(*args)
    see 'Bits: instruction operand types'

Help on function strlit_flag in module ida_bytes:

strlit_flag(*args)
    Get a flags_t representing a string literal.

Help on function stroff_flag in module ida_bytes:

stroff_flag(*args)
    see 'Bits: instruction operand types'

Help on function stru_flag in module ida_bytes:

stru_flag(*args)
    Get a flags_t representing a struct.

Help on function tbyte_flag in module ida_bytes:

tbyte_flag(*args)
    Get a flags_t representing a tbyte.

Help on function toggle_bnot in module ida_bytes:

toggle_bnot(*args)
    Toggle binary negation of operand. also see 'is_bnot()'
    
    toggle_bnot(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function toggle_lzero in module ida_bytes:

toggle_lzero(*args)
    toggle_lzero(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function toggle_sign in module ida_bytes:

toggle_sign(*args)
    Toggle sign of n-th operand. allowed values of n: 0-first operand,
    1-other operands
    
    toggle_sign(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function unregister_custom_data_format in module ida_bytes:

unregister_custom_data_format(*args)
    unregister_custom_data_format(dfid) -> bool
    Unregisters a custom data format
    @param dfid: data format id
    @return: Boolean

Help on function unregister_custom_data_type in module ida_bytes:

unregister_custom_data_type(*args)
    unregister_custom_data_type(dtid) -> bool
    Unregisters a custom data type.
    @param dtid: the data type id
    @return: Boolean

Help on function unregister_data_types_and_formats in module ida_bytes:

unregister_data_types_and_formats(formats)
    As opposed to register_data_types_and_formats(), this function
    unregisters multiple data types and formats at once.

Help on function update_hidden_range in module ida_bytes:

update_hidden_range(*args)
    Update hidden range information in the database. You cannot use this
    function to change the range boundaries
    
    update_hidden_range(ha) -> bool
        @param ha: range to update (C++: const  hidden_range_t  *)
        @return: success

Help on function use_mapping in module ida_bytes:

use_mapping(*args)
    Translate address according to current mappings.
    
    use_mapping(ea) -> ea_t
        @param ea: address to translate (C++: ea_t)
        @return: translated address

Help on function visit_patched_bytes in module ida_bytes:

visit_patched_bytes(*args)
    visit_patched_bytes(ea1, ea2, py_callable) -> int
    Enumerates patched bytes in the given range and invokes a callable
    @param ea1: start address
    @param ea2: end address
    @param callable: a Python callable with the following prototype:
                     callable(ea, fpos, org_val, patch_val).
                     If the callable returns non-zero then that value will be
                     returned to the caller and the enumeration will be
                     interrupted.
    @return: Zero if the enumeration was successful or the return
             value of the callback if enumeration was interrupted.

Help on function word_flag in module ida_bytes:

word_flag(*args)
    Get a flags_t representing a word.

Help on function yword_flag in module ida_bytes:

yword_flag(*args)
    Get a flags_t representing a ymm word.

Help on function zword_flag in module ida_bytes:

zword_flag(*args)
    Get a flags_t representing a zmm word.

=== ida_bytes EPYDOC INJECTIONS ===
ida_bytes.ALOPT_IGNCLT
"""
if set, don't stop at codepoints that are not part of the current
'culture'; accept all those that are graphical (this is typically used
used by user-initiated actions creating string literals.)
"""

ida_bytes.ALOPT_IGNHEADS
"""
don't stop if another data item is encountered. only the byte values
will be used to determine the string length. if not set, a defined
data item or instruction will truncate the string
"""

ida_bytes.ALOPT_IGNPRINT
"""
if set, don't stop at non-printable codepoints, but only at the
terminating character (or not unicode-mapped character (e.g., 0x8f in
CP1252))
"""

ida_bytes.ALOPT_MAX4K
"""
accumulated length

if string length is more than 4K, return the
"""

ida_bytes.BIN_SEARCH_BACKWARD
"""
search backward for bytes
"""

ida_bytes.BIN_SEARCH_CASE
"""
case sensitive
"""

ida_bytes.BIN_SEARCH_FORWARD
"""
search forward for bytes
"""

ida_bytes.BIN_SEARCH_INITED
"""
find_byte, find_byter: any initilized value
"""

ida_bytes.BIN_SEARCH_NOBREAK
"""
don't check for Ctrl-Break
"""

ida_bytes.BIN_SEARCH_NOCASE
"""
case insensitive
"""

ida_bytes.BIN_SEARCH_NOSHOW
"""
don't show search progress or update screen
"""

ida_bytes.DELIT_DELNAMES
"""
delete any names at the specified address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_EXPAND
"""
propagate undefined items; for example if removing an instruction
removes all references to the next instruction, then plan to convert
to unexplored the next instruction too.
"""

ida_bytes.DELIT_KEEPFUNC
"""
Just delete xrefs, ops e.t.c.

do not undefine the function start.
"""

ida_bytes.DELIT_NOCMT
"""
reject to delete if a comment is in address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_NOTRUNC
"""
even if 'AF_TRFUNC' is set

don't truncate the current function
"""

ida_bytes.DELIT_NOUNAME
"""
reject to delete if a user name is in address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_SIMPLE
"""
simply undefine the specified item(s)
"""

ida_bytes.DTP_NODUP
"""
do not use dup construct
"""

ida_bytes.DT_TYPE
"""
Mask for DATA typing.
"""

ida_bytes.FF_0CHAR
"""
Char ('x')?
"""

ida_bytes.FF_0CUST
"""
Custom representation?
"""

ida_bytes.FF_0ENUM
"""
Enumeration?
"""

ida_bytes.FF_0FLT
"""
Floating point number?
"""

ida_bytes.FF_0FOP
"""
Forced operand?
"""

ida_bytes.FF_0NUMB
"""
Binary number?
"""

ida_bytes.FF_0NUMD
"""
Decimal number?
"""

ida_bytes.FF_0NUMH
"""
Hexadecimal number?
"""

ida_bytes.FF_0NUMO
"""
Octal number?
"""

ida_bytes.FF_0OFF
"""
Offset?
"""

ida_bytes.FF_0SEG
"""
Segment?
"""

ida_bytes.FF_0STK
"""
Stack variable?
"""

ida_bytes.FF_0STRO
"""
Struct offset?
"""

ida_bytes.FF_0VOID
"""
Void (unknown)?
"""

ida_bytes.FF_1CHAR
"""
Char ('x')?
"""

ida_bytes.FF_1CUST
"""
Custom representation?
"""

ida_bytes.FF_1ENUM
"""
Enumeration?
"""

ida_bytes.FF_1FLT
"""
Floating point number?
"""

ida_bytes.FF_1FOP
"""
Forced operand?
"""

ida_bytes.FF_1NUMB
"""
Binary number?
"""

ida_bytes.FF_1NUMD
"""
Decimal number?
"""

ida_bytes.FF_1NUMH
"""
Hexadecimal number?
"""

ida_bytes.FF_1NUMO
"""
Octal number?
"""

ida_bytes.FF_1OFF
"""
Offset?
"""

ida_bytes.FF_1SEG
"""
Segment?
"""

ida_bytes.FF_1STK
"""
Stack variable?
"""

ida_bytes.FF_1STRO
"""
Struct offset?
"""

ida_bytes.FF_1VOID
"""
Void (unknown)?
"""

ida_bytes.FF_ALIGN
"""
alignment directive
"""

ida_bytes.FF_BNOT
"""
Bitwise negation of operands.
"""

ida_bytes.FF_BYTE
"""
byte
"""

ida_bytes.FF_CODE
"""
Code ?
"""

ida_bytes.FF_COMM
"""
Has comment ?
"""

ida_bytes.FF_CUSTOM
"""
custom data type
"""

ida_bytes.FF_DATA
"""
Data ?
"""

ida_bytes.FF_DOUBLE
"""
double
"""

ida_bytes.FF_DWORD
"""
double word
"""

ida_bytes.FF_FLOAT
"""
float
"""

ida_bytes.FF_FLOW
"""
Exec flow from prev instruction.
"""

ida_bytes.FF_FUNC
"""
function start?
"""

ida_bytes.FF_IMMD
"""
Has Immediate value ?
"""

ida_bytes.FF_IVL
"""
Byte has value ?
"""

ida_bytes.FF_JUMP
"""
Has jump table or switch_info?
"""

ida_bytes.FF_LABL
"""
Has dummy name?
"""

ida_bytes.FF_LINE
"""
Has next or prev lines ?
"""

ida_bytes.FF_NAME
"""
Has name ?
"""

ida_bytes.FF_OWORD
"""
octaword/xmm word (16 bytes/128 bits)
"""

ida_bytes.FF_PACKREAL
"""
packed decimal real
"""

ida_bytes.FF_QWORD
"""
quadro word
"""

ida_bytes.FF_REF
"""
has references
"""

ida_bytes.FF_SIGN
"""
Inverted sign of operands.
"""

ida_bytes.FF_STRLIT
"""
string literal
"""

ida_bytes.FF_STRUCT
"""
struct variable
"""

ida_bytes.FF_TAIL
"""
Tail ?
"""

ida_bytes.FF_TBYTE
"""
tbyte
"""

ida_bytes.FF_UNK
"""
Unknown ?
"""

ida_bytes.FF_UNUSED
"""
unused bit (was used for variable bytes)
"""

ida_bytes.FF_WORD
"""
word
"""

ida_bytes.FF_YWORD
"""
ymm word (32 bytes/256 bits)
"""

ida_bytes.FF_ZWORD
"""
zmm word (64 bytes/512 bits)
"""

ida_bytes.GFE_VALUE
"""
get flags with 'FF_IVL' & 'MS_VAL' . It is much slower under remote
debugging because the kernel needs to read the process memory.
"""

ida_bytes.GMB_READALL
"""
if this bit is not set, fail at first uninited byte

try to read all bytes
"""

ida_bytes.GMB_WAITBOX
"""
show wait box (may return -1 in this case)
"""

ida_bytes.ITEM_END_FIXUP
"""
stop at the first fixup
"""

ida_bytes.ITEM_END_INITED
"""
stop when initialization changes i.e.if is_loaded(ea): stop if
uninitialized byte is encounteredif !is_loaded(ea): stop if
initialized byte is encountered
"""

ida_bytes.ITEM_END_NAME
"""
stop at the first named location
"""

ida_bytes.ITEM_END_XREF
"""
stop at the first referenced location
"""

ida_bytes.MS_0TYPE
"""
Mask for 1st arg typing.
"""

ida_bytes.MS_1TYPE
"""
Mask for the type of other operands.
"""

ida_bytes.MS_CLS
"""
Mask for typing.
"""

ida_bytes.MS_CODE
"""
Mask for code bits.
"""

ida_bytes.MS_COMM
"""
Mask of common bits.
"""

ida_bytes.MS_VAL
"""
Mask for byte value.
"""

ida_bytes.OPND_ALL
"""
all operands
"""

ida_bytes.OPND_MASK
"""
mask for operand number
"""

ida_bytes.OPND_OUTER
"""
used only in set, get, del_offset() functions

outer offset base (combined with operand number).
"""

ida_bytes.PSTF_ENC
"""
if encoding is specified, append it
"""

ida_bytes.PSTF_HOTKEY
"""
have hotkey markers part of the name
"""

ida_bytes.PSTF_TBRIEF
"""
use brief name (e.g., in the 'Strings window')
"""

ida_bytes.PSTF_TINLIN
"""
use 'inline' name (e.g., in the structures comments)
"""

ida_bytes.PSTF_TMASK
"""
type mask
"""

ida_bytes.PSTF_TNORM
"""
use normal name
"""

ida_bytes.STRCONV_ESCAPE
"""
convert non-printable characters to C escapes (, \\xNN, \\uNNNN)
"""

ida_bytes.STRCONV_INCLLEN
"""
for Pascal-style strings, include the prefixing length byte(s) as
C-escaped sequence
"""

ida_bytes.STRCONV_REPLCHAR
"""
convert non-printable characters to the Unicode replacement character
(U+FFFD)
"""
=== ida_bytes EPYDOC INJECTIONS END ===
Help on class DBG_Hooks in module ida_dbg:

class DBG_Hooks(__builtin__.object)
 |  Proxy of C++ DBG_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> DBG_Hooks
 |          _flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  dbg_bpt(self, *args)
 |      A user defined breakpoint was reached.
 |      
 |      dbg_bpt(self, tid, bptea) -> int
 |          @param tid (C++: thid_t)
 |          @param bptea (C++: ea_t)
 |  
 |  dbg_bpt_changed(self, *args)
 |      Breakpoint has been changed.
 |      
 |      dbg_bpt_changed(self, bptev_code, bpt)
 |          @param bptev_code: Breakpoint modification events  (C++: int)
 |          @param bpt (C++: bpt_t *)
 |  
 |  dbg_exception(self, *args)
 |      dbg_exception(self, pid, tid, ea, exc_code, exc_can_cont, exc_ea, exc_info) -> int
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |          exc_code: int
 |          exc_can_cont: bool
 |          exc_ea: ea_t
 |          exc_info: char const *
 |  
 |  dbg_finished_loading_bpts(self, *args)
 |      Finished loading breakpoint info from idb.
 |  
 |  dbg_information(self, *args)
 |      dbg_information(self, pid, tid, ea, info)
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |          info: char const *
 |  
 |  dbg_library_load(self, *args)
 |      dbg_library_load(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |          modinfo_name: char const *
 |          modinfo_base: ea_t
 |          modinfo_size: asize_t
 |  
 |  dbg_library_unload(self, *args)
 |      dbg_library_unload(self, pid, tid, ea, info)
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |          info: char const *
 |  
 |  dbg_process_attach(self, *args)
 |      This event notification is also an asynchronous function result
 |      notification for 'start_process()' !
 |      
 |      dbg_process_attach(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |          modinfo_name: char const *
 |          modinfo_base: ea_t
 |          modinfo_size: asize_t
 |  
 |  dbg_process_detach(self, *args)
 |      This event notification is also an asynchronous function result
 |      notification for 'start_process()' !
 |      
 |      dbg_process_detach(self, pid, tid, ea)
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |  
 |  dbg_process_exit(self, *args)
 |      This event notification is also an asynchronous function result
 |      notification for 'start_process()' !
 |      
 |      dbg_process_exit(self, pid, tid, ea, exit_code)
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |          exit_code: int
 |  
 |  dbg_process_start(self, *args)
 |      This event notification is also an asynchronous function result
 |      notification for 'start_process()' !
 |      
 |      dbg_process_start(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |          modinfo_name: char const *
 |          modinfo_base: ea_t
 |          modinfo_size: asize_t
 |  
 |  dbg_request_error(self, *args)
 |      An error occurred during the processing of a request.
 |      
 |      dbg_request_error(self, failed_command, failed_dbg_notification)
 |          @param failed_command (C++: ui_notification_t)
 |          @param failed_dbg_notification (C++: dbg_notification_t)
 |  
 |  dbg_run_to(self, *args)
 |      dbg_run_to(self, pid, tid, ea)
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |  
 |  dbg_started_loading_bpts(self, *args)
 |      Started loading breakpoint info from idb.
 |  
 |  dbg_step_into(self, *args)
 |      dbg_step_into(self)
 |  
 |  dbg_step_over(self, *args)
 |      dbg_step_over(self)
 |  
 |  dbg_step_until_ret(self, *args)
 |      dbg_step_until_ret(self)
 |  
 |  dbg_suspend_process(self, *args)
 |      The process is now suspended.This event notification is also an
 |      asynchronous function result notification for 'suspend_process()' !
 |  
 |  dbg_thread_exit(self, *args)
 |      dbg_thread_exit(self, pid, tid, ea, exit_code)
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |          exit_code: int
 |  
 |  dbg_thread_start(self, *args)
 |      dbg_thread_start(self, pid, tid, ea)
 |          pid: pid_t
 |          tid: thid_t
 |          ea: ea_t
 |  
 |  dbg_trace(self, *args)
 |      A step occurred (one instruction was executed). This event
 |      notification is only generated if step tracing is enabled.
 |      
 |      dbg_trace(self, tid, ip) -> int
 |          @param tid: thread ID  (C++: thid_t)
 |          @param ip: current instruction pointer. usually points after the
 |                     executed instruction  (C++: ea_t)
 |          @retval: 1 - do not log this trace event
 |          @retval: 0 - log it
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_DBG_Hooks>
 |      delete_DBG_Hooks(self)

Help on function add_bpt in module ida_dbg:

add_bpt(*args)
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous
    function)}Only one breakpoint can exist at a given address.
    
    add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
        @param ea: any address in the process memory space. Depending on the
                   architecture, hardware breakpoints always be setup at
                   random address. For example, on x86, hardware breakpoints
                   should be aligned depending on their size. Moreover, on the
                   x86 architecture, it is impossible to setup more than 4
                   hardware breakpoints. (C++: ea_t)
        @param size: size of the breakpoint (irrelevant for software
                     breakpoints): As for the address, hardware breakpoints
                     can't always be setup with random size. (C++: asize_t)
        @param type: type of the breakpoint ( BPT_SOFT  for software
                     breakpoint) special case  BPT_DEFAULT  ( BPT_SOFT |
                     BPT_EXEC ): try to add instruction breakpoint of the
                     appropriate type as follows: software bpt if supported,
                     hwbpt otherwise (C++: bpttype_t)
    
    
    add_bpt(bpt) -> bool
        bpt: bpt_t const &

Help on function add_path_mapping in module ida_dbg:

add_path_mapping(*args)
    add_path_mapping(src, dst)
        @param src (C++: const char *)
        @param dst (C++: const char *)

Help on function add_virt_module in module ida_dbg:

add_virt_module(*args)
    add_virt_module(mod) -> bool
        @param mod (C++: const  modinfo_t  *)

Help on function attach_process in module ida_dbg:

attach_process(*args)
    Attach the debugger to a running process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_attach'
    }This function shouldn't be called as a request if 'NO_PROCESS' is
    used.
    
    attach_process(pid=pid_t(-1), event_id=-1) -> int
        @param pid: PID of the process to attach to. If  NO_PROCESS , a dialog
                    box will interactively ask the user for the process to
                    attach to. (C++: pid_t)
        @param event_id (C++: int)
        @retval: -4 - debugger was not inited
        @retval: -3 - the attaching is not supported
        @retval: -2 - impossible to find a compatible process
        @retval: -1 - impossible to attach to the given process (process died,
                      privilege needed, not supported by the debugger plugin,
                      ...)
        @retval: 0 - the user cancelled the attaching to the process
        @retval: 1 - the debugger properly attached to the process

Help on class bpt_location_t in module ida_dbg:

class bpt_location_t(__builtin__.object)
 |  Proxy of C++ bpt_location_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: bpt_location_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: bpt_location_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: bpt_location_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bpt_location_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: bpt_location_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: bpt_location_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: bpt_location_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      Lexically compare two breakpoint locations. Bpt locations are first
 |      compared based on type (i.e. 'BPLT_ABS' < 'BPLT_REL' ). 'BPLT_ABS'
 |      locations are compared based on their ea values. For all other
 |      location types, locations are first compared based on their string
 |      (path/filename/symbol), then their offset/lineno.
 |      
 |      compare(self, r) -> int
 |          @param r (C++: const  bpt_location_t  &)
 |  
 |  ea(self, *args)
 |      Get address ( 'BPLT_ABS' )
 |  
 |  is_empty_path(self, *args)
 |      No path/filename specified? ( 'BPLT_REL' , 'BPLT_SRC' )
 |  
 |  lineno(self, *args)
 |      Get line number ( 'BPLT_SRC' )
 |  
 |  offset(self, *args)
 |      Get offset ( 'BPLT_REL' , 'BPLT_SYM' )
 |  
 |  path(self, *args)
 |      Get path/filename ( 'BPLT_REL' , 'BPLT_SRC' )
 |  
 |  set_abs_bpt(self, *args)
 |      Specify an absolute address location.
 |      
 |      set_abs_bpt(self, a)
 |          @param a (C++: ea_t)
 |  
 |  set_rel_bpt(self, *args)
 |      Specify a relative address location.
 |      
 |      set_rel_bpt(self, mod, _offset)
 |          @param mod (C++: const char *)
 |          @param _offset (C++: uval_t)
 |  
 |  set_src_bpt(self, *args)
 |      Specify a source level location.
 |      
 |      set_src_bpt(self, fn, _lineno)
 |          @param fn (C++: const char *)
 |          @param _lineno (C++: int)
 |  
 |  set_sym_bpt(self, *args)
 |      Specify a symbolic location.
 |      
 |      set_sym_bpt(self, _symbol, _offset=0)
 |          @param _symbol (C++: const char *)
 |          @param _offset (C++: uval_t)
 |  
 |  symbol(self, *args)
 |      Get symbol name ( 'BPLT_SYM' )
 |  
 |  type(self, *args)
 |      Get bpt type.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  index
 |      bpt_location_t_index_get(self) -> int
 |  
 |  info
 |      bpt_location_t_info_get(self) -> ea_t
 |  
 |  loctype
 |      bpt_location_t_loctype_get(self) -> bpt_loctype_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_bpt_location_t>
 |      delete_bpt_location_t(self)

Help on class bpt_t in module ida_dbg:

class bpt_t(__builtin__.object)
 |  Proxy of C++ bpt_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bpt_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  badbpt(self, *args)
 |      Failed to write bpt to process memory?
 |  
 |  enabled(self, *args)
 |      Is breakpoint enabled?
 |  
 |  get_cnd_elang_idx(self, *args)
 |      get_cnd_elang_idx(self) -> size_t
 |  
 |  get_size(self, *args)
 |      Get bpt size.
 |  
 |  is_absbpt(self, *args)
 |      Is absolute address breakpoint?
 |  
 |  is_active(self, *args)
 |      Written completely to process?
 |  
 |  is_compiled(self, *args)
 |      Condition has been compiled?
 |  
 |  is_hwbpt(self, *args)
 |      Is hardware breakpoint?
 |  
 |  is_inactive(self, *args)
 |      Not written to process at all?
 |  
 |  is_low_level(self, *args)
 |      Is bpt condition calculated at low level?
 |  
 |  is_page_bpt(self, *args)
 |      Page breakpoint?
 |  
 |  is_partially_active(self, *args)
 |      Written partially to process?
 |  
 |  is_relbpt(self, *args)
 |      Is relative address breakpoint?
 |  
 |  is_srcbpt(self, *args)
 |      Is source level breakpoint?
 |  
 |  is_symbpt(self, *args)
 |      Is symbolic breakpoint?
 |  
 |  is_tracemodebpt(self, *args)
 |      Does breakpoint trace anything?
 |  
 |  is_traceoffbpt(self, *args)
 |      Is this a tracing breakpoint, and is tracing disabled?
 |  
 |  is_traceonbpt(self, *args)
 |      Is this a tracing breakpoint, and is tracing enabled?
 |  
 |  listbpt(self, *args)
 |      Include in the bpt list?
 |  
 |  set_abs_bpt(self, *args)
 |      Set bpt location to an absolute address.
 |      
 |      set_abs_bpt(self, a)
 |          @param a (C++: ea_t)
 |  
 |  set_rel_bpt(self, *args)
 |      Set bpt location to a relative address.
 |      
 |      set_rel_bpt(self, mod, o)
 |          @param mod (C++: const char *)
 |          @param o (C++: uval_t)
 |  
 |  set_src_bpt(self, *args)
 |      Set bpt location to a source line.
 |      
 |      set_src_bpt(self, fn, lineno)
 |          @param fn (C++: const char *)
 |          @param lineno (C++: int)
 |  
 |  set_sym_bpt(self, *args)
 |      Set bpt location to a symbol.
 |      
 |      set_sym_bpt(self, sym, o)
 |          @param sym (C++: const char *)
 |          @param o (C++: uval_t)
 |  
 |  set_trace_action(self, *args)
 |      Configure tracing options.
 |      
 |      set_trace_action(self, enable, trace_types) -> bool
 |          @param enable (C++: bool)
 |          @param trace_types (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      bpt_t_cb_get(self) -> size_t
 |  
 |  cndidx
 |      bpt_t_cndidx_get(self) -> int
 |  
 |  condition
 |      bpt_t_condition_get(self) -> PyObject *
 |  
 |  ea
 |      bpt_t_ea_get(self) -> ea_t
 |  
 |  elang
 |      bpt_t_elang_get(self) -> PyObject *
 |  
 |  flags
 |      bpt_t_flags_get(self) -> uint32
 |  
 |  loc
 |      bpt_t_loc_get(self) -> bpt_location_t
 |  
 |  pass_count
 |      bpt_t_pass_count_get(self) -> int
 |  
 |  pid
 |      bpt_t_pid_get(self) -> pid_t
 |  
 |  props
 |      bpt_t_props_get(self) -> uint32
 |  
 |  size
 |      bpt_t_size_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      bpt_t_tid_get(self) -> thid_t
 |  
 |  type
 |      bpt_t_type_get(self) -> bpttype_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_bpt_t>
 |      delete_bpt_t(self)

Help on class bpt_vec_t in module ida_dbg:

class bpt_vec_t(__builtin__.object)
 |  Proxy of C++ qvector< bpt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> bpt_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bpt_vec_t
 |          x: qvector< bpt_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: bpt_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> bpt_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> bpt_t
 |      begin(self) -> bpt_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> bpt_t
 |      end(self) -> bpt_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> bpt_t
 |          it: qvector< bpt_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> bpt_t
 |          first: qvector< bpt_t >::iterator
 |          last: qvector< bpt_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> bpt_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=bpt_t())
 |          x: bpt_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: bpt_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> bpt_t
 |          it: qvector< bpt_t >::iterator
 |          x: bpt_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: bpt_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: bpt_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< bpt_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_bpt_vec_t>
 |      delete_bpt_vec_t(self)

Help on function bring_debugger_to_front in module ida_dbg:

bring_debugger_to_front(*args)
    bring_debugger_to_front()

Help on function check_bpt in module ida_dbg:

check_bpt(*args)
    Check the breakpoint at the specified address.
    
    check_bpt(ea) -> int
        @param ea (C++: ea_t)
        @return: one of  Breakpoint status codes

Help on function choose_trace_file in module ida_dbg:

choose_trace_file(*args)
    Show the choose trace dialog.

Help on function clear_requests_queue in module ida_dbg:

clear_requests_queue(*args)
    Clear the queue of waiting requests. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}If a request is currently
    running, this one isn't stopped.

Help on function clear_trace in module ida_dbg:

clear_trace(*args)
    Clear all events in the trace buffer. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}

Help on function collect_stack_trace in module ida_dbg:

collect_stack_trace(*args)
    collect_stack_trace(tid, trace) -> bool
        @param tid (C++: thid_t)
        @param trace (C++: call_stack_t  *)

Help on function continue_process in module ida_dbg:

continue_process(*args)
    Continue the execution of the process in the debugger. \sq{Type,
    Synchronous function - available as Request, Notification, none
    (synchronous function)}The 'continue_process()' function can be called
    from a notification handler to force the continuation of the process.
    In this case the request queue will not be examined, IDA will simply
    resume execution. Usually it makes sense to call
    'request_continue_process()' followed by 'run_requests()' , so that
    IDA will first start a queued request (if any) and then resume the
    application.

Help on function create_source_viewer in module ida_dbg:

create_source_viewer(*args)
    Create a source code view.
    
    create_source_viewer(out_ccv, parent, custview, sf, lines, lnnum, colnum, flags) -> source_view_t *
        @param out_ccv (C++: TWidget **)
        @param parent (C++: TWidget *)
        @param custview (C++: TWidget *)
        @param sf (C++: source_file_ptr)
        @param lines (C++: strvec_t  *)
        @param lnnum (C++: int)
        @param colnum (C++: int)
        @param flags (C++: int)

Help on function dbg_add_bpt_tev in module ida_dbg:

dbg_add_bpt_tev(*args)
    Add a new breakpoint trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    dbg_add_bpt_tev(tid, ea, bp) -> bool
        @param tid (C++: thid_t)
        @param ea (C++: ea_t)
        @param bp (C++: ea_t)
        @return: false if the operation failed, true otherwise

Help on function dbg_add_call_tev in module ida_dbg:

dbg_add_call_tev(*args)
    Add a new call trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    dbg_add_call_tev(tid, caller, callee)
        @param tid (C++: thid_t)
        @param caller (C++: ea_t)
        @param callee (C++: ea_t)

Help on function dbg_add_debug_event in module ida_dbg:

dbg_add_debug_event(*args)
    Add a new debug event to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    dbg_add_debug_event(event)
        @param event (C++: debug_event_t  *)

Help on function dbg_add_insn_tev in module ida_dbg:

dbg_add_insn_tev(*args)
    Add a new instruction trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    dbg_add_insn_tev(tid, ea, save=SAVE_DIFF) -> bool
        @param tid (C++: thid_t)
        @param ea (C++: ea_t)
        @param save (C++: save_reg_values_t)
        @return: false if the operation failed, true otherwise

Help on function dbg_add_many_tevs in module ida_dbg:

dbg_add_many_tevs(*args)
    Add many new trace elements to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    dbg_add_many_tevs(new_tevs) -> bool
        @param new_tevs (C++: tevinforeg_vec_t  *)
        @return: false if the operation failed for any  tev_info_t  object

Help on function dbg_add_ret_tev in module ida_dbg:

dbg_add_ret_tev(*args)
    Add a new return trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    dbg_add_ret_tev(tid, ret_insn, return_to)
        @param tid (C++: thid_t)
        @param ret_insn (C++: ea_t)
        @param return_to (C++: ea_t)

Help on function dbg_add_tev in module ida_dbg:

dbg_add_tev(*args)
    Add a new trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    dbg_add_tev(type, tid, address)
        @param type (C++: tev_type_t)
        @param tid (C++: thid_t)
        @param address (C++: ea_t)

Help on function dbg_add_thread in module ida_dbg:

dbg_add_thread(*args)
    Add a thread to the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    dbg_add_thread(tid)
        @param tid (C++: thid_t)

Help on function dbg_bin_search in module ida_dbg:

dbg_bin_search(*args)
    dbg_bin_search(start_ea, end_ea, data, srch_flags) -> str
        @param start_ea (C++: ea_t)
        @param end_ea (C++: ea_t)
        @param data (C++: const  compiled_binpat_vec_t  &)
        @param srch_flags (C++: int)

Help on function dbg_can_query in module ida_dbg:

dbg_can_query(*args)
    dbg_can_query() -> bool
    This function can be used to check if the debugger can be queried:
      - debugger is loaded
      - process is suspended
      - process is not suspended but can take requests. In this case some requests like
        memory read/write, bpt management succeed and register querying will fail.
        Check if idaapi.get_process_state() < 0 to tell if the process is suspended
    @return: Boolean

Help on function dbg_del_thread in module ida_dbg:

dbg_del_thread(*args)
    Delete a thread from the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    dbg_del_thread(tid)
        @param tid (C++: thid_t)

Help on function dbg_is_loaded in module ida_dbg:

dbg_is_loaded(*args)
    dbg_is_loaded() -> bool
    Checks if a debugger is loaded
    @return: Boolean

Help on function define_exception in module ida_dbg:

define_exception(*args)
    Convenience function: define new exception code.
    
    define_exception(code, name, desc, flags) -> char const *
        @param code: exception code (cannot be 0) (C++: uint)
        @param name: exception name (cannot be empty or NULL) (C++: const char
                     *)
        @param desc: exception description (maybe NULL) (C++: const char *)
        @param flags: combination of  Exception info flags (C++: int)
        @return: failure message or NULL. You must call  store_exceptions()
                 if this function succeeds

Help on function del_bpt in module ida_dbg:

del_bpt(*args)
    Delete an existing breakpoint in the debugged process. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    del_bpt(ea) -> bool
        @param ea: any address in the breakpoint range (C++: ea_t)
    
    
    del_bpt(bptloc) -> bool
        bptloc: bpt_location_t const &

Help on function del_bptgrp in module ida_dbg:

del_bptgrp(*args)
    del_bptgrp(name) -> bool
        @param name (C++: const char *)

Help on function del_virt_module in module ida_dbg:

del_virt_module(*args)
    del_virt_module(base) -> bool
        @param base (C++: const ea_t)

Help on function detach_process in module ida_dbg:

detach_process(*args)
    Detach the debugger from the debugged process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_detach' }

Help on function diff_trace_file in module ida_dbg:

diff_trace_file(*args)
    Show difference between the current trace and the one from 'filename'.
    
    diff_trace_file(filename) -> bool
        @param filename (C++: const char *)

Help on function disable_bblk_trace in module ida_dbg:

disable_bblk_trace(*args)
    disable_bblk_trace() -> bool

Help on function disable_bpt in module ida_dbg:

disable_bpt(*args)
    disable_bpt(ea) -> bool
        @param ea (C++: ea_t)
    
    
    disable_bpt(bptloc) -> bool
        bptloc: bpt_location_t const &

Help on function disable_func_trace in module ida_dbg:

disable_func_trace(*args)
    disable_func_trace() -> bool

Help on function disable_insn_trace in module ida_dbg:

disable_insn_trace(*args)
    disable_insn_trace() -> bool

Help on function disable_step_trace in module ida_dbg:

disable_step_trace(*args)
    disable_step_trace() -> bool

Help on function edit_manual_regions in module ida_dbg:

edit_manual_regions(*args)
    edit_manual_regions()

Help on function enable_bblk_trace in module ida_dbg:

enable_bblk_trace(*args)
    enable_bblk_trace(enable=True) -> bool
        @param enable (C++: bool)

Help on function enable_bpt in module ida_dbg:

enable_bpt(*args)
    enable_bpt(ea, enable=True) -> bool
        @param ea (C++: ea_t)
        @param enable (C++: bool)
    
    
    enable_bpt(bptloc, enable=True) -> bool
        bptloc: bpt_location_t const &
        @param enable (C++: bool)

Help on function enable_func_trace in module ida_dbg:

enable_func_trace(*args)
    enable_func_trace(enable=True) -> bool
        @param enable (C++: bool)

Help on function enable_insn_trace in module ida_dbg:

enable_insn_trace(*args)
    enable_insn_trace(enable=True) -> bool
        @param enable (C++: bool)

Help on function enable_manual_regions in module ida_dbg:

enable_manual_regions(*args)
    enable_manual_regions(enable)
        @param enable (C++: bool)

Help on function enable_step_trace in module ida_dbg:

enable_step_trace(*args)
    enable_step_trace(enable=1) -> bool
        @param enable (C++: int)

Help on class eval_ctx_t in module ida_dbg:

class eval_ctx_t(__builtin__.object)
 |  Proxy of C++ eval_ctx_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea) -> eval_ctx_t
 |          _ea: ea_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      eval_ctx_t_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_eval_ctx_t>
 |      delete_eval_ctx_t(self)

Help on function exist_bpt in module ida_dbg:

exist_bpt(*args)
    Does a breakpoint exist at the given location?
    
    exist_bpt(ea) -> bool
        @param ea (C++: ea_t)

Help on function exit_process in module ida_dbg:

exit_process(*args)
    Terminate the debugging of the current process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_exit' }

Help on function find_bpt in module ida_dbg:

find_bpt(*args)
    Find a breakpoint by location. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    find_bpt(bptloc, bpt) -> bool
        @param bptloc: Breakpoint location (C++: const  bpt_location_t  &)
        @param bpt: bpt is filled if the breakpoint was found (C++: bpt_t  *)

Help on function get_bblk_trace_options in module ida_dbg:

get_bblk_trace_options(*args)
    Get current basic block tracing options. Also see 'BT_LOG_INSTS'
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}

Help on function get_bpt in module ida_dbg:

get_bpt(*args)
    Get the characteristics of a breakpoint. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    get_bpt(ea, bpt) -> bool
        @param ea: any address in the breakpoint range (C++: ea_t)
        @param bpt: if not NULL, is filled with the characteristics. (C++:
                    bpt_t  *)
        @return: false if no breakpoint exists

Help on function get_bpt_group in module ida_dbg:

get_bpt_group(*args)
    get_bpt_group(bptloc) -> str
        @param bptloc (C++: const  bpt_location_t  &)

Help on function get_bpt_qty in module ida_dbg:

get_bpt_qty(*args)
    Get number of breakpoints. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function get_bpt_tev_ea in module ida_dbg:

get_bpt_tev_ea(*args)
    Get the address associated to a read, read/write or execution trace
    event. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}Usually, a breakpoint is associated with a read, read/write
    or execution trace event. However, the returned address could be any
    address in the range of this breakpoint. If the breakpoint was deleted
    after the trace event, the address no longer corresponds to a valid
    breakpoint.
    
    get_bpt_tev_ea(n) -> ea_t
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @return: BADADDR  if not a read, read/write or execution trace event.

Help on function get_bptloc_string in module ida_dbg:

get_bptloc_string(*args)
    Helper function for 'bpt_location_t' .
    
    get_bptloc_string(i) -> char const *
        @param i (C++: int)

Help on function get_call_tev_callee in module ida_dbg:

get_call_tev_callee(*args)
    Get the called function from a function call trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    get_call_tev_callee(n) -> ea_t
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @return: BADADDR  if not a function call event.

Help on function get_current_source_file in module ida_dbg:

get_current_source_file(*args)
    get_current_source_file() -> str

Help on function get_current_source_line in module ida_dbg:

get_current_source_line(*args)
    get_current_source_line() -> int

Help on function get_current_thread in module ida_dbg:

get_current_thread(*args)
    Get current thread ID. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}

Help on function get_dbg_byte in module ida_dbg:

get_dbg_byte(*args)
    Get one byte of the debugged process memory.
    
    get_dbg_byte(x, ea) -> bool
        @param x: pointer to byte value (C++: uint32  *)
        @param ea: linear address (C++: ea_t)
        @return: true success

Help on function get_dbg_memory_info in module ida_dbg:

get_dbg_memory_info(*args)
    get_dbg_memory_info(ranges) -> int
        @param ranges (C++: meminfo_vec_t  *)

Help on function get_dbg_reg_info in module ida_dbg:

get_dbg_reg_info(*args)
    Get register information \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    get_dbg_reg_info(regname, ri) -> bool
        @param regname (C++: const char *)
        @param ri (C++: register_info_t  *)

Help on function get_debug_event in module ida_dbg:

get_debug_event(*args)
    Get the current debugger event.

Help on function get_debugger_event_cond in module ida_dbg:

get_debugger_event_cond(*args)
    get_debugger_event_cond() -> char const *

Help on function get_first_module in module ida_dbg:

get_first_module(*args)
    get_first_module(modinfo) -> bool
        @param modinfo (C++: modinfo_t  *)

Help on function get_func_trace_options in module ida_dbg:

get_func_trace_options(*args)
    Get current function tracing options. Also see 'FT_LOG_RET' \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

Help on function get_global_var in module ida_dbg:

get_global_var(*args)
    get_global_var(prov, ea, name, out) -> bool
        @param prov (C++: srcinfo_provider_t  *)
        @param ea (C++: ea_t)
        @param name (C++: const char *)
        @param out (C++: source_item_ptr  *)

Help on function get_grp_bpts in module ida_dbg:

get_grp_bpts(*args)
    get_grp_bpts(bpts, grp_name) -> ssize_t
        @param bpts (C++: bpt_vec_t  *)
        @param grp_name (C++: const char *)

Help on function get_insn_tev_reg_mem in module ida_dbg:

get_insn_tev_reg_mem(*args)
    Read the memory pointed by register values from an instruction trace
    event. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    get_insn_tev_reg_mem(n, memmap) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param memmap: result (C++: memreg_infos_t  *)
        @return: false if not an instruction event or no memory is available

Help on function get_insn_tev_reg_result in module ida_dbg:

get_insn_tev_reg_result(*args)
    Read the resulting register value from an instruction trace event.
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    get_insn_tev_reg_result(n, regname, regval) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param regname: name of desired register (C++: const char *)
        @param regval: result (C++: regval_t  *)
        @return: false if not an instruction trace event or register wasn't
                 modified.

Help on function get_insn_tev_reg_val in module ida_dbg:

get_insn_tev_reg_val(*args)
    Read a register value from an instruction trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}This
    is the value of the register before the execution of the instruction.
    
    get_insn_tev_reg_val(n, regname, regval) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param regname: name of desired register (C++: const char *)
        @param regval: result (C++: regval_t  *)
        @return: false if not an instruction event.

Help on function get_insn_trace_options in module ida_dbg:

get_insn_trace_options(*args)
    Get current instruction tracing options. Also see 'IT_LOG_SAME_IP'
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}

Help on function get_ip_val in module ida_dbg:

get_ip_val(*args)
    Get value of the IP (program counter) register for the current thread.
    Requires a suspended debugger.

Help on function get_local_var in module ida_dbg:

get_local_var(*args)
    get_local_var(prov, ea, name, out) -> bool
        @param prov (C++: srcinfo_provider_t  *)
        @param ea (C++: ea_t)
        @param name (C++: const char *)
        @param out (C++: source_item_ptr  *)

Help on function get_local_vars in module ida_dbg:

get_local_vars(*args)
    get_local_vars(prov, ea, out) -> bool
        @param prov (C++: srcinfo_provider_t  *)
        @param ea (C++: ea_t)
        @param out (C++: source_items_t  *)

Help on function get_manual_regions in module ida_dbg:

get_manual_regions(*args)
    get_manual_regions(ranges)
    Returns the manual memory regions
    @return: list(start_ea, end_ea, name, sclass, sbase, bitness, perm)

Help on function get_module_info in module ida_dbg:

get_module_info(*args)
    get_module_info(ea, modinfo) -> bool
        @param ea (C++: ea_t)
        @param modinfo (C++: modinfo_t  *)

Help on function get_next_module in module ida_dbg:

get_next_module(*args)
    get_next_module(modinfo) -> bool
        @param modinfo (C++: modinfo_t  *)

Help on function get_process_options in module ida_dbg:

get_process_options(*args)
    Get process options. Any of the arguments may be NULL

Help on function get_process_state in module ida_dbg:

get_process_state(*args)
    Return the state of the currently debugged process. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

Help on function get_processes in module ida_dbg:

get_processes(*args)
    Take a snapshot of running processes and return their description.
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    get_processes(proclist) -> ssize_t
        @param proclist (C++: procinfo_vec_t  *)
        @return: number of processes or -1 on error

Help on function get_reg_val in module ida_dbg:

get_reg_val(*args)
    Read a register value from the current thread. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    get_reg_val(regname, regval) -> bool
        @param regname (C++: const char *)
        @param regval (C++: regval_t  *)
    
    
    get_reg_val(regname, ival) -> bool
        @param regname (C++: const char *)
        ival: uint64 *
    
    
    get_reg_val(regname) -> PyObject *
        @param regname (C++: const char *)

Help on function get_reg_vals in module ida_dbg:

get_reg_vals(*args)
    get_reg_vals(tid, clsmask, values) -> int
        @param tid (C++: thid_t)
        @param clsmask (C++: int)
        @param values (C++: regval_t  *)

Help on function get_ret_tev_return in module ida_dbg:

get_ret_tev_return(*args)
    Get the return address from a function return trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    get_ret_tev_return(n) -> ea_t
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @return: BADADDR  if not a function return event.

Help on function get_running_notification in module ida_dbg:

get_running_notification(*args)
    Get the notification associated (if any) with the current running
    request. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}

Help on function get_running_request in module ida_dbg:

get_running_request(*args)
    Get the current running request. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function get_sp_val in module ida_dbg:

get_sp_val(*args)
    Get value of the SP register for the current thread. Requires a
    suspended debugger.

Help on function get_srcinfo_provider in module ida_dbg:

get_srcinfo_provider(*args)
    get_srcinfo_provider(name) -> srcinfo_provider_t *
        @param name (C++: const char *)

Help on function get_step_trace_options in module ida_dbg:

get_step_trace_options(*args)
    Get current step tracing options. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function get_tev_ea in module ida_dbg:

get_tev_ea(*args)
    get_tev_ea(n) -> ea_t
        @param n (C++: int)

Help on function get_tev_event in module ida_dbg:

get_tev_event(*args)
    Get the corresponding debug event, if any, for the specified tev
    object. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    get_tev_event(n, d) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param d: result (C++: debug_event_t  *)
        @return: false if the tev_t object doesn't have any associated debug
                 event, true otherwise, with the debug event in "d".

Help on function get_tev_info in module ida_dbg:

get_tev_info(*args)
    Get main information about a trace event. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    get_tev_info(n, tev_info) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param tev_info: result (C++: tev_info_t  *)
        @return: success

Help on function get_tev_memory_info in module ida_dbg:

get_tev_memory_info(*args)
    Get the memory layout, if any, for the specified tev object. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    get_tev_memory_info(n, mi) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param mi: result (C++: meminfo_vec_t  *)
        @return: false if the tev_t object is not of type  tev_mem , true
                 otherwise, with the new memory layout in "mi".

Help on function get_tev_qty in module ida_dbg:

get_tev_qty(*args)
    Get number of trace events available in trace buffer. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

Help on function get_tev_reg_mem in module ida_dbg:

get_tev_reg_mem(tev, idx)

Help on function get_tev_reg_mem_ea in module ida_dbg:

get_tev_reg_mem_ea(tev, idx)

Help on function get_tev_reg_mem_qty in module ida_dbg:

get_tev_reg_mem_qty(tev)

Help on function get_tev_reg_val in module ida_dbg:

get_tev_reg_val(tev, reg)

Help on function get_tev_tid in module ida_dbg:

get_tev_tid(*args)
    get_tev_tid(n) -> int
        @param n (C++: int)

Help on function get_tev_type in module ida_dbg:

get_tev_type(*args)
    get_tev_type(n) -> int
        @param n (C++: int)

Help on function get_thread_qty in module ida_dbg:

get_thread_qty(*args)
    Get number of threads. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}

Help on function get_trace_base_address in module ida_dbg:

get_trace_base_address(*args)
    Get the base address of the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}

Help on function get_trace_dynamic_register_set in module ida_dbg:

get_trace_dynamic_register_set(*args)
    Get dynamic register set of current trace.
    
    get_trace_dynamic_register_set(idaregs)
        @param idaregs (C++: dynamic_register_set_t  *)

Help on function get_trace_file_desc in module ida_dbg:

get_trace_file_desc(*args)
    Get the file header of the specified trace file.
    
    get_trace_file_desc(filename) -> str
        @param filename (C++: const char *)

Help on function get_trace_platform in module ida_dbg:

get_trace_platform(*args)
    Get platform name of current trace.

Help on function getn_bpt in module ida_dbg:

getn_bpt(*args)
    Get the characteristics of a breakpoint. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    getn_bpt(n, bpt) -> bool
        @param n: number of breakpoint, is in range 0.. get_bpt_qty() -1 (C++:
                  int)
        @param bpt: filled with the characteristics. (C++: bpt_t  *)
        @return: false if no breakpoint exists

Help on function getn_thread in module ida_dbg:

getn_thread(*args)
    Get the ID of a thread. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    getn_thread(n) -> thid_t
        @param n: number of thread, is in range 0.. get_thread_qty() -1 (C++:
                  int)
        @return: NO_THREAD  if the thread doesn't exist.

Help on function getn_thread_name in module ida_dbg:

getn_thread_name(*args)
    Get the NAME of a thread \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    getn_thread_name(n) -> char const *
        @param n: number of thread, is in range 0.. get_thread_qty() -1 or -1
                  for the current thread (C++: int)
        @return: thread name or NULL if the thread doesn't exist.

Help on function graph_trace in module ida_dbg:

graph_trace(*args)
    Show the trace callgraph.

Help on function handle_debug_event in module ida_dbg:

handle_debug_event(*args)
    handle_debug_event(ev, rqflags) -> int
        @param ev (C++: const  debug_event_t  *)
        @param rqflags (C++: int)

Help on function hide_all_bpts in module ida_dbg:

hide_all_bpts(*args)
    hide_all_bpts() -> int

Help on function internal_get_sreg_base in module ida_dbg:

internal_get_sreg_base(*args)
    internal_get_sreg_base(tid, sreg_value) -> ea_t
    Get the sreg base, for the given thread.
    
    @return: The sreg base, or BADADDR on failure.

Help on function internal_ioctl in module ida_dbg:

internal_ioctl(*args)
    internal_ioctl(fn, buf, poutbuf, poutsize) -> int
        @param fn (C++: int)
        @param buf (C++: const void *)
        @param poutbuf (C++: void **)
        @param poutsize (C++: ssize_t  *)

Help on function invalidate_dbg_state in module ida_dbg:

invalidate_dbg_state(*args)
    Invalidate cached debugger information. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    invalidate_dbg_state(dbginv) -> int
        @param dbginv: Debugged process invalidation options (C++: int)
        @return: current debugger state (one of  Debugged process states )

Help on function invalidate_dbgmem_config in module ida_dbg:

invalidate_dbgmem_config(*args)
    Invalidate the debugged process memory configuration. Call this
    function if the debugged process might have changed its memory layout
    (allocated more memory, for example)

Help on function invalidate_dbgmem_contents in module ida_dbg:

invalidate_dbgmem_contents(*args)
    Invalidate the debugged process memory contents. Call this function
    each time the process has been stopped or the process memory is
    modified. If ea == 'BADADDR' , then the whole memory contents will be
    invalidated
    
    invalidate_dbgmem_contents(ea, size)
        @param ea (C++: ea_t)
        @param size (C++: asize_t)

Help on function is_bblk_trace_enabled in module ida_dbg:

is_bblk_trace_enabled(*args)
    is_bblk_trace_enabled() -> bool

Help on function is_debugger_busy in module ida_dbg:

is_debugger_busy(*args)
    Is the debugger busy?. Some debuggers do not accept any commands while
    the debugged application is running. For such a debugger, it is unsafe
    to do anything with the database (even simple queries like get_byte
    may lead to undesired consequences). Returns: true if the debugged
    application is running under such a debugger

Help on function is_debugger_memory in module ida_dbg:

is_debugger_memory(*args)
    Is the address mapped to debugger memory?
    
    is_debugger_memory(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_debugger_on in module ida_dbg:

is_debugger_on(*args)
    Is the debugger currently running?

Help on function is_func_trace_enabled in module ida_dbg:

is_func_trace_enabled(*args)
    Get current state of functions tracing. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}

Help on function is_insn_trace_enabled in module ida_dbg:

is_insn_trace_enabled(*args)
    Get current state of instruction tracing. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}

Help on function is_reg_custom in module ida_dbg:

is_reg_custom(*args)
    Does a register contain a value of a custom data type? \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    is_reg_custom(regname) -> bool
        @param regname (C++: const char *)

Help on function is_reg_float in module ida_dbg:

is_reg_float(*args)
    Does a register contain a floating point value? \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    is_reg_float(regname) -> bool
        @param regname (C++: const char *)

Help on function is_reg_integer in module ida_dbg:

is_reg_integer(*args)
    Does a register contain an integer value? \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    is_reg_integer(regname) -> bool
        @param regname (C++: const char *)

Help on function is_request_running in module ida_dbg:

is_request_running(*args)
    Is a request currently running?

Help on function is_step_trace_enabled in module ida_dbg:

is_step_trace_enabled(*args)
    Get current state of step tracing. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function is_valid_trace_file in module ida_dbg:

is_valid_trace_file(*args)
    Is the specified file a valid trace file for the current database?
    
    is_valid_trace_file(filename) -> bool
        @param filename (C++: const char *)

Help on function list_bptgrps in module ida_dbg:

list_bptgrps(*args)
    list_bptgrps(bptgrps) -> size_t
        @param bptgrps (C++: qstrvec_t  *)

Help on function load_debugger in module ida_dbg:

load_debugger(*args)
    load_debugger(dbgname, use_remote) -> bool
        @param dbgname (C++: const char *)
        @param use_remote (C++: bool)

Help on function load_trace_file in module ida_dbg:

load_trace_file(*args)
    Load a recorded trace file in the trace window. If the call succeeds
    and 'buf' is not null, the description of the trace stored in the
    binary trace file will be returned in 'buf'
    
    load_trace_file(filename) -> str
        @param filename (C++: const char *)

Help on class memreg_info_t in module ida_dbg:

class memreg_info_t(__builtin__.object)
 |  Proxy of C++ memreg_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> memreg_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_bytes(self, *args)
 |      get_bytes(self) -> PyObject *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bytes
 |      get_bytes(self) -> PyObject *
 |  
 |  ea
 |      memreg_info_t_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_memreg_info_t>
 |      delete_memreg_info_t(self)

Help on class memreg_infos_t in module ida_dbg:

class memreg_infos_t(__builtin__.object)
 |  Proxy of C++ qvector< memreg_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> memreg_info_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> memreg_infos_t
 |          x: qvector< memreg_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: memreg_info_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> memreg_info_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> memreg_info_t
 |      begin(self) -> memreg_info_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> memreg_info_t
 |      end(self) -> memreg_info_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> memreg_info_t
 |          it: qvector< memreg_info_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> memreg_info_t
 |          first: qvector< memreg_info_t >::iterator
 |          last: qvector< memreg_info_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> memreg_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=memreg_info_t())
 |          x: memreg_info_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: memreg_info_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> memreg_info_t
 |          it: qvector< memreg_info_t >::iterator
 |          x: memreg_info_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: memreg_info_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: memreg_info_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< memreg_info_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_memreg_infos_t>
 |      delete_memreg_infos_t(self)

Help on function move_bpt_to_grp in module ida_dbg:

move_bpt_to_grp(*args)
    move_bpt_to_grp(bpt, grp_name)
    Sets new group for the breakpoint

Help on function put_dbg_byte in module ida_dbg:

put_dbg_byte(*args)
    Change one byte of the debugged process memory.
    
    put_dbg_byte(ea, x) -> bool
        @param ea: linear address (C++: ea_t)
        @param x: byte value (C++: uint32)
        @return: true if the process memory has been modified

Help on function read_dbg_memory in module ida_dbg:

read_dbg_memory(*args)
    read_dbg_memory(ea, buffer, size) -> ssize_t
        @param ea (C++: ea_t)
        @param buffer (C++: void *)
        @param size (C++: size_t)

Help on function refresh_debugger_memory in module ida_dbg:

refresh_debugger_memory(*args)
    refresh_debugger_memory() -> PyObject *
    Refreshes the debugger memory
    @return: Nothing

Help on function rename_bptgrp in module ida_dbg:

rename_bptgrp(*args)
    rename_bptgrp(old_name, new_name) -> bool
        @param old_name (C++: const char *)
        @param new_name (C++: const char *)

Help on function request_add_bpt in module ida_dbg:

request_add_bpt(*args)
    Post an 'add_bpt(ea_t, asize_t, bpttype_t)' request.
    
    request_add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
        @param ea (C++: ea_t)
        @param size (C++: asize_t)
        @param type (C++: bpttype_t)
    
    
    request_add_bpt(bpt) -> bool
        bpt: bpt_t const &

Help on function request_attach_process in module ida_dbg:

request_attach_process(*args)
    Post an 'attach_process()' request.
    
    request_attach_process(pid, event_id) -> int
        @param pid (C++: pid_t)
        @param event_id (C++: int)

Help on function request_clear_trace in module ida_dbg:

request_clear_trace(*args)
    Post a 'clear_trace()' request.

Help on function request_continue_process in module ida_dbg:

request_continue_process(*args)
    Post a 'continue_process()' request.This requires an explicit call to
    'run_requests()'

Help on function request_del_bpt in module ida_dbg:

request_del_bpt(*args)
    Post a 'del_bpt(ea_t)' request.
    
    request_del_bpt(ea) -> bool
        @param ea (C++: ea_t)
    
    
    request_del_bpt(bptloc) -> bool
        bptloc: bpt_location_t const &

Help on function request_detach_process in module ida_dbg:

request_detach_process(*args)
    Post a 'detach_process()' request.

Help on function request_disable_bblk_trace in module ida_dbg:

request_disable_bblk_trace(*args)
    request_disable_bblk_trace() -> bool

Help on function request_disable_bpt in module ida_dbg:

request_disable_bpt(*args)
    request_disable_bpt(ea) -> bool
        @param ea (C++: ea_t)
    
    
    request_disable_bpt(bptloc) -> bool
        bptloc: bpt_location_t const &

Help on function request_disable_func_trace in module ida_dbg:

request_disable_func_trace(*args)
    request_disable_func_trace() -> bool

Help on function request_disable_insn_trace in module ida_dbg:

request_disable_insn_trace(*args)
    request_disable_insn_trace() -> bool

Help on function request_disable_step_trace in module ida_dbg:

request_disable_step_trace(*args)
    request_disable_step_trace() -> bool

Help on function request_enable_bblk_trace in module ida_dbg:

request_enable_bblk_trace(*args)
    request_enable_bblk_trace(enable=True) -> bool
        @param enable (C++: bool)

Help on function request_enable_bpt in module ida_dbg:

request_enable_bpt(*args)
    request_enable_bpt(ea, enable=True) -> bool
        @param ea (C++: ea_t)
        @param enable (C++: bool)
    
    
    request_enable_bpt(bptloc, enable=True) -> bool
        bptloc: bpt_location_t const &
        @param enable (C++: bool)

Help on function request_enable_func_trace in module ida_dbg:

request_enable_func_trace(*args)
    request_enable_func_trace(enable=True) -> bool
        @param enable (C++: bool)

Help on function request_enable_insn_trace in module ida_dbg:

request_enable_insn_trace(*args)
    request_enable_insn_trace(enable=True) -> bool
        @param enable (C++: bool)

Help on function request_enable_step_trace in module ida_dbg:

request_enable_step_trace(*args)
    request_enable_step_trace(enable=1) -> bool
        @param enable (C++: int)

Help on function request_exit_process in module ida_dbg:

request_exit_process(*args)
    Post an 'exit_process()' request.

Help on function request_resume_thread in module ida_dbg:

request_resume_thread(*args)
    Post a 'resume_thread()' request.
    
    request_resume_thread(tid) -> int
        @param tid (C++: thid_t)

Help on function request_run_to in module ida_dbg:

request_run_to(*args)
    Post a 'run_to()' request.
    
    request_run_to(ea, pid=pid_t(-1), tid=0) -> bool
        @param ea (C++: ea_t)
        @param pid (C++: pid_t)
        @param tid (C++: thid_t)

Help on function request_select_thread in module ida_dbg:

request_select_thread(*args)
    Post a 'select_thread()' request.
    
    request_select_thread(tid) -> bool
        @param tid (C++: thid_t)

Help on function request_set_bblk_trace_options in module ida_dbg:

request_set_bblk_trace_options(*args)
    Post a 'set_bblk_trace_options()' request.
    
    request_set_bblk_trace_options(options)
        @param options (C++: int)

Help on function request_set_func_trace_options in module ida_dbg:

request_set_func_trace_options(*args)
    Post a 'set_func_trace_options()' request.
    
    request_set_func_trace_options(options)
        @param options (C++: int)

Help on function request_set_insn_trace_options in module ida_dbg:

request_set_insn_trace_options(*args)
    Post a 'set_insn_trace_options()' request.
    
    request_set_insn_trace_options(options)
        @param options (C++: int)

Help on function request_set_reg_val in module ida_dbg:

request_set_reg_val(*args)
    Post a 'set_reg_val()' request.
    
    request_set_reg_val(regname, o) -> PyObject *
        @param regname (C++: const char *)
        o: PyObject *

Help on function request_set_resume_mode in module ida_dbg:

request_set_resume_mode(*args)
    Post a 'set_resume_mode()' request.
    
    request_set_resume_mode(tid, mode) -> bool
        @param tid (C++: thid_t)
        @param mode (C++: resume_mode_t)

Help on function request_set_step_trace_options in module ida_dbg:

request_set_step_trace_options(*args)
    Post a 'set_step_trace_options()' request.
    
    request_set_step_trace_options(options)
        @param options (C++: int)

Help on function request_start_process in module ida_dbg:

request_start_process(*args)
    Post a 'start_process()' request.
    
    request_start_process(path=None, args=None, sdir=None) -> int
        @param path (C++: const char *)
        @param args (C++: const char *)
        @param sdir (C++: const char *)

Help on function request_step_into in module ida_dbg:

request_step_into(*args)
    Post a 'step_into()' request.

Help on function request_step_over in module ida_dbg:

request_step_over(*args)
    Post a 'step_over()' request.

Help on function request_step_until_ret in module ida_dbg:

request_step_until_ret(*args)
    Post a 'step_until_ret()' request.

Help on function request_suspend_process in module ida_dbg:

request_suspend_process(*args)
    Post a 'suspend_process()' request.

Help on function request_suspend_thread in module ida_dbg:

request_suspend_thread(*args)
    Post a 'suspend_thread()' request.
    
    request_suspend_thread(tid) -> int
        @param tid (C++: thid_t)

Help on function resume_thread in module ida_dbg:

resume_thread(*args)
    Resume thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    resume_thread(tid) -> int
        @param tid: thread id (C++: thid_t)
        @retval: -1 - network error
        @retval: 0 - failed
        @retval: 1 - ok

Help on function retrieve_exceptions in module ida_dbg:

retrieve_exceptions(*args)
    Retrieve the exception information. You may freely modify the returned
    vector and add/edit/delete exceptions You must call
    'store_exceptions()' after any modifications Note: exceptions with
    code zero, multiple exception codes or names are prohibited

Help on function run_requests in module ida_dbg:

run_requests(*args)
    Execute requests until all requests are processed or an asynchronous
    function is called. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}If called from a notification handler, the
    execution of requests will be postponed to the end of the execution of
    all notification handlers.

Help on function run_to in module ida_dbg:

run_to(*args)
    Execute the process until the given address is reached. If no process
    is active, a new process is started. Technically, the debugger sets up
    a temporary breakpoint at the given address, and continues (or starts)
    the execution of the whole process. So, all threads continue their
    execution! \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_run_to' }
    
    run_to(ea, pid=pid_t(-1), tid=0) -> bool
        @param ea: target address (C++: ea_t)
        @param pid: not used yet. please do not specify this parameter. (C++:
                    pid_t)
        @param tid: not used yet. please do not specify this parameter. (C++:
                    thid_t)

Help on function save_trace_file in module ida_dbg:

save_trace_file(*args)
    Save the current trace in the specified file.
    
    save_trace_file(filename, description) -> bool
        @param filename (C++: const char *)
        @param description (C++: const char *)

Help on function select_thread in module ida_dbg:

select_thread(*args)
    Select the given thread as the current debugged thread. All thread
    related execution functions will work on this thread. The process must
    be suspended to select a new thread. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    select_thread(tid) -> bool
        @param tid: ID of the thread to select (C++: thid_t)
        @return: false if the thread doesn't exist.

Help on function send_dbg_command in module ida_dbg:

send_dbg_command(command)
    Send a direct command to the debugger backend, and
    retrieve the result as a string.
    
    Note: any double-quotes in 'command' must be backslash-escaped.
    Note: this only works with some debugger backends: Bochs, WinDbg, GDB.
    
    Returns: (True, <result string>) on success, or (False, <Error message string>) on failure

Help on function set_bblk_trace_options in module ida_dbg:

set_bblk_trace_options(*args)
    Modify basic block tracing options (see 'BT_LOG_INSTS' )
    
    set_bblk_trace_options(options)
        @param options (C++: int)

Help on function set_bpt_group in module ida_dbg:

set_bpt_group(*args)
    set_bpt_group(bpt, grp_name)
        @param bpt (C++: bpt_t  &)
        @param grp_name (C++: const char *)

Help on function set_bptloc_group in module ida_dbg:

set_bptloc_group(*args)
    set_bptloc_group(bptloc, grp_name) -> bool
        @param bptloc (C++: const  bpt_location_t  &)
        @param grp_name (C++: const char *)

Help on function set_bptloc_string in module ida_dbg:

set_bptloc_string(*args)
    Helper function for 'bpt_location_t' .
    
    set_bptloc_string(s) -> int
        @param s (C++: const char *)

Help on function set_debugger_event_cond in module ida_dbg:

set_debugger_event_cond(*args)
    set_debugger_event_cond(evcond)
        @param evcond (C++: const char *)

Help on function set_debugger_options in module ida_dbg:

set_debugger_options(*args)
    Set debugger options. Replaces debugger options with the specification
    combination 'Debugger options'
    
    set_debugger_options(options) -> uint
        @param options (C++: uint)
        @return: the old debugger options

Help on function set_func_trace_options in module ida_dbg:

set_func_trace_options(*args)
    Modify function tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    set_func_trace_options(options)
        @param options (C++: int)

Help on function set_highlight_trace_options in module ida_dbg:

set_highlight_trace_options(*args)
    Set highlight trace parameters.
    
    set_highlight_trace_options(hilight, color, diff)
        @param hilight (C++: bool)
        @param color (C++: bgcolor_t)
        @param diff (C++: bgcolor_t)

Help on function set_insn_trace_options in module ida_dbg:

set_insn_trace_options(*args)
    Modify instruction tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    set_insn_trace_options(options)
        @param options (C++: int)

Help on function set_manual_regions in module ida_dbg:

set_manual_regions(*args)
    set_manual_regions(ranges)
        @param ranges (C++: const  meminfo_vec_t  *)

Help on function set_process_options in module ida_dbg:

set_process_options(*args)
    Set process options. Any of the arguments may be NULL, which means 'do
    not modify'
    
    set_process_options(path, args, sdir, host, _pass, port)
        @param path (C++: const char *)
        @param args (C++: const char *)
        @param sdir (C++: const char *)
        @param host (C++: const char *)
        pass: char const *
        @param port (C++: int)

Help on function set_process_state in module ida_dbg:

set_process_state(*args)
    Set new state for the debugged process. Notifies the IDA kernel about
    the change of the debugged process state. For example, a debugger
    module could call this function when it knows that the process is
    suspended for a short period of time. Some IDA API calls can be made
    only when the process is suspended. The process state is usually
    restored before returning control to the caller. You must know that it
    is ok to change the process state, doing it at arbitrary moments may
    crash the application or IDA. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    set_process_state(newstate, p_thid, dbginv) -> int
        @param newstate: new process state (one of  Debugged process states )
                         if  DSTATE_NOTASK  is passed then the state is not
                         changed (C++: int)
        @param p_thid: ptr to new thread id. may be NULL or pointer to
                       NO_THREAD . the pointed variable will contain the old
                       thread id upon return (C++: thid_t  *)
        @param dbginv: Debugged process invalidation options (C++: int)
        @return: old debugger state (one of  Debugged process states )

Help on function set_reg_val in module ida_dbg:

set_reg_val(*args)
    Write a register value to the current thread. \sq{Type, Synchronous
    function - available as Request, Notification, none (synchronous
    function)}
    
    set_reg_val(regname, o) -> PyObject
        @param regname (C++: const char *)
        o: PyObject *
    
    
    set_reg_val(tid, regidx, o) -> PyObject *
        tid: thid_t
        regidx: int
        o: PyObject *

Help on function set_remote_debugger in module ida_dbg:

set_remote_debugger(*args)
    Set remote debugging options. Should be used before starting the
    debugger.
    
    set_remote_debugger(host, _pass, port=-1)
        @param host: If empty, IDA will use local debugger. If NULL, the host
                     will not be set. (C++: const char *)
        pass: char const *
        @param port: If -1, the default port number will be used (C++: int)

Help on function set_resume_mode in module ida_dbg:

set_resume_mode(*args)
    How to resume the application. Set resume mode but do not resume
    process.
    
    set_resume_mode(tid, mode) -> bool
        @param tid (C++: thid_t)
        @param mode (C++: resume_mode_t)

Help on function set_step_trace_options in module ida_dbg:

set_step_trace_options(*args)
    Modify step tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    set_step_trace_options(options)
        @param options (C++: int)

Help on function set_trace_base_address in module ida_dbg:

set_trace_base_address(*args)
    Set the base address of the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    set_trace_base_address(ea)
        @param ea (C++: ea_t)

Help on function set_trace_dynamic_register_set in module ida_dbg:

set_trace_dynamic_register_set(*args)
    Set dynamic register set of current trace.
    
    set_trace_dynamic_register_set(idaregs)
        @param idaregs (C++: dynamic_register_set_t  &)

Help on function set_trace_file_desc in module ida_dbg:

set_trace_file_desc(*args)
    Change the description of the specified trace file.
    
    set_trace_file_desc(filename, description) -> bool
        @param filename (C++: const char *)
        @param description (C++: const char *)

Help on function set_trace_platform in module ida_dbg:

set_trace_platform(*args)
    Set platform name of current trace.
    
    set_trace_platform(platform)
        @param platform (C++: const char *)

Help on function set_trace_size in module ida_dbg:

set_trace_size(*args)
    Specify the new size of the circular buffer. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}If you specify 0,
    all available memory can be quickly used !!!
    
    set_trace_size(size) -> bool
        @param size: if 0, buffer isn't circular and events are never removed.
                     If the new size is smaller than the existing number of
                     trace events, a corresponding number of trace events are
                     removed. (C++: int)

Help on function srcdbg_request_step_into in module ida_dbg:

srcdbg_request_step_into(*args)
    srcdbg_request_step_into() -> bool

Help on function srcdbg_request_step_over in module ida_dbg:

srcdbg_request_step_over(*args)
    srcdbg_request_step_over() -> bool

Help on function srcdbg_request_step_until_ret in module ida_dbg:

srcdbg_request_step_until_ret(*args)
    srcdbg_request_step_until_ret() -> bool

Help on function srcdbg_step_into in module ida_dbg:

srcdbg_step_into(*args)
    srcdbg_step_into() -> bool

Help on function srcdbg_step_over in module ida_dbg:

srcdbg_step_over(*args)
    srcdbg_step_over() -> bool

Help on function srcdbg_step_until_ret in module ida_dbg:

srcdbg_step_until_ret(*args)
    srcdbg_step_until_ret() -> bool

Help on function start_process in module ida_dbg:

start_process(*args)
    Start a process in the debugger. \sq{Type, Asynchronous function -
    available as Request, Notification, 'dbg_process_start' }You can also
    use the 'run_to()' function to easily start the execution of a process
    until a given address is reached.For all parameters, a NULL value
    indicates the debugger will take the value from the defined Process
    Options.
    
    start_process(path=None, args=None, sdir=None) -> int
        @param path: path to the executable to start (C++: const char *)
        @param args: arguments to pass to process (C++: const char *)
        @param sdir: starting directory for the process (C++: const char *)
        @retval: -1 - impossible to create the process
        @retval: 0 - the starting of the process was cancelled by the user
        @retval: 1 - the process was properly started

Help on function step_into in module ida_dbg:

step_into(*args)
    Execute one instruction in the current thread. Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_into' }

Help on function step_over in module ida_dbg:

step_over(*args)
    Execute one instruction in the current thread, but without entering
    into functions. Others threads keep suspended. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_step_over' }

Help on function step_until_ret in module ida_dbg:

step_until_ret(*args)
    Execute instructions in the current thread until a function return
    instruction is executed (aka "step out"). Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_until_ret' }

Help on function store_exceptions in module ida_dbg:

store_exceptions(*args)
    Update the exception information stored in the debugger module by
    invoking its dbg->set_exception_info callback

Help on function suspend_process in module ida_dbg:

suspend_process(*args)
    Suspend the process in the debugger. \sq{ Type,Synchronous function
    (if in a notification handler)Asynchronous function (everywhere
    else)available as Request, Notification,none (if in a notification
    handler) 'dbg_suspend_process' (everywhere else) }The
    'suspend_process()' function can be called from a notification handler
    to force the stopping of the process. In this case, no notification
    will be generated. When you suspend a process, the running command is
    always aborted.

Help on function suspend_thread in module ida_dbg:

suspend_thread(*args)
    Suspend thread. Suspending a thread may deadlock the whole application
    if the suspended was owning some synchronization objects. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    suspend_thread(tid) -> int
        @param tid: thread id (C++: thid_t)
        @retval: -1 - network error
        @retval: 0 - failed
        @retval: 1 - ok

Help on class tev_info_reg_t in module ida_dbg:

class tev_info_reg_t(__builtin__.object)
 |  Proxy of C++ tev_info_reg_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tev_info_reg_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  info
 |      tev_info_reg_t_info_get(self) -> tev_info_t
 |  
 |  registers
 |      tev_info_reg_t_registers_get(self) -> tev_reg_values_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_tev_info_reg_t>
 |      delete_tev_info_reg_t(self)

Help on class tev_info_t in module ida_dbg:

class tev_info_t(__builtin__.object)
 |  Proxy of C++ tev_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tev_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      tev_info_t_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      tev_info_t_tid_get(self) -> thid_t
 |  
 |  type
 |      tev_info_t_type_get(self) -> tev_type_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_tev_info_t>
 |      delete_tev_info_t(self)

Help on class tev_reg_value_t in module ida_dbg:

class tev_reg_value_t(__builtin__.object)
 |  Proxy of C++ tev_reg_value_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _reg_idx=-1, _value=uint64(-1)) -> tev_reg_value_t
 |          _reg_idx: int
 |          _value: uint64
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  reg_idx
 |      tev_reg_value_t_reg_idx_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      tev_reg_value_t_value_get(self) -> regval_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_tev_reg_value_t>
 |      delete_tev_reg_value_t(self)

Help on class tev_reg_values_t in module ida_dbg:

class tev_reg_values_t(__builtin__.object)
 |  Proxy of C++ qvector< tev_reg_value_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> tev_reg_value_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tev_reg_values_t
 |          x: qvector< tev_reg_value_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: tev_reg_value_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> tev_reg_value_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> tev_reg_value_t
 |      begin(self) -> tev_reg_value_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> tev_reg_value_t
 |      end(self) -> tev_reg_value_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> tev_reg_value_t
 |          it: qvector< tev_reg_value_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> tev_reg_value_t
 |          first: qvector< tev_reg_value_t >::iterator
 |          last: qvector< tev_reg_value_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> tev_reg_value_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=tev_reg_value_t())
 |          x: tev_reg_value_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: tev_reg_value_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> tev_reg_value_t
 |          it: qvector< tev_reg_value_t >::iterator
 |          x: tev_reg_value_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: tev_reg_value_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: tev_reg_value_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< tev_reg_value_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_tev_reg_values_t>
 |      delete_tev_reg_values_t(self)

Help on class tevinforeg_vec_t in module ida_dbg:

class tevinforeg_vec_t(__builtin__.object)
 |  Proxy of C++ qvector< tev_info_reg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> tev_info_reg_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tevinforeg_vec_t
 |          x: qvector< tev_info_reg_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: tev_info_reg_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> tev_info_reg_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> tev_info_reg_t
 |      begin(self) -> tev_info_reg_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> tev_info_reg_t
 |      end(self) -> tev_info_reg_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> tev_info_reg_t
 |          it: qvector< tev_info_reg_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> tev_info_reg_t
 |          first: qvector< tev_info_reg_t >::iterator
 |          last: qvector< tev_info_reg_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> tev_info_reg_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=tev_info_reg_t())
 |          x: tev_info_reg_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: tev_info_reg_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> tev_info_reg_t
 |          it: qvector< tev_info_reg_t >::iterator
 |          x: tev_info_reg_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: tev_info_reg_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: tev_info_reg_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< tev_info_reg_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_tevinforeg_vec_t>
 |      delete_tevinforeg_vec_t(self)

Help on function update_bpt in module ida_dbg:

update_bpt(*args)
    Update modifiable characteristics of an existing breakpoint. To update
    the breakpoint location, use 'change_bptlocs()' \sq{Type, Synchronous
    function, Notification, none (synchronous function)}Only the following
    fields can be modified: 'bpt_t::cndbody'  'bpt_t::pass_count'
    'bpt_t::flags'  'bpt_t::size'  'bpt_t::type' Changing some properties
    will require removing and then re-adding the breakpoint to the process
    memory (or the debugger backend), which can lead to race conditions
    (i.e., breakpoint(s) can be missed) in case the process is not
    suspended. Here are a list of scenarios that will require the
    breakpoint to be removed & then re-added: 'bpt_t::size' is modified
    'bpt_t::type' is modified 'bpt_t::flags' 's BPT_ENABLED is modified
    'bpt_t::flags' 's BPT_LOWCND is changed 'bpt_t::flags' 's BPT_LOWCND
    remains set, but cndbody changed
    
    update_bpt(bpt) -> bool
        @param bpt (C++: const  bpt_t  *)

Help on function wait_for_next_event in module ida_dbg:

wait_for_next_event(*args)
    Wait for the next event.This function (optionally) resumes the process
    execution, and waits for a debugger event until a possible timeout
    occurs.
    
    wait_for_next_event(wfne, timeout) -> dbg_event_code_t
        @param wfne: combination of  Wait for debugger event flags  constants
                     (C++: int)
        @param timeout: number of seconds to wait, -1-infinity (C++: int)
        @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <=
                 0)

Help on function write_dbg_memory in module ida_dbg:

write_dbg_memory(*args)
    write_dbg_memory(ea, py_buf, size=size_t(-1)) -> ssize_t
        @param ea (C++: ea_t)
        py_buf: PyObject *
        @param size (C++: size_t)

=== ida_dbg EPYDOC INJECTIONS ===
ida_dbg.BKPT_ACTIVE
"""
active?
"""

ida_dbg.BKPT_BADBPT
"""
failed to write the bpt to the process memory (at least one location)
"""

ida_dbg.BKPT_CNDREADY
"""
condition has been compiled
"""

ida_dbg.BKPT_FAKEPEND
"""
bpt of the same type is active at the same address(es)

fake pending bpt: it is inactive but another
"""

ida_dbg.BKPT_LISTBPT
"""
include in bpt list (user-defined bpt)
"""

ida_dbg.BKPT_PAGE
"""
only after writing the bpt to the process.

written to the process as a page bpt. is available
"""

ida_dbg.BKPT_PARTIAL
"""
partially active? (some locations were not written yet)
"""

ida_dbg.BKPT_TRACE
"""
trace bpt; should not be deleted when the process gets suspended
"""

ida_dbg.BPTCK_ACT
"""
breakpoint is active (written to the process)
"""

ida_dbg.BPTCK_NO
"""
breakpoint is disabled
"""

ida_dbg.BPTCK_NONE
"""
breakpoint does not exist
"""

ida_dbg.BPTCK_YES
"""
breakpoint is enabled
"""

ida_dbg.BPTEV_ADDED
"""
Breakpoint has been added.
"""

ida_dbg.BPTEV_CHANGED
"""
Breakpoint has been modified.
"""

ida_dbg.BPTEV_REMOVED
"""
Breakpoint has been removed.
"""

ida_dbg.BPT_BRK
"""
suspend execution upon hit
"""

ida_dbg.BPT_ELANG_SHIFT
"""
index of the extlang (scripting language) of the condition
"""

ida_dbg.BPT_ENABLED
"""
enabled?
"""

ida_dbg.BPT_LOWCND
"""
condition is calculated at low level (on the server side)
"""

ida_dbg.BPT_TRACE
"""
add trace information upon hit
"""

ida_dbg.BPT_TRACEON
"""
enable tracing when the breakpoint is reached
"""

ida_dbg.BPT_TRACE_BBLK
"""
basic block tracing
"""

ida_dbg.BPT_TRACE_FUNC
"""
function tracing
"""

ida_dbg.BPT_TRACE_INSN
"""
instruction tracing
"""

ida_dbg.BPT_TRACE_TYPES
"""
trace insns, functions, and basic blocks. if any of 'BPT_TRACE_TYPES'
bits are set but 'BPT_TRACEON' is clear, then turn off tracing for the
specified trace types
"""

ida_dbg.BPT_UPDMEM
"""
refresh the memory layout and contents before evaluating bpt condition
"""

ida_dbg.BT_LOG_INSTS
"""
specific options for basic block tracing (see
'set_bblk_trace_options()' )

log all instructions in the current basic block
"""

ida_dbg.DBGINV_ALL
"""
invalidate everything
"""

ida_dbg.DBGINV_MEMCFG
"""
invalidate cached process segmentation
"""

ida_dbg.DBGINV_MEMORY
"""
invalidate cached memory contents
"""

ida_dbg.DBGINV_NONE
"""
invalidate nothing
"""

ida_dbg.DBGINV_REDRAW
"""
refresh the screen
"""

ida_dbg.DBGINV_REGS
"""
invalidate cached register values
"""

ida_dbg.DOPT_BPT_MSGS
"""
log breakpoints
"""

ida_dbg.DOPT_END_BPT
"""
evaluate event condition on process end
"""

ida_dbg.DOPT_ENTRY_BPT
"""
break on program entry point
"""

ida_dbg.DOPT_EXCDLG
"""
exception dialogs:
"""

ida_dbg.DOPT_INFO_BPT
"""
break on debugging information
"""

ida_dbg.DOPT_INFO_MSGS
"""
log debugging info events
"""

ida_dbg.DOPT_LIB_BPT
"""
break on library load/unload
"""

ida_dbg.DOPT_LIB_MSGS
"""
log library loads/unloads
"""

ida_dbg.DOPT_LOAD_DINFO
"""
automatically load debug files (pdb)
"""

ida_dbg.DOPT_REAL_MEMORY
"""
do not hide breakpoint instructions
"""

ida_dbg.DOPT_REDO_STACK
"""
reconstruct the stack
"""

ida_dbg.DOPT_SEGM_MSGS
"""
log debugger segments modifications
"""

ida_dbg.DOPT_START_BPT
"""
break on process start
"""

ida_dbg.DOPT_TEMP_HWBPT
"""
when possible use hardware bpts for temp bpts
"""

ida_dbg.DOPT_THREAD_BPT
"""
break on thread start/exit
"""

ida_dbg.DOPT_THREAD_MSGS
"""
log thread starts/exits
"""

ida_dbg.DSTATE_NOTASK
"""
no process is currently debugged
"""

ida_dbg.DSTATE_RUN
"""
process is running
"""

ida_dbg.DSTATE_SUSP
"""
process is suspended and will not continue
"""

ida_dbg.EXCDLG_ALWAYS
"""
always display
"""

ida_dbg.EXCDLG_NEVER
"""
never display exception dialogs
"""

ida_dbg.EXCDLG_UNKNOWN
"""
display for unknown exceptions
"""

ida_dbg.FT_LOG_RET
"""
specific options for function tracing (see 'set_func_trace_options()'
)

function tracing will log returning instructions
"""

ida_dbg.IT_LOG_SAME_IP
"""
specific options for instruction tracing (see
'set_insn_trace_options()' )

instruction tracing will log new instructions even when IP doesn't
change
"""

ida_dbg.ST_ALREADY_LOGGED
"""
step tracing will be disabled when IP is already logged
"""

ida_dbg.ST_DIFFERENTIAL
"""
tracing: log only new instructions (not previously logged)
"""

ida_dbg.ST_OPTIONS_MASK
"""
mask of available options, to ensure compatibility with newer IDA
versions
"""

ida_dbg.ST_OVER_DEBUG_SEG
"""
step tracing will be disabled when IP is in a debugger segment
"""

ida_dbg.ST_OVER_LIB_FUNC
"""
step tracing will be disabled when IP is in a library function
"""

ida_dbg.ST_SKIP_LOOPS
"""
step tracing will try to skip loops already recorded
"""

ida_dbg.WFNE_ANY
"""
return the first event (even if it doesn't suspend the process)
"""

ida_dbg.WFNE_CONT
"""
continue from the suspended state
"""

ida_dbg.WFNE_NOWAIT
"""
(to be used with 'WFNE_CONT' )

do not wait for any event, immediately return 'DEC_TIMEOUT'
"""

ida_dbg.WFNE_SILENT
"""
1: be slient, 0:display modal boxes if necessary
"""

ida_dbg.WFNE_SUSP
"""
wait until the process gets suspended
"""

ida_dbg.WFNE_USEC
"""
(minimum non-zero timeout is 40000us)

timeout is specified in microseconds
"""
=== ida_dbg EPYDOC INJECTIONS END ===
Help on function choose_ioport_device2 in module ida_diskio:

choose_ioport_device2(*args)
    choose_ioport_device2(_device, file, parse_params) -> bool
        @param _device (C++: qstring  *)
        @param file (C++: const char *)
        @param parse_params (C++: choose_ioport_parser_t  *)

Help on class choose_ioport_parser_t in module ida_diskio:

class choose_ioport_parser_t(__builtin__.object)
 |  Proxy of C++ choose_ioport_parser_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> choose_ioport_parser_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  parse(self, *args)
 |      parse(self, param, line) -> bool
 |          @param param (C++: qstring  *)
 |          @param line (C++: const char *)
 |          @retval: true - and fill PARAM with a displayed string
 |          @retval: false - and empty PARAM to skip the current device
 |          @retval: false - and fill PARAM with an error message
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_choose_ioport_parser_t>
 |      delete_choose_ioport_parser_t(self)

Help on function close_linput in module ida_diskio:

close_linput(*args)
    Close loader input.
    
    close_linput(li)
        @param li (C++: linput_t *)

Help on function create_bytearray_linput in module ida_diskio:

create_bytearray_linput(*args)
    Trivial memory linput.
    
    create_bytearray_linput(s) -> linput_t *
        s: qstring const &

Help on function create_generic_linput in module ida_diskio:

create_generic_linput(*args)
    Create a generic linput
    
    create_generic_linput(gl) -> linput_t *
        @param gl: linput description. this object will be destroyed by
                   close_linput()  using "delete gl;" (C++: generic_linput_t
                   *)

Help on function create_memory_linput in module ida_diskio:

create_memory_linput(*args)
    Create a linput for process memory. This linput will use
    read_dbg_memory() to read data.
    
    create_memory_linput(start, size) -> linput_t *
        @param start: starting address of the input (C++: ea_t)
        @param size: size of the memory area to represent as linput if
                     unknown, may be passed as 0 (C++: asize_t)

Help on function eclose in module ida_diskio:

eclose(*args)
    eclose(fp)
        @param fp (C++: FILE *)

Help on function enumerate_files in module ida_diskio:

enumerate_files(*args)
    enumerate_files(path, fname, callback) -> PyObject *
    Enumerate files in the specified directory while the callback returns 0.
    @param path: directory to enumerate files in
    @param fname: mask of file names to enumerate
    @param callback: a callable object that takes the filename as
                     its first argument and it returns 0 to continue
                     enumeration or non-zero to stop enumeration.
    @return:
        None in case of script errors
        tuple(code, fname) : If the callback returns non-zero

Help on function enumerate_files2 in module ida_diskio:

enumerate_files2(*args)
    enumerate_files2(answer, answer_size, path, fname, fv) -> int
        @param answer (C++: char *)
        @param answer_size (C++: size_t)
        @param path (C++: const char *)
        @param fname (C++: const char *)
        @param fv (C++: file_enumerator_t  &)

Help on class file_enumerator_t in module ida_diskio:

class file_enumerator_t(__builtin__.object)
 |  Proxy of C++ file_enumerator_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> file_enumerator_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_file(self, *args)
 |      visit_file(self, file) -> int
 |          @param file (C++: const char *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_file_enumerator_t>
 |      delete_file_enumerator_t(self)

Help on function fopenA in module ida_diskio:

fopenA(*args)
    Open a file for append in text mode, deny none.
    
    fopenA(file) -> FILE *
        @param file (C++: const char *)
        @return: NULL if failure

Help on function fopenM in module ida_diskio:

fopenM(*args)
    Open a file for read/write in binary mode, deny write.
    
    fopenM(file) -> FILE *
        @param file (C++: const char *)
        @return: NULL if failure

Help on function fopenRB in module ida_diskio:

fopenRB(*args)
    Open a file for read in binary mode, deny none.
    
    fopenRB(file) -> FILE *
        @param file (C++: const char *)
        @return: NULL if failure

Help on function fopenRT in module ida_diskio:

fopenRT(*args)
    Open a file for read in text mode, deny none.
    
    fopenRT(file) -> FILE *
        @param file (C++: const char *)
        @return: NULL if failure

Help on function fopenWB in module ida_diskio:

fopenWB(*args)
    Open a new file for write in binary mode, deny read/write. If a file
    exists, it will be removed.
    
    fopenWB(file) -> FILE *
        @param file (C++: const char *)
        @return: NULL if failure

Help on function fopenWT in module ida_diskio:

fopenWT(*args)
    Open a new file for write in text mode, deny write. If a file exists,
    it will be removed.
    
    fopenWT(file) -> FILE *
        @param file (C++: const char *)
        @return: NULL if failure

Help on class generic_linput_t in module ida_diskio:

class generic_linput_t(__builtin__.object)
 |  Proxy of C++ generic_linput_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  read(self, *args)
 |      read(self, off, buffer, nbytes) -> ssize_t
 |          @param off (C++: qoff64_t)
 |          @param buffer (C++: void *)
 |          @param nbytes (C++: size_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blocksize
 |      generic_linput_t_blocksize_get(self) -> uint32
 |  
 |  filesize
 |      generic_linput_t_filesize_get(self) -> uint64
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_generic_linput_t>
 |      delete_generic_linput_t(self)

Help on function get_ida_subdirs in module ida_diskio:

get_ida_subdirs(*args)
    Get list of directories in which to find a specific IDA resource (see
    'IDA subdirectories' ). The order of the resulting list is as follows:
    
    - [$IDAUSR/subdir (0..N entries)]
    - $IDADIR/subdir
    
    get_ida_subdirs(subdir, flags=0) -> int
        @param subdir: name of the resource to list (C++: const char *)
        @param flags: Subdirectory modification flags  bits (C++: int)
        @return: number of directories appended to 'dirs'

Help on function get_linput_type in module ida_diskio:

get_linput_type(*args)
    Get linput type.
    
    get_linput_type(li) -> linput_type_t
        @param li (C++: linput_t *)

Help on function get_special_folder in module ida_diskio:

get_special_folder(*args)
    Get a folder location by CSIDL (see 'Common CSIDLs' ). Path should be
    of at least MAX_PATH size
    
    get_special_folder(csidl) -> str
        @param csidl (C++: int)

Help on function get_user_idadir in module ida_diskio:

get_user_idadir(*args)
    Get user ida related directory.
    
    - if $IDAUSR is defined:
        - the first element in $IDAUSR
    - else
        - default user directory ($HOME/.idapro or %APPDATA%Hex-Rays/IDA Pro)

Help on function getsysfile in module ida_diskio:

getsysfile(*args)
    Search for IDA system file. This function searches for a file in:each
    directory specified by IDAUSR%ida directory [+ subdir] and returns the
    first match.
    
    getsysfile(filename, subdir) -> str
        @param filename (C++: const char *)
        @param subdir (C++: const char *)
        @return: NULL if not found, otherwise a pointer to full file name.

Help on function idadir in module ida_diskio:

idadir(*args)
    Get IDA directory (if subdir==NULL) or the specified subdirectory (see
    'IDA subdirectories' )
    
    idadir(subdir) -> char const *
        @param subdir (C++: const char *)

Help on class ioports_fallback_t in module ida_diskio:

class ioports_fallback_t(__builtin__.object)
 |  Proxy of C++ ioports_fallback_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ioports_fallback_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  handle(self, *args)
 |      handle(self, ports, line) -> bool
 |          @param ports (C++: const  ioports_t  &)
 |          @param line (C++: const char *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ioports_fallback_t>
 |      delete_ioports_fallback_t(self)

Help on function open_linput in module ida_diskio:

open_linput(*args)
    Open loader input.
    
    open_linput(file, remote) -> linput_t *
        @param file (C++: const char *)
        @param remote (C++: bool)

Help on function qlgetz in module ida_diskio:

qlgetz(*args)
    Read a zero-terminated string from the input. If fpos == -1 then no
    seek will be performed.
    
    qlgetz(li, fpos) -> str
        @param li (C++: linput_t *)
        @param fpos (C++: int64)

Help on function read_ioports2 in module ida_diskio:

read_ioports2(*args)
    read_ioports2(ports, device, file, callback=None) -> ssize_t
        @param ports (C++: ioports_t  *)
        @param device (C++: qstring  *)
        @param file (C++: const char *)
        @param callback (C++: ioports_fallback_t  *)

=== ida_diskio EPYDOC INJECTIONS ===
ida_diskio.IDA_SUBDIR_IDADIR_FIRST
"""
$IDADIR/subdir will be first, not last
"""

ida_diskio.IDA_SUBDIR_IDP
"""
append the processor name as a subdirectory
"""

ida_diskio.IDA_SUBDIR_ONLY_EXISTING
"""
only existing directories will be present
"""
=== ida_diskio EPYDOC INJECTIONS END ===
Help on function add_entry in module ida_entry:

add_entry(*args)
    Add an entry point to the list of entry points.
    
    add_entry(ord, ea, name, makecode, flags=0) -> bool
        @param ord: ordinal number if ordinal number is equal to 'ea' then
                    ordinal is not used (C++: uval_t)
        @param ea: linear address (C++: ea_t)
        @param name: name of entry point. If the specified location already
                     has a name, the old name will be appended to the regular
                     comment. If name == NULL, then the old name will be
                     retained. (C++: const char *)
        @param makecode: should the kernel convert bytes at the entry point to
                         instruction(s) (C++: bool)
        @param flags: See AEF_* (C++: int)
        @return: success (currently always true)

Help on function get_entry in module ida_entry:

get_entry(*args)
    Get entry point address by its ordinal
    
    get_entry(ord) -> ea_t
        @param ord: ordinal number of entry point (C++: uval_t)
        @return: address or  BADADDR

Help on function get_entry_forwarder in module ida_entry:

get_entry_forwarder(*args)
    Get forwarder name for the entry point by its ordinal.
    
    get_entry_forwarder(ord) -> str
        @param ord: ordinal number of entry point (C++: uval_t)
        @return: size of entry forwarder name or -1

Help on function get_entry_name in module ida_entry:

get_entry_name(*args)
    Get name of the entry point by its ordinal.
    
    get_entry_name(ord) -> str
        @param ord: ordinal number of entry point (C++: uval_t)
        @return: size of entry name or -1

Help on function get_entry_ordinal in module ida_entry:

get_entry_ordinal(*args)
    Get ordinal number of an entry point.
    
    get_entry_ordinal(idx) -> uval_t
        @param idx: internal number of entry point. Should be in the range 0..
                    get_entry_qty() -1 (C++: size_t)
        @return: ordinal number or 0.

Help on function get_entry_qty in module ida_entry:

get_entry_qty(*args)
    Get number of entry points.

Help on function rename_entry in module ida_entry:

rename_entry(*args)
    Rename entry point.
    
    rename_entry(ord, name, flags=0) -> bool
        @param ord: ordinal number of the entry point (C++: uval_t)
        @param name: name of entry point. If the specified location already
                     has a name, the old name will be appended to a repeatable
                     comment. (C++: const char *)
        @param flags: See AEF_* (C++: int)
        @return: success

Help on function set_entry_forwarder in module ida_entry:

set_entry_forwarder(*args)
    Set forwarder name for ordinal.
    
    set_entry_forwarder(ord, name, flags=0) -> bool
        @param ord: ordinal number of the entry point (C++: uval_t)
        @param name: forwarder name for entry point. (C++: const char *)
        @param flags: See AEF_* (C++: int)
        @return: success

=== ida_entry EPYDOC INJECTIONS ===
ida_entry.AEF_IDBENC
"""
the name is given in the IDB encoding; non-ASCII bytes will be decoded
accordingly Specifying AEF_IDBENC also implies AEF_NODUMMY
"""

ida_entry.AEF_NODUMMY
"""
it begins with a dummy suffix. See also AEF_IDBENC

automatically prepend the name with '_' if
"""

ida_entry.AEF_UTF8
"""
the name is given in UTF-8 (default)
"""
=== ida_entry EPYDOC INJECTIONS END ===
Help on function add_enum in module ida_enum:

add_enum(*args)
    Add new enum type.if idx== 'BADADDR' then add as the last idxif
    name==NULL then generate a unique name "enum_%d"
    
    add_enum(idx, name, flag) -> enum_t
        @param idx (C++: size_t)
        @param name (C++: const char *)
        @param flag (C++: flags_t)

Help on function add_enum_member in module ida_enum:

add_enum_member(*args)
    Add member to enum type.
    
    add_enum_member(id, name, value, bmask=(bmask_t(-1))) -> int
        @param id (C++: enum_t)
        @param name (C++: const char *)
        @param value (C++: uval_t)
        @param bmask (C++: bmask_t)
        @return: 0 if ok, otherwise one of  Add enum member result codes

Help on function del_enum in module ida_enum:

del_enum(*args)
    Delete an enum type.
    
    del_enum(id)
        @param id (C++: enum_t)

Help on function del_enum_member in module ida_enum:

del_enum_member(*args)
    Delete member of enum type.
    
    del_enum_member(id, value, serial, bmask) -> bool
        @param id (C++: enum_t)
        @param value (C++: uval_t)
        @param serial (C++: uchar)
        @param bmask (C++: bmask_t)

Help on class enum_member_visitor_t in module ida_enum:

class enum_member_visitor_t(__builtin__.object)
 |  Proxy of C++ enum_member_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_member_visitor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_enum_member(self, *args)
 |      Implements action to take when enum member is visited.
 |      
 |      visit_enum_member(self, cid, value) -> int
 |          @param cid (C++: const_t)
 |          @param value (C++: uval_t)
 |          @return: nonzero to stop the iteration
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_enum_member_visitor_t>
 |      delete_enum_member_visitor_t(self)

Help on function for_all_enum_members in module ida_enum:

for_all_enum_members(*args)
    Visit all members of a given enum.
    
    for_all_enum_members(id, cv) -> int
        @param id (C++: enum_t)
        @param cv (C++: enum_member_visitor_t  &)

Help on function get_bmask_cmt in module ida_enum:

get_bmask_cmt(*args)
    get_bmask_cmt(id, bmask, repeatable) -> str
        @param id (C++: enum_t)
        @param bmask (C++: bmask_t)
        @param repeatable (C++: bool)

Help on function get_bmask_name in module ida_enum:

get_bmask_name(*args)
    get_bmask_name(id, bmask) -> str
        @param id (C++: enum_t)
        @param bmask (C++: bmask_t)

Help on function get_enum in module ida_enum:

get_enum(*args)
    Get enum by name.
    
    get_enum(name) -> enum_t
        @param name (C++: const char *)

Help on function get_enum_cmt in module ida_enum:

get_enum_cmt(*args)
    Get enum comment.
    
    get_enum_cmt(id, repeatable) -> str
        @param id (C++: enum_t)
        @param repeatable (C++: bool)

Help on function get_enum_flag in module ida_enum:

get_enum_flag(*args)
    Get flags determining the representation of the enum. (currently they
    define the numeric base: octal, decimal, hex, bin) and signness.
    
    get_enum_flag(id) -> flags_t
        @param id (C++: enum_t)

Help on function get_enum_idx in module ida_enum:

get_enum_idx(*args)
    Get the index in the list of enums.
    
    get_enum_idx(id) -> uval_t
        @param id (C++: enum_t)

Help on function get_enum_member in module ida_enum:

get_enum_member(*args)
    Find an enum member by enum, value and bitmaskif serial -1, return a
    member with any serial
    
    get_enum_member(id, value, serial, mask) -> const_t
        @param id (C++: enum_t)
        @param value (C++: uval_t)
        @param serial (C++: int)
        @param mask (C++: bmask_t)

Help on function get_enum_member_bmask in module ida_enum:

get_enum_member_bmask(*args)
    Get bitmask of an enum member.
    
    get_enum_member_bmask(id) -> bmask_t
        @param id (C++: const_t)

Help on function get_enum_member_by_name in module ida_enum:

get_enum_member_by_name(*args)
    Get a reference to an enum member by its name.
    
    get_enum_member_by_name(name) -> const_t
        @param name (C++: const char *)

Help on function get_enum_member_cmt in module ida_enum:

get_enum_member_cmt(*args)
    Get enum member's comment.
    
    get_enum_member_cmt(id, repeatable) -> str
        @param id (C++: const_t)
        @param repeatable (C++: bool)

Help on function get_enum_member_enum in module ida_enum:

get_enum_member_enum(*args)
    Get the parent enum of an enum member.
    
    get_enum_member_enum(id) -> enum_t
        @param id (C++: const_t)

Help on function get_enum_member_name in module ida_enum:

get_enum_member_name(*args)
    Get name of an enum member by const_t.
    
    get_enum_member_name(id) -> str
        @param id (C++: const_t)

Help on function get_enum_member_serial in module ida_enum:

get_enum_member_serial(*args)
    Get serial number of an enum member.
    
    get_enum_member_serial(cid) -> uchar
        @param cid (C++: const_t)

Help on function get_enum_member_value in module ida_enum:

get_enum_member_value(*args)
    Get value of an enum member.
    
    get_enum_member_value(id) -> uval_t
        @param id (C++: const_t)

Help on function get_enum_name in module ida_enum:

get_enum_name(*args)
    Get name of enum.
    
    get_enum_name(id) -> str
        @param id (C++: enum_t)

Help on function get_enum_name2 in module ida_enum:

get_enum_name2(*args)
    Get name of enum
    
    get_enum_name2(id, flags=0) -> str
        @param id: enum id (C++: enum_t)
        @param flags: Enum name flags (C++: int)

Help on function get_enum_qty in module ida_enum:

get_enum_qty(*args)
    Get number of declared 'enum_t' types.

Help on function get_enum_size in module ida_enum:

get_enum_size(*args)
    Get the number of the members of the enum.
    
    get_enum_size(id) -> size_t
        @param id (C++: enum_t)

Help on function get_enum_type_ordinal in module ida_enum:

get_enum_type_ordinal(*args)
    Get corresponding type ordinal number.
    
    get_enum_type_ordinal(id) -> int32
        @param id (C++: enum_t)

Help on function get_enum_width in module ida_enum:

get_enum_width(*args)
    Get the width of a enum element allowed values: 0
    (unspecified),1,2,4,8,16,32,64
    
    get_enum_width(id) -> size_t
        @param id (C++: enum_t)

Help on function get_first_bmask in module ida_enum:

get_first_bmask(*args)
    Get first bitmask in the enum (bitfield)
    
    get_first_bmask(id) -> bmask_t
        @param id (C++: enum_t)
        @return: the smallest bitmask for enum, or DEFMASK

Help on function get_first_enum_member in module ida_enum:

get_first_enum_member(*args)
    get_first_enum_member(id, bmask=(bmask_t(-1))) -> uval_t
        @param id (C++: enum_t)
        @param bmask (C++: bmask_t)

Help on function get_first_serial_enum_member in module ida_enum:

get_first_serial_enum_member(*args)
    get_first_serial_enum_member(id, value, bmask) -> const_t
        @param id (C++: enum_t)
        @param value (C++: uval_t)
        @param bmask (C++: bmask_t)

Help on function get_last_bmask in module ida_enum:

get_last_bmask(*args)
    Get last bitmask in the enum (bitfield)
    
    get_last_bmask(id) -> bmask_t
        @param id (C++: enum_t)
        @return: the biggest bitmask for enum, or DEFMASK

Help on function get_last_enum_member in module ida_enum:

get_last_enum_member(*args)
    get_last_enum_member(id, bmask=(bmask_t(-1))) -> uval_t
        @param id (C++: enum_t)
        @param bmask (C++: bmask_t)

Help on function get_last_serial_enum_member in module ida_enum:

get_last_serial_enum_member(*args)
    get_last_serial_enum_member(id, value, bmask) -> const_t
        @param id (C++: enum_t)
        @param value (C++: uval_t)
        @param bmask (C++: bmask_t)

Help on function get_next_bmask in module ida_enum:

get_next_bmask(*args)
    Get next bitmask in the enum (bitfield)
    
    get_next_bmask(id, bmask) -> bmask_t
        @param id (C++: enum_t)
        @param bmask (C++: bmask_t)
        @return: value of a bitmask with value higher than the specified
                 value, or DEFMASK

Help on function get_next_enum_member in module ida_enum:

get_next_enum_member(*args)
    get_next_enum_member(id, value, bmask=(bmask_t(-1))) -> uval_t
        @param id (C++: enum_t)
        @param value (C++: uval_t)
        @param bmask (C++: bmask_t)

Help on function get_next_serial_enum_member in module ida_enum:

get_next_serial_enum_member(*args)
    get_next_serial_enum_member(in_out_serial, first_cid) -> const_t
        @param in_out_serial (C++: uchar  *)
        @param first_cid (C++: const_t)

Help on function get_prev_bmask in module ida_enum:

get_prev_bmask(*args)
    Get prev bitmask in the enum (bitfield)
    
    get_prev_bmask(id, bmask) -> bmask_t
        @param id (C++: enum_t)
        @param bmask (C++: bmask_t)
        @return: value of a bitmask with value lower than the specified value,
                 or DEFMASK

Help on function get_prev_enum_member in module ida_enum:

get_prev_enum_member(*args)
    get_prev_enum_member(id, value, bmask=(bmask_t(-1))) -> uval_t
        @param id (C++: enum_t)
        @param value (C++: uval_t)
        @param bmask (C++: bmask_t)

Help on function get_prev_serial_enum_member in module ida_enum:

get_prev_serial_enum_member(*args)
    get_prev_serial_enum_member(in_out_serial, first_cid) -> const_t
        @param in_out_serial (C++: uchar  *)
        @param first_cid (C++: const_t)

Help on function getn_enum in module ida_enum:

getn_enum(*args)
    Get enum by its index in the list of enums (0.. 'get_enum_qty()' -1).
    
    getn_enum(idx) -> enum_t
        @param idx (C++: size_t)

Help on function is_bf in module ida_enum:

is_bf(*args)
    Is enum a bitfield? (otherwise - plain enum, no bitmasks except for
    'DEFMASK' are allowed)
    
    is_bf(id) -> bool
        @param id (C++: enum_t)

Help on function is_enum_fromtil in module ida_enum:

is_enum_fromtil(*args)
    Does enum come from type library?
    
    is_enum_fromtil(id) -> bool
        @param id (C++: enum_t)

Help on function is_enum_hidden in module ida_enum:

is_enum_hidden(*args)
    Is enum collapsed?
    
    is_enum_hidden(id) -> bool
        @param id (C++: enum_t)

Help on function is_ghost_enum in module ida_enum:

is_ghost_enum(*args)
    Is a ghost copy of a local type?
    
    is_ghost_enum(id) -> bool
        @param id (C++: enum_t)

Help on function is_one_bit_mask in module ida_enum:

is_one_bit_mask(*args)
    Is bitmask one bit?
    
    is_one_bit_mask(mask) -> bool
        @param mask (C++: bmask_t)

Help on function set_bmask_cmt in module ida_enum:

set_bmask_cmt(*args)
    set_bmask_cmt(id, bmask, cmt, repeatable) -> bool
        @param id (C++: enum_t)
        @param bmask (C++: bmask_t)
        @param cmt (C++: const char *)
        @param repeatable (C++: bool)

Help on function set_bmask_name in module ida_enum:

set_bmask_name(*args)
    set_bmask_name(id, bmask, name) -> bool
        @param id (C++: enum_t)
        @param bmask (C++: bmask_t)
        @param name (C++: const char *)

Help on function set_enum_bf in module ida_enum:

set_enum_bf(*args)
    Set 'bitfield' bit of enum (i.e. convert it to a bitfield)
    
    set_enum_bf(id, bf) -> bool
        @param id (C++: enum_t)
        @param bf (C++: bool)

Help on function set_enum_cmt in module ida_enum:

set_enum_cmt(*args)
    Set comment for enum type.
    
    set_enum_cmt(id, cmt, repeatable) -> bool
        @param id (C++: enum_t)
        @param cmt (C++: const char *)
        @param repeatable (C++: bool)

Help on function set_enum_flag in module ida_enum:

set_enum_flag(*args)
    Set data representation flags.
    
    set_enum_flag(id, flag) -> bool
        @param id (C++: enum_t)
        @param flag (C++: flags_t)

Help on function set_enum_fromtil in module ida_enum:

set_enum_fromtil(*args)
    Specify that enum comes from a type library.
    
    set_enum_fromtil(id, fromtil) -> bool
        @param id (C++: enum_t)
        @param fromtil (C++: bool)

Help on function set_enum_ghost in module ida_enum:

set_enum_ghost(*args)
    Specify that enum is a ghost copy of a local type.
    
    set_enum_ghost(id, ghost) -> bool
        @param id (C++: enum_t)
        @param ghost (C++: bool)

Help on function set_enum_hidden in module ida_enum:

set_enum_hidden(*args)
    Collapse enum.
    
    set_enum_hidden(id, hidden) -> bool
        @param id (C++: enum_t)
        @param hidden (C++: bool)

Help on function set_enum_idx in module ida_enum:

set_enum_idx(*args)
    Set serial number of enum. Also see 'get_enum_idx()' .
    
    set_enum_idx(id, idx) -> bool
        @param id (C++: enum_t)
        @param idx (C++: size_t)

Help on function set_enum_member_cmt in module ida_enum:

set_enum_member_cmt(*args)
    Set comment for enum member.
    
    set_enum_member_cmt(id, cmt, repeatable) -> bool
        @param id (C++: const_t)
        @param cmt (C++: const char *)
        @param repeatable (C++: bool)

Help on function set_enum_member_name in module ida_enum:

set_enum_member_name(*args)
    Set name of enum member.
    
    set_enum_member_name(id, name) -> bool
        @param id (C++: const_t)
        @param name (C++: const char *)

Help on function set_enum_name in module ida_enum:

set_enum_name(*args)
    Set name of enum type.
    
    set_enum_name(id, name) -> bool
        @param id (C++: enum_t)
        @param name (C++: const char *)

Help on function set_enum_type_ordinal in module ida_enum:

set_enum_type_ordinal(*args)
    Set corresponding type ordinal number.
    
    set_enum_type_ordinal(id, ord)
        @param id (C++: enum_t)
        @param ord (C++: int32)

Help on function set_enum_width in module ida_enum:

set_enum_width(*args)
    See comment for 'get_enum_width()'
    
    set_enum_width(id, width) -> bool
        @param id (C++: enum_t)
        @param width (C++: int)

=== ida_enum EPYDOC INJECTIONS ===
ida_enum.DEFMASK
"""
default bitmask
"""

ida_enum.ENFL_REGEX
"""
apply regular expressions to beautify the name
"""

ida_enum.ENUM_MEMBER_ERROR_ENUM
"""
bad enum id
"""

ida_enum.ENUM_MEMBER_ERROR_ILLV
"""
bad bmask and value combination (~bmask & value != 0)
"""

ida_enum.ENUM_MEMBER_ERROR_MASK
"""
bad bmask
"""

ida_enum.ENUM_MEMBER_ERROR_NAME
"""
already have member with this name (bad name)
"""

ida_enum.ENUM_MEMBER_ERROR_VALUE
"""
already have 256 members with this value
"""
=== ida_enum EPYDOC INJECTIONS END ===
Help on class _IdcFunction in module ida_expr:

class _IdcFunction(__builtin__.object)
 |  Internal class that calls pyw_call_idc_func() with a context
 |  
 |  Methods defined here:
 |  
 |  __call__(self, args, res)
 |  
 |  __init__(self, ctxptr)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fp_ptr

Help on function add_idc_class in module ida_expr:

add_idc_class(*args)
    Create a new IDC class.
    
    add_idc_class(name, super=None) -> idc_class_t *
        @param name: name of the new class (C++: const char *)
        @param super: the base class for the new class. if the new class is
                      not based on any other class, pass NULL (C++: const
                      idc_class_t *)
        @return: pointer to the created class. If such a class already exists,
                 a pointer to it will be returned. Pointers to other existing
                 classes may be invalidated by this call.

Help on function add_idc_func in module ida_expr:

add_idc_func(name, fp, args, defvals=(), flags=0)
    Extends the IDC language by exposing a new IDC function that is backed up by a Python function
    
    @param name: IDC function name to expose
    @param fp: Python callable that will receive the arguments and return a tuple.
    @param args: Arguments. A tuple of idaapi.VT_XXX constants
    @param defvals: default argument values (optional)
    @param flags: IDC function flags. A combination of EXTFUN_XXX constants (optional)
    
    @return: Boolean

Help on function add_idc_gvar in module ida_expr:

add_idc_gvar(*args)
    Add global IDC variable.
    
    add_idc_gvar(name) -> idc_value_t
        @param name: name of the global variable (C++: const char *)
        @return: pointer to the created variable or existing variable. NB: the
                 returned pointer is valid until a new global var is added.

Help on function compile_idc_file in module ida_expr:

compile_idc_file(*args)
    compile_idc_file(nonnul_line) -> str
        nonnul_line: char const *

Help on function compile_idc_snippet in module ida_expr:

compile_idc_snippet(*args)
    Compile text with IDC statements.
    
    compile_idc_snippet(func, text, resolver=None, only_safe_funcs=False) -> str
        @param func: name of the function to create out of the snippet (C++:
                     const char *)
        @param text: text to compile (C++: const char *)
        @param resolver: callback object to get values of undefined variables
                         This object will be called if IDC function contains
                         references to undefined variables. May be NULL. (C++:
                         idc_resolver_t  *)
        @param only_safe_funcs: if true, any calls to functions without
                                EXTFUN_SAFE  flag will lead to a compilation
                                error. (C++: bool)
        @retval: true - ok
        @retval: false - error, see errbuf

Help on function compile_idc_text in module ida_expr:

compile_idc_text(*args)
    compile_idc_text(nonnul_line) -> str
        nonnul_line: char const *

Help on function copy_idcv in module ida_expr:

copy_idcv(*args)
    Copy 'src' to 'dst'. For idc objects only a reference is copied.
    
    copy_idcv(dst, src) -> error_t
        @param dst (C++: idc_value_t  *)
        @param src (C++: const  idc_value_t  &)

Help on function create_idcv_ref in module ida_expr:

create_idcv_ref(*args)
    Create a variable reference. Currently only references to global
    variables can be created.
    
    create_idcv_ref(ref, v) -> bool
        @param ref: ptr to the result (C++: idc_value_t  *)
        @param v: variable to reference (C++: const  idc_value_t  *)
        @return: success

Help on function deep_copy_idcv in module ida_expr:

deep_copy_idcv(*args)
    Deep copy an IDC object. This function performs deep copy of idc
    objects. If 'src' is not an object, 'copy_idcv()' will be called
    
    deep_copy_idcv(dst, src) -> error_t
        @param dst (C++: idc_value_t  *)
        @param src (C++: const  idc_value_t  &)

Help on function del_idc_func in module ida_expr:

del_idc_func(name)
    Unregisters the specified IDC function
    
    @param name: IDC function name to unregister
    
    @return: Boolean

Help on function del_idcv_attr in module ida_expr:

del_idcv_attr(*args)
    Delete an object attribute.
    
    del_idcv_attr(obj, attr) -> error_t
        @param obj: variable that holds an object reference (C++: idc_value_t
                    *)
        @param attr: attribute name (C++: const char *)
        @return: error code, eOk on success

Help on function deref_idcv in module ida_expr:

deref_idcv(*args)
    Dereference a 'VT_REF' variable.
    
    deref_idcv(v, vref_flags) -> idc_value_t
        @param v: variable to dereference (C++: idc_value_t  *)
        @param vref_flags: Dereference IDC variable flags (C++: int)
        @return: pointer to the dereference result or NULL. If returns NULL,
                 qerrno is set to eExecBadRef "Illegal variable reference"

Help on function eval_expr in module ida_expr:

eval_expr(*args)
    Compile and calculate an expression.
    
    eval_expr(rv, where, line) -> str
        @param rv: pointer to the result (C++: idc_value_t  *)
        @param where: the current linear address in the addressing space of
                      the program being disassembled. If will be used to
                      resolve names of local variables etc. if not applicable,
                      then should be  BADADDR . (C++: ea_t)
        @param line: the expression to evaluate (C++: const char *)
        @retval: true - ok
        @retval: false - error, see errbuf

Help on function eval_idc_expr in module ida_expr:

eval_idc_expr(*args)
    Same as 'eval_expr()' , but will always use the IDC interpreter
    regardless of the currently installed extlang.
    
    eval_idc_expr(rv, where, line) -> str
        @param rv (C++: idc_value_t  *)
        @param where (C++: ea_t)
        line: char const *

Help on function exec_idc_script in module ida_expr:

exec_idc_script(*args)
    Compile and execute IDC function(s) from file.
    
    exec_idc_script(result, path, func, args, argsnum) -> str
        @param result: ptr to  idc_value_t  to hold result of the function. If
                       execution fails, this variable will contain the
                       exception information. You may pass NULL if you are not
                       interested in the returned value. (C++: idc_value_t  *)
        @param path: text file containing text of IDC functions (C++: const
                     char *)
        @param func: function name to execute (C++: const char *)
        @param args: array of parameters (C++: const  idc_value_t)
        @param argsnum: number of parameters to pass to 'fname' This number
                        should be equal to number of parameters the function
                        expects. (C++: size_t)
        @retval: true - ok
        @retval: false - error, see errbuf

Help on function exec_system_script in module ida_expr:

exec_system_script(*args)
    Compile and execute "main" function from system file.
    
    exec_system_script(file, complain_if_no_file=True) -> bool
        @param file: file name with IDC function(s). The file will be searched
                     in the idc subdir of ida (C++: const char *)
        @param complain_if_no_file: 1: display warning if the file is not
                                    found   0: don't complain if file doesn't
                                    exist (C++: bool)
        @retval: 1 - ok, file is compiled and executed
        @retval: 0 - failure, compilation or execution error, warning is
                     displayed

Help on function find_idc_class in module ida_expr:

find_idc_class(*args)
    Find an existing IDC class by its name.
    
    find_idc_class(name) -> idc_class_t *
        @param name: name of the class (C++: const char *)
        @return: pointer to the class or NULL. The returned pointer is valid
                 until a new call to  add_idc_class()

Help on function find_idc_func in module ida_expr:

find_idc_func(*args)
    find_idc_func(prefix, n=0) -> str
        @param prefix (C++: const char *)
        @param n (C++: int)

Help on function find_idc_gvar in module ida_expr:

find_idc_gvar(*args)
    Find an existing global IDC variable by its name.
    
    find_idc_gvar(name) -> idc_value_t
        @param name: name of the global variable (C++: const char *)
        @return: pointer to the variable or NULL. NB: the returned pointer is
                 valid until a new global var is added. FIXME: it is difficult
                 to use this function in a thread safe manner

Help on function first_idcv_attr in module ida_expr:

first_idcv_attr(*args)
    first_idcv_attr(obj) -> char const *
        @param obj (C++: const  idc_value_t  *)

Help on function free_idcv in module ida_expr:

free_idcv(*args)
    Free storage used by 'VT_STR' / 'VT_OBJ' IDC variables. After this
    call the variable has a numeric value 0
    
    free_idcv(v)
        @param v (C++: idc_value_t  *)

Help on function get_idc_filename in module ida_expr:

get_idc_filename(*args)
    Get full name of IDC file name. Search for file in list of include
    directories, IDCPATH directory and the current directory.
    
    get_idc_filename(file) -> str
        @param file: file name without full path (C++: const char *)
        @return: NULL is file not found. otherwise returns pointer to buf

Help on function get_idcv_attr in module ida_expr:

get_idcv_attr(*args)
    Get an object attribute.
    
    get_idcv_attr(res, obj, attr, may_use_getattr=False) -> error_t
        @param res: buffer for the attribute value (C++: idc_value_t  *)
        @param obj: variable that holds an object reference. if obj is NULL it
                    searches global variables, then user functions (C++: const
                    idc_value_t  *)
        @param attr: attribute name (C++: const char *)
        @param may_use_getattr: may call getattr functions to calculate the
                                attribute if it does not exist (C++: bool)
        @return: error code, eOk on success

Help on function get_idcv_class_name in module ida_expr:

get_idcv_class_name(*args)
    Retrieves the IDC object class name.
    
    get_idcv_class_name(obj) -> str
        @param obj: class instance variable (C++: const  idc_value_t  *)
        @return: error code, eOk on success

Help on function get_idcv_slice in module ida_expr:

get_idcv_slice(*args)
    Get slice.
    
    get_idcv_slice(res, v, i1, i2, flags=0) -> error_t
        @param res: output variable that will contain the slice (C++:
                    idc_value_t  *)
        @param v: input variable (string or object) (C++: const  idc_value_t
                  *)
        @param i1: slice start index (C++: uval_t)
        @param i2: slice end index (excluded) (C++: uval_t)
        @param flags: IDC variable slice flags  or 0 (C++: int)
        @return: eOk if success

Help on class highlighter_cbs_t in module ida_expr:

class highlighter_cbs_t(__builtin__.object)
 |  Proxy of C++ highlighter_cbs_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> highlighter_cbs_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  cur_block_state(self, *args)
 |      cur_block_state(self) -> int32
 |  
 |  prev_block_state(self, *args)
 |      prev_block_state(self) -> int32
 |  
 |  set_block_state(self, *args)
 |      set_block_state(self, arg0)
 |          arg0: int32
 |  
 |  set_style(self, *args)
 |      set_style(self, arg0, arg1, arg2)
 |          arg0: int32
 |          arg1: int32
 |          arg2: enum syntax_highlight_style
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_highlighter_cbs_t>
 |      delete_highlighter_cbs_t(self)

Help on class idc_global_t in module ida_expr:

class idc_global_t(__builtin__.object)
 |  Proxy of C++ idc_global_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idc_global_t
 |          n: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      idc_global_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      idc_global_t_value_get(self) -> idc_value_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_idc_global_t>
 |      delete_idc_global_t(self)

Help on class idc_value_t in module ida_expr:

class idc_value_t(__builtin__.object)
 |  Proxy of C++ idc_value_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, n=0) -> idc_value_t
 |          n: sval_t
 |      
 |      
 |      __init__(self, r) -> idc_value_t
 |          r: idc_value_t const &
 |      
 |      
 |      __init__(self, _str) -> idc_value_t
 |          _str: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _create_empty_string(self, *args)
 |      _create_empty_string(self)
 |  
 |  _idc_value_t__get_e = __get_e(self, *args)
 |      __get_e(self) -> wrapped_array_t< ushort,6 >
 |  
 |  c_str(self, *args)
 |      'VT_STR'
 |  
 |  clear(self, *args)
 |      See 'free_idcv()'
 |  
 |  create_empty_string(self, *args)
 |      create_empty_string(self)
 |  
 |  is_convertible(self, *args)
 |      Convertible types are 'VT_LONG' , 'VT_FLOAT' , 'VT_INT64' , and
 |      'VT_STR' .
 |  
 |  is_integral(self, *args)
 |      Does value represent a whole number?
 |  
 |  is_zero(self, *args)
 |      Does value represent the integer 0?
 |  
 |  qstr(self, *args)
 |      'VT_STR'
 |  
 |  set_float(self, *args)
 |      set_float(self, f)
 |          f: ushort const [6]
 |  
 |  set_int64(self, *args)
 |      set_int64(self, v)
 |          v: int64
 |  
 |  set_long(self, *args)
 |      set_long(self, v)
 |          v: sval_t
 |  
 |  set_pvoid(self, *args)
 |      set_pvoid(self, p)
 |          p: void *
 |  
 |  set_string(self, *args)
 |      set_string(self, _str, len)
 |          _str: char const *
 |          len: size_t
 |      
 |      
 |      set_string(self, _str)
 |          _str: char const *
 |  
 |  swap(self, *args)
 |      Set this = r and v = this.
 |      
 |      swap(self, v)
 |          @param v (C++: idc_value_t  &)
 |  
 |  u_str(self, *args)
 |      'VT_STR'
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  e
 |      __get_e(self) -> wrapped_array_t< ushort,6 >
 |  
 |  funcidx
 |      idc_value_t_funcidx_get(self) -> int
 |  
 |  i64
 |      idc_value_t_i64_get(self) -> int64
 |  
 |  num
 |      idc_value_t_num_get(self) -> sval_t
 |  
 |  obj
 |      idc_value_t_obj_get(self) -> idc_object_t *
 |  
 |  pvoid
 |      idc_value_t_pvoid_get(self) -> void *
 |  
 |  reserve
 |      idc_value_t_reserve_get(self) -> uchar [sizeof(qstring)]
 |  
 |  str
 |  
 |  thisown
 |      The membership flag
 |  
 |  vtype
 |      idc_value_t_vtype_get(self) -> char
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_idc_value_t>
 |      delete_idc_value_t(self)

Help on class idc_values_t in module ida_expr:

class idc_values_t(__builtin__.object)
 |  Proxy of C++ qvector< idc_value_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> idc_value_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idc_values_t
 |          x: qvector< idc_value_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: idc_value_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> idc_value_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> idc_value_t
 |      begin(self) -> idc_value_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> idc_value_t
 |      end(self) -> idc_value_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> idc_value_t
 |          it: qvector< idc_value_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> idc_value_t
 |          first: qvector< idc_value_t >::iterator
 |          last: qvector< idc_value_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> idc_value_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=idc_value_t())
 |          x: idc_value_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: idc_value_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> idc_value_t
 |          it: qvector< idc_value_t >::iterator
 |          x: idc_value_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: idc_value_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: idc_value_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< idc_value_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_idc_values_t>
 |      delete_idc_values_t(self)

Help on function idcv_float in module ida_expr:

idcv_float(*args)
    Convert IDC variable to a floating point.
    
    idcv_float(v) -> error_t
        @param v (C++: idc_value_t  *)

Help on function idcv_int64 in module ida_expr:

idcv_int64(*args)
    Convert IDC variable to a 64bit number.
    
    idcv_int64(v) -> error_t
        @param v (C++: idc_value_t  *)
        @return: v = 0 if impossible to convert to int64

Help on function idcv_long in module ida_expr:

idcv_long(*args)
    Convert IDC variable to a long (32/64bit) number.
    
    idcv_long(v) -> error_t
        @param v (C++: idc_value_t  *)
        @return: v = 0 if impossible to convert to long

Help on function idcv_num in module ida_expr:

idcv_num(*args)
    Convert IDC variable to a long number.
    
    idcv_num(v) -> error_t
        @param v (C++: idc_value_t  *)
        @return: v = 0 if IDC variable = "false" string   v = 1 if IDC
                 variable = "true" string   v = number if IDC variable is
                 number or string containing a number   eTypeConflict if IDC
                 variable = empty string

Help on function idcv_object in module ida_expr:

idcv_object(*args)
    Create an IDC object. The original value of 'v' is discarded (freed).
    
    idcv_object(v, icls=None) -> error_t
        @param v: variable to hold the object. any previous value will be
                  cleaned (C++: idc_value_t  *)
        @param icls: ptr to the desired class. NULL means "object" class this
                     ptr must be returned by  add_idc_class()  or
                     find_idc_class() (C++: const idc_class_t *)
        @return: always eOk

Help on function idcv_string in module ida_expr:

idcv_string(*args)
    Convert IDC variable to a text string.
    
    idcv_string(v) -> error_t
        @param v (C++: idc_value_t  *)

Help on function last_idcv_attr in module ida_expr:

last_idcv_attr(*args)
    last_idcv_attr(obj) -> char const *
        @param obj (C++: const  idc_value_t  *)

Help on function move_idcv in module ida_expr:

move_idcv(*args)
    Move 'src' to 'dst'. This function is more effective than copy_idcv
    since it never copies big amounts of data.
    
    move_idcv(dst, src) -> error_t
        @param dst (C++: idc_value_t  *)
        @param src (C++: idc_value_t  *)

Help on function next_idcv_attr in module ida_expr:

next_idcv_attr(*args)
    next_idcv_attr(obj, attr) -> char const *
        @param obj (C++: const  idc_value_t  *)
        @param attr (C++: const char *)

Help on function prev_idcv_attr in module ida_expr:

prev_idcv_attr(*args)
    prev_idcv_attr(obj, attr) -> char const *
        @param obj (C++: const  idc_value_t  *)
        @param attr (C++: const char *)

Help on function print_idcv in module ida_expr:

print_idcv(*args)
    Get text representation of 'idc_value_t' .
    
    print_idcv(v, name=None, indent=0) -> str
        @param v (C++: const  idc_value_t  &)
        @param name (C++: const char *)
        @param indent (C++: int)

Help on function py_add_idc_func in module ida_expr:

py_add_idc_func(*args)
    py_add_idc_func(name, fp_ptr, args, defvals, flags) -> bool
        name: char const *
        fp_ptr: size_t
        args: char const *
        defvals: idc_values_t const &
        flags: int

Help on function py_get_call_idc_func in module ida_expr:

py_get_call_idc_func(*args)
    py_get_call_idc_func() -> size_t

Help on function pyw_convert_defvals in module ida_expr:

pyw_convert_defvals(*args)
    pyw_convert_defvals(out, py_seq) -> bool
        out: idc_values_t *
        py_seq: PyObject *

Help on function pyw_register_idc_func in module ida_expr:

pyw_register_idc_func(*args)
    pyw_register_idc_func(name, args, py_fp) -> size_t
        name: char const *
        args: char const *
        py_fp: PyObject *

Help on function pyw_unregister_idc_func in module ida_expr:

pyw_unregister_idc_func(*args)
    pyw_unregister_idc_func(ctxptr) -> bool
        ctxptr: size_t

Help on function set_header_path in module ida_expr:

set_header_path(*args)
    Set or append a header path. IDA looks for the include files in the
    appended header paths, then in the ida executable directory.
    
    set_header_path(path, add) -> bool
        @param path: list of directories to add (separated by ';') may be
                     NULL, in this case nothing is added (C++: const char *)
        @param add: true: append. false: remove old paths. (C++: bool)
        @retval: true - success
        @retval: false - no memory

Help on function set_idcv_attr in module ida_expr:

set_idcv_attr(*args)
    Set an object attribute.
    
    set_idcv_attr(obj, attr, value, may_use_setattr=False) -> error_t
        @param obj: variable that holds an object reference. if obj is NULL
                    then it tries to modify a global variable with the
                    attribute name (C++: idc_value_t  *)
        @param attr: attribute name (C++: const char *)
        @param value: new attribute value (C++: const  idc_value_t  &)
        @param may_use_setattr: may call setattr functions for the class (C++:
                                bool)
        @return: error code, eOk on success

Help on function set_idcv_slice in module ida_expr:

set_idcv_slice(*args)
    Set slice.
    
    set_idcv_slice(v, i1, i2, _in, flags=0) -> error_t
        @param v: variable to modify (string or object) (C++: idc_value_t  *)
        @param i1: slice start index (C++: uval_t)
        @param i2: slice end index (excluded) (C++: uval_t)
        in: idc_value_t const &
        @param flags: IDC variable slice flags  or 0 (C++: int)
        @return: eOk on success

Help on function swap_idcvs in module ida_expr:

swap_idcvs(*args)
    Swap 2 variables.
    
    swap_idcvs(v1, v2)
        @param v1 (C++: idc_value_t  *)
        @param v2 (C++: idc_value_t  *)

Help on function throw_idc_exception in module ida_expr:

throw_idc_exception(*args)
    Create an idc execution exception object. This helper function can be
    used to return an exception from C++ code to IDC. In other words this
    function can be called from 'idc_func_t()' callbacks. Sample usage: if
    ( !ok ) return throw_idc_exception(r, "detailed error msg");
    
    throw_idc_exception(r, desc) -> error_t
        @param r: object to hold the exception object (C++: idc_value_t  *)
        @param desc: exception description (C++: const char *)
        @return: eExecThrow

=== ida_expr EPYDOC INJECTIONS ===
ida_expr.CPL_DEL_MACROS
"""
delete macros at the end of compilation
"""

ida_expr.CPL_ONLY_SAFE
"""
allow calls of only thread-safe functions
"""

ida_expr.CPL_USE_LABELS
"""
allow program labels in the script
"""

ida_expr.IDC_LANG_EXT
"""
IDC script extension.
"""

ida_expr.VARSLICE_SINGLE
"""
return single index (i2 is ignored)
"""

ida_expr.VREF_COPY
"""
copy the result to the input var (v)
"""

ida_expr.VREF_LOOP
"""
dereference until we get a non 'VT_REF'
"""

ida_expr.VREF_ONCE
"""
dereference only once, do not loop
"""

ida_expr.VT_FLOAT
"""
Floating point (see 'idc_value_t::e' )
"""

ida_expr.VT_FUNC
"""
Function (see 'idc_value_t::funcidx' )
"""

ida_expr.VT_INT64
"""
i64
"""

ida_expr.VT_LONG
"""
Integer (see 'idc_value_t::num' )
"""

ida_expr.VT_OBJ
"""
Object (see idc_value_t::obj)
"""

ida_expr.VT_PVOID
"""
void *
"""

ida_expr.VT_REF
"""
Reference.
"""

ida_expr.VT_STR
"""
String (see qstr() and similar functions)
"""

ida_expr.VT_WILD
"""
Function with arbitrary number of arguments. The actual number of
arguments will be passed in 'idc_value_t::num' . This value should not
be used for 'idc_value_t' .
"""

ida_expr.eExecThrow
"""
See return value of 'idc_func_t' .
"""
=== ida_expr EPYDOC INJECTIONS END ===
Help on function calc_fixup_size in module ida_fixup:

calc_fixup_size(*args)
    Calculate size of fixup in bytes (the number of bytes the fixup
    patches)
    
    calc_fixup_size(type) -> int
        @param type (C++: fixup_type_t)
        @retval: -1 - means error

Help on function contains_fixups in module ida_fixup:

contains_fixups(*args)
    Does the specified address range contain any fixup information?
    
    contains_fixups(ea, size) -> bool
        @param ea (C++: ea_t)
        @param size (C++: asize_t)

Help on function del_fixup in module ida_fixup:

del_fixup(*args)
    Delete fixup information.
    
    del_fixup(source)
        @param source (C++: ea_t)

Help on function exists_fixup in module ida_fixup:

exists_fixup(*args)
    Check that a fixup exists at the given address.
    
    exists_fixup(source) -> bool
        @param source (C++: ea_t)

Help on function find_custom_fixup in module ida_fixup:

find_custom_fixup(*args)
    Get id of a custom fixup handler.
    
    find_custom_fixup(name) -> fixup_type_t
        @param name: name of the custom fixup handler (C++: const char *)
        @return: id with FIXUP_CUSTOM bit set or 0

Help on class fixup_data_t in module ida_fixup:

class fixup_data_t(__builtin__.object)
 |  Proxy of C++ fixup_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> fixup_data_t
 |          type_: fixup_type_t
 |          flags_: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  calc_size(self, *args)
 |      'calc_fixup_size()'
 |  
 |  clr_extdef(self, *args)
 |      clr_extdef(self)
 |  
 |  clr_unused(self, *args)
 |      clr_unused(self)
 |  
 |  get(self, *args)
 |      'get_fixup()'
 |      
 |      get(self, source) -> bool
 |          @param source (C++: ea_t)
 |  
 |  get_base(self, *args)
 |      Get base of fixup.The target is calculated as 'get_base()' + off.
 |      'get_base()' + off 'FIXUPF_REL'
 |  
 |  get_desc(self, *args)
 |      'get_fixup_desc()'
 |      
 |      get_desc(self, source) -> char const *
 |          @param source (C++: ea_t)
 |  
 |  get_flags(self, *args)
 |      Fixup flags 'Fixup flags' .
 |  
 |  get_handler(self, *args)
 |      'get_fixup_handler()'
 |  
 |  get_type(self, *args)
 |      Fixup type 'Types of fixups' .
 |  
 |  get_value(self, *args)
 |      'get_fixup_value()'
 |      
 |      get_value(self, ea) -> uval_t
 |          @param ea (C++: ea_t)
 |  
 |  has_base(self, *args)
 |      Is fixup relative?
 |  
 |  is_custom(self, *args)
 |      'is_fixup_custom()'
 |  
 |  is_extdef(self, *args)
 |      is_extdef(self) -> bool
 |  
 |  is_unused(self, *args)
 |      is_unused(self) -> bool
 |  
 |  patch_value(self, *args)
 |      'patch_fixup_value()'
 |      
 |      patch_value(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |  
 |  set(self, *args)
 |      'set_fixup()'
 |      
 |      set(self, source)
 |          @param source (C++: ea_t)
 |  
 |  set_base(self, *args)
 |      Set base of fixup. The target should be set before a call of this
 |      function.
 |      
 |      set_base(self, new_base)
 |          @param new_base (C++: ea_t)
 |  
 |  set_extdef(self, *args)
 |      set_extdef(self)
 |  
 |  set_sel(self, *args)
 |      set_sel(self, seg)
 |          @param seg (C++: const  segment_t  *)
 |  
 |  set_target_sel(self, *args)
 |      Set selector of fixup to the target. The target should be set before a
 |      call of this function.
 |  
 |  set_type(self, *args)
 |      set_type(self, type_)
 |          @param type_ (C++: fixup_type_t)
 |  
 |  set_type_and_flags(self, *args)
 |      set_type_and_flags(self, type_, flags_=0)
 |          @param type_ (C++: fixup_type_t)
 |          @param flags_ (C++: uint32)
 |  
 |  set_unused(self, *args)
 |      set_unused(self)
 |  
 |  was_created(self, *args)
 |      Is fixup artificial?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  displacement
 |      fixup_data_t_displacement_get(self) -> adiff_t
 |  
 |  off
 |      fixup_data_t_off_get(self) -> ea_t
 |  
 |  sel
 |      fixup_data_t_sel_get(self) -> sel_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_fixup_data_t>
 |      delete_fixup_data_t(self)

Help on class fixup_info_t in module ida_fixup:

class fixup_info_t(__builtin__.object)
 |  Proxy of C++ fixup_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> fixup_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      fixup_info_t_ea_get(self) -> ea_t
 |  
 |  fd
 |      fixup_info_t_fd_get(self) -> fixup_data_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_fixup_info_t>
 |      delete_fixup_info_t(self)

Help on function gen_fix_fixups in module ida_fixup:

gen_fix_fixups(*args)
    Relocate the bytes with fixup information once more (generic
    function). This function may be called from 'loader_t::move_segm()' if
    it suits the goal. If 'loader_t::move_segm' is not defined then this
    function will be called automatically when moving segments or rebasing
    the entire program. Special parameter values (from = BADADDR, size =
    0, to = delta) are used when the function is called from
    rebase_program(delta).
    
    gen_fix_fixups(_from, to, size)
        @param _from (C++: ea_t)
        @param to (C++: ea_t)
        @param size (C++: asize_t)

Help on function get_first_fixup_ea in module ida_fixup:

get_first_fixup_ea(*args)
    Get the first address with fixup information

Help on function get_fixup in module ida_fixup:

get_fixup(*args)
    Get fixup information.
    
    get_fixup(fd, source) -> bool
        @param fd (C++: fixup_data_t  *)
        @param source (C++: ea_t)

Help on function get_fixup_desc in module ida_fixup:

get_fixup_desc(*args)
    Get FIXUP description comment.
    
    get_fixup_desc(source, fd) -> str
        @param source (C++: ea_t)
        @param fd (C++: const  fixup_data_t  &)

Help on function get_fixup_handler in module ida_fixup:

get_fixup_handler(*args)
    Get handler of standard or custom fixup.
    
    get_fixup_handler(type) -> fixup_handler_t const *
        @param type (C++: fixup_type_t)

Help on function get_fixup_value in module ida_fixup:

get_fixup_value(*args)
    Get the operand value. This function get fixup bytes from data or an
    instruction at `ea' and convert them to the operand value (maybe
    partially). It is opposite in meaning to the 'patch_fixup_value()' .
    For example, FIXUP_HI8 read a byte at 'patch_fixup_value()'  `ea' and
    shifts it left by 8 bits, or AArch64's custom fixup BRANCH26 get low
    26 bits of the insn at `ea' and shifts it left by 2 bits. This
    function is mainly used to get a relocation addend.
    'fixup_handler_t::size'
    
    get_fixup_value(ea, type) -> uval_t
        @param ea: address to get fixup bytes from, the size of the fixup
                   bytes depends on the fixup type. (C++: ea_t)
        @param type (C++: fixup_type_t)
        @retval: operand - value

Help on function get_fixups in module ida_fixup:

get_fixups(*args)
    get_fixups(out, ea, size) -> bool
        @param out (C++: fixups_t  *)
        @param ea (C++: ea_t)
        @param size (C++: asize_t)

Help on function get_next_fixup_ea in module ida_fixup:

get_next_fixup_ea(*args)
    Find next address with fixup information
    
    get_next_fixup_ea(ea) -> ea_t
        @param ea: current address (C++: ea_t)
        @return: the next address with fixup information, or BADADDR

Help on function get_prev_fixup_ea in module ida_fixup:

get_prev_fixup_ea(*args)
    Find previous address with fixup information
    
    get_prev_fixup_ea(ea) -> ea_t
        @param ea: current address (C++: ea_t)
        @return: the previous address with fixup information, or BADADDR

Help on function is_fixup_custom in module ida_fixup:

is_fixup_custom(*args)
    Is fixup processed by processor module?
    
    is_fixup_custom(type) -> bool
        @param type (C++: fixup_type_t)

Help on function patch_fixup_value in module ida_fixup:

patch_fixup_value(*args)
    Patch the fixup bytes. This function updates data or an instruction at
    `ea' to the fixup bytes. For example, FIXUP_HI8 updates a byte at `ea'
    to the high byte of `fd->off' , or AArch64's custom fixup BRANCH26
    updates low 26 bits of the insn at `ea' to the value of `fd->off'
    shifted right by 2. 'fixup_handler_t::size'
    
    patch_fixup_value(ea, fd) -> bool
        @param ea: address where data are changed, the size of the changed
                   data depends on the fixup type. (C++: ea_t)
        @param fd (C++: const  fixup_data_t  &)
        @retval: false - the fixup bytes do not fit (e.g.  fd->off  is greater
                         than 0xFFFFFFC for BRANCH26). The database is changed
                         even in this case.

Help on function set_fixup in module ida_fixup:

set_fixup(*args)
    Set fixup information. You should fill 'fixup_data_t' and call this
    function and the kernel will remember information in the database.
    
    set_fixup(source, fd)
        @param source: the fixup source address, i.e. the address modified by
                       the fixup (C++: ea_t)
        @param fd: fixup data (C++: const  fixup_data_t  &)

=== ida_fixup EPYDOC INJECTIONS ===
ida_fixup.FIXUPF_CREATED
"""
fixup was not present in the input file
"""

ida_fixup.FIXUPF_EXTDEF
"""
target is a location (otherwise - segment). Use this bit if the target
is a symbol rather than an offset from the beginning of a segment.
"""

ida_fixup.FIXUPF_LOADER_MASK
"""
additional flags. The bits from this mask are not stored in the
database and can be used by the loader at its discretion.
"""

ida_fixup.FIXUPF_REL
"""
fixup is relative to the linear address `base' . Otherwise fixup is
relative to the start of the segment with `sel' selector.
"""

ida_fixup.FIXUPF_UNUSED
"""
fixup is ignored by IDAdisallows the kernel to convert operandsthis
fixup is not used during output
"""
=== ida_fixup EPYDOC INJECTIONS END ===
Help on class qfile_t in module ida_fpro:

class qfile_t(__builtin__.object)
 |  Proxy of C++ qfile_t class.
 |  
 |  
 |  A helper class to work with FILE related functions.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, rhs) -> qfile_t
 |      Closes the file
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  close(self, *args)
 |      close(self)
 |  
 |  filename(self, *args)
 |      filename(self) -> PyObject *
 |  
 |  flush(self, *args)
 |      flush(self) -> int
 |      Reads a single byte from the file. Returns None if EOF or the read byte
 |  
 |  get_char(self, *args)
 |      get_char(self) -> PyObject *
 |  
 |  get_fp(self, *args)
 |      get_fp(self) -> FILE *
 |  
 |  gets(self, *args)
 |      gets(self, size) -> PyObject *
 |      Reads a line from the input file. Returns the read line or None
 |  
 |  open(self, *args)
 |      open(self, filename, mode) -> bool
 |      Opens a file
 |      
 |      @param filename: the file name
 |      @param mode: The mode string, ala fopen() style
 |      @return: Boolean
 |  
 |  opened(self, *args)
 |      opened(self) -> bool
 |      Checks if the file is opened or not
 |  
 |  put_char(self, *args)
 |      put_char(self, chr) -> int
 |          chr: char
 |  
 |  puts(self, *args)
 |      puts(self, str) -> int
 |          str: char const *
 |  
 |  read(self, *args)
 |      read(self, size) -> PyObject *
 |      Reads from the file. Returns the buffer or None
 |  
 |  readbytes(self, *args)
 |      readbytes(self, size, big_endian) -> PyObject *
 |      Similar to read() but it respect the endianness
 |  
 |  seek(self, *args)
 |      seek(self, offset, whence=SEEK_SET) -> int
 |      Set input source position
 |      @return: the new position (not 0 as fseek!)
 |  
 |  size(self, *args)
 |      size(self) -> int64
 |  
 |  tell(self, *args)
 |      tell(self) -> int64
 |      Returns the current position
 |  
 |  write(self, *args)
 |      write(self, py_buf) -> int
 |      Writes to the file. Returns 0 or the number of bytes written
 |  
 |  writebytes(self, *args)
 |      writebytes(self, py_buf, big_endian) -> int
 |      Similar to write() but it respect the endianness
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  from_capsule(*args)
 |      from_capsule(pycapsule) -> qfile_t
 |          pycapsule: PyObject *
 |  
 |  from_fp(*args)
 |      from_fp(fp) -> qfile_t
 |          fp: FILE *
 |  
 |  tmpfile(*args)
 |      tmpfile() -> qfile_t
 |      A static method to construct an instance using a temporary file
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __idc_cvt_id__
 |      qfile_t___idc_cvt_id___get(self) -> int
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qfile_t>
 |      delete_qfile_t(self)

Help on function qfile_t_from_capsule in module ida_fpro:

qfile_t_from_capsule(*args)
    qfile_t_from_capsule(pycapsule) -> qfile_t
        pycapsule: PyObject *

Help on function qfile_t_from_fp in module ida_fpro:

qfile_t_from_fp(*args)
    qfile_t_from_fp(fp) -> qfile_t
        fp: FILE *

Help on function qfile_t_tmpfile in module ida_fpro:

qfile_t_tmpfile(*args)
    qfile_t_tmpfile() -> qfile_t

Help on function add_auto_stkpnt in module ida_frame:

add_auto_stkpnt(*args)
    Add automatic SP register change point.
    
    add_auto_stkpnt(pfn, ea, delta) -> bool
        @param pfn: pointer to function. may be NULL. (C++: func_t  *)
        @param ea: linear address where SP changes. usually this is the end of
                   the instruction which modifies the stack pointer
                   (\cmd{ea}+\cmd{size}) (C++: ea_t)
        @param delta: difference between old and new values of SP (C++:
                      sval_t)
        @return: success

Help on function add_frame in module ida_frame:

add_frame(*args)
    Add function frame.
    
    add_frame(pfn, frsize, frregs, argsize) -> bool
        @param pfn: pointer to function structure (C++: func_t  *)
        @param frsize: size of function local variables (C++: sval_t)
        @param frregs: size of saved registers (C++: ushort)
        @param argsize: size of function arguments range which will be purged
                        upon return. this parameter is used for __stdcall and
                        __pascal calling conventions. for other calling
                        conventions please pass 0. (C++: asize_t)
        @retval: 1 - ok
        @retval: 0 - failed (no function, frame already exists)

Help on function add_regvar in module ida_frame:

add_regvar(*args)
    Define a register variable.
    
    add_regvar(pfn, ea1, ea2, canon, user, cmt) -> int
        @param pfn: function in which the definition will be created (C++:
                    func_t  *)
        @param ea1: range of addresses within the function where the
                    definition will be used (C++: ea_t)
        @param ea2: range of addresses within the function where the
                    definition will be used (C++: ea_t)
        @param canon: name of a general register (C++: const char *)
        @param user: user-defined name for the register (C++: const char *)
        @param cmt: comment for the definition (C++: const char *)
        @return: Register variable error codes

Help on function add_user_stkpnt in module ida_frame:

add_user_stkpnt(*args)
    Add user-defined SP register change point.
    
    add_user_stkpnt(ea, delta) -> bool
        @param ea: linear address where SP changes (C++: ea_t)
        @param delta: difference between old and new values of SP (C++:
                      sval_t)
        @return: success

Help on function build_stkvar_name in module ida_frame:

build_stkvar_name(*args)
    Build automatic stack variable name.
    
    build_stkvar_name(pfn, v) -> str
        @param pfn: pointer to function (can't be NULL!) (C++: const  func_t
                    *)
        @param v: value of variable offset (C++: sval_t)
        @return: length of stack variable name or -1

Help on function build_stkvar_xrefs in module ida_frame:

build_stkvar_xrefs(*args)
    Fill 'out' with a list of all the xrefs made from function 'pfn', to
    the argument or variable 'mptr' in 'pfn's stack frame.
    
    build_stkvar_xrefs(out, pfn, mptr)
        @param out: the list of xrefs to fill. (C++: xreflist_t  *)
        @param pfn: the function to scan. (C++: func_t  *)
        @param mptr: the argument/variable in pfn's stack frame. (C++: const
                     member_t  *)

Help on function calc_stkvar_struc_offset in module ida_frame:

calc_stkvar_struc_offset(*args)
    Calculate offset of stack variable in the frame structure.
    
    calc_stkvar_struc_offset(pfn, insn, n) -> ea_t
        @param pfn: pointer to function (can't be NULL!) (C++: func_t  *)
        @param insn: the instruction  - an ida_ua.insn_t, or an address (C++:
                     const insn_t &)
        @param n: number of operand: (0.. UA_MAXOP -1) -1 if error, return
                  BADADDR (C++: int)
        @return: BADADDR  if some error (issue a warning if stack frame is
                 bad)

Help on function define_stkvar in module ida_frame:

define_stkvar(*args)
    Define/redefine a stack variable.
    
    define_stkvar(pfn, name, off, flags, ti, nbytes) -> bool
        @param pfn: pointer to function (C++: func_t  *)
        @param name: variable name, NULL means autogenerate a name (C++: const
                     char *)
        @param off: offset of the stack variable in the frame. negative values
                    denote local variables, positive - function arguments.
                    (C++: sval_t)
        @param flags: variable type flags ( byte_flag()  for a byte variable,
                      for example) (C++: flags_t)
        @param ti: additional type information (like offsets, structs, etc)
                   (C++: const  opinfo_t  *)
        @param nbytes: number of bytes occupied by the variable (C++: asize_t)
        @return: success

Help on function del_frame in module ida_frame:

del_frame(*args)
    Delete a function frame.
    
    del_frame(pfn) -> bool
        @param pfn: pointer to function structure (C++: func_t  *)
        @return: success

Help on function del_regvar in module ida_frame:

del_regvar(*args)
    Delete a register variable definition.
    
    del_regvar(pfn, ea1, ea2, canon) -> int
        @param pfn: function in question (C++: func_t  *)
        @param ea1: range of addresses within the function where the
                    definition holds (C++: ea_t)
        @param ea2: range of addresses within the function where the
                    definition holds (C++: ea_t)
        @param canon: name of a general register (C++: const char *)
        @return: Register variable error codes

Help on function del_stkpnt in module ida_frame:

del_stkpnt(*args)
    Delete SP register change point.
    
    del_stkpnt(pfn, ea) -> bool
        @param pfn: pointer to function. may be NULL. (C++: func_t  *)
        @param ea: linear address (C++: ea_t)
        @return: success

Help on function delete_unreferenced_stkvars in module ida_frame:

delete_unreferenced_stkvars(*args)
    delete_unreferenced_stkvars(pfn) -> int
        @param pfn (C++: func_t  *)

Help on function delete_wrong_stkvar_ops in module ida_frame:

delete_wrong_stkvar_ops(*args)
    delete_wrong_stkvar_ops(pfn) -> int
        @param pfn (C++: func_t  *)

Help on function find_regvar in module ida_frame:

find_regvar(*args)
    Find a register variable definition (powerful version). One of 'canon'
    and 'user' should be NULL. If both 'canon' and 'user' are NULL it
    returns the first regvar definition in the range.
    
    find_regvar(pfn, ea1, ea2, canon, user) -> regvar_t
        @param pfn: function in question (C++: func_t  *)
        @param ea1: range of addresses to search. ea1==BADADDR means the
                    entire function (C++: ea_t)
        @param ea2: range of addresses to search. ea1==BADADDR means the
                    entire function (C++: ea_t)
        @param canon: name of a general register (C++: const char *)
        @param user: user-defined name for the register (C++: const char *)
        @return: NULL-not found, otherwise ptr to  regvar_t
    
    
    find_regvar(pfn, ea, canon) -> regvar_t
        @param pfn: function in question (C++: func_t  *)
        ea: ea_t
        @param canon: name of a general register (C++: const char *)
        @return: NULL-not found, otherwise ptr to  regvar_t

Help on function frame_off_args in module ida_frame:

frame_off_args(*args)
    Get starting address of arguments section.
    
    frame_off_args(pfn) -> ea_t
        @param pfn (C++: const  func_t  *)

Help on function frame_off_lvars in module ida_frame:

frame_off_lvars(*args)
    Get start address of local variables section.
    
    frame_off_lvars(pfn) -> ea_t
        @param pfn (C++: const  func_t  *)

Help on function frame_off_retaddr in module ida_frame:

frame_off_retaddr(*args)
    Get starting address of return address section.
    
    frame_off_retaddr(pfn) -> ea_t
        @param pfn (C++: const  func_t  *)

Help on function frame_off_savregs in module ida_frame:

frame_off_savregs(*args)
    Get starting address of saved registers section.
    
    frame_off_savregs(pfn) -> ea_t
        @param pfn (C++: const  func_t  *)

Help on function get_effective_spd in module ida_frame:

get_effective_spd(*args)
    Get effective difference between the initial and current values of
    ESP. This function returns the sp-diff used by the instruction. The
    difference between 'get_spd()' and 'get_effective_spd()' is present
    only for instructions like "pop [esp+N]": they modify sp and use the
    modified value.
    
    get_effective_spd(pfn, ea) -> sval_t
        @param pfn: pointer to function. may be NULL. (C++: func_t  *)
        @param ea: linear address (C++: ea_t)
        @return: 0 or the difference, usually a negative number

Help on function get_frame in module ida_frame:

get_frame(*args)
    Get pointer to function frame.
    
    get_frame(pfn) -> struc_t
        @param pfn: pointer to function structure (C++: const  func_t  *)
    
    
    get_frame(ea) -> struc_t *
        ea: ea_t

Help on function get_frame_part in module ida_frame:

get_frame_part(*args)
    Get offsets of the frame part in the frame.
    
    get_frame_part(range, pfn, part)
        @param range: pointer to the output buffer with the frame part
                      start/end(exclusive) offsets, can't be NULL (C++:
                      range_t  *)
        @param pfn: pointer to function structure, can't be NULL (C++: const
                    func_t  *)
        @param part: frame part (C++: frame_part_t)

Help on function get_frame_retsize in module ida_frame:

get_frame_retsize(*args)
    Get size of function return address.
    
    get_frame_retsize(pfn) -> int
        @param pfn: pointer to function structure, can't be NULL (C++: const
                    func_t  *)

Help on function get_frame_size in module ida_frame:

get_frame_size(*args)
    Get full size of a function frame. This function takes into account
    size of local variables + size of saved registers + size of return
    address + number of purged bytes. The purged bytes correspond to the
    arguments of the functions with __stdcall and __fastcall calling
    conventions.
    
    get_frame_size(pfn) -> asize_t
        @param pfn: pointer to function structure, may be NULL (C++: const
                    func_t  *)
        @return: size of frame in bytes or zero

Help on function get_func_by_frame in module ida_frame:

get_func_by_frame(*args)
    Get function by its frame id.this function works only with databases
    created by IDA > 5.6
    
    get_func_by_frame(frame_id) -> ea_t
        @param frame_id: id of the function frame (C++: tid_t)
        @return: start address of the function or  BADADDR

Help on function get_min_spd_ea in module ida_frame:

get_min_spd_ea(*args)
    get_min_spd_ea(pfn) -> ea_t
        @param pfn (C++: func_t  *)

Help on function get_sp_delta in module ida_frame:

get_sp_delta(*args)
    Get modification of SP made at the specified location
    
    get_sp_delta(pfn, ea) -> sval_t
        @param pfn: pointer to function. may be NULL. (C++: func_t  *)
        @param ea: linear address (C++: ea_t)
        @return: 0 if the specified location doesn't contain a SP change
                 point. otherwise return delta of SP modification.

Help on function get_spd in module ida_frame:

get_spd(*args)
    Get difference between the initial and current values of ESP.
    
    get_spd(pfn, ea) -> sval_t
        @param pfn: pointer to function. may be NULL. (C++: func_t  *)
        @param ea: linear address of an instruction (C++: ea_t)
        @return: 0 or the difference, usually a negative number. returns the
                 sp-diff before executing the instruction.

Help on function get_stkvar in module ida_frame:

get_stkvar(*args)
    get_stkvar(insn, op, v) -> PyObject *
    Get pointer to stack variable
    @param op: reference to instruction operand
    @param v: immediate value in the operand (usually op.addr)
    @return:
        - None on failure
        - tuple(member_t, actval)
          where actval: actual value used to fetch stack variable

Help on function has_regvar in module ida_frame:

has_regvar(*args)
    Is there a register variable definition?
    
    has_regvar(pfn, ea) -> bool
        @param pfn: function in question (C++: func_t  *)
        @param ea: current address (C++: ea_t)

Help on function is_funcarg_off in module ida_frame:

is_funcarg_off(*args)
    is_funcarg_off(pfn, frameoff) -> bool
        pfn: func_t const *
        frameoff: uval_t

Help on function lvar_off in module ida_frame:

lvar_off(*args)
    lvar_off(pfn, frameoff) -> sval_t
        pfn: func_t const *
        frameoff: uval_t

Help on function recalc_spd in module ida_frame:

recalc_spd(*args)
    Recalculate SP delta for an instruction that stops execution. The next
    instruction is not reached from the current instruction. We need to
    recalculate SP for the next instruction.This function will create a
    new automatic SP register change point if necessary. It should be
    called from the emulator (emu.cpp) when auto_state == 'AU_USED' if the
    current instruction doesn't pass the execution flow to the next
    instruction.
    
    recalc_spd(cur_ea) -> bool
        @param cur_ea: linear address of the current instruction (C++: ea_t)
        @retval: 1 - new stkpnt is added
        @retval: 0 - nothing is changed

Help on class regvar_t in module ida_frame:

class regvar_t(ida_range.range_t)
 |  Proxy of C++ regvar_t class.
 |  
 |  Method resolution order:
 |      regvar_t
 |      ida_range.range_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regvar_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  canon
 |      regvar_t_canon_get(self) -> char *
 |  
 |  cmt
 |      regvar_t_cmt_get(self) -> char *
 |  
 |  thisown
 |      The membership flag
 |  
 |  user
 |      regvar_t_user_get(self) -> char *
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_regvar_t>
 |      delete_regvar_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: range_t const &
 |  
 |  _print(self, *args)
 |      _print(self) -> size_t
 |  
 |  clear(self, *args)
 |      Set 'start_ea' , 'end_ea' to 0.
 |  
 |  compare(self, *args)
 |      Compare two 'range_t' instances, based on the start_ea.
 |      
 |      compare(self, r) -> int
 |          @param r (C++: const  range_t  &)
 |  
 |  contains(self, *args)
 |      Is 'ea' in the address range?
 |      
 |      contains(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |      
 |      
 |      contains(self, r) -> bool
 |          r: range_t const &
 |  
 |  empty(self, *args)
 |      Is the size of the 'range_t' <= 0?
 |  
 |  extend(self, *args)
 |      Ensure that the 'range_t' includes 'ea'.
 |      
 |      extend(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  intersect(self, *args)
 |      Assign the 'range_t' to the intersection between the 'range_t' and
 |      'r'.
 |      
 |      intersect(self, r)
 |          @param r (C++: const  range_t  &)
 |  
 |  overlaps(self, *args)
 |      Is there an ea in 'r' that is also in this 'range_t' ?
 |      
 |      overlaps(self, r) -> bool
 |          @param r (C++: const  range_t  &)
 |  
 |  size(self, *args)
 |      Get 'end_ea' - 'start_ea' .
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t

Help on function rename_regvar in module ida_frame:

rename_regvar(*args)
    Rename a register variable.
    
    rename_regvar(pfn, v, user) -> int
        @param pfn: function in question (C++: func_t  *)
        @param v: variable to rename (C++: regvar_t  *)
        @param user: new user-defined name for the register (C++: const char
                     *)
        @return: Register variable error codes

Help on function set_frame_size in module ida_frame:

set_frame_size(*args)
    Set size of function frame. Note: The returned size may not include
    all stack arguments. It does so only for __stdcall and __fastcall
    calling conventions. To get the entire frame size for all cases use
    get_struc_size(get_frame(pfn)).
    
    set_frame_size(pfn, frsize, frregs, argsize) -> bool
        @param pfn: pointer to function structure (C++: func_t  *)
        @param frsize: size of function local variables (C++: asize_t)
        @param frregs: size of saved registers (C++: ushort)
        @param argsize: size of function arguments that will be purged from
                        the stack upon return (C++: asize_t)
        @return: success

Help on function set_purged in module ida_frame:

set_purged(*args)
    Set the number of purged bytes for a function or data item (funcptr).
    This function will update the database and plan to reanalyze items
    referencing the specified address. It works only for processors with
    'PR_PURGING' bit in 16 and 32 bit modes.
    
    set_purged(ea, nbytes, override_old_value) -> bool
        @param ea: address of the function of item (C++: ea_t)
        @param nbytes: number of purged bytes (C++: int)
        @param override_old_value: may overwrite old information about purged
                                   bytes (C++: bool)
        @return: success

Help on function set_regvar_cmt in module ida_frame:

set_regvar_cmt(*args)
    Set comment for a register variable.
    
    set_regvar_cmt(pfn, v, cmt) -> int
        @param pfn: function in question (C++: func_t  *)
        @param v: variable to rename (C++: regvar_t  *)
        @param cmt: new comment (C++: const char *)
        @return: Register variable error codes

Help on function soff_to_fpoff in module ida_frame:

soff_to_fpoff(*args)
    Convert struct offsets into fp-relative offsets. This function
    converts the offsets inside the 'struc_t' object into the frame
    pointer offsets (for example, EBP-relative).
    
    soff_to_fpoff(pfn, soff) -> sval_t
        @param pfn (C++: func_t  *)
        @param soff (C++: uval_t)

Help on class stkpnt_t in module ida_frame:

class stkpnt_t(__builtin__.object)
 |  Proxy of C++ stkpnt_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: stkpnt_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: stkpnt_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: stkpnt_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> stkpnt_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: stkpnt_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: stkpnt_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: stkpnt_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: stkpnt_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      stkpnt_t_ea_get(self) -> ea_t
 |  
 |  spd
 |      stkpnt_t_spd_get(self) -> sval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_stkpnt_t>
 |      delete_stkpnt_t(self)

Help on class stkpnts_t in module ida_frame:

class stkpnts_t(__builtin__.object)
 |  Proxy of C++ stkpnts_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: stkpnts_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: stkpnts_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: stkpnts_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> stkpnts_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: stkpnts_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: stkpnts_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: stkpnts_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: stkpnts_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_stkpnts_t>
 |      delete_stkpnts_t(self)

Help on function update_fpd in module ida_frame:

update_fpd(*args)
    Update frame pointer delta.
    
    update_fpd(pfn, fpd) -> bool
        @param pfn: pointer to function structure (C++: func_t  *)
        @param fpd: new fpd value. cannot be bigger than the local variable
                    range size. (C++: asize_t)
        @return: success

Help on class xreflist_entry_t in module ida_frame:

class xreflist_entry_t(__builtin__.object)
 |  Proxy of C++ xreflist_entry_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: xreflist_entry_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: xreflist_entry_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: xreflist_entry_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> xreflist_entry_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: xreflist_entry_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: xreflist_entry_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: xreflist_entry_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: xreflist_entry_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      xreflist_entry_t_ea_get(self) -> ea_t
 |  
 |  opnum
 |      xreflist_entry_t_opnum_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      xreflist_entry_t_type_get(self) -> uchar
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_xreflist_entry_t>
 |      delete_xreflist_entry_t(self)

Help on class xreflist_t in module ida_frame:

class xreflist_t(__builtin__.object)
 |  Proxy of C++ qvector< xreflist_entry_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< xreflist_entry_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> xreflist_entry_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> xreflist_t
 |          x: qvector< xreflist_entry_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< xreflist_entry_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: xreflist_entry_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: xreflist_entry_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: xreflist_entry_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> xreflist_entry_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> xreflist_entry_t
 |      begin(self) -> xreflist_entry_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> xreflist_entry_t
 |      end(self) -> xreflist_entry_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> xreflist_entry_t
 |          it: qvector< xreflist_entry_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> xreflist_entry_t
 |          first: qvector< xreflist_entry_t >::iterator
 |          last: qvector< xreflist_entry_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> xreflist_entry_t
 |  
 |  find(self, *args)
 |      find(self, x) -> xreflist_entry_t
 |          x: xreflist_entry_t const &
 |      
 |      
 |      find(self, x) -> xreflist_entry_t
 |          x: xreflist_entry_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=xreflist_entry_t())
 |          x: xreflist_entry_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: xreflist_entry_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: xreflist_entry_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> xreflist_entry_t
 |          it: qvector< xreflist_entry_t >::iterator
 |          x: xreflist_entry_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: xreflist_entry_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: xreflist_entry_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< xreflist_entry_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_xreflist_t>
 |      delete_xreflist_t(self)

=== ida_frame EPYDOC INJECTIONS ===
ida_frame.REGVAR_ERROR_ARG
"""
function arguments are bad
"""

ida_frame.REGVAR_ERROR_NAME
"""
the provided name(s) can't be accepted
"""

ida_frame.REGVAR_ERROR_OK
"""
all ok
"""

ida_frame.REGVAR_ERROR_RANGE
"""
the definition range is bad
"""

ida_frame.STKVAR_VALID_SIZE
"""
x.dtyp contains correct variable type (for insns like 'lea' this bit
must be off) in general, dr_O references do not allow to determine the
variable size
"""
=== ida_frame EPYDOC INJECTIONS END ===
Help on function add_func in module ida_funcs:

add_func(*args)
    Add a new function. If the function end address is 'BADADDR' , then
    IDA will try to determine the function bounds by calling
    find_func_bounds(..., 'FIND_FUNC_DEFINE' ).
    
    add_func(ea1, ea2=BADADDR) -> bool
        @param ea1: start address (C++: ea_t)
        @param ea2: end address (C++: ea_t)
        @return: success

Help on function add_func_ex in module ida_funcs:

add_func_ex(*args)
    Add a new function. If the fn->end_ea is 'BADADDR' , then IDA will try
    to determine the function bounds by calling find_func_bounds(...,
    'FIND_FUNC_DEFINE' ).
    
    add_func_ex(pfn) -> bool
        @param pfn: ptr to filled function structure (C++: func_t  *)
        @return: success

Help on function add_regarg in module ida_funcs:

add_regarg(*args)
    add_regarg(pfn, reg, tif, name)
        @param pfn (C++: func_t  *)
        @param reg (C++: int)
        @param tif (C++: const  tinfo_t  &)
        @param name (C++: const char *)

Help on function append_func_tail in module ida_funcs:

append_func_tail(*args)
    Append a new tail chunk to the function definition. If the tail
    already exists, then it will simply be added to the function tail list
    Otherwise a new tail will be created and its owner will be set to be
    our function If a new tail cannot be created, then this function will
    fail.
    
    append_func_tail(pfn, ea1, ea2) -> bool
        @param pfn (C++: func_t  *)
        @param ea1: start of the tail. If a tail already exists at the
                    specified address it must start at 'ea1' (C++: ea_t)
        @param ea2: end of the tail. If a tail already exists at the specified
                    address it must end at 'ea2'. If specified as BADADDR, IDA
                    will determine the end address itself. (C++: ea_t)

Help on function apply_idasgn_to in module ida_funcs:

apply_idasgn_to(*args)
    Apply a signature file to the specified address.
    
    apply_idasgn_to(signame, ea, is_startup) -> int
        @param signame: short name of signature file (the file name without
                        path) (C++: const char *)
        @param ea: address to apply the signature (C++: ea_t)
        @param is_startup: if set, then the signature is treated as a startup
                           one for startup signature ida doesn't rename the
                           first function of the applied module. (C++: bool)
        @return: Library function codes

Help on function apply_startup_sig in module ida_funcs:

apply_startup_sig(*args)
    Apply a startup signature file to the specified address.
    
    apply_startup_sig(ea, startup) -> bool
        @param ea: address to apply the signature to; usually \inf{start_ea}
                   (C++: ea_t)
        @param startup: the name of the signature file without path and
                        extension (C++: const char *)
        @return: true if successfully applied the signature

Help on function calc_func_size in module ida_funcs:

calc_func_size(*args)
    Calculate function size. This function takes into account all
    fragments of the function.
    
    calc_func_size(pfn) -> asize_t
        @param pfn: ptr to function structure (C++: func_t  *)

Help on function calc_idasgn_state in module ida_funcs:

calc_idasgn_state(*args)
    Get state of a signature in the list of planned signatures
    
    calc_idasgn_state(n) -> int
        @param n: number of signature in the list (0.. get_idasgn_qty() -1)
                  (C++: int)
        @return: state of signature or  IDASGN_BADARG

Help on function calc_thunk_func_target in module ida_funcs:

calc_thunk_func_target(*args)
    Calculate target of a thunk function.
    
    calc_thunk_func_target(pfn) -> ea_t
        @param pfn: pointer to function (may not be nullptr) (C++: func_t  *)
        @return: the target function or  BADADDR

Help on function del_func in module ida_funcs:

del_func(*args)
    Delete a function.
    
    del_func(ea) -> bool
        @param ea: any address in the function entry chunk (C++: ea_t)
        @return: success

Help on function del_idasgn in module ida_funcs:

del_idasgn(*args)
    Remove signature from the list of planned signatures.
    
    del_idasgn(n) -> int
        @param n: number of signature in the list (0.. get_idasgn_qty() -1)
                  (C++: int)
        @return: IDASGN_OK ,  IDASGN_BADARG ,  IDASGN_APPLIED

Help on class dyn_ea_array in module ida_funcs:

class dyn_ea_array(__builtin__.object)
 |  Proxy of C++ dynamic_wrapped_array_t< ea_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &↗
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_ea_array
 |          _data: unsigned-ea-like-numeric-type *↗
 |          _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: unsigned-ea-like-numeric-type const &↗
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      dyn_ea_array_count_get(self) -> size_t
 |  
 |  data
 |      dyn_ea_array_data_get(self) -> unsigned-ea-like-numeric-type *↗
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_dyn_ea_array>
 |      delete_dyn_ea_array(self)

Help on class dyn_range_array in module ida_funcs:

class dyn_range_array(__builtin__.object)
 |  Proxy of C++ dynamic_wrapped_array_t< range_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> range_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_range_array
 |          _data: range_t *
 |          _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: range_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      dyn_range_array_count_get(self) -> size_t
 |  
 |  data
 |      dyn_range_array_data_get(self) -> range_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_dyn_range_array>
 |      delete_dyn_range_array(self)

Help on class dyn_regarg_array in module ida_funcs:

class dyn_regarg_array(__builtin__.object)
 |  Proxy of C++ dynamic_wrapped_array_t< regarg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> regarg_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_regarg_array
 |          _data: regarg_t *
 |          _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: regarg_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      dyn_regarg_array_count_get(self) -> size_t
 |  
 |  data
 |      dyn_regarg_array_data_get(self) -> regarg_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_dyn_regarg_array>
 |      delete_dyn_regarg_array(self)

Help on class dyn_regvar_array in module ida_funcs:

class dyn_regvar_array(__builtin__.object)
 |  Proxy of C++ dynamic_wrapped_array_t< regvar_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> regvar_t const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_regvar_array
 |          _data: regvar_t *
 |          _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: regvar_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      dyn_regvar_array_count_get(self) -> size_t
 |  
 |  data
 |      dyn_regvar_array_data_get(self) -> regvar_t *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_dyn_regvar_array>
 |      delete_dyn_regvar_array(self)

Help on class dyn_stkpnt_array in module ida_funcs:

class dyn_stkpnt_array(__builtin__.object)
 |  Proxy of C++ dynamic_wrapped_array_t< stkpnt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> stkpnt_t const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_stkpnt_array
 |          _data: stkpnt_t *
 |          _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: stkpnt_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      dyn_stkpnt_array_count_get(self) -> size_t
 |  
 |  data
 |      dyn_stkpnt_array_data_get(self) -> stkpnt_t *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_dyn_stkpnt_array>
 |      delete_dyn_stkpnt_array(self)

Help on function f_any in module ida_funcs:

f_any(*args)
    Helper function to accept any address.
    
    f_any(arg1, arg2) -> bool
        arg1: flags_t
        arg2: void *

Help on function find_func_bounds in module ida_funcs:

find_func_bounds(*args)
    Determine the boundaries of a new function. This function tries to
    find the start and end addresses of a new function. It calls the
    module with \ph{func_bounds} in order to fine tune the function
    boundaries.
    
    find_func_bounds(nfn, flags) -> int
        @param nfn: structure to fill with information \ nfn->start_ea points
                    to the start address of the new function. (C++: func_t  *)
        @param flags: Find function bounds flags (C++: int)
        @return: Find function bounds result codes

Help on function func_contains in module ida_funcs:

func_contains(*args)
    Does the given function contain the given address?
    
    func_contains(pfn, ea) -> bool
        @param pfn (C++: func_t  *)
        @param ea (C++: ea_t)

Help on function func_does_return in module ida_funcs:

func_does_return(*args)
    Does the function return?. To calculate the answer, 'FUNC_NORET' flag
    and is_noret() are consulted The latter is required for imported
    functions in the .idata section. Since in .idata we have only function
    pointers but not functions, we have to introduce a special flag for
    them.
    
    func_does_return(callee) -> bool
        @param callee (C++: ea_t)

Help on function func_item_iterator_decode_preceding_insn in module ida_funcs:

func_item_iterator_decode_preceding_insn(*args)
    func_item_iterator_decode_preceding_insn(fii, visited, p_farref, out) -> bool
        fii: func_item_iterator_t *
        visited: eavec_t *
        p_farref: bool *
        out: insn_t *

Help on function func_item_iterator_decode_prev_insn in module ida_funcs:

func_item_iterator_decode_prev_insn(*args)
    func_item_iterator_decode_prev_insn(fii, out) -> bool
        fii: func_item_iterator_t *
        out: insn_t *

Help on function func_item_iterator_next in module ida_funcs:

func_item_iterator_next(*args)
    func_item_iterator_next(fii, testf, ud) -> bool
        fii: func_item_iterator_t *
        testf: testf_t *
        ud: void *

Help on function func_item_iterator_prev in module ida_funcs:

func_item_iterator_prev(*args)
    func_item_iterator_prev(fii, testf, ud) -> bool
        fii: func_item_iterator_t *
        testf: testf_t *
        ud: void *

Help on class func_item_iterator_t in module ida_funcs:

class func_item_iterator_t(__builtin__.object)
 |  Proxy of C++ func_item_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_item_iterator_t
 |          pfn: func_t *
 |          _ea: ea_t
 |  
 |  __next__(self, *args)
 |      __next__(self, func, ud) -> bool
 |          func: testf_t *
 |          ud: void *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  chunk(self, *args)
 |      chunk(self) -> range_t
 |  
 |  current(self, *args)
 |      current(self) -> ea_t
 |  
 |  decode_preceding_insn(self, *args)
 |      decode_preceding_insn(self, visited, p_farref, out) -> bool
 |          @param visited (C++: eavec_t  *)
 |          @param p_farref (C++: bool *)
 |          @param out (C++: insn_t  *)
 |  
 |  decode_prev_insn(self, *args)
 |      decode_prev_insn(self, out) -> bool
 |          @param out (C++: insn_t  *)
 |  
 |  first(self, *args)
 |      first(self) -> bool
 |  
 |  last(self, *args)
 |      last(self) -> bool
 |  
 |  next = __next__(self, *args)
 |  
 |  next_addr(self, *args)
 |      next_addr(self) -> bool
 |  
 |  next_code(self, *args)
 |      next_code(self) -> bool
 |  
 |  next_data(self, *args)
 |      next_data(self) -> bool
 |  
 |  next_head(self, *args)
 |      next_head(self) -> bool
 |  
 |  next_not_tail(self, *args)
 |      next_not_tail(self) -> bool
 |  
 |  prev(self, *args)
 |      prev(self, func, ud) -> bool
 |          @param func (C++: testf_t  *)
 |          @param ud (C++: void *)
 |  
 |  prev_addr(self, *args)
 |      prev_addr(self) -> bool
 |  
 |  prev_code(self, *args)
 |      prev_code(self) -> bool
 |  
 |  prev_data(self, *args)
 |      prev_data(self) -> bool
 |  
 |  prev_head(self, *args)
 |      prev_head(self) -> bool
 |  
 |  prev_not_tail(self, *args)
 |      prev_not_tail(self) -> bool
 |  
 |  set(self, *args)
 |      Set a function range. if pfn == nullptr then a segment range will be
 |      set.
 |      
 |      set(self, pfn, _ea=BADADDR) -> bool
 |          @param pfn (C++: func_t  *)
 |          @param _ea (C++: ea_t)
 |  
 |  set_range(self, *args)
 |      Set an arbitrary range.
 |      
 |      set_range(self, ea1, ea2) -> bool
 |          @param ea1 (C++: ea_t)
 |          @param ea2 (C++: ea_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_func_item_iterator_t>
 |      delete_func_item_iterator_t(self)

Help on function func_parent_iterator_set in module ida_funcs:

func_parent_iterator_set(*args)
    func_parent_iterator_set(fpi, pfn) -> bool
        fpi: func_parent_iterator_t *
        pfn: func_t *

Help on class func_parent_iterator_t in module ida_funcs:

class func_parent_iterator_t(__builtin__.object)
 |  Proxy of C++ func_parent_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_parent_iterator_t
 |          _fnt: func_t *
 |  
 |  __next__(self, *args)
 |      __next__(self) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  first(self, *args)
 |      first(self) -> bool
 |  
 |  last(self, *args)
 |      last(self) -> bool
 |  
 |  next = __next__(self, *args)
 |  
 |  parent(self, *args)
 |      parent(self) -> ea_t
 |  
 |  prev(self, *args)
 |      prev(self) -> bool
 |  
 |  reset_fnt(self, *args)
 |      reset_fnt(self, _fnt)
 |          @param _fnt (C++: func_t  *)
 |  
 |  set(self, *args)
 |      set(self, _fnt) -> bool
 |          @param _fnt (C++: func_t  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_func_parent_iterator_t>
 |      delete_func_parent_iterator_t(self)

Help on class func_t in module ida_funcs:

class func_t(ida_range.range_t)
 |  Proxy of C++ func_t class.
 |  
 |  Method resolution order:
 |      func_t
 |      ida_range.range_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __get_points__(self, *args)
 |      __get_points__(self) -> dyn_stkpnt_array
 |  
 |  __get_referers__(self, *args)
 |      __get_referers__(self) -> dyn_ea_array
 |  
 |  __get_regargs__(self, *args)
 |      __get_regargs__(self) -> dyn_regarg_array
 |  
 |  __get_regvars__(self, *args)
 |      __get_regvars__(self) -> dyn_regvar_array
 |  
 |  __get_tails__(self, *args)
 |      __get_tails__(self) -> dyn_range_array
 |  
 |  __init__(self, *args)
 |      __init__(self, start=0, end=0, f=0) -> func_t
 |          start: ea_t
 |          end: ea_t
 |          f: flags_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  analyzed_sp(self, *args)
 |      Has SP-analysis been performed?
 |  
 |  does_return(self, *args)
 |      Does function return?
 |  
 |  is_far(self, *args)
 |      Is a far function?
 |  
 |  need_prolog_analysis(self, *args)
 |      Needs prolog analysis?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  argsize
 |      func_t_argsize_get(self) -> asize_t
 |  
 |  color
 |      func_t_color_get(self) -> bgcolor_t
 |  
 |  flags
 |      func_t_flags_get(self) -> uint64
 |  
 |  fpd
 |      func_t_fpd_get(self) -> asize_t
 |  
 |  frame
 |      func_t_frame_get(self) -> uval_t
 |  
 |  frregs
 |      func_t_frregs_get(self) -> ushort
 |  
 |  frsize
 |      func_t_frsize_get(self) -> asize_t
 |  
 |  owner
 |      func_t_owner_get(self) -> ea_t
 |  
 |  pntqty
 |      func_t_pntqty_get(self) -> uint32
 |  
 |  points
 |      __get_points__(self) -> dyn_stkpnt_array
 |  
 |  referers
 |      __get_referers__(self) -> dyn_ea_array
 |  
 |  refqty
 |      func_t_refqty_get(self) -> int
 |  
 |  regargqty
 |      func_t_regargqty_get(self) -> int
 |  
 |  regargs
 |      __get_regargs__(self) -> dyn_regarg_array
 |  
 |  regvarqty
 |      func_t_regvarqty_get(self) -> int
 |  
 |  regvars
 |      __get_regvars__(self) -> dyn_regvar_array
 |  
 |  tailqty
 |      func_t_tailqty_get(self) -> int
 |  
 |  tails
 |      __get_tails__(self) -> dyn_range_array
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_func_t>
 |      delete_func_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: range_t const &
 |  
 |  _print(self, *args)
 |      _print(self) -> size_t
 |  
 |  clear(self, *args)
 |      Set 'start_ea' , 'end_ea' to 0.
 |  
 |  compare(self, *args)
 |      Compare two 'range_t' instances, based on the start_ea.
 |      
 |      compare(self, r) -> int
 |          @param r (C++: const  range_t  &)
 |  
 |  contains(self, *args)
 |      Is 'ea' in the address range?
 |      
 |      contains(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |      
 |      
 |      contains(self, r) -> bool
 |          r: range_t const &
 |  
 |  empty(self, *args)
 |      Is the size of the 'range_t' <= 0?
 |  
 |  extend(self, *args)
 |      Ensure that the 'range_t' includes 'ea'.
 |      
 |      extend(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  intersect(self, *args)
 |      Assign the 'range_t' to the intersection between the 'range_t' and
 |      'r'.
 |      
 |      intersect(self, r)
 |          @param r (C++: const  range_t  &)
 |  
 |  overlaps(self, *args)
 |      Is there an ea in 'r' that is also in this 'range_t' ?
 |      
 |      overlaps(self, r) -> bool
 |          @param r (C++: const  range_t  &)
 |  
 |  size(self, *args)
 |      Get 'end_ea' - 'start_ea' .
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t

Help on function func_t__from_ptrval__ in module ida_funcs:

func_t__from_ptrval__(*args)
    func_t__from_ptrval__(ptrval) -> func_t
        ptrval: size_t

Help on function func_tail_iterator_set in module ida_funcs:

func_tail_iterator_set(*args)
    func_tail_iterator_set(fti, pfn, ea) -> bool
        fti: func_tail_iterator_t *
        pfn: func_t *
        ea: ea_t

Help on function func_tail_iterator_set_ea in module ida_funcs:

func_tail_iterator_set_ea(*args)
    func_tail_iterator_set_ea(fti, ea) -> bool
        fti: func_tail_iterator_t *
        ea: ea_t

Help on class func_tail_iterator_t in module ida_funcs:

class func_tail_iterator_t(__builtin__.object)
 |  Proxy of C++ func_tail_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_tail_iterator_t
 |          _pfn: func_t *
 |          ea: ea_t
 |  
 |  __next__(self, *args)
 |      __next__(self) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  chunk(self, *args)
 |      chunk(self) -> range_t
 |  
 |  first(self, *args)
 |      first(self) -> bool
 |  
 |  last(self, *args)
 |      last(self) -> bool
 |  
 |  main(self, *args)
 |      main(self) -> bool
 |  
 |  next = __next__(self, *args)
 |  
 |  prev(self, *args)
 |      prev(self) -> bool
 |  
 |  set(self, *args)
 |      set(self, _pfn, ea=BADADDR) -> bool
 |          @param _pfn (C++: func_t  *)
 |          @param ea (C++: ea_t)
 |  
 |  set_ea(self, *args)
 |      set_ea(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |  
 |  set_range(self, *args)
 |      set_range(self, ea1, ea2) -> bool
 |          @param ea1 (C++: ea_t)
 |          @param ea2 (C++: ea_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_func_tail_iterator_t>
 |      delete_func_tail_iterator_t(self)

Help on function get_current_idasgn in module ida_funcs:

get_current_idasgn(*args)
    Get number of the the current signature.

Help on function get_fchunk in module ida_funcs:

get_fchunk(*args)
    Get pointer to function chunk structure by address.
    
    get_fchunk(ea) -> func_t
        @param ea: any address in a function chunk (C++: ea_t)
        @return: ptr to a function chunk or nullptr. This function may return
                 a function entry as well as a function tail.

Help on function get_fchunk_num in module ida_funcs:

get_fchunk_num(*args)
    Get ordinal number of a function chunk in the global list of function
    chunks.
    
    get_fchunk_num(ea) -> int
        @param ea: any address in the function chunk (C++: ea_t)
        @return: number of function chunk (0.. get_fchunk_qty() -1). -1 means
                 'no function chunk at the specified address'.

Help on function get_fchunk_qty in module ida_funcs:

get_fchunk_qty(*args)
    Get total number of function chunks in the program.

Help on function get_fchunk_referer in module ida_funcs:

get_fchunk_referer(*args)
    get_fchunk_referer(ea, idx) -> ea_t
        ea: ea_t
        idx: size_t

Help on function get_func in module ida_funcs:

get_func(*args)
    Get pointer to function structure by address.
    
    get_func(ea) -> func_t
        @param ea: any address in a function (C++: ea_t)
        @return: ptr to a function or nullptr. This function returns a
                 function entry chunk.

Help on function get_func_bitness in module ida_funcs:

get_func_bitness(*args)
    Get function bitness (which is equal to the function segment bitness).
    pfn==nullptr => returns 0
    
    get_func_bitness(pfn) -> int
        @param pfn (C++: const  func_t  *)
        @retval: 0 - 16
        @retval: 1 - 32
        @retval: 2 - 64

Help on function get_func_bits in module ida_funcs:

get_func_bits(*args)
    Get number of bits in the function addressing.
    
    get_func_bits(pfn) -> int
        @param pfn (C++: const  func_t  *)

Help on function get_func_bytes in module ida_funcs:

get_func_bytes(*args)
    Get number of bytes in the function addressing.
    
    get_func_bytes(pfn) -> int
        @param pfn (C++: const  func_t  *)

Help on function get_func_chunknum in module ida_funcs:

get_func_chunknum(*args)
    Get the containing tail chunk of 'ea'.
    
    get_func_chunknum(pfn, ea) -> int
        @param pfn (C++: func_t  *)
        @param ea (C++: ea_t)
        @retval: -1 - means 'does not contain ea'
        @retval: 0 - means the 'pfn' itself contains ea
        @retval: >0 - the number of the containing function tail chunk

Help on function get_func_cmt in module ida_funcs:

get_func_cmt(*args)
    Get function comment.
    
    get_func_cmt(pfn, repeatable) -> str
        @param pfn: ptr to function structure (C++: const  func_t  *)
        @param repeatable: get repeatable comment? (C++: bool)
        @return: size of comment or -1 In fact this function works with
                 function chunks too.

Help on function get_func_name in module ida_funcs:

get_func_name(*args)
    Get function name.
    
    get_func_name(ea) -> str
        @param ea: any address in the function (C++: ea_t)
        @return: length of the function name

Help on function get_func_num in module ida_funcs:

get_func_num(*args)
    Get ordinal number of a function.
    
    get_func_num(ea) -> int
        @param ea: any address in the function (C++: ea_t)
        @return: number of function (0.. get_func_qty() -1). -1 means 'no
                 function at the specified address'.

Help on function get_func_qty in module ida_funcs:

get_func_qty(*args)
    Get total number of functions in the program.

Help on function get_func_ranges in module ida_funcs:

get_func_ranges(*args)
    Get function ranges.
    
    get_func_ranges(ranges, pfn) -> ea_t
        @param ranges: buffer to receive the range info (C++: rangeset_t  *)
        @param pfn: ptr to function structure (C++: func_t  *)
        @return: end address of the last function range (BADADDR-error)

Help on function get_idasgn_desc in module ida_funcs:

get_idasgn_desc(*args)
    get_idasgn_desc(n) -> PyObject *
    Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries)
    
    See also: get_idasgn_desc_with_matches
    
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @return: None on failure or tuple(signame, optlibs)

Help on function get_idasgn_desc_with_matches in module ida_funcs:

get_idasgn_desc_with_matches(*args)
    get_idasgn_desc_with_matches(n) -> PyObject *
    Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries, number of matches)
    
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @return: None on failure or tuple(signame, optlibs, nmatches)

Help on function get_idasgn_qty in module ida_funcs:

get_idasgn_qty(*args)
    Get number of signatures in the list of planned and applied
    signatures.

Help on function get_idasgn_title in module ida_funcs:

get_idasgn_title(*args)
    Get full description of the signature by its short name.
    
    get_idasgn_title(name) -> str
        @param name: short name of a signature (C++: const char *)
        @return: size of signature description or -1

Help on function get_next_fchunk in module ida_funcs:

get_next_fchunk(*args)
    Get pointer to the next function chunk in the global list.
    
    get_next_fchunk(ea) -> func_t
        @param ea: any address in the program (C++: ea_t)
        @return: ptr to function chunk or nullptr if next function chunk
                 doesn't exist

Help on function get_next_func in module ida_funcs:

get_next_func(*args)
    Get pointer to the next function.
    
    get_next_func(ea) -> func_t
        @param ea: any address in the program (C++: ea_t)
        @return: ptr to function or nullptr if next function doesn't exist

Help on function get_next_func_addr in module ida_funcs:

get_next_func_addr(*args)
    get_next_func_addr(pfn, ea) -> ea_t
        @param pfn (C++: func_t  *)
        @param ea (C++: ea_t)

Help on function get_prev_fchunk in module ida_funcs:

get_prev_fchunk(*args)
    Get pointer to the previous function chunk in the global list.
    
    get_prev_fchunk(ea) -> func_t
        @param ea: any address in the program (C++: ea_t)
        @return: ptr to function chunk or nullptr if previous function chunk
                 doesn't exist

Help on function get_prev_func in module ida_funcs:

get_prev_func(*args)
    Get pointer to the previous function.
    
    get_prev_func(ea) -> func_t
        @param ea: any address in the program (C++: ea_t)
        @return: ptr to function or nullptr if previous function doesn't exist

Help on function get_prev_func_addr in module ida_funcs:

get_prev_func_addr(*args)
    get_prev_func_addr(pfn, ea) -> ea_t
        @param pfn (C++: func_t  *)
        @param ea (C++: ea_t)

Help on function getn_fchunk in module ida_funcs:

getn_fchunk(*args)
    Get pointer to function chunk structure by number.
    
    getn_fchunk(n) -> func_t
        @param n: number of function chunk, is in range 0.. get_fchunk_qty()
                  -1 (C++: int)
        @return: ptr to a function chunk or nullptr. This function may return
                 a function entry as well as a function tail.

Help on function getn_func in module ida_funcs:

getn_func(*args)
    Get pointer to function structure by number.
    
    getn_func(n) -> func_t
        @param n: number of function, is in range 0.. get_func_qty() -1 (C++:
                  size_t)
        @return: ptr to a function or nullptr. This function returns a
                 function entry chunk.

Help on function is_finally_visible_func in module ida_funcs:

is_finally_visible_func(*args)
    Is the function visible (event after considering 'SCF_SHHID_FUNC' )?
    
    is_finally_visible_func(pfn) -> bool
        @param pfn (C++: func_t  *)

Help on function is_func_entry in module ida_funcs:

is_func_entry(*args)
    Does function describe a function entry chunk?
    
    is_func_entry(pfn) -> bool
        @param pfn (C++: const  func_t  *)

Help on function is_func_locked in module ida_funcs:

is_func_locked(*args)
    Is the function pointer locked?
    
    is_func_locked(pfn) -> bool
        @param pfn (C++: const  func_t  *)

Help on function is_func_tail in module ida_funcs:

is_func_tail(*args)
    Does function describe a function tail chunk?
    
    is_func_tail(pfn) -> bool
        @param pfn (C++: const  func_t  *)

Help on function is_same_func in module ida_funcs:

is_same_func(*args)
    Do two addresses belong to the same function?
    
    is_same_func(ea1, ea2) -> bool
        @param ea1 (C++: ea_t)
        @param ea2 (C++: ea_t)

Help on function is_visible_func in module ida_funcs:

is_visible_func(*args)
    Is the function visible (not hidden)?
    
    is_visible_func(pfn) -> bool
        @param pfn (C++: func_t  *)

Help on class lock_func in module ida_funcs:

class lock_func(__builtin__.object)
 |  Proxy of C++ lock_func class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _pfn) -> lock_func
 |          _pfn: func_t const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lock_func>
 |      delete_lock_func(self)

Help on function lock_func_range in module ida_funcs:

lock_func_range(*args)
    Lock function pointer Locked pointers are guaranteed to remain valid
    until they are unlocked. Ranges with locked pointers cannot be deleted
    or moved.
    
    lock_func_range(pfn, lock)
        @param pfn (C++: const  func_t  *)
        @param lock (C++: bool)

Help on function plan_to_apply_idasgn in module ida_funcs:

plan_to_apply_idasgn(*args)
    Add a signature file to the list of planned signature files.
    
    plan_to_apply_idasgn(fname) -> int
        @param fname: file name. should not contain directory part. (C++:
                      const char *)
        @return: 0 if failed, otherwise number of planned (and applied)
                 signatures

Help on function read_regargs in module ida_funcs:

read_regargs(*args)
    read_regargs(pfn)
        @param pfn (C++: func_t  *)

Help on function reanalyze_function in module ida_funcs:

reanalyze_function(*args)
    Reanalyze a function. This function plans to analyzes all chunks of
    the given function. Optional parameters (ea1, ea2) may be used to
    narrow the analyzed range.
    
    reanalyze_function(pfn, ea1=0, ea2=BADADDR, analyze_parents=False)
        @param pfn: pointer to a function (C++: func_t  *)
        @param ea1: start of the range to analyze (C++: ea_t)
        @param ea2: end of range to analyze (C++: ea_t)
        @param analyze_parents: meaningful only if pfn points to a function
                                tail. if true, all tail parents will be
                                reanalyzed. if false, only the given tail will
                                be reanalyzed. (C++: bool)

Help on function reanalyze_noret_flag in module ida_funcs:

reanalyze_noret_flag(*args)
    Plan to reanalyze noret flag. This function does not remove FUNC_NORET
    if it is already present. It just plans to reanalysis.
    
    reanalyze_noret_flag(ea) -> bool
        @param ea (C++: ea_t)

Help on class regarg_t in module ida_funcs:

class regarg_t(__builtin__.object)
 |  Proxy of C++ regarg_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regarg_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      regarg_t_name_get(self) -> char *
 |  
 |  reg
 |      regarg_t_reg_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      regarg_t_type_get(self) -> type_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_regarg_t>
 |      delete_regarg_t(self)

Help on function remove_func_tail in module ida_funcs:

remove_func_tail(*args)
    Remove a function tail. If the tail belongs only to one function, it
    will be completely removed. Otherwise if the function was the tail
    owner, the first function using this tail becomes the owner of the
    tail.
    
    remove_func_tail(pfn, tail_ea) -> bool
        @param pfn (C++: func_t  *)
        @param tail_ea (C++: ea_t)

Help on function set_func_cmt in module ida_funcs:

set_func_cmt(*args)
    Set function comment. This function works with function chunks too.
    
    set_func_cmt(pfn, cmt, repeatable) -> bool
        @param pfn: ptr to function structure (C++: const  func_t  *)
        @param cmt: comment string, may be multiline (with '  '). Use empty
                    str ("") to delete comment (C++: const char *)
        @param repeatable: set repeatable comment? (C++: bool)

Help on function set_func_end in module ida_funcs:

set_func_end(*args)
    Move function chunk end address.
    
    set_func_end(ea, newend) -> bool
        @param ea: any address in the function (C++: ea_t)
        @param newend: new end address of the function (C++: ea_t)
        @return: success

Help on function set_func_name_if_jumpfunc in module ida_funcs:

set_func_name_if_jumpfunc(*args)
    Give a meaningful name to function if it consists of only 'jump'
    instruction.
    
    set_func_name_if_jumpfunc(pfn, oldname) -> int
        @param pfn: pointer to function (may be nullptr) (C++: func_t  *)
        @param oldname: old name of function. if old name was in "j_..." form,
                        then we may discard it and set a new name. if oldname
                        is not known, you may pass nullptr. (C++: const char
                        *)
        @return: success

Help on function set_func_start in module ida_funcs:

set_func_start(*args)
    Move function chunk start address.
    
    set_func_start(ea, newstart) -> int
        @param ea: any address in the function (C++: ea_t)
        @param newstart: new end address of the function (C++: ea_t)
        @return: Function move result codes

Help on function set_noret_insn in module ida_funcs:

set_noret_insn(*args)
    Signal a non-returning instruction. This function can be used by the
    processor module to tell the kernel about non-returning instructions
    (like call exit). The kernel will perform the global function analysis
    and find out if the function returns at all. This analysis will be
    done at the first call to 'func_does_return()'
    
    set_noret_insn(insn_ea, noret) -> bool
        @param insn_ea (C++: ea_t)
        @param noret (C++: bool)
        @return: true if the instruction 'noret' flag has been changed

Help on function set_tail_owner in module ida_funcs:

set_tail_owner(*args)
    Set a function as the possessing function of a function tail. The
    function should already refer to the tail (after append_func_tail).
    
    set_tail_owner(fnt, func_start) -> bool
        @param fnt (C++: func_t  *)
        @param func_start (C++: ea_t)

Help on function set_visible_func in module ida_funcs:

set_visible_func(*args)
    Set visibility of function.
    
    set_visible_func(pfn, visible)
        @param pfn (C++: func_t  *)
        @param visible (C++: bool)

Help on function try_to_add_libfunc in module ida_funcs:

try_to_add_libfunc(*args)
    Apply the currently loaded signature file to the specified address. If
    a library function is found, then create a function and name it
    accordingly.
    
    try_to_add_libfunc(ea) -> int
        @param ea: any address in the program (C++: ea_t)
        @return: Library function codes

Help on function update_func in module ida_funcs:

update_func(*args)
    Update information about a function in the database ( 'func_t' ). You
    must not change the function start and end addresses using this
    function. Use 'set_func_start()' and 'set_func_end()' for it.
    
    update_func(pfn) -> bool
        @param pfn: ptr to function structure (C++: func_t  *)
        @return: success

=== ida_funcs EPYDOC INJECTIONS ===
ida_funcs.FIND_FUNC_DEFINE
"""
create instruction if undefined byte is encountered
"""

ida_funcs.FIND_FUNC_EXIST
"""
its bounds are returned in 'nfn'.

function exists already.
"""

ida_funcs.FIND_FUNC_IGNOREFN
"""
ignore existing function boundaries. by default the function returns
function boundaries if ea belongs to a function.
"""

ida_funcs.FIND_FUNC_KEEPBD
"""
just create instructions inside the boundaries.

do not modify incoming function boundaries,
"""

ida_funcs.FIND_FUNC_NORMAL
"""
stop processing if undefined byte is encountered
"""

ida_funcs.FIND_FUNC_OK
"""
ok, 'nfn' is ready for 'add_func()'
"""

ida_funcs.FIND_FUNC_UNDEF
"""
nfn->end_ea will have the address of the unexplored byte.

function has instructions that pass execution flow to unexplored
bytes.
"""

ida_funcs.FUNC_BOTTOMBP
"""
BP points to the bottom of the stack frame.
"""

ida_funcs.FUNC_FAR
"""
Far function.
"""

ida_funcs.FUNC_FRAME
"""
Function uses frame pointer (BP)
"""

ida_funcs.FUNC_FUZZY_SP
"""
for example: and esp, 0FFFFFFF0h

Function changes SP in untraceable way,
"""

ida_funcs.FUNC_HIDDEN
"""
A hidden function chunk.
"""

ida_funcs.FUNC_LIB
"""
Library function.
"""

ida_funcs.FUNC_LUMINA
"""
Function info is provided by Lumina.
"""

ida_funcs.FUNC_NORET
"""
Function doesn't return.
"""

ida_funcs.FUNC_NORET_PENDING
"""
This flag is verified upon 'func_does_return()'

Function 'non-return' analysis must be performed.
"""

ida_funcs.FUNC_PROLOG_OK
"""
by last SP-analysis

Prolog analysis has be performed
"""

ida_funcs.FUNC_PURGED_OK
"""
'argsize' field has been validated. If this bit is clear and 'argsize'
is 0, then we do not known the real number of bytes removed from the
stack. This bit is handled by the processor module.
"""

ida_funcs.FUNC_SP_READY
"""
SP-analysis has been performed. If this flag is on, the stack change
points should not be not modified anymore. Currently this analysis is
performed only for PC
"""

ida_funcs.FUNC_STATICDEF
"""
Static function.
"""

ida_funcs.FUNC_TAIL
"""
This is a function tail. Other bits must be clear (except
'FUNC_HIDDEN' ).
"""

ida_funcs.FUNC_THUNK
"""
Thunk (jump) function.
"""

ida_funcs.FUNC_USERFAR
"""
of the function

User has specified far-ness
"""

ida_funcs.IDASGN_APPLIED
"""
signature is already applied
"""

ida_funcs.IDASGN_BADARG
"""
bad number of signature
"""

ida_funcs.IDASGN_CURRENT
"""
signature is currently being applied
"""

ida_funcs.IDASGN_OK
"""
ok
"""

ida_funcs.IDASGN_PLANNED
"""
signature is planned to be applied
"""

ida_funcs.LIBFUNC_DELAY
"""
no decision because of lack of information
"""

ida_funcs.LIBFUNC_FOUND
"""
ok, library function is found
"""

ida_funcs.LIBFUNC_NONE
"""
no, this is not a library function
"""

ida_funcs.MOVE_FUNC_BADSTART
"""
bad new start address
"""

ida_funcs.MOVE_FUNC_NOCODE
"""
no instruction at 'newstart'
"""

ida_funcs.MOVE_FUNC_NOFUNC
"""
no function at 'ea'
"""

ida_funcs.MOVE_FUNC_OK
"""
ok
"""

ida_funcs.MOVE_FUNC_REFUSED
"""
a plugin refused the action
"""
=== ida_funcs EPYDOC INJECTIONS END ===
Help on class BasicBlock in module ida_gdl:

class BasicBlock(__builtin__.object)
 |  Basic block class. It is returned by the Flowchart class
 |  
 |  Methods defined here:
 |  
 |  __init__(self, id, bb, fc)
 |  
 |  preds(self)
 |      Iterates the predecessors list
 |  
 |  succs(self)
 |      Iterates the successors list
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  startEA

Help on class FlowChart in module ida_gdl:

class FlowChart(__builtin__.object)
 |  Flowchart class used to determine basic blocks.
 |  Check ex_gdl_qflow_chart.py for sample usage.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, index)
 |      Returns a basic block
 |      
 |      @return: BasicBlock
 |  
 |  __init__(self, f=None, bounds=None, flags=0)
 |      Constructor
 |      @param f: A func_t type, use get_func(ea) to get a reference
 |      @param bounds: A tuple of the form (start, end). Used if "f" is None
 |      @param flags: one of the FC_xxxx flags.
 |  
 |  __iter__(self)
 |  
 |  _getitem(self, index)
 |  
 |  refresh(self)
 |      Refreshes the flow chart
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  size

Help on function display_gdl in module ida_gdl:

display_gdl(*args)
    Display GDL file by calling wingraph32. The exact name of the grapher
    is taken from the configuration file and set up by
    'setup_graph_subsystem()' .
    
    display_gdl(fname) -> int
        @param fname (C++: const char *)
        @return: error code from os, 0 if ok

Help on function gen_complex_call_chart in module ida_gdl:

gen_complex_call_chart(*args)
    Build and display a complex xref graph.
    
    gen_complex_call_chart(filename, wait, title, ea1, ea2, flags, recursion_depth=-1) -> bool
        @param filename: output file name. the file extension is not used.
                         maybe NULL. (C++: const char *)
        @param wait: message to display during graph building (C++: const char
                     *)
        @param title: graph title (C++: const char *)
        @param ea1: address range (C++: ea_t)
        @param ea2: address range (C++: ea_t)
        @param flags: combination of  Call chart building flags  and  Flow
                      graph building flags . if none of  CHART_GEN_DOT ,
                      CHART_GEN_GDL ,  CHART_WINGRAPH  is specified, the
                      function will return false. (C++: int)
        @param recursion_depth: optional limit of recursion (C++: int32)
        @return: success. if fails, a warning message is displayed on the
                 screen

Help on function gen_flow_graph in module ida_gdl:

gen_flow_graph(*args)
    Build and display a flow graph.
    
    gen_flow_graph(filename, title, pfn, ea1, ea2, gflags) -> bool
        @param filename: output file name. the file extension is not used.
                         maybe NULL. (C++: const char *)
        @param title: graph title (C++: const char *)
        @param pfn: function to graph (C++: func_t  *)
        @param ea1: if pfn == NULL, then the address range (C++: ea_t)
        @param ea2: if pfn == NULL, then the address range (C++: ea_t)
        @param gflags: combination of  Flow graph building flags . if none of
                       CHART_GEN_DOT ,  CHART_GEN_GDL ,  CHART_WINGRAPH  is
                       specified, the function will return false (C++: int)
        @return: success. if fails, a warning message is displayed on the
                 screen

Help on function gen_gdl in module ida_gdl:

gen_gdl(*args)
    Create GDL file for graph.
    
    gen_gdl(g, fname)
        @param g (C++: const  gdl_graph_t  *)
        @param fname (C++: const char *)

Help on function gen_simple_call_chart in module ida_gdl:

gen_simple_call_chart(*args)
    Build and display a simple function call graph.
    
    gen_simple_call_chart(filename, wait, title, gflags) -> bool
        @param filename: output file name. the file extension is not used.
                         maybe NULL. (C++: const char *)
        @param wait: message to display during graph building (C++: const char
                     *)
        @param title: graph title (C++: const char *)
        @param gflags: combination of  CHART_NOLIBFUNCS  and  Flow graph
                       building flags . if none of  CHART_GEN_DOT ,
                       CHART_GEN_GDL ,  CHART_WINGRAPH  is specified, the
                       function will return false. (C++: int)
        @return: success. if fails, a warning message is displayed on the
                 screen

Help on function is_noret_block in module ida_gdl:

is_noret_block(*args)
    Does this block never return?
    
    is_noret_block(btype) -> bool
        @param btype (C++: fc_block_type_t)

Help on function is_ret_block in module ida_gdl:

is_ret_block(*args)
    Does this block return?
    
    is_ret_block(btype) -> bool
        @param btype (C++: fc_block_type_t)

Help on class node_iterator in module ida_gdl:

class node_iterator(__builtin__.object)
 |  Proxy of C++ node_iterator class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, n) -> bool
 |          n: node_iterator const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _g, n) -> node_iterator
 |          _g: gdl_graph_t const *
 |          n: int
 |  
 |  __ne__(self, *args)
 |      __ne__(self, n) -> bool
 |          n: node_iterator const &
 |  
 |  __ref__(self, *args)
 |      __ref__(self) -> int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_node_iterator>
 |      delete_node_iterator(self)

Help on class qbasic_block_t in module ida_gdl:

class qbasic_block_t(ida_range.range_t)
 |  Proxy of C++ qbasic_block_t class.
 |  
 |  Method resolution order:
 |      qbasic_block_t
 |      ida_range.range_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qbasic_block_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qbasic_block_t>
 |      delete_qbasic_block_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: range_t const &
 |  
 |  _print(self, *args)
 |      _print(self) -> size_t
 |  
 |  clear(self, *args)
 |      Set 'start_ea' , 'end_ea' to 0.
 |  
 |  compare(self, *args)
 |      Compare two 'range_t' instances, based on the start_ea.
 |      
 |      compare(self, r) -> int
 |          @param r (C++: const  range_t  &)
 |  
 |  contains(self, *args)
 |      Is 'ea' in the address range?
 |      
 |      contains(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |      
 |      
 |      contains(self, r) -> bool
 |          r: range_t const &
 |  
 |  empty(self, *args)
 |      Is the size of the 'range_t' <= 0?
 |  
 |  extend(self, *args)
 |      Ensure that the 'range_t' includes 'ea'.
 |      
 |      extend(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  intersect(self, *args)
 |      Assign the 'range_t' to the intersection between the 'range_t' and
 |      'r'.
 |      
 |      intersect(self, r)
 |          @param r (C++: const  range_t  &)
 |  
 |  overlaps(self, *args)
 |      Is there an ea in 'r' that is also in this 'range_t' ?
 |      
 |      overlaps(self, r) -> bool
 |          @param r (C++: const  range_t  &)
 |  
 |  size(self, *args)
 |      Get 'end_ea' - 'start_ea' .
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t

Help on class qflow_chart_t in module ida_gdl:

class qflow_chart_t(__builtin__.object)
 |  Proxy of C++ qflow_chart_t class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, n) -> qbasic_block_t
 |          n: int
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qflow_chart_t
 |          _title: char const *
 |          _pfn: func_t *
 |          _ea1: ea_t
 |          _ea2: ea_t
 |          _flags: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  append_to_flowchart(self, *args)
 |      append_to_flowchart(self, ea1, ea2)
 |          @param ea1 (C++: ea_t)
 |          @param ea2 (C++: ea_t)
 |  
 |  calc_block_type(self, *args)
 |      calc_block_type(self, blknum) -> fc_block_type_t
 |          @param blknum (C++: size_t)
 |  
 |  create(self, *args)
 |      create(self, _title, _pfn, _ea1, _ea2, _flags)
 |          @param _title (C++: const char *)
 |          @param _pfn (C++: func_t  *)
 |          @param _ea1 (C++: ea_t)
 |          @param _ea2 (C++: ea_t)
 |          @param _flags (C++: int)
 |      
 |      
 |      create(self, _title, ranges, _flags)
 |          @param _title (C++: const char *)
 |          ranges: rangevec_t const &
 |          @param _flags (C++: int)
 |  
 |  get_node_label(self, *args)
 |      get_node_label(self, arg2, arg3, arg4) -> char *
 |          arg2: char *
 |          arg3: int
 |          arg4: int
 |  
 |  is_noret_block(self, *args)
 |      is_noret_block(self, blknum) -> bool
 |          @param blknum (C++: size_t)
 |  
 |  is_ret_block(self, *args)
 |      is_ret_block(self, blknum) -> bool
 |          @param blknum (C++: size_t)
 |  
 |  npred(self, *args)
 |      npred(self, node) -> int
 |          @param node (C++: int)
 |  
 |  nsucc(self, *args)
 |      nsucc(self, node) -> int
 |          @param node (C++: int)
 |  
 |  pred(self, *args)
 |      pred(self, node, i) -> int
 |          @param node (C++: int)
 |          @param i (C++: int)
 |  
 |  print_names(self, *args)
 |      print_names(self) -> bool
 |  
 |  print_node_attributes(self, *args)
 |      print_node_attributes(self, arg2, arg3)
 |          arg2: FILE *
 |          arg3: int
 |  
 |  refresh(self, *args)
 |      refresh(self)
 |  
 |  size(self, *args)
 |      size(self) -> int
 |  
 |  succ(self, *args)
 |      succ(self, node, i) -> int
 |          @param node (C++: int)
 |          @param i (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bounds
 |      qflow_chart_t_bounds_get(self) -> range_t
 |  
 |  flags
 |      qflow_chart_t_flags_get(self) -> int
 |  
 |  nproper
 |      qflow_chart_t_nproper_get(self) -> int
 |  
 |  pfn
 |      qflow_chart_t_pfn_get(self) -> func_t *
 |  
 |  thisown
 |      The membership flag
 |  
 |  title
 |      qflow_chart_t_title_get(self) -> qstring *
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qflow_chart_t>
 |      delete_qflow_chart_t(self)

=== ida_gdl EPYDOC INJECTIONS ===
ida_gdl.CHART_FOLLOW_DIRECTION
"""
analyze references to added blocks only in the direction of the
reference who discovered the current block
"""

ida_gdl.CHART_GEN_DOT
"""
generate .dot file (file extension is forced to .dot)
"""

ida_gdl.CHART_GEN_GDL
"""
generate .gdl file (file extension is forced to .gdl)
"""

ida_gdl.CHART_IGNORE_LIB_FROM
"""
ignore references from library functions
"""

ida_gdl.CHART_IGNORE_LIB_TO
"""
ignore references to library functions
"""

ida_gdl.CHART_NOLIBFUNCS
"""
don't include library functions in the graph
"""

ida_gdl.CHART_PRINT_DOTS
"""
print dots if xrefs exist outside of the range recursion depth
"""

ida_gdl.CHART_PRINT_NAMES
"""
print labels for each block?
"""

ida_gdl.CHART_RECURSIVE
"""
analyze added blocks
"""

ida_gdl.CHART_REFERENCED
"""
references from the addresses in the list
"""

ida_gdl.CHART_REFERENCING
"""
references to the addresses in the list
"""

ida_gdl.CHART_WINGRAPH
"""
call grapher to display the graph
"""

ida_gdl.FC_APPND
"""
multirange flowchart (set by append_to_flowchart)
"""

ida_gdl.FC_CALL_ENDS
"""
call instructions terminate basic blocks
"""

ida_gdl.FC_CHKBREAK
"""
build_qflow_chart() may be aborted by user
"""

ida_gdl.FC_NOEXT
"""
do not compute external blocks. Use this to prevent jumps leaving the
function from appearing in the flow chart. Unless specified, the
targets of those outgoing jumps will be present in the flow chart
under the form of one-instruction blocks
"""

ida_gdl.FC_NOPREDS
"""
do not compute predecessor lists
"""

ida_gdl.FC_PRINT
"""
print names (used only by display_flow_chart())
"""
=== ida_gdl EPYDOC INJECTIONS END ===
Help on class GraphViewer in module ida_graph:

class GraphViewer(ida_kernwin.CustomIDAMemo)
 |  Method resolution order:
 |      GraphViewer
 |      ida_kernwin.CustomIDAMemo
 |      ida_kernwin.View_Hooks
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  AddCommand(self, title, shortcut)
 |  
 |  AddEdge(self, src_node, dest_node)
 |      Creates an edge between two given node ids
 |  
 |  AddNode(self, obj)
 |      Creates a node associated with the given object and returns the node id
 |  
 |  Clear(self)
 |      Clears all the nodes and edges
 |  
 |  Close(self)
 |      Closes the graph.
 |      It is possible to call Show() again (which will recreate the graph)
 |  
 |  Count(self)
 |      Returns the node count
 |  
 |  OnCommand(self, cmd_id)
 |  
 |  OnPopup(self, widget, popup_handle)
 |  
 |  OnRefresh(self)
 |      Event called when the graph is refreshed or first created.
 |      From this event you are supposed to create nodes and edges.
 |      This callback is mandatory.
 |      
 |      @note: ***It is important to clear previous nodes before adding nodes.***
 |      @return: Returning True tells the graph viewer to use the items. Otherwise old items will be used.
 |  
 |  Select(self, node_id)
 |      Selects a node on the graph
 |  
 |  Show(self)
 |      Shows an existing graph or creates a new one
 |      
 |      @return: Boolean
 |  
 |  __getitem__(self, idx)
 |      Returns a reference to the object associated with this node id
 |  
 |  __init__(self, title, close_open=False)
 |      Constructs the GraphView object.
 |      Please do not remove or rename the private fields
 |      
 |      @param title: The title of the graph window
 |      @param close_open: Should it attempt to close an existing graph (with same title) before creating this graph?
 |  
 |  __iter__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  UI_Hooks_Trampoline = <class 'ida_graph.UI_Hooks_Trampoline'>
 |  
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_kernwin.CustomIDAMemo:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |  
 |  view_click(self, view, ve)
 |  
 |  view_close(self, view, *args)
 |  
 |  view_curpos(self, view, *args)
 |  
 |  view_dblclick(self, view, ve)
 |  
 |  view_deactivated(self, view)
 |  
 |  view_keydown(self, view, key, state)
 |  
 |  view_loc_changed(self, view, now, was)
 |  
 |  view_mouse_moved(self, view, ve)
 |  
 |  view_mouse_over(self, view, ve)
 |  
 |  view_switched(self, view, rt)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from ida_kernwin.CustomIDAMemo:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_kernwin.View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args)
 |      A view is being created.
 |      
 |      view_created(self, view)
 |          @param view (C++: TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_kernwin.View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_kernwin.View_Hooks:
 |  
 |  __swig_destroy__ = <built-in function delete_View_Hooks>
 |      delete_View_Hooks(self)

Help on class TPointDouble in module ida_graph:

class TPointDouble(__builtin__.object)
 |  Proxy of C++ TPointDouble class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: TPointDouble const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> TPointDouble
 |          a: double
 |          b: double
 |      
 |      
 |      __init__(self, r) -> TPointDouble
 |          r: point_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: TPointDouble const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  add(self, *args)
 |      add(self, r)
 |          @param r (C++: const  TPointDouble  &)
 |  
 |  negate(self, *args)
 |      negate(self)
 |  
 |  sub(self, *args)
 |      sub(self, r)
 |          @param r (C++: const  TPointDouble  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      TPointDouble_x_get(self) -> double
 |  
 |  y
 |      TPointDouble_y_get(self) -> double
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_TPointDouble>
 |      delete_TPointDouble(self)

Help on function calc_dist in module ida_graph:

calc_dist(*args)
    Calculate distance between p and q.
    
    calc_dist(p, q) -> double
        @param p (C++: point_t)
        @param q (C++: point_t)

Help on function clr_node_info in module ida_graph:

clr_node_info(*args)
    Clear node info for the given node.
    
    clr_node_info(gid, node, flags)
        @param gid: id of desired graph (C++: graph_id_t)
        @param node: node number (C++: int)
        @param flags: combination of  Node info flags , identifying which
                      fields of  node_info_t  will be cleared (C++: uint32)

Help on function create_disasm_graph in module ida_graph:

create_disasm_graph(*args)
    Create a graph for the function that contains 'ea'.
    
    create_disasm_graph(ea) -> mutable_graph_t
        @param ea (C++: ea_t)
    
    
    create_disasm_graph(ranges) -> mutable_graph_t
        ranges: rangevec_t const &

Help on function create_graph_viewer in module ida_graph:

create_graph_viewer(*args)
    Create a custom graph viewer.
    
    create_graph_viewer(title, id, callback, ud, title_height, parent=None) -> graph_viewer_t *
        @param title: the widget title (C++: const char *)
        @param id: graph id (C++: uval_t)
        @param callback: callback to handle graph notifications (
                         graph_notification_t ) (C++: hook_cb_t  *)
        @param ud: user data passed to callback (C++: void *)
        @param title_height: node title height (C++: int)
        @param parent (C++: TWidget *)
        @return: new viewer

Help on function create_mutable_graph in module ida_graph:

create_mutable_graph(*args)
    Create a new empty graph with given id.
    
    create_mutable_graph(id) -> mutable_graph_t
        @param id (C++: uval_t)

Help on function create_user_graph_place in module ida_graph:

create_user_graph_place(*args)
    Get a copy of a 'user_graph_place_t' (returns a pointer to static
    storage)
    
    create_user_graph_place(node, lnnum) -> user_graph_place_t
        @param node (C++: int)
        @param lnnum (C++: int)

Help on function del_node_info in module ida_graph:

del_node_info(*args)
    Delete the 'node_info_t' for the given node.
    
    del_node_info(gid, node)
        @param gid (C++: graph_id_t)
        @param node (C++: int)

Help on function delete_mutable_graph in module ida_graph:

delete_mutable_graph(*args)
    Delete graph object.use this only if you are dealing with
    'mutable_graph_t' instances that have not been used together with a
    'graph_viewer_t' . If you have called 'set_viewer_graph()' with your
    graph, the graph's lifecycle will be managed by the viewer, and you
    shouldn't interfere with it
    
    delete_mutable_graph(g)
        @param g (C++: mutable_graph_t  *)

Help on class edge_info_t in module ida_graph:

class edge_info_t(__builtin__.object)
 |  Proxy of C++ edge_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  reverse_layout(self, *args)
 |      reverse_layout(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  color
 |      edge_info_t_color_get(self) -> bgcolor_t
 |  
 |  dstoff
 |      edge_info_t_dstoff_get(self) -> int
 |  
 |  layout
 |      edge_info_t_layout_get(self) -> pointseq_t
 |  
 |  srcoff
 |      edge_info_t_srcoff_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  width
 |      edge_info_t_width_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_edge_info_t>
 |      delete_edge_info_t(self)

Help on class edge_infos_wrapper_t in module ida_graph:

class edge_infos_wrapper_t(__builtin__.object)
 |  Proxy of C++ edge_infos_wrapper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ptr
 |      edge_infos_wrapper_t_ptr_get(self) -> edge_infos_t *
 |  
 |  thisown
 |      The membership flag

Help on class edge_layout_point_t in module ida_graph:

class edge_layout_point_t(__builtin__.object)
 |  Proxy of C++ edge_layout_point_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: edge_layout_point_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_layout_point_t
 |          r: edge_layout_point_t const &
 |      
 |      
 |      __init__(self, _e, _pidx) -> edge_layout_point_t
 |          _e: edge_t const &
 |          _pidx: int
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: edge_layout_point_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          @param r (C++: const  edge_layout_point_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  e
 |      edge_layout_point_t_e_get(self) -> edge_t
 |  
 |  pidx
 |      edge_layout_point_t_pidx_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_edge_layout_point_t>
 |      delete_edge_layout_point_t(self)

Help on class edge_segment_t in module ida_graph:

class edge_segment_t(__builtin__.object)
 |  Proxy of C++ edge_segment_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_segment_t
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: edge_segment_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  length(self, *args)
 |      length(self) -> size_t
 |  
 |  toright(self, *args)
 |      toright(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  e
 |      edge_segment_t_e_get(self) -> edge_t
 |  
 |  nseg
 |      edge_segment_t_nseg_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  x0
 |      edge_segment_t_x0_get(self) -> int
 |  
 |  x1
 |      edge_segment_t_x1_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_edge_segment_t>
 |      delete_edge_segment_t(self)

Help on class edge_t in module ida_graph:

class edge_t(__builtin__.object)
 |  Proxy of C++ edge_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, y) -> bool
 |          y: edge_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_t
 |          x: int
 |          y: int
 |  
 |  __lt__(self, *args)
 |      __lt__(self, y) -> bool
 |          y: edge_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, y) -> bool
 |          y: edge_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dst
 |      edge_t_dst_get(self) -> int
 |  
 |  src
 |      edge_t_src_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_edge_t>
 |      delete_edge_t(self)

Help on function get_graph_viewer in module ida_graph:

get_graph_viewer(*args)
    Get custom graph viewer for given form.
    
    get_graph_viewer(parent) -> graph_viewer_t *
        @param parent (C++: TWidget *)

Help on function get_node_info in module ida_graph:

get_node_info(*args)
    Get node info.
    
    get_node_info(out, gid, node) -> bool
        @param out: result (C++: node_info_t  *)
        @param gid: id of desired graph (C++: graph_id_t)
        @param node: node number (C++: int)
        @return: success

Help on function get_viewer_graph in module ida_graph:

get_viewer_graph(*args)
    Get graph object for given custom graph viewer.
    
    get_viewer_graph(gv) -> mutable_graph_t
        @param gv (C++: graph_viewer_t  *)

Help on class graph_item_t in module ida_graph:

class graph_item_t(__builtin__.object)
 |  Proxy of C++ graph_item_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_item_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  is_edge(self, *args)
 |      is_edge(self) -> bool
 |  
 |  is_node(self, *args)
 |      is_node(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  b
 |      graph_item_t_b_get(self) -> int
 |  
 |  e
 |      graph_item_t_e_get(self) -> edge_t
 |  
 |  elp
 |      graph_item_t_elp_get(self) -> edge_layout_point_t
 |  
 |  n
 |      graph_item_t_n_get(self) -> int
 |  
 |  p
 |      graph_item_t_p_get(self) -> point_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      graph_item_t_type_get(self) -> graph_item_type_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_graph_item_t>
 |      delete_graph_item_t(self)

Help on class graph_node_visitor_t in module ida_graph:

class graph_node_visitor_t(__builtin__.object)
 |  Proxy of C++ graph_node_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_node_visitor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  is_forbidden_edge(self, *args)
 |      Should the edge between 'n' and 'm' be ignored?
 |      
 |      is_forbidden_edge(self, arg0, arg1) -> bool
 |          arg0: int
 |          arg1: int
 |  
 |  is_visited(self, *args)
 |      Have we already visited the given node?
 |      
 |      is_visited(self, n) -> bool
 |          @param n (C++: int)
 |  
 |  reinit(self, *args)
 |      Reset visited nodes.
 |  
 |  set_visited(self, *args)
 |      Mark node as visited.
 |      
 |      set_visited(self, n)
 |          @param n (C++: int)
 |  
 |  visit_node(self, *args)
 |      Implements action to take when a node is visited.
 |      
 |      visit_node(self, arg0) -> int
 |          arg0: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_graph_node_visitor_t>
 |      delete_graph_node_visitor_t(self)

Help on class graph_path_visitor_t in module ida_graph:

class graph_path_visitor_t(__builtin__.object)
 |  Proxy of C++ graph_path_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_path_visitor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  walk_backward(self, *args)
 |      walk_backward(self, arg0) -> int
 |          arg0: int
 |  
 |  walk_forward(self, *args)
 |      walk_forward(self, arg0) -> int
 |          arg0: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  path
 |      graph_path_visitor_t_path_get(self) -> intvec_t *
 |  
 |  prune
 |      graph_path_visitor_t_prune_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_graph_path_visitor_t>
 |      delete_graph_path_visitor_t(self)

Help on class graph_visitor_t in module ida_graph:

class graph_visitor_t(__builtin__.object)
 |  Proxy of C++ graph_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_visitor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_edge(self, *args)
 |      visit_edge(self, arg2, arg3) -> int
 |          arg2: edge_t
 |          arg3: edge_info_t *
 |  
 |  visit_node(self, *args)
 |      visit_node(self, arg2, arg3) -> int
 |          arg2: int
 |          arg3: rect_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_graph_visitor_t>
 |      delete_graph_visitor_t(self)

Help on class group_crinfo_t in module ida_graph:

class group_crinfo_t(__builtin__.object)
 |  Proxy of C++ group_crinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> group_crinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  nodes
 |      group_crinfo_t_nodes_get(self) -> intvec_t *
 |  
 |  text
 |      group_crinfo_t_text_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_group_crinfo_t>
 |      delete_group_crinfo_t(self)

Help on class interval_t in module ida_graph:

class interval_t(__builtin__.object)
 |  Proxy of C++ interval_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: interval_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> interval_t
 |          y0: int
 |          y1: int
 |      
 |      
 |      __init__(self, s) -> interval_t
 |          s: edge_segment_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: interval_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  contains(self, *args)
 |      contains(self, x) -> bool
 |          @param x (C++: int)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  intersect(self, *args)
 |      intersect(self, r)
 |          @param r (C++: const  interval_t  &)
 |  
 |  length(self, *args)
 |      length(self) -> int
 |  
 |  make_union(self, *args)
 |      make_union(self, r)
 |          @param r (C++: const  interval_t  &)
 |  
 |  move_by(self, *args)
 |      move_by(self, shift)
 |          @param shift (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x0
 |      interval_t_x0_get(self) -> int
 |  
 |  x1
 |      interval_t_x1_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_interval_t>
 |      delete_interval_t(self)

Help on class mutable_graph_t in module ida_graph:

class mutable_graph_t(__builtin__.object)
 |  Proxy of C++ mutable_graph_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  calc_group_ea(self, *args)
 |      calc_group_ea(self, arg0) -> ea_t
 |          arg0: intvec_t const &
 |  
 |  change_group_visibility(self, *args)
 |      change_group_visibility(self, group, expand) -> bool
 |          @param group (C++: int)
 |          @param expand (C++: bool)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  create_digraph_layout(self, *args)
 |      create_digraph_layout(self) -> bool
 |  
 |  create_group(self, *args)
 |      create_group(self, nodes) -> int
 |          @param nodes (C++: const  intvec_t  &)
 |  
 |  del_custom_layout(self, *args)
 |      del_custom_layout(self)
 |  
 |  delete_group(self, *args)
 |      delete_group(self, group) -> bool
 |          @param group (C++: int)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  exists(self, *args)
 |      exists(self, node) -> bool
 |          @param node (C++: int)
 |  
 |  get_custom_layout(self, *args)
 |      get_custom_layout(self) -> bool
 |  
 |  get_edge(self, *args)
 |      get_edge(self, e) -> edge_info_t
 |          @param e (C++: edge_t)
 |  
 |  get_first_subgraph_node(self, *args)
 |      get_first_subgraph_node(self, group) -> int
 |          @param group (C++: int)
 |  
 |  get_graph_groups(self, *args)
 |      get_graph_groups(self) -> bool
 |  
 |  get_next_subgraph_node(self, *args)
 |      get_next_subgraph_node(self, group, current) -> int
 |          @param group (C++: int)
 |          @param current (C++: int)
 |  
 |  get_node_group(self, *args)
 |      get_node_group(self, node) -> int
 |          @param node (C++: int)
 |  
 |  get_node_representative(self, *args)
 |      get_node_representative(self, node) -> int
 |          @param node (C++: int)
 |  
 |  is_collapsed_node(self, *args)
 |      is_collapsed_node(self, node) -> bool
 |          @param node (C++: int)
 |  
 |  is_deleted_node(self, *args)
 |      is_deleted_node(self, node) -> bool
 |          @param node (C++: int)
 |  
 |  is_displayable_node(self, *args)
 |      is_displayable_node(self, node) -> bool
 |          @param node (C++: int)
 |  
 |  is_dot_node(self, *args)
 |      is_dot_node(self, node) -> bool
 |          @param node (C++: int)
 |  
 |  is_group_node(self, *args)
 |      is_group_node(self, node) -> bool
 |          @param node (C++: int)
 |  
 |  is_simple_node(self, *args)
 |      is_simple_node(self, node) -> bool
 |          @param node (C++: int)
 |  
 |  is_subgraph_node(self, *args)
 |      is_subgraph_node(self, node) -> bool
 |          @param node (C++: int)
 |  
 |  is_uncollapsed_node(self, *args)
 |      is_uncollapsed_node(self, node) -> bool
 |          @param node (C++: int)
 |  
 |  is_user_graph(self, *args)
 |      is_user_graph(self) -> bool
 |  
 |  is_visible_node(self, *args)
 |      is_visible_node(self, node) -> bool
 |          @param node (C++: int)
 |  
 |  node_qty(self, *args)
 |      node_qty(self) -> int
 |  
 |  npred(self, *args)
 |      npred(self, b) -> int
 |          @param b (C++: int)
 |  
 |  nrect(self, *args)
 |      nrect(self, n) -> rect_t
 |          @param n (C++: int)
 |      
 |      
 |      nrect(self, n) -> rect_t
 |          @param n (C++: int)
 |  
 |  nsucc(self, *args)
 |      nsucc(self, b) -> int
 |          @param b (C++: int)
 |  
 |  pred(self, *args)
 |      pred(self, b, i) -> int
 |          @param b (C++: int)
 |          @param i (C++: int)
 |  
 |  predset(self, *args)
 |      predset(self, b) -> intvec_t const &
 |          @param b (C++: int)
 |  
 |  reset(self, *args)
 |      reset(self)
 |  
 |  set_custom_layout(self, *args)
 |      set_custom_layout(self)
 |  
 |  set_deleted_node(self, *args)
 |      set_deleted_node(self, node)
 |          @param node (C++: int)
 |  
 |  set_edge(self, *args)
 |      set_edge(self, e, ei) -> bool
 |          @param e (C++: edge_t)
 |          @param ei (C++: const  edge_info_t  *)
 |  
 |  set_graph_groups(self, *args)
 |      set_graph_groups(self)
 |  
 |  set_node_group(self, *args)
 |      set_node_group(self, node, group)
 |          @param node (C++: int)
 |          @param group (C++: int)
 |  
 |  size(self, *args)
 |      size(self) -> int
 |  
 |  succ(self, *args)
 |      succ(self, b, i) -> int
 |          @param b (C++: int)
 |          @param i (C++: int)
 |  
 |  succset(self, *args)
 |      succset(self, b) -> intvec_t const &
 |          @param b (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  belongs
 |      mutable_graph_t_belongs_get(self) -> intvec_t *
 |  
 |  edges
 |      mutable_graph_t_edges_get(self) -> edge_infos_wrapper_t
 |  
 |  gid
 |      mutable_graph_t_gid_get(self) -> uval_t
 |  
 |  node_flags
 |      mutable_graph_t_node_flags_get(self) -> bytevec_t *
 |  
 |  nodes
 |      mutable_graph_t_nodes_get(self) -> node_layout_t
 |  
 |  org_preds
 |      mutable_graph_t_org_preds_get(self) -> array_of_intvec_t
 |  
 |  org_succs
 |      mutable_graph_t_org_succs_get(self) -> array_of_intvec_t
 |  
 |  preds
 |      mutable_graph_t_preds_get(self) -> array_of_intvec_t
 |  
 |  succs
 |      mutable_graph_t_succs_get(self) -> array_of_intvec_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mutable_graph_t>
 |      delete_mutable_graph_t(self)

Help on class node_info_t in module ida_graph:

class node_info_t(__builtin__.object)
 |  Proxy of C++ node_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> node_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_flags_for_valid(self, *args)
 |      Get combination of 'Node info flags' describing which attributes are
 |      valid.
 |  
 |  valid_bg_color(self, *args)
 |      Has valid 'bg_color' ?
 |  
 |  valid_ea(self, *args)
 |      Has valid 'ea' ?
 |  
 |  valid_flags(self, *args)
 |      Has valid 'flags' ?
 |  
 |  valid_frame_color(self, *args)
 |      Has valid 'frame_color' ?
 |  
 |  valid_text(self, *args)
 |      Has non-empty 'text' ?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bg_color
 |      node_info_t_bg_color_get(self) -> bgcolor_t
 |  
 |  ea
 |      node_info_t_ea_get(self) -> ea_t
 |  
 |  flags
 |      node_info_t_flags_get(self) -> uint32
 |  
 |  frame_color
 |      node_info_t_frame_color_get(self) -> bgcolor_t
 |  
 |  text
 |      node_info_t_text_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_node_info_t>
 |      delete_node_info_t(self)

Help on class node_layout_t in module ida_graph:

class node_layout_t(__builtin__.object)
 |  Proxy of C++ qvector< rect_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< rect_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> rect_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> node_layout_t
 |          x: qvector< rect_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< rect_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: rect_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: rect_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: rect_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> rect_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> rect_t
 |      begin(self) -> rect_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> rect_t
 |      end(self) -> rect_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> rect_t
 |          it: qvector< rect_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> rect_t
 |          first: qvector< rect_t >::iterator
 |          last: qvector< rect_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> rect_t
 |  
 |  find(self, *args)
 |      find(self, x) -> rect_t
 |          x: rect_t const &
 |      
 |      
 |      find(self, x) -> rect_t
 |          x: rect_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=rect_t())
 |          x: rect_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: rect_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: rect_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> rect_t
 |          it: qvector< rect_t >::iterator
 |          x: rect_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: rect_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: rect_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< rect_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_node_layout_t>
 |      delete_node_layout_t(self)

Help on class node_ordering_t in module ida_graph:

class node_ordering_t(__builtin__.object)
 |  Proxy of C++ node_ordering_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> node_ordering_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  node(self, *args)
 |      node(self, _order) -> int
 |          @param _order (C++: size_t)
 |  
 |  resize(self, *args)
 |      resize(self, n)
 |          @param n (C++: int)
 |  
 |  set(self, *args)
 |      set(self, _node, num)
 |          @param _node (C++: int)
 |          @param num (C++: int)
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_node_ordering_t>
 |      delete_node_ordering_t(self)

Help on class point_t in module ida_graph:

class point_t(__builtin__.object)
 |  Proxy of C++ point_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: point_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> point_t
 |          _x: int
 |          _y: int
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: point_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  add(self, *args)
 |      add(self, r) -> point_t
 |          @param r (C++: const  point_t  &)
 |  
 |  negate(self, *args)
 |      negate(self)
 |  
 |  sub(self, *args)
 |      sub(self, r) -> point_t
 |          @param r (C++: const  point_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      point_t_x_get(self) -> int
 |  
 |  y
 |      point_t_y_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_point_t>
 |      delete_point_t(self)

Help on class pointseq_t in module ida_graph:

class pointseq_t(pointvec_t)
 |  Proxy of C++ pointseq_t class.
 |  
 |  Method resolution order:
 |      pointseq_t
 |      pointvec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pointseq_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_pointseq_t>
 |      delete_pointseq_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from pointvec_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< point_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> point_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< point_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: point_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: point_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: point_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> point_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> point_t
 |      begin(self) -> point_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> point_t
 |      end(self) -> point_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> point_t
 |          it: qvector< point_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> point_t
 |          first: qvector< point_t >::iterator
 |          last: qvector< point_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> point_t
 |  
 |  find(self, *args)
 |      find(self, x) -> point_t
 |          x: point_t const &
 |      
 |      
 |      find(self, x) -> point_t
 |          x: point_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=point_t())
 |          x: point_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: point_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: point_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> point_t
 |          it: qvector< point_t >::iterator
 |          x: point_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: point_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: point_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< point_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pointvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class pointvec_t in module ida_graph:

class pointvec_t(__builtin__.object)
 |  Proxy of C++ qvector< point_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< point_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> point_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pointvec_t
 |          x: qvector< point_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< point_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: point_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: point_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: point_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> point_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> point_t
 |      begin(self) -> point_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> point_t
 |      end(self) -> point_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> point_t
 |          it: qvector< point_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> point_t
 |          first: qvector< point_t >::iterator
 |          last: qvector< point_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> point_t
 |  
 |  find(self, *args)
 |      find(self, x) -> point_t
 |          x: point_t const &
 |      
 |      
 |      find(self, x) -> point_t
 |          x: point_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=point_t())
 |          x: point_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: point_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: point_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> point_t
 |          it: qvector< point_t >::iterator
 |          x: point_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: point_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: point_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< point_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_pointvec_t>
 |      delete_pointvec_t(self)

Help on function pyg_close in module ida_graph:

pyg_close(*args)
    pyg_close(_self)
        self: PyObject *

Help on function pyg_select_node in module ida_graph:

pyg_select_node(*args)
    pyg_select_node(_self, nid)
        self: PyObject *
        nid: int

Help on function pyg_show in module ida_graph:

pyg_show(*args)
    pyg_show(_self) -> bool
        self: PyObject *

Help on class rect_t in module ida_graph:

class rect_t(__builtin__.object)
 |  Proxy of C++ rect_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: rect_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rect_t
 |          l: int
 |          t: int
 |          r: int
 |          b: int
 |      
 |      
 |      __init__(self, p0, p1) -> rect_t
 |          p0: point_t const &
 |          p1: point_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: rect_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  area(self, *args)
 |      area(self) -> int
 |  
 |  bottomright(self, *args)
 |      bottomright(self) -> point_t
 |  
 |  center(self, *args)
 |      center(self) -> point_t
 |  
 |  contains(self, *args)
 |      contains(self, p) -> bool
 |          @param p (C++: const  point_t  &)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  grow(self, *args)
 |      grow(self, delta)
 |          @param delta (C++: int)
 |  
 |  height(self, *args)
 |      height(self) -> int
 |  
 |  intersect(self, *args)
 |      intersect(self, r)
 |          @param r (C++: const  rect_t  &)
 |  
 |  is_intersection_empty(self, *args)
 |      is_intersection_empty(self, r) -> bool
 |          @param r (C++: const  rect_t  &)
 |  
 |  make_union(self, *args)
 |      make_union(self, r)
 |          @param r (C++: const  rect_t  &)
 |  
 |  move_by(self, *args)
 |      move_by(self, p)
 |          @param p (C++: const  point_t  &)
 |  
 |  move_to(self, *args)
 |      move_to(self, p)
 |          @param p (C++: const  point_t  &)
 |  
 |  topleft(self, *args)
 |      topleft(self) -> point_t
 |  
 |  width(self, *args)
 |      width(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bottom
 |      rect_t_bottom_get(self) -> int
 |  
 |  left
 |      rect_t_left_get(self) -> int
 |  
 |  right
 |      rect_t_right_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  top
 |      rect_t_top_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_rect_t>
 |      delete_rect_t(self)

Help on function refresh_viewer in module ida_graph:

refresh_viewer(*args)
    Redraw the graph in the given view.
    
    refresh_viewer(gv)
        @param gv (C++: graph_viewer_t  *)

Help on class row_info_t in module ida_graph:

class row_info_t(__builtin__.object)
 |  Proxy of C++ row_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> row_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  height(self, *args)
 |      height(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bottom
 |      row_info_t_bottom_get(self) -> int
 |  
 |  nodes
 |      row_info_t_nodes_get(self) -> intvec_t *
 |  
 |  thisown
 |      The membership flag
 |  
 |  top
 |      row_info_t_top_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_row_info_t>
 |      delete_row_info_t(self)

Help on class screen_graph_selection_base_t in module ida_graph:

class screen_graph_selection_base_t(__builtin__.object)
 |  Proxy of C++ qvector< selection_item_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< selection_item_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> selection_item_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> screen_graph_selection_base_t
 |          x: qvector< selection_item_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< selection_item_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: selection_item_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: selection_item_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: selection_item_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> selection_item_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> selection_item_t
 |      begin(self) -> selection_item_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> selection_item_t
 |      end(self) -> selection_item_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> selection_item_t
 |          it: qvector< selection_item_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> selection_item_t
 |          first: qvector< selection_item_t >::iterator
 |          last: qvector< selection_item_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> selection_item_t
 |  
 |  find(self, *args)
 |      find(self, x) -> selection_item_t
 |          x: selection_item_t const &
 |      
 |      
 |      find(self, x) -> selection_item_t
 |          x: selection_item_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=selection_item_t())
 |          x: selection_item_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: selection_item_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: selection_item_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> selection_item_t
 |          it: qvector< selection_item_t >::iterator
 |          x: selection_item_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: selection_item_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: selection_item_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< selection_item_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_screen_graph_selection_ba...
 |      delete_screen_graph_selection_base_t(self)

Help on class screen_graph_selection_t in module ida_graph:

class screen_graph_selection_t(screen_graph_selection_base_t)
 |  Proxy of C++ screen_graph_selection_t class.
 |  
 |  Method resolution order:
 |      screen_graph_selection_t
 |      screen_graph_selection_base_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> screen_graph_selection_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  add(self, *args)
 |      add(self, s)
 |          @param s (C++: const  screen_graph_selection_t  &)
 |  
 |  add_node(self, *args)
 |      add_node(self, node)
 |          @param node (C++: int)
 |  
 |  add_point(self, *args)
 |      add_point(self, e, idx)
 |          @param e (C++: edge_t)
 |          @param idx (C++: int)
 |  
 |  del_node(self, *args)
 |      del_node(self, node)
 |          @param node (C++: int)
 |  
 |  del_point(self, *args)
 |      del_point(self, e, idx)
 |          @param e (C++: edge_t)
 |          @param idx (C++: int)
 |  
 |  has(self, *args)
 |      has(self, item) -> bool
 |          @param item (C++: const  selection_item_t  &)
 |  
 |  items_count(self, *args)
 |      items_count(self, look_for_nodes) -> size_t
 |          @param look_for_nodes (C++: bool)
 |  
 |  nodes_count(self, *args)
 |      nodes_count(self) -> size_t
 |  
 |  points_count(self, *args)
 |      points_count(self) -> size_t
 |  
 |  sub(self, *args)
 |      sub(self, s)
 |          @param s (C++: const  screen_graph_selection_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_screen_graph_selection_t>
 |      delete_screen_graph_selection_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from screen_graph_selection_base_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< selection_item_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> selection_item_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< selection_item_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: selection_item_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: selection_item_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: selection_item_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> selection_item_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> selection_item_t
 |      begin(self) -> selection_item_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> selection_item_t
 |      end(self) -> selection_item_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> selection_item_t
 |          it: qvector< selection_item_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> selection_item_t
 |          first: qvector< selection_item_t >::iterator
 |          last: qvector< selection_item_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> selection_item_t
 |  
 |  find(self, *args)
 |      find(self, x) -> selection_item_t
 |          x: selection_item_t const &
 |      
 |      
 |      find(self, x) -> selection_item_t
 |          x: selection_item_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=selection_item_t())
 |          x: selection_item_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: selection_item_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> selection_item_t
 |          it: qvector< selection_item_t >::iterator
 |          x: selection_item_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: selection_item_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: selection_item_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< selection_item_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from screen_graph_selection_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class selection_item_t in module ida_graph:

class selection_item_t(__builtin__.object)
 |  Proxy of C++ selection_item_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: selection_item_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> selection_item_t
 |          n: int
 |      
 |      
 |      __init__(self, _elp) -> selection_item_t
 |          _elp: edge_layout_point_t &
 |      
 |      
 |      __init__(self, e, idx) -> selection_item_t
 |          e: edge_t
 |          idx: int
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: selection_item_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: selection_item_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          @param r (C++: const  selection_item_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  elp
 |      selection_item_t_elp_get(self) -> edge_layout_point_t
 |  
 |  is_node
 |      selection_item_t_is_node_get(self) -> bool
 |  
 |  node
 |      selection_item_t_node_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_selection_item_t>
 |      delete_selection_item_t(self)

Help on function set_node_info in module ida_graph:

set_node_info(*args)
    Set node info.
    
    set_node_info(gid, node, ni, flags)
        @param gid: id of desired graph (C++: graph_id_t)
        @param node: node number (C++: int)
        @param ni: node info to use (C++: const  node_info_t  &)
        @param flags: combination of  Node info flags , identifying which
                      fields of 'ni' will be used (C++: uint32)

Help on function set_viewer_graph in module ida_graph:

set_viewer_graph(*args)
    Set the underlying graph object for the given viewer.
    
    set_viewer_graph(gv, g)
        @param gv (C++: graph_viewer_t  *)
        @param g (C++: mutable_graph_t  *)

Help on class user_graph_place_t in module ida_graph:

class user_graph_place_t(__builtin__.object)
 |  Proxy of C++ user_graph_place_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  node
 |      user_graph_place_t_node_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_user_graph_place_t>
 |      delete_user_graph_place_t(self)

Help on function viewer_attach_menu_item in module ida_graph:

viewer_attach_menu_item(*args)
    Attach a previously-registered action to the view's context menu. See
    'kernwin.hpp' for how to register actions.
    
    viewer_attach_menu_item(g, name) -> bool
        @param g (C++: graph_viewer_t  *)
        @param name: action name (C++: const char *)
        @return: success

Help on function viewer_center_on in module ida_graph:

viewer_center_on(*args)
    Center the graph view on the given node.
    
    viewer_center_on(gv, node)
        @param gv (C++: graph_viewer_t  *)
        @param node (C++: int)

Help on function viewer_create_groups in module ida_graph:

viewer_create_groups(*args)
    This will perform an operation similar to what happens when a user
    manually selects a set of nodes, right-clicks and selects "Create
    group". This is a wrapper around mutable_graph_t::create_group that
    will, in essence:clone the current graphfor each 'group_crinfo_t' ,
    attempt creating group in that new graphif all were successful,
    animate to that new graph.this accepts parameters that allow creating
    of multiple groups at once; which means only one graph animation will
    be triggered.
    
    viewer_create_groups(gv, out_group_nodes, gi) -> bool
        @param gv (C++: graph_viewer_t  *)
        @param out_group_nodes (C++: intvec_t  *)
        @param gi (C++: const  groups_crinfos_t  &)

Help on function viewer_del_node_info in module ida_graph:

viewer_del_node_info(*args)
    Delete node info for node in given viewer (see 'del_node_info()' )
    
    viewer_del_node_info(gv, n)
        @param gv (C++: graph_viewer_t  *)
        @param n (C++: int)

Help on function viewer_delete_groups in module ida_graph:

viewer_delete_groups(*args)
    Wrapper around mutable_graph_t::delete_group. This function will:clone
    the current graphattempt deleting the groups in that new graphif
    successful, animate to that new graph.
    
    viewer_delete_groups(gv, groups, new_current=-1) -> bool
        @param gv (C++: graph_viewer_t  *)
        @param groups (C++: const  intvec_t  &)
        @param new_current (C++: int)

Help on function viewer_fit_window in module ida_graph:

viewer_fit_window(*args)
    Fit graph viewer to its parent form.
    
    viewer_fit_window(gv)
        @param gv (C++: graph_viewer_t  *)

Help on function viewer_get_curnode in module ida_graph:

viewer_get_curnode(*args)
    Get number of currently selected node (-1 if none)
    
    viewer_get_curnode(gv) -> int
        @param gv (C++: graph_viewer_t  *)

Help on function viewer_get_gli in module ida_graph:

viewer_get_gli(*args)
    Get location info for given graph view If flags contains
    GLICTL_CENTER, then the gli that will be retrieved, will be the one at
    the center of the view. Otherwise it will be the top-left.
    
    viewer_get_gli(out, gv, flags=0) -> bool
        @param out (C++: graph_location_info_t  *)
        @param gv (C++: graph_viewer_t  *)
        @param flags (C++: uint32)

Help on function viewer_get_node_info in module ida_graph:

viewer_get_node_info(*args)
    Get node info for node in given viewer (see 'get_node_info()' )
    
    viewer_get_node_info(gv, out, n) -> bool
        @param gv (C++: graph_viewer_t  *)
        @param out (C++: node_info_t  *)
        @param n (C++: int)

Help on function viewer_get_selection in module ida_graph:

viewer_get_selection(*args)
    Get currently selected items for graph viewer.
    
    viewer_get_selection(gv, sgs) -> bool
        @param gv (C++: graph_viewer_t  *)
        @param sgs (C++: screen_graph_selection_t  *)

Help on function viewer_set_gli in module ida_graph:

viewer_set_gli(*args)
    Set location info for given graph view If flags contains
    GLICTL_CENTER, then the gli will be set to be the center of the view.
    Otherwise it will be the top-left.
    
    viewer_set_gli(gv, gli, flags=0)
        @param gv (C++: graph_viewer_t  *)
        @param gli (C++: const  graph_location_info_t  *)
        @param flags (C++: uint32)

Help on function viewer_set_groups_visibility in module ida_graph:

viewer_set_groups_visibility(*args)
    Wrapper around mutable_graph_t::change_visibility. This function
    will:clone the current graphattempt changing visibility of the groups
    in that new graphif successful, animate to that new graph.
    
    viewer_set_groups_visibility(gv, groups, expand, new_current=-1) -> bool
        @param gv (C++: graph_viewer_t  *)
        @param groups (C++: const  intvec_t  &)
        @param expand (C++: bool)
        @param new_current (C++: int)

Help on function viewer_set_node_info in module ida_graph:

viewer_set_node_info(*args)
    Set node info for node in given viewer (see 'set_node_info()' )
    
    viewer_set_node_info(gv, n, ni, flags)
        @param gv (C++: graph_viewer_t  *)
        @param n (C++: int)
        @param ni (C++: const  node_info_t  &)
        @param flags (C++: uint32)

Help on function viewer_set_titlebar_height in module ida_graph:

viewer_set_titlebar_height(*args)
    Set height of node title bars ( 'grcode_set_titlebar_height' )
    
    viewer_set_titlebar_height(gv, height) -> int
        @param gv (C++: graph_viewer_t  *)
        @param height (C++: int)

=== ida_graph EPYDOC INJECTIONS ===
ida_graph.GLICTL_CENTER
"""
the gli should be set/get as center
"""

ida_graph.MTG_DOT_NODE
"""
is dot node?
"""

ida_graph.MTG_GROUP_NODE
"""
is group node?
"""

ida_graph.MTG_NON_DISPLAYABLE_NODE
"""
for disassembly graphs - non-displayable nodes have a visible area
that is too large to generate disassembly lines for without IDA
slowing down significantly (see MAX_VISIBLE_NODE_AREA)
"""

ida_graph.NIF_BG_COLOR
"""
'node_info_t::bg_color'
"""

ida_graph.NIF_EA
"""
'node_info_t::ea'
"""

ida_graph.NIF_FLAGS
"""
'node_info_t::flags'
"""

ida_graph.NIF_FRAME_COLOR
"""
'node_info_t::frame_color'
"""

ida_graph.NIF_TEXT
"""
'node_info_t::text'
"""
=== ida_graph EPYDOC INJECTIONS END ===
Help on class DecompilationFailure in module ida_hexrays:

class DecompilationFailure(exceptions.Exception)
 |  Raised on a decompilation error.
 |  
 |  The associated hexrays_failure_t object is stored in the
 |  'info' member of this exception.
 |  
 |  Method resolution order:
 |      DecompilationFailure
 |      exceptions.Exception
 |      exceptions.BaseException
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, info)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from exceptions.Exception:
 |  
 |  __new__ = <built-in method __new__ of type object>
 |      T.__new__(S, ...) -> a new object with type S, a subtype of T
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from exceptions.BaseException:
 |  
 |  __delattr__(...)
 |      x.__delattr__('name') <==> del x.name
 |  
 |  __getattribute__(...)
 |      x.__getattribute__('name') <==> x.name
 |  
 |  __getitem__(...)
 |      x.__getitem__(y) <==> x[y]
 |  
 |  __getslice__(...)
 |      x.__getslice__(i, j) <==> x[i:j]
 |      
 |      Use of negative indices is not supported.
 |  
 |  __reduce__(...)
 |  
 |  __repr__(...)
 |      x.__repr__() <==> repr(x)
 |  
 |  __setattr__(...)
 |      x.__setattr__('name', value) <==> x.name = value
 |  
 |  __setstate__(...)
 |  
 |  __str__(...)
 |      x.__str__() <==> str(x)
 |  
 |  __unicode__(...)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from exceptions.BaseException:
 |  
 |  __dict__
 |  
 |  args
 |  
 |  message

Help on class Hexrays_Hooks in module ida_hexrays:

class Hexrays_Hooks(__builtin__.object)
 |  Proxy of C++ Hexrays_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> Hexrays_Hooks
 |          _flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  close_pseudocode(self, *args)
 |      Pseudocode view is being closed.
 |      
 |      close_pseudocode(self, vu) -> int
 |          @param vu (C++: vdui_t *)
 |  
 |  cmt_changed(self, *args)
 |      Comment got changed.
 |      
 |      cmt_changed(self, cfunc, loc, cmt) -> int
 |          @param cfunc (C++: cfunc_t *)
 |          @param loc (C++: const treeloc_t *)
 |          @param cmt (C++: const char *)
 |  
 |  combine(self, *args)
 |      Trying to combine instructions of basic block.
 |      
 |      combine(self, blk, insn) -> int
 |          @param blk (C++: mblock_t *)
 |          @param insn: Should return: 1 if combined the current instruction with
 |                       a preceding one  (C++: minsn_t *)
 |  
 |  create_hint(self, *args)
 |      Create a hint for the current item.
 |      
 |      create_hint(self, vu) -> PyObject *
 |          @param vu (C++: vdui_t *)
 |  
 |  curpos(self, *args)
 |      Current cursor position has been changed. (for example, by left-
 |      clicking or using keyboard)
 |      
 |      curpos(self, vu) -> int
 |          @param vu (C++: vdui_t *)
 |  
 |  double_click(self, *args)
 |      Mouse double click.
 |      
 |      double_click(self, vu, shift_state) -> int
 |          @param vu (C++: vdui_t *)
 |          @param shift_state: Should return: 1 if the event has been handled
 |                              (C++: int)
 |  
 |  flowchart(self, *args)
 |      Flowchart has been generated.
 |      
 |      flowchart(self, fc) -> int
 |          @param fc (C++: qflow_chart_t *)
 |  
 |  func_printed(self, *args)
 |      Function text has been generated. Plugins may modify the text in
 |      'cfunc_t::sv' .
 |      
 |      func_printed(self, cfunc) -> int
 |          @param cfunc (C++: cfunc_t *)
 |  
 |  glbopt(self, *args)
 |      Global optimization has been finished. If microcode is modified,
 |      MERR_LOOP must be returned. It will cause a complete restart of the
 |      optimization.
 |      
 |      glbopt(self, mba) -> int
 |          @param mba: return Microcode error codes code  (C++: mba_t *)
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  interr(self, *args)
 |      Internal error has occurred.
 |      
 |      interr(self, errcode) -> int
 |          @param errcode (C++: int )
 |  
 |  keyboard(self, *args)
 |      Keyboard has been hit.
 |      
 |      keyboard(self, vu, key_code, shift_state) -> int
 |          @param vu (C++: vdui_t *)
 |          @param key_code: VK_...  (C++: int)
 |          @param shift_state: Should return: 1 if the event has been handled
 |                              (C++: int)
 |  
 |  locopt(self, *args)
 |      Basic block level optimization has been finished.
 |      
 |      locopt(self, mba) -> int
 |          @param mba: return Microcode error codes code  (C++: mba_t *)
 |  
 |  lvar_cmt_changed(self, *args)
 |      Local variable comment got changed.
 |      
 |      lvar_cmt_changed(self, vu, v, cmt) -> int
 |          @param vu (C++: vdui_t *)
 |          @param v (C++: lvar_t *)
 |          @param cmt: Please note that it is possible to read/write user
 |                      settings for lvars directly from the idb.  (C++: const
 |                      char *)
 |  
 |  lvar_mapping_changed(self, *args)
 |      Local variable mapping got changed.
 |      
 |      lvar_mapping_changed(self, vu, frm, to) -> int
 |          @param vu (C++: vdui_t *)
 |          @param frm (C++: lvar_t *)
 |          @param to: Please note that it is possible to read/write user settings
 |                     for lvars directly from the idb.  (C++: lvar_t *)
 |  
 |  lvar_name_changed(self, *args)
 |      Local variable got renamed.
 |      
 |      lvar_name_changed(self, vu, v, name, is_user_name) -> int
 |          @param vu (C++: vdui_t *)
 |          @param v (C++: lvar_t *)
 |          @param name (C++: const char *)
 |          @param is_user_name: Please note that it is possible to read/write
 |                               user settings for lvars directly from the idb.
 |                               (C++: bool)
 |  
 |  lvar_type_changed(self, *args)
 |      Local variable type got changed.
 |      
 |      lvar_type_changed(self, vu, v, tinfo) -> int
 |          @param vu (C++: vdui_t *)
 |          @param v (C++: lvar_t *)
 |          @param tinfo: Please note that it is possible to read/write user
 |                        settings for lvars directly from the idb.  (C++: const
 |                        tinfo_t *)
 |  
 |  maturity(self, *args)
 |      Ctree maturity level is being changed.
 |      
 |      maturity(self, cfunc, new_maturity) -> int
 |          @param cfunc (C++: cfunc_t *)
 |          @param new_maturity (C++: ctree_maturity_t)
 |  
 |  microcode(self, *args)
 |      Microcode has been generated.
 |      
 |      microcode(self, mba) -> int
 |          @param mba: return Microcode error codes code  (C++: mba_t *)
 |  
 |  open_pseudocode(self, *args)
 |      New pseudocode view has been opened.
 |      
 |      open_pseudocode(self, vu) -> int
 |          @param vu (C++: vdui_t *)
 |  
 |  populating_popup(self, *args)
 |      Populating popup menu. We can add menu items now.
 |      
 |      populating_popup(self, widget, popup_handle, vu) -> int
 |          @param widget (C++: TWidget *)
 |          @param popup_handle (C++: TPopupMenu *)
 |          @param vu (C++: vdui_t *)
 |  
 |  prealloc(self, *args)
 |      Local variables: preallocation step begins.
 |      
 |      prealloc(self, mba) -> int
 |          @param mba: This event may occur several times. Should return: 1 if
 |                      modified microcode Negative values are Microcode error
 |                      codes error codes  (C++: mba_t *)
 |  
 |  preoptimized(self, *args)
 |      Microcode has been preoptimized.
 |      
 |      preoptimized(self, mba) -> int
 |          @param mba: return Microcode error codes code  (C++: mba_t *)
 |  
 |  print_func(self, *args)
 |      Printing ctree and generating text.
 |      
 |      print_func(self, cfunc, vp) -> int
 |          @param cfunc (C++: cfunc_t *)
 |          @param vp: Returns: 1 if text has been generated by the plugin  (C++:
 |                     vc_printer_t *)
 |  
 |  prolog(self, *args)
 |      Prolog analysis has been finished.
 |      
 |      prolog(self, mba, fc, reachable_blocks, decomp_flags) -> int
 |          @param mba (C++: mba_t *)
 |          @param fc (C++: qflow_chart_t *)
 |          @param reachable_blocks (C++: bitset_t *)
 |          @param decomp_flags: return Microcode error codes code  (C++: int)
 |  
 |  refresh_pseudocode(self, *args)
 |      Existing pseudocode text has been refreshed. Adding/removing
 |      pseudocode lines is forbidden in this event.
 |      
 |      refresh_pseudocode(self, vu) -> int
 |          @param vu: See also hxe_text_ready, which happens earlier  (C++:
 |                     vdui_t *)
 |  
 |  resolve_stkaddrs(self, *args)
 |      The optimizer is about to resolve stack addresses.
 |      
 |      resolve_stkaddrs(self, mba) -> int
 |          @param mba (C++: mba_t *)
 |  
 |  right_click(self, *args)
 |      Mouse right click. Use hxe_populating_popup instead, in case you want
 |      to add items in the popup menu.
 |      
 |      right_click(self, vu) -> int
 |          @param vu (C++: vdui_t *)
 |  
 |  stkpnts(self, *args)
 |      SP change points have been calculated.
 |      
 |      stkpnts(self, mba, _sps) -> int
 |          @param mba (C++: mba_t *)
 |          _sps: stkpnts_t *
 |  
 |  structural(self, *args)
 |      Structural analysis has been finished.
 |      
 |      structural(self, ct) -> int
 |          @param ct (C++: control_graph_t *)
 |  
 |  switch_pseudocode(self, *args)
 |      Existing pseudocode view has been reloaded with a new function. Its
 |      text has not been refreshed yet, only cfunc and mba pointers are
 |      ready.
 |      
 |      switch_pseudocode(self, vu) -> int
 |          @param vu (C++: vdui_t *)
 |  
 |  text_ready(self, *args)
 |      Decompiled text is ready.
 |      
 |      text_ready(self, vu) -> int
 |          @param vu: This event can be used to modify the output text (sv). The
 |                     text uses regular color codes (see lines.hpp) COLOR_ADDR is
 |                     used to store pointers to ctree elements  (C++: vdui_t *)
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_Hexrays_Hooks>
 |      delete_Hexrays_Hooks(self)

Help on class __cbhooks_t in module ida_hexrays:

class __cbhooks_t(Hexrays_Hooks)
 |  Method resolution order:
 |      __cbhooks_t
 |      Hexrays_Hooks
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, callback)
 |  
 |  close_pseudocode(self, *args)
 |  
 |  create_hint(self, *args)
 |  
 |  curpos(self, *args)
 |  
 |  double_click(self, *args)
 |  
 |  func_printed(self, *args)
 |  
 |  interr(self, *args)
 |  
 |  keyboard(self, *args)
 |  
 |  maturity(self, *args)
 |  
 |  open_pseudocode(self, *args)
 |  
 |  populating_popup(self, *args)
 |  
 |  print_func(self, *args)
 |  
 |  refresh_pseudocode(self, *args)
 |  
 |  right_click(self, *args)
 |  
 |  switch_pseudocode(self, *args)
 |  
 |  text_ready(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  instances = []
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from Hexrays_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  cmt_changed(self, *args)
 |      Comment got changed.
 |      
 |      cmt_changed(self, cfunc, loc, cmt) -> int
 |          @param cfunc (C++: cfunc_t *)
 |          @param loc (C++: const treeloc_t *)
 |          @param cmt (C++: const char *)
 |  
 |  combine(self, *args)
 |      Trying to combine instructions of basic block.
 |      
 |      combine(self, blk, insn) -> int
 |          @param blk (C++: mblock_t *)
 |          @param insn: Should return: 1 if combined the current instruction with
 |                       a preceding one  (C++: minsn_t *)
 |  
 |  flowchart(self, *args)
 |      Flowchart has been generated.
 |      
 |      flowchart(self, fc) -> int
 |          @param fc (C++: qflow_chart_t *)
 |  
 |  glbopt(self, *args)
 |      Global optimization has been finished. If microcode is modified,
 |      MERR_LOOP must be returned. It will cause a complete restart of the
 |      optimization.
 |      
 |      glbopt(self, mba) -> int
 |          @param mba: return Microcode error codes code  (C++: mba_t *)
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  locopt(self, *args)
 |      Basic block level optimization has been finished.
 |      
 |      locopt(self, mba) -> int
 |          @param mba: return Microcode error codes code  (C++: mba_t *)
 |  
 |  lvar_cmt_changed(self, *args)
 |      Local variable comment got changed.
 |      
 |      lvar_cmt_changed(self, vu, v, cmt) -> int
 |          @param vu (C++: vdui_t *)
 |          @param v (C++: lvar_t *)
 |          @param cmt: Please note that it is possible to read/write user
 |                      settings for lvars directly from the idb.  (C++: const
 |                      char *)
 |  
 |  lvar_mapping_changed(self, *args)
 |      Local variable mapping got changed.
 |      
 |      lvar_mapping_changed(self, vu, frm, to) -> int
 |          @param vu (C++: vdui_t *)
 |          @param frm (C++: lvar_t *)
 |          @param to: Please note that it is possible to read/write user settings
 |                     for lvars directly from the idb.  (C++: lvar_t *)
 |  
 |  lvar_name_changed(self, *args)
 |      Local variable got renamed.
 |      
 |      lvar_name_changed(self, vu, v, name, is_user_name) -> int
 |          @param vu (C++: vdui_t *)
 |          @param v (C++: lvar_t *)
 |          @param name (C++: const char *)
 |          @param is_user_name: Please note that it is possible to read/write
 |                               user settings for lvars directly from the idb.
 |                               (C++: bool)
 |  
 |  lvar_type_changed(self, *args)
 |      Local variable type got changed.
 |      
 |      lvar_type_changed(self, vu, v, tinfo) -> int
 |          @param vu (C++: vdui_t *)
 |          @param v (C++: lvar_t *)
 |          @param tinfo: Please note that it is possible to read/write user
 |                        settings for lvars directly from the idb.  (C++: const
 |                        tinfo_t *)
 |  
 |  microcode(self, *args)
 |      Microcode has been generated.
 |      
 |      microcode(self, mba) -> int
 |          @param mba: return Microcode error codes code  (C++: mba_t *)
 |  
 |  prealloc(self, *args)
 |      Local variables: preallocation step begins.
 |      
 |      prealloc(self, mba) -> int
 |          @param mba: This event may occur several times. Should return: 1 if
 |                      modified microcode Negative values are Microcode error
 |                      codes error codes  (C++: mba_t *)
 |  
 |  preoptimized(self, *args)
 |      Microcode has been preoptimized.
 |      
 |      preoptimized(self, mba) -> int
 |          @param mba: return Microcode error codes code  (C++: mba_t *)
 |  
 |  prolog(self, *args)
 |      Prolog analysis has been finished.
 |      
 |      prolog(self, mba, fc, reachable_blocks, decomp_flags) -> int
 |          @param mba (C++: mba_t *)
 |          @param fc (C++: qflow_chart_t *)
 |          @param reachable_blocks (C++: bitset_t *)
 |          @param decomp_flags: return Microcode error codes code  (C++: int)
 |  
 |  resolve_stkaddrs(self, *args)
 |      The optimizer is about to resolve stack addresses.
 |      
 |      resolve_stkaddrs(self, mba) -> int
 |          @param mba (C++: mba_t *)
 |  
 |  stkpnts(self, *args)
 |      SP change points have been calculated.
 |      
 |      stkpnts(self, mba, _sps) -> int
 |          @param mba (C++: mba_t *)
 |          _sps: stkpnts_t *
 |  
 |  structural(self, *args)
 |      Structural analysis has been finished.
 |      
 |      structural(self, ct) -> int
 |          @param ct (C++: control_graph_t *)
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from Hexrays_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from Hexrays_Hooks:
 |  
 |  __swig_destroy__ = <built-in function delete_Hexrays_Hooks>
 |      delete_Hexrays_Hooks(self)

Help on function _call_with_transferrable_ownership in module ida_hexrays:

_call_with_transferrable_ownership(fun, *args)
    # Object ownership

Help on function _kludge_force_declare_TPopupMenu in module ida_hexrays:

_kludge_force_declare_TPopupMenu(*args)
    _kludge_force_declare_TPopupMenu(arg1)
        arg1: TPopupMenu const *

Help on function _ll_call_helper in module ida_hexrays:

_ll_call_helper(*args)
    _ll_call_helper(rettype, args, format) -> cexpr_t
        rettype: tinfo_t const &
        args: carglist_t *
        format: char const *

Help on function _ll_create_helper in module ida_hexrays:

_ll_create_helper(*args)
    _ll_create_helper(standalone, type, format) -> cexpr_t
        standalone: bool
        type: tinfo_t const &
        format: char const *

Help on function _ll_dereference in module ida_hexrays:

_ll_dereference(*args)
    _ll_dereference(e, ptrsize, is_flt=False) -> cexpr_t
        e: cexpr_t *
        ptrsize: int
        is_flt: bool

Help on function _ll_lnot in module ida_hexrays:

_ll_lnot(*args)
    _ll_lnot(e) -> cexpr_t
        e: cexpr_t *

Help on function _ll_make_num in module ida_hexrays:

_ll_make_num(*args)
    _ll_make_num(n, func=None, ea=BADADDR, opnum=0, sign=no_sign, size=0) -> cexpr_t
        n: uint64
        func: cfunc_t *
        ea: ea_t
        opnum: int
        sign: type_sign_t
        size: int

Help on function _ll_make_ref in module ida_hexrays:

_ll_make_ref(*args)
    _ll_make_ref(e) -> cexpr_t
        e: cexpr_t *

Help on function _ll_new_block in module ida_hexrays:

_ll_new_block(*args)
    _ll_new_block() -> cinsn_t

Help on function _map_as_dict in module ida_hexrays:

_map_as_dict(maptype, name, keytype, valuetype)
    # dictify all dict-like types

Help on function accepts_small_udts in module ida_hexrays:

accepts_small_udts(*args)
    Is the operator allowed on small structure or union?
    
    accepts_small_udts(op) -> bool
        @param op (C++: ctype_t)

Help on function accepts_udts in module ida_hexrays:

accepts_udts(*args)
    accepts_udts(op) -> bool
        @param op (C++: ctype_t)

Help on function arglocs_overlap in module ida_hexrays:

arglocs_overlap(*args)
    Do two arglocs overlap?
    
    arglocs_overlap(loc1, w1, loc2, w2) -> bool
        @param loc1 (C++: const  vdloc_t  &)
        @param w1 (C++: size_t)
        @param loc2 (C++: const  vdloc_t  &)
        @param w2 (C++: size_t)

Help on class array_of_bitsets in module ida_hexrays:

class array_of_bitsets(__builtin__.object)
 |  Proxy of C++ qvector< bitset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< bitset_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> bitset_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_of_bitsets
 |          x: qvector< bitset_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< bitset_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: bitset_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: bitset_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: bitset_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> bitset_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> bitset_t
 |      begin(self) -> bitset_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> bitset_t
 |      end(self) -> bitset_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> bitset_t
 |          it: qvector< bitset_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> bitset_t
 |          first: qvector< bitset_t >::iterator
 |          last: qvector< bitset_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> bitset_t
 |  
 |  find(self, *args)
 |      find(self, x) -> bitset_t
 |          x: bitset_t const &
 |      
 |      
 |      find(self, x) -> bitset_t
 |          x: bitset_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=bitset_t())
 |          x: bitset_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: bitset_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: bitset_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> bitset_t
 |          it: qvector< bitset_t >::iterator
 |          x: bitset_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: bitset_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: bitset_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< bitset_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_array_of_bitsets>
 |      delete_array_of_bitsets(self)

Help on class array_of_ivlsets in module ida_hexrays:

class array_of_ivlsets(__builtin__.object)
 |  Proxy of C++ qvector< ivlset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< ivlset_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> ivlset_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_of_ivlsets
 |          x: qvector< ivlset_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< ivlset_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: ivlset_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: ivlset_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: ivlset_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> ivlset_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> ivlset_t
 |      begin(self) -> ivlset_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> ivlset_t
 |      end(self) -> ivlset_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> ivlset_t
 |          it: qvector< ivlset_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> ivlset_t
 |          first: qvector< ivlset_t >::iterator
 |          last: qvector< ivlset_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> ivlset_t
 |  
 |  find(self, *args)
 |      find(self, x) -> ivlset_t
 |          x: ivlset_t const &
 |      
 |      
 |      find(self, x) -> ivlset_t
 |          x: ivlset_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=ivlset_t())
 |          x: ivlset_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: ivlset_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: ivlset_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> ivlset_t
 |          it: qvector< ivlset_t >::iterator
 |          x: ivlset_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: ivlset_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: ivlset_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< ivlset_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_array_of_ivlsets>
 |      delete_array_of_ivlsets(self)

Help on function asgop in module ida_hexrays:

asgop(*args)
    Convert plain operator into assignment operator. For example, cot_add
    returns cot_asgadd.
    
    asgop(cop) -> ctype_t
        @param cop (C++: ctype_t)

Help on function asgop_revert in module ida_hexrays:

asgop_revert(*args)
    Convert assignment operator into plain operator. For example,
    cot_asgadd returns cot_add
    
    asgop_revert(cop) -> ctype_t
        @param cop (C++: ctype_t)
        @return: cot_empty is the input operator is not an assignment
                 operator.

Help on class bit_bound_t in module ida_hexrays:

class bit_bound_t(__builtin__.object)
 |  Proxy of C++ bit_bound_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, n=0, s=0) -> bit_bound_t
 |          n: int
 |          s: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  nbits
 |      bit_bound_t_nbits_get(self) -> int16
 |  
 |  sbits
 |      bit_bound_t_sbits_get(self) -> int16
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_bit_bound_t>
 |      delete_bit_bound_t(self)

Help on class bitset_t in module ida_hexrays:

class bitset_t(__builtin__.object)
 |  Proxy of C++ bitset_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bitset_t
 |          m: bitset_t const &
 |  
 |  __iter__(self)
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __len__ = count(self, *args)
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  add(self, *args)
 |      add(self, bit) -> bool
 |          @param bit (C++: int)
 |      
 |      
 |      add(self, bit, width) -> bool
 |          @param bit (C++: int)
 |          width: int
 |      
 |      
 |      add(self, ml) -> bool
 |          ml: bitset_t const &
 |  
 |  back(self, *args)
 |      back(self) -> int
 |  
 |  begin(self, *args)
 |      begin(self) -> iterator
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: bitset_t const &
 |  
 |  copy(self, *args)
 |      copy(self, m) -> bitset_t
 |          @param m (C++: const  bitset_t  &)
 |  
 |  count(self, *args)
 |      count(self) -> int
 |          bit: int
 |  
 |  cut_at(self, *args)
 |      cut_at(self, maxbit) -> bool
 |          @param maxbit (C++: int)
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> iterator
 |  
 |  fill_with_ones(self, *args)
 |      fill_with_ones(self, maxbit)
 |          @param maxbit (C++: int)
 |  
 |  front(self, *args)
 |      front(self) -> int
 |  
 |  has(self, *args)
 |      has(self, bit) -> bool
 |          @param bit (C++: int)
 |  
 |  has_all(self, *args)
 |      has_all(self, bit, width) -> bool
 |          @param bit (C++: int)
 |          @param width (C++: int)
 |  
 |  has_any(self, *args)
 |      has_any(self, bit, width) -> bool
 |          @param bit (C++: int)
 |          @param width (C++: int)
 |  
 |  has_common(self, *args)
 |      has_common(self, ml) -> bool
 |          @param ml (C++: const  bitset_t  &)
 |  
 |  inc(self, *args)
 |      inc(self, p, n=1)
 |          @param p (C++: iterator  &)
 |          @param n (C++: int)
 |  
 |  includes(self, *args)
 |      includes(self, ml) -> bool
 |          @param ml (C++: const  bitset_t  &)
 |  
 |  intersect(self, *args)
 |      intersect(self, ml) -> bool
 |          @param ml (C++: const  bitset_t  &)
 |  
 |  is_subset_of(self, *args)
 |      is_subset_of(self, ml) -> bool
 |          @param ml (C++: const  bitset_t  &)
 |  
 |  itat(self, *args)
 |      itat(self, n) -> iterator
 |          @param n (C++: int)
 |  
 |  itv(self, *args)
 |      itv(self, it) -> int
 |          it: bitset_t::const_iterator
 |  
 |  last(self, *args)
 |      last(self) -> int
 |  
 |  shift_down(self, *args)
 |      shift_down(self, shift)
 |          @param shift (C++: int)
 |  
 |  sub(self, *args)
 |      sub(self, bit) -> bool
 |          @param bit (C++: int)
 |      
 |      
 |      sub(self, bit, width) -> bool
 |          @param bit (C++: int)
 |          width: int
 |      
 |      
 |      sub(self, ml) -> bool
 |          ml: bitset_t const &
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: bitset_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_bitset_t>
 |      delete_bitset_t(self)

Help on function block_chains_begin in module ida_hexrays:

block_chains_begin(*args)
    Get iterator pointing to the beginning of 'block_chains_t' .
    
    block_chains_begin(set) -> block_chains_iterator_t
        @param set (C++: const  block_chains_t  *)

Help on function block_chains_clear in module ida_hexrays:

block_chains_clear(*args)
    Clear 'block_chains_t' .
    
    block_chains_clear(set)
        @param set (C++: block_chains_t  *)

Help on function block_chains_end in module ida_hexrays:

block_chains_end(*args)
    Get iterator pointing to the end of 'block_chains_t' .
    
    block_chains_end(set) -> block_chains_iterator_t
        @param set (C++: const  block_chains_t  *)

Help on function block_chains_erase in module ida_hexrays:

block_chains_erase(*args)
    Erase current element from 'block_chains_t' .
    
    block_chains_erase(set, p)
        @param set (C++: block_chains_t  *)
        @param p (C++: block_chains_iterator_t)

Help on function block_chains_find in module ida_hexrays:

block_chains_find(*args)
    Find the specified key in set 'block_chains_t' .
    
    block_chains_find(set, val) -> block_chains_iterator_t
        @param set (C++: const  block_chains_t  *)
        @param val (C++: const  chain_t  &)

Help on function block_chains_free in module ida_hexrays:

block_chains_free(*args)
    Delete 'block_chains_t' instance.
    
    block_chains_free(set)
        @param set (C++: block_chains_t  *)

Help on function block_chains_get in module ida_hexrays:

block_chains_get(*args)
    Get reference to the current set value.
    
    block_chains_get(p) -> chain_t
        @param p (C++: block_chains_iterator_t)

Help on function block_chains_insert in module ida_hexrays:

block_chains_insert(*args)
    Insert new ( 'chain_t' ) into set 'block_chains_t' .
    
    block_chains_insert(set, val) -> block_chains_iterator_t
        @param set (C++: block_chains_t  *)
        @param val (C++: const  chain_t  &)

Help on class block_chains_iterator_t in module ida_hexrays:

class block_chains_iterator_t(__builtin__.object)
 |  Proxy of C++ block_chains_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, p) -> bool
 |          p: block_chains_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> block_chains_iterator_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, p) -> bool
 |          p: block_chains_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      block_chains_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_block_chains_iterator_t>
 |      delete_block_chains_iterator_t(self)

Help on function block_chains_new in module ida_hexrays:

block_chains_new(*args)
    Create a new 'block_chains_t' instance.

Help on function block_chains_next in module ida_hexrays:

block_chains_next(*args)
    Move to the next element.
    
    block_chains_next(p) -> block_chains_iterator_t
        @param p (C++: block_chains_iterator_t)

Help on function block_chains_prev in module ida_hexrays:

block_chains_prev(*args)
    Move to the previous element.
    
    block_chains_prev(p) -> block_chains_iterator_t
        @param p (C++: block_chains_iterator_t)

Help on function block_chains_size in module ida_hexrays:

block_chains_size(*args)
    Get size of 'block_chains_t' .
    
    block_chains_size(set) -> size_t
        @param set (C++: block_chains_t  *)

Help on class block_chains_t in module ida_hexrays:

class block_chains_t(__builtin__.object)
 |  Proxy of C++ block_chains_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> block_chains_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self)
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  get_chain(self, *args)
 |      Get chain for the specified value offset.
 |      
 |      get_chain(self, k, width=1) -> chain_t
 |          @param k: value offset (register number or stack offset) (C++: const
 |                    voff_t  &)
 |          @param width: size of value in bytes (C++: int)
 |      
 |      
 |      get_chain(self, k, width=1) -> chain_t
 |          @param k: value offset (register number or stack offset) (C++: const
 |                    voff_t  &)
 |          @param width: size of value in bytes (C++: int)
 |      
 |      
 |      get_chain(self, ch) -> chain_t
 |          ch: chain_t const &
 |      
 |      
 |      get_chain(self, ch) -> chain_t
 |          ch: chain_t const &
 |  
 |  get_reg_chain(self, *args)
 |      Get chain for the specified register
 |      
 |      get_reg_chain(self, reg, width=1) -> chain_t
 |          @param reg: register number (C++: mreg_t)
 |          @param width: size of register in bytes (C++: int)
 |      
 |      
 |      get_reg_chain(self, reg, width=1) -> chain_t
 |          @param reg: register number (C++: mreg_t)
 |          @param width: size of register in bytes (C++: int)
 |  
 |  get_stk_chain(self, *args)
 |      Get chain for the specified stack offset
 |      
 |      get_stk_chain(self, off, width=1) -> chain_t
 |          @param off: stack offset (C++: sval_t)
 |          @param width: size of stack value in bytes (C++: int)
 |      
 |      
 |      get_stk_chain(self, off, width=1) -> chain_t
 |          @param off: stack offset (C++: sval_t)
 |          @param width: size of stack value in bytes (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_block_chains_t>
 |      delete_block_chains_t(self)

Help on class block_chains_vec_t in module ida_hexrays:

class block_chains_vec_t(__builtin__.object)
 |  Proxy of C++ qvector< block_chains_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> block_chains_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> block_chains_vec_t
 |          x: qvector< block_chains_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: block_chains_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> block_chains_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> block_chains_t
 |      begin(self) -> block_chains_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> block_chains_t
 |      end(self) -> block_chains_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> block_chains_t
 |          it: qvector< block_chains_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> block_chains_t
 |          first: qvector< block_chains_t >::iterator
 |          last: qvector< block_chains_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> block_chains_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=block_chains_t())
 |          x: block_chains_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: block_chains_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> block_chains_t
 |          it: qvector< block_chains_t >::iterator
 |          x: block_chains_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: block_chains_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: block_chains_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< block_chains_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_block_chains_vec_t>
 |      delete_block_chains_vec_t(self)

Help on function boundaries_begin in module ida_hexrays:

boundaries_begin(*args)
    Get iterator pointing to the beginning of boundaries_t.
    
    boundaries_begin(map) -> boundaries_iterator_t
        @param map (C++: const boundaries_t *)

Help on function boundaries_clear in module ida_hexrays:

boundaries_clear(*args)
    Clear boundaries_t.
    
    boundaries_clear(map)
        @param map (C++: boundaries_t *)

Help on function boundaries_end in module ida_hexrays:

boundaries_end(*args)
    Get iterator pointing to the end of boundaries_t.
    
    boundaries_end(map) -> boundaries_iterator_t
        @param map (C++: const boundaries_t *)

Help on function boundaries_erase in module ida_hexrays:

boundaries_erase(*args)
    Erase current element from boundaries_t.
    
    boundaries_erase(map, p)
        @param map (C++: boundaries_t *)
        @param p (C++: boundaries_iterator_t)

Help on function boundaries_find in module ida_hexrays:

boundaries_find(*args)
    Find the specified key in boundaries_t.
    
    boundaries_find(map, key) -> boundaries_iterator_t
        @param map (C++: const boundaries_t *)
        @param key (C++: const  cinsn_t  *&)

Help on function boundaries_first in module ida_hexrays:

boundaries_first(*args)
    Get reference to the current map key.
    
    boundaries_first(p) -> cinsn_t
        @param p (C++: boundaries_iterator_t)

Help on function boundaries_free in module ida_hexrays:

boundaries_free(*args)
    Delete boundaries_t instance.
    
    boundaries_free(map)
        @param map (C++: boundaries_t *)

Help on function boundaries_insert in module ida_hexrays:

boundaries_insert(*args)
    Insert new ( 'cinsn_t' *, 'rangeset_t' ) pair into boundaries_t.
    
    boundaries_insert(map, key, val) -> boundaries_iterator_t
        @param map (C++: boundaries_t *)
        @param key (C++: const  cinsn_t  *&)
        @param val (C++: const  rangeset_t  &)

Help on class boundaries_iterator_t in module ida_hexrays:

class boundaries_iterator_t(__builtin__.object)
 |  Proxy of C++ boundaries_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, p) -> bool
 |          p: boundaries_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> boundaries_iterator_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, p) -> bool
 |          p: boundaries_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      boundaries_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_boundaries_iterator_t>
 |      delete_boundaries_iterator_t(self)

Help on function boundaries_new in module ida_hexrays:

boundaries_new(*args)
    Create a new boundaries_t instance.

Help on function boundaries_next in module ida_hexrays:

boundaries_next(*args)
    Move to the next element.
    
    boundaries_next(p) -> boundaries_iterator_t
        @param p (C++: boundaries_iterator_t)

Help on function boundaries_prev in module ida_hexrays:

boundaries_prev(*args)
    Move to the previous element.
    
    boundaries_prev(p) -> boundaries_iterator_t
        @param p (C++: boundaries_iterator_t)

Help on function boundaries_second in module ida_hexrays:

boundaries_second(*args)
    Get reference to the current map value.
    
    boundaries_second(p) -> rangeset_t
        @param p (C++: boundaries_iterator_t)

Help on function boundaries_size in module ida_hexrays:

boundaries_size(*args)
    Get size of boundaries_t.
    
    boundaries_size(map) -> size_t
        @param map (C++: boundaries_t *)

Help on class boundaries_t in module ida_hexrays:

class boundaries_t(__builtin__.object)
 |  Proxy of C++ std::map< cinsn_t *,rangeset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> boundaries_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  at(self, *args)
 |      at(self, _Keyval) -> rangeset_t
 |          _Keyval: cinsn_t *const &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __begin = <built-in function boundaries_begin>
 |      boundaries_begin(map) -> boundaries_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t const *
 |  
 |  __clear = <built-in function boundaries_clear>
 |      boundaries_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t *
 |  
 |  __end = <built-in function boundaries_end>
 |      boundaries_end(map) -> boundaries_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t const *
 |  
 |  __erase = <built-in function boundaries_erase>
 |      boundaries_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t *
 |      p: boundaries_iterator_t
 |  
 |  __find = <built-in function boundaries_find>
 |      boundaries_find(map, key) -> boundaries_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t const *
 |      key: cinsn_t const *
 |  
 |  __first = <built-in function boundaries_first>
 |      boundaries_first(p) -> cinsn_t
 |      
 |      Parameters
 |      ----------
 |      p: boundaries_iterator_t
 |  
 |  __insert = <built-in function boundaries_insert>
 |      boundaries_insert(map, key, val) -> boundaries_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t *
 |      key: cinsn_t const *
 |      val: rangeset_t const &
 |  
 |  __next = <built-in function boundaries_next>
 |      boundaries_next(p) -> boundaries_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: boundaries_iterator_t
 |  
 |  __second = <built-in function boundaries_second>
 |      boundaries_second(p) -> rangeset_t
 |      
 |      Parameters
 |      ----------
 |      p: boundaries_iterator_t
 |  
 |  __size = <built-in function boundaries_size>
 |      boundaries_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t *
 |  
 |  __swig_destroy__ = <built-in function delete_boundaries_t>
 |      delete_boundaries_t(self)
 |  
 |  keytype = <class 'ida_hexrays.cinsn_t'>
 |      Proxy of C++ cinsn_t class.
 |  
 |  valuetype = <class 'ida_range.rangeset_t'>
 |      Proxy of C++ rangeset_t class.

Help on function call_helper in module ida_hexrays:

call_helper(rettype, args, *rest)

Help on class carg_t in module ida_hexrays:

class carg_t(cexpr_t)
 |  Proxy of C++ carg_t class.
 |  
 |  Method resolution order:
 |      carg_t
 |      cexpr_t
 |      citem_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: carg_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: carg_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: carg_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> carg_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: carg_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: carg_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: carg_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: carg_t const &
 |  
 |  consume_cexpr(self, *args)
 |      consume_cexpr(self, e)
 |          @param e (C++: cexpr_t  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  formal_type
 |      carg_t_formal_type_get(self) -> tinfo_t
 |  
 |  is_vararg
 |      carg_t_is_vararg_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_carg_t>
 |      delete_carg_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cexpr_t:
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  _get_a(self, *args)
 |      _get_a(self) -> carglist_t
 |  
 |  _get_fpc(self, *args)
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_helper(self, *args)
 |      _get_helper(self) -> char *
 |  
 |  _get_insn(self, *args)
 |      _get_insn(self) -> cinsn_t
 |  
 |  _get_m(self, *args)
 |      _get_m(self) -> int
 |  
 |  _get_n(self, *args)
 |      _get_n(self) -> cnumber_t
 |  
 |  _get_obj_ea(self, *args)
 |      _get_obj_ea(self) -> ea_t
 |  
 |  _get_ptrsize(self, *args)
 |      _get_ptrsize(self) -> int
 |  
 |  _get_refwidth(self, *args)
 |      _get_refwidth(self) -> int
 |  
 |  _get_string(self, *args)
 |      _get_string(self) -> char *
 |  
 |  _get_x(self, *args)
 |      _get_x(self) -> cexpr_t
 |  
 |  _get_y(self, *args)
 |      _get_y(self) -> cexpr_t
 |  
 |  _get_z(self, *args)
 |      _get_z(self) -> cexpr_t
 |  
 |  _register(self, *args)
 |      _register(self)
 |  
 |  _replace_by(self, *args)
 |      _replace_by(self, r)
 |          r: cexpr_t *
 |  
 |  _set_a(self, *args)
 |      _set_a(self, _v)
 |          _v: carglist_t *
 |  
 |  _set_fpc(self, *args)
 |      _set_fpc(self, _v)
 |          _v: fnumber_t *
 |  
 |  _set_helper(self, *args)
 |      _set_helper(self, _v)
 |          _v: char *
 |  
 |  _set_insn(self, *args)
 |      _set_insn(self, _v)
 |          _v: cinsn_t *
 |  
 |  _set_m(self, *args)
 |      _set_m(self, _v)
 |          _v: int
 |  
 |  _set_n(self, *args)
 |      _set_n(self, _v)
 |          _v: cnumber_t *
 |  
 |  _set_obj_ea(self, *args)
 |      _set_obj_ea(self, _v)
 |          _v: ea_t
 |  
 |  _set_ptrsize(self, *args)
 |      _set_ptrsize(self, _v)
 |          _v: int
 |  
 |  _set_refwidth(self, *args)
 |      _set_refwidth(self, _v)
 |          _v: int
 |  
 |  _set_string(self, *args)
 |      _set_string(self, _v)
 |          _v: char *
 |  
 |  _set_x(self, *args)
 |      _set_x(self, _v)
 |          _v: cexpr_t *
 |  
 |  _set_y(self, *args)
 |      _set_y(self, _v)
 |          _v: cexpr_t *
 |  
 |  _set_z(self, *args)
 |      _set_z(self, _v)
 |          _v: cexpr_t *
 |  
 |  assign(self, *args)
 |      assign(self, r) -> cexpr_t
 |          @param r (C++: const  cexpr_t  &)
 |  
 |  calc_type(self, *args)
 |      Calculate the type of the expression. Use this function to calculate
 |      the expression type when a new expression is built
 |      
 |      calc_type(self, recursive)
 |          @param recursive: if true, types of all children expression will be
 |                            calculated before calculating our type (C++: bool)
 |  
 |  cleanup(self, *args)
 |      Cleanup the expression. This function properly deletes all children
 |      and sets the item type to cot_empty.
 |  
 |  contains_comma(self, *args)
 |      Does the expression contain a comma operator?
 |      
 |      contains_comma(self, times=1) -> bool
 |          @param times (C++: int)
 |  
 |  contains_comma_or_insn_or_label(self, *args)
 |      Does the expression contain a comma operator or an embedded statement
 |      operator or a label?
 |      
 |      contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
 |          @param maxcommas (C++: int)
 |  
 |  contains_insn(self, *args)
 |      Does the expression contain an embedded statement operator?
 |      
 |      contains_insn(self, times=1) -> bool
 |          @param times (C++: int)
 |  
 |  contains_insn_or_label(self, *args)
 |      Does the expression contain an embedded statement operator or a label?
 |  
 |  contains_operator(self, *args)
 |      Check if the expression contains the specified operator.
 |      
 |      contains_operator(self, needed_op, times=1) -> bool
 |          @param needed_op: operator code to search for (C++: ctype_t)
 |          @param times: how many times the operator code should be present (C++:
 |                        int)
 |          @return: true if the expression has at least TIMES children with
 |                   NEEDED_OP
 |  
 |  cpadone(self, *args)
 |      Pointer arithmetic correction done for this expression?
 |  
 |  equal_effect(self, *args)
 |      Compare two expressions. This function tries to compare two
 |      expressions in an 'intelligent' manner. For example, it knows about
 |      commutitive operators and can ignore useless casts.
 |      
 |      equal_effect(self, r) -> bool
 |          @param r: the expression to compare against the current expression
 |                    (C++: const  cexpr_t  &)
 |          @return: true expressions can be considered equal
 |  
 |  find_num_op(self, *args)
 |      Find the operand with a numeric value.
 |  
 |  find_op(self, *args)
 |      Find the child with the specified operator.
 |      
 |      find_op(self, _op) -> cexpr_t
 |          @param _op (C++: ctype_t)
 |      
 |      
 |      find_op(self, _op) -> cexpr_t
 |          @param _op (C++: ctype_t)
 |  
 |  get_1num_op(self, *args)
 |      Get pointers to operands. at last one operand should be a number o1
 |      will be pointer to the number
 |      
 |      get_1num_op(self, o1, o2) -> bool
 |          @param o1 (C++: cexpr_t  **)
 |          @param o2 (C++: cexpr_t  **)
 |  
 |  get_const_value(self, *args)
 |      Get expression value.
 |  
 |  get_high_nbit_bound(self, *args)
 |      Get max number of bits that can really be used by the expression. For
 |      example, x % 16 can yield only 4 non-zero bits, higher bits are zero
 |  
 |  get_low_nbit_bound(self, *args)
 |      Get min number of bits that are certainly required to represent the
 |      expression. For example, constant 16 always uses 5 bits: 10000.
 |  
 |  get_ptr_or_array(self, *args)
 |      Find pointer or array child.
 |  
 |  get_type_sign(self, *args)
 |      Get expression sign.
 |  
 |  get_v(self, *args)
 |      get_v(self) -> var_ref_t
 |  
 |  has_side_effects(self, *args)
 |      Check if the expression has side effects. Calls, pre/post inc/dec, and
 |      assignments have side effects.
 |  
 |  is_call_arg_of(self, *args)
 |      Is call argument?
 |      
 |      is_call_arg_of(self, parent) -> bool
 |          @param parent (C++: const  citem_t  *)
 |          @return: true if our expression is a call argument of the specified
 |                   parent expression.
 |  
 |  is_call_object_of(self, *args)
 |      Is call object?
 |      
 |      is_call_object_of(self, parent) -> bool
 |          @param parent (C++: const  citem_t  *)
 |          @return: true if our expression is the call object of the specified
 |                   parent expression.
 |  
 |  is_child_of(self, *args)
 |      Verify if the specified item is our parent.
 |      
 |      is_child_of(self, parent) -> bool
 |          @param parent: possible parent item (C++: const  citem_t  *)
 |          @return: true if the specified item is our parent
 |  
 |  is_const_value(self, *args)
 |      Check if the expression is a number with the specified value.
 |      
 |      is_const_value(self, _v) -> bool
 |          @param _v (C++: uint64)
 |  
 |  is_cstr(self, *args)
 |      is_cstr(self) -> bool
 |  
 |  is_fpop(self, *args)
 |      is_fpop(self) -> bool
 |  
 |  is_jumpout(self, *args)
 |      is_jumpout(self) -> bool
 |  
 |  is_negative_const(self, *args)
 |      Check if the expression is a negative number.
 |  
 |  is_nice_cond(self, *args)
 |      Is nice condition?. Nice condition is a nice expression of the boolean
 |      type.
 |  
 |  is_nice_expr(self, *args)
 |      Is nice expression? Nice expressions do not contain comma operators,
 |      embedded statements, or labels.
 |  
 |  is_non_negative_const(self, *args)
 |      Check if the expression is a non-negative number.
 |  
 |  is_non_zero_const(self, *args)
 |      Check if the expression is a non-zero number.
 |  
 |  is_odd_lvalue(self, *args)
 |      is_odd_lvalue(self) -> bool
 |  
 |  is_type_signed(self, *args)
 |      Is expression signed?
 |  
 |  is_type_unsigned(self, *args)
 |      Is expression unsigned?
 |  
 |  is_undef_val(self, *args)
 |      is_undef_val(self) -> bool
 |  
 |  is_vftable(self, *args)
 |      is_vftable(self) -> bool
 |  
 |  is_zero_const(self, *args)
 |      Check if the expression is a zero.
 |  
 |  maybe_ptr(self, *args)
 |      May the expression be a pointer?
 |  
 |  numval(self, *args)
 |      Get numeric value of the expression. This function can be called only
 |      on cot_num expressions!
 |  
 |  print1(self, *args)
 |      Print expression into one line.
 |      
 |      print1(self, func)
 |          @param func: parent function. This argument is used to find out the
 |                       referenced variable names. (C++: const  cfunc_t  *)
 |  
 |  put_number(self, *args)
 |      Assign a number to the expression.
 |      
 |      put_number(self, func, value, nbytes, sign=no_sign)
 |          @param func: current function (C++: cfunc_t  *)
 |          @param value: number value (C++: uint64)
 |          @param nbytes: size of the number in bytes (C++: int)
 |          @param sign: number sign (C++: type_sign_t)
 |  
 |  requires_lvalue(self, *args)
 |      Check if the expression requires an lvalue.
 |      
 |      requires_lvalue(self, child) -> bool
 |          @param child: The function will check if this child of our expression
 |                        must be an lvalue. (C++: const  cexpr_t  *)
 |          @return: true if child must be an lvalue.
 |  
 |  set_cpadone(self, *args)
 |      set_cpadone(self)
 |  
 |  set_v(self, *args)
 |      set_v(self, v)
 |          v: var_ref_t const *
 |  
 |  set_vftable(self, *args)
 |      set_vftable(self)
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: cexpr_t  &)
 |  
 |  theother(self, *args)
 |      Get the other operand. This function returns the other operand (not
 |      the specified one) for binary expressions.
 |      
 |      theother(self, what) -> cexpr_t
 |          @param what (C++: const  cexpr_t  *)
 |      
 |      
 |      theother(self, what) -> cexpr_t
 |          @param what (C++: const  cexpr_t  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cexpr_t:
 |  
 |  a
 |  
 |  exflags
 |      cexpr_t_exflags_get(self) -> uint32
 |  
 |  fpc
 |  
 |  helper
 |  
 |  insn
 |  
 |  m
 |  
 |  n
 |  
 |  obj_ea
 |  
 |  operands
 |      return a dictionary with the operands of a cexpr_t.
 |  
 |  opname
 |  
 |  ptrsize
 |  
 |  refwidth
 |  
 |  string
 |  
 |  type
 |      cexpr_t_type_get(self) -> tinfo_t
 |  
 |  v
 |  
 |  x
 |  
 |  y
 |  
 |  z
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from cexpr_t:
 |  
 |  op_to_typename = {0: 'empty', 1: 'comma', 2: 'asg', 3: 'asgbor', 4: 'a...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args)
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args)
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _get_op(self, *args)
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args)
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args)
 |      _set_op(self, v)
 |          v: enum ctype_t
 |  
 |  contains_expr(self, *args)
 |      Does the item contain an expression?
 |      
 |      contains_expr(self, e) -> bool
 |          @param e (C++: const  cexpr_t  *)
 |  
 |  contains_label(self, *args)
 |      Does the item contain a label?
 |  
 |  find_closest_addr(self, *args)
 |      find_closest_addr(self, _ea) -> citem_t
 |          @param _ea (C++: ea_t)
 |  
 |  find_parent_of(self, *args)
 |      Find parent of the specified item.
 |      
 |      find_parent_of(self, sitem) -> citem_t
 |          @param sitem: Item to find the parent of. The search will be performed
 |                        among the children of the item pointed by  this . (C++:
 |                        const  citem_t  *)
 |          @return: NULL if not found
 |      
 |      
 |      find_parent_of(self, item) -> citem_t
 |          item: citem_t const *
 |          @return: NULL if not found
 |  
 |  is_expr(self, *args)
 |      Is an expression?
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cexpr
 |      citem_t_cexpr_get(self) -> cexpr_t
 |  
 |  cinsn
 |      citem_t_cinsn_get(self) -> cinsn_t
 |  
 |  ea
 |      citem_t_ea_get(self) -> ea_t
 |  
 |  index
 |      citem_t_index_get(self) -> int
 |  
 |  label_num
 |      citem_t_label_num_get(self) -> int
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on class carglist_t in module ida_hexrays:

class carglist_t(qvector_carg_t)
 |  Proxy of C++ carglist_t class.
 |  
 |  Method resolution order:
 |      carglist_t
 |      qvector_carg_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: carglist_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: carglist_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: carglist_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> carglist_t
 |          ftype: tinfo_t const &
 |          fl: int
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: carglist_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: carglist_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: carglist_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: carglist_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  flags
 |      carglist_t_flags_get(self) -> int
 |  
 |  functype
 |      carglist_t_functype_get(self) -> tinfo_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_carglist_t>
 |      delete_carglist_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_carg_t:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> carg_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: carg_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: carg_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: carg_t const &
 |  
 |  append = push_back(self, *args)
 |      push_back(self, x)
 |          x: carg_t const &
 |  
 |  at = __getitem__(self, *args)
 |      __getitem__(self, i) -> carg_t
 |          i: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> carg_t
 |      begin(self) -> carg_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> carg_t
 |      end(self) -> carg_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> carg_t
 |          it: qvector< carg_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> carg_t
 |          first: qvector< carg_t >::iterator
 |          last: qvector< carg_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> carg_t
 |  
 |  find(self, *args)
 |      find(self, x) -> carg_t
 |          x: carg_t const &
 |      
 |      
 |      find(self, x) -> carg_t
 |          x: carg_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=carg_t())
 |          x: carg_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: carg_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: carg_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> carg_t
 |          it: qvector< carg_t >::iterator
 |          x: carg_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: carg_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: carg_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< carg_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_carg_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class casm_t in module ida_hexrays:

class casm_t(ida_pro.eavec_t)↗
 |  Proxy of C++ casm_t class.
 |  
 |  Method resolution order:
 |      casm_t
 |      ida_pro.eavec_t↗
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: casm_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: casm_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: casm_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, ea) -> casm_t
 |          ea: ea_t
 |      
 |      
 |      __init__(self, r) -> casm_t
 |          r: casm_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: casm_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: casm_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: casm_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: casm_t const &
 |  
 |  one_insn(self, *args)
 |      one_insn(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_casm_t>
 |      delete_casm_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_pro.eavec_t:↗
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &↗
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: unsigned-ea-like-numeric-type const &↗
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: unsigned-ea-like-numeric-type const &↗
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: unsigned-ea-like-numeric-type const &↗
 |  
 |  append = push_back(self, *args)
 |      push_back(self, x)
 |          x: unsigned-ea-like-numeric-type const &↗
 |  
 |  at = __getitem__(self, *args)
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &↗
 |          i: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |      begin(self) -> qvector< unsigned-ea-like-numeric-type >::const_iterator↗
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |      end(self) -> qvector< unsigned-ea-like-numeric-type >::const_iterator↗
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |          it: qvector< unsigned-ea-like-numeric-type >::iterator↗
 |      
 |      
 |      erase(self, first, last) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |          first: qvector< unsigned-ea-like-numeric-type >::iterator↗
 |          last: qvector< unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  extract(self, *args)
 |      extract(self) -> unsigned-ea-like-numeric-type *↗
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |          x: unsigned-ea-like-numeric-type const &↗
 |      
 |      
 |      find(self, x) -> qvector< unsigned-ea-like-numeric-type >::const_iterator↗
 |          x: unsigned-ea-like-numeric-type const &↗
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: unsigned-ea-like-numeric-type const &↗
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: unsigned-ea-like-numeric-type *↗
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< unsigned-ea-like-numeric-type >::iterator↗
 |          it: qvector< unsigned-ea-like-numeric-type >::iterator↗
 |          x: unsigned-ea-like-numeric-type const &↗
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: unsigned-ea-like-numeric-type const &↗
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: unsigned-ea-like-numeric-type const &↗
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< unsigned-ea-like-numeric-type > &↗
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_pro.eavec_t:↗
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class cblock_t in module ida_hexrays:

class cblock_t(qlist_cinsn_t)
 |  Proxy of C++ cblock_t class.
 |  
 |  Method resolution order:
 |      cblock_t
 |      qlist_cinsn_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: cblock_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: cblock_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: cblock_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cblock_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: cblock_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: cblock_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: cblock_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: cblock_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cblock_t>
 |      delete_cblock_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qlist_cinsn_t:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> cinsn_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: cinsn_t const &
 |  
 |  at(self, index)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qlist_cinsn_t_iterator
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qlist_cinsn_t_iterator
 |  
 |  erase(self, *args)
 |      erase(self, p) -> qlist< cinsn_t >::iterator
 |          p: qlist< cinsn_t >::iterator
 |      
 |      
 |      erase(self, p1, p2)
 |          p1: qlist< cinsn_t >::iterator
 |          p2: qlist< cinsn_t >::iterator
 |      
 |      
 |      erase(self, p)
 |          p: qlist_cinsn_t_iterator
 |  
 |  find(self, item)
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  index(self, item)
 |  
 |  insert(self, *args)
 |      insert(self, p, x) -> qlist< cinsn_t >::iterator
 |          p: qlist< cinsn_t >::iterator
 |          x: cinsn_t const &
 |      
 |      
 |      insert(self, p) -> qlist< cinsn_t >::iterator
 |          p: qlist< cinsn_t >::iterator
 |      
 |      
 |      insert(self, i, v)
 |          i: size_t
 |          v: cinsn_t const &
 |      
 |      
 |      insert(self, p, x) -> qlist_cinsn_t_iterator
 |          p: qlist_cinsn_t_iterator
 |          x: cinsn_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  pop_front(self, *args)
 |      pop_front(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: cinsn_t const &
 |  
 |  push_front(self, *args)
 |      push_front(self, x)
 |          x: cinsn_t const &
 |  
 |  rbegin(self, *args)
 |      rbegin(self) -> qlist< cinsn_t >::reverse_iterator
 |      rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  remove(self, *args)
 |      remove(self, v) -> bool
 |          v: cinsn_t const &
 |  
 |  rend(self, *args)
 |      rend(self) -> qlist< cinsn_t >::reverse_iterator
 |      rend(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, x)
 |          x: qlist< cinsn_t > &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qlist_cinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class ccase_t in module ida_hexrays:

class ccase_t(cinsn_t)
 |  Proxy of C++ ccase_t class.
 |  
 |  Method resolution order:
 |      ccase_t
 |      cinsn_t
 |      citem_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: ccase_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: ccase_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: ccase_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ccase_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: ccase_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: ccase_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: ccase_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: ccase_t const &
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  value(self, *args)
 |      value(self, i) -> uint64 const &
 |          @param i (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  values
 |      ccase_t_values_get(self) -> ulonglongvec_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ccase_t>
 |      delete_ccase_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cinsn_t:
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  _get_casm(self, *args)
 |      _get_casm(self) -> casm_t
 |  
 |  _get_cblock(self, *args)
 |      _get_cblock(self) -> cblock_t
 |  
 |  _get_cdo(self, *args)
 |      _get_cdo(self) -> cdo_t
 |  
 |  _get_cexpr(self, *args)
 |      _get_cexpr(self) -> cexpr_t
 |  
 |  _get_cfor(self, *args)
 |      _get_cfor(self) -> cfor_t
 |  
 |  _get_cgoto(self, *args)
 |      _get_cgoto(self) -> cgoto_t
 |  
 |  _get_cif(self, *args)
 |      _get_cif(self) -> cif_t
 |  
 |  _get_creturn(self, *args)
 |      _get_creturn(self) -> creturn_t
 |  
 |  _get_cswitch(self, *args)
 |      _get_cswitch(self) -> cswitch_t
 |  
 |  _get_cwhile(self, *args)
 |      _get_cwhile(self) -> cwhile_t
 |  
 |  _print(self, *args)
 |      _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
 |          indent: int
 |          vp: vc_printer_t &
 |          use_curly: enum use_curly_t
 |  
 |  _register(self, *args)
 |      _register(self)
 |  
 |  _replace_by(self, *args)
 |      _replace_by(self, r)
 |          r: cinsn_t *
 |  
 |  _set_casm(self, *args)
 |      _set_casm(self, _v)
 |          _v: casm_t *
 |  
 |  _set_cblock(self, *args)
 |      _set_cblock(self, _v)
 |          _v: cblock_t *
 |  
 |  _set_cdo(self, *args)
 |      _set_cdo(self, _v)
 |          _v: cdo_t *
 |  
 |  _set_cexpr(self, *args)
 |      _set_cexpr(self, _v)
 |          _v: cexpr_t *
 |  
 |  _set_cfor(self, *args)
 |      _set_cfor(self, _v)
 |          _v: cfor_t *
 |  
 |  _set_cgoto(self, *args)
 |      _set_cgoto(self, _v)
 |          _v: cgoto_t *
 |  
 |  _set_cif(self, *args)
 |      _set_cif(self, _v)
 |          _v: cif_t *
 |  
 |  _set_creturn(self, *args)
 |      _set_creturn(self, _v)
 |          _v: creturn_t *
 |  
 |  _set_cswitch(self, *args)
 |      _set_cswitch(self, _v)
 |          _v: cswitch_t *
 |  
 |  _set_cwhile(self, *args)
 |      _set_cwhile(self, _v)
 |          _v: cwhile_t *
 |  
 |  assign(self, *args)
 |      assign(self, r) -> cinsn_t
 |          @param r (C++: const  cinsn_t  &)
 |  
 |  cleanup(self, *args)
 |      Cleanup the statement. This function properly deletes all children and
 |      sets the item type to cit_empty.
 |  
 |  collect_free_breaks(self, *args)
 |      Collect free 'break' statements. This function finds all free 'break'
 |      statements within the current statement. A 'break' statement is free
 |      if it does not have a loop or switch parent that that is also within
 |      the current statement.
 |      
 |      collect_free_breaks(self, breaks) -> bool
 |          @param breaks: pointer to the variable where the vector of all found
 |                         free  break  statements is returned. This argument can
 |                         be NULL. (C++: cinsnptrvec_t  *)
 |          @return: true if some free  break  statements have been found
 |  
 |  collect_free_continues(self, *args)
 |      Collect free 'continue' statements. This function finds all free
 |      'continue' statements within the current statement. A 'continue'
 |      statement is free if it does not have a loop parent that that is also
 |      within the current statement.
 |      
 |      collect_free_continues(self, continues) -> bool
 |          @param continues: pointer to the variable where the vector of all
 |                            found free  continue  statements is returned. This
 |                            argument can be NULL. (C++: cinsnptrvec_t  *)
 |          @return: true if some free  continue  statements have been found
 |  
 |  contains_free_break(self, *args)
 |      Check if the statement has free 'break' statements.
 |  
 |  contains_free_continue(self, *args)
 |      Check if the statement has free 'continue' statements.
 |  
 |  contains_insn(self, *args)
 |      Check if the statement contains a statement of the specified type.
 |      
 |      contains_insn(self, type, times=1) -> bool
 |          @param type: statement opcode to look for (C++: ctype_t)
 |          @param times: how many times TYPE should be present (C++: int)
 |          @return: true if the statement has at least TIMES children with opcode
 |                   == TYPE
 |  
 |  create_if(self, *args)
 |      Create a new if-statement. The current statement must be a block. The
 |      new statement will be appended to it.
 |      
 |      create_if(self, cnd) -> cif_t
 |          @param cnd: if condition. It will be deleted after being copied. (C++:
 |                      cexpr_t  *)
 |  
 |  is_epilog(self)
 |  
 |  is_ordinary_flow(self, *args)
 |      Check if the statement passes execution to the next statement.
 |  
 |  new_insn(self, *args)
 |      Create a new statement. The current statement must be a block. The new
 |      statement will be appended to it.
 |      
 |      new_insn(self, insn_ea) -> cinsn_t
 |          @param insn_ea: statement address (C++: ea_t)
 |  
 |  print1(self, *args)
 |      Print the statement into one line. Currently this function is not
 |      available.
 |      
 |      print1(self, func)
 |          @param func: parent function. This argument is used to find out the
 |                       referenced variable names. (C++: const  cfunc_t  *)
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: cinsn_t  &)
 |  
 |  zero(self, *args)
 |      Overwrite with zeroes without cleaning memory or deleting children.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from cinsn_t:
 |  
 |  insn_is_epilog(*args)
 |      insn_is_epilog(insn) -> bool
 |          insn: cinsn_t const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cinsn_t:
 |  
 |  casm
 |  
 |  cblock
 |  
 |  cdo
 |  
 |  cexpr
 |  
 |  cfor
 |  
 |  cgoto
 |  
 |  cif
 |  
 |  creturn
 |  
 |  cswitch
 |  
 |  cwhile
 |  
 |  details
 |      return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.
 |  
 |  opname
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from cinsn_t:
 |  
 |  op_to_typename = {70: 'empty', 71: 'block', 72: 'expr', 73: 'if', 74: ...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args)
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args)
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _get_op(self, *args)
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args)
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args)
 |      _set_op(self, v)
 |          v: enum ctype_t
 |  
 |  contains_expr(self, *args)
 |      Does the item contain an expression?
 |      
 |      contains_expr(self, e) -> bool
 |          @param e (C++: const  cexpr_t  *)
 |  
 |  contains_label(self, *args)
 |      Does the item contain a label?
 |  
 |  find_closest_addr(self, *args)
 |      find_closest_addr(self, _ea) -> citem_t
 |          @param _ea (C++: ea_t)
 |  
 |  find_parent_of(self, *args)
 |      Find parent of the specified item.
 |      
 |      find_parent_of(self, sitem) -> citem_t
 |          @param sitem: Item to find the parent of. The search will be performed
 |                        among the children of the item pointed by  this . (C++:
 |                        const  citem_t  *)
 |          @return: NULL if not found
 |      
 |      
 |      find_parent_of(self, item) -> citem_t
 |          item: citem_t const *
 |          @return: NULL if not found
 |  
 |  is_expr(self, *args)
 |      Is an expression?
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cinsn
 |      citem_t_cinsn_get(self) -> cinsn_t
 |  
 |  ea
 |      citem_t_ea_get(self) -> ea_t
 |  
 |  index
 |      citem_t_index_get(self) -> int
 |  
 |  label_num
 |      citem_t_label_num_get(self) -> int
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on class ccases_t in module ida_hexrays:

class ccases_t(qvector_ccase_t)
 |  Proxy of C++ ccases_t class.
 |  
 |  Method resolution order:
 |      ccases_t
 |      qvector_ccase_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: ccases_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: ccases_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: ccases_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ccases_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: ccases_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: ccases_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: ccases_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: ccases_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ccases_t>
 |      delete_ccases_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_ccase_t:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> ccase_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: ccase_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: ccase_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: ccase_t const &
 |  
 |  append = push_back(self, *args)
 |      push_back(self, x)
 |          x: ccase_t const &
 |  
 |  at = __getitem__(self, *args)
 |      __getitem__(self, i) -> ccase_t
 |          i: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> ccase_t
 |      begin(self) -> ccase_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> ccase_t
 |      end(self) -> ccase_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> ccase_t
 |          it: qvector< ccase_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> ccase_t
 |          first: qvector< ccase_t >::iterator
 |          last: qvector< ccase_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> ccase_t
 |  
 |  find(self, *args)
 |      find(self, x) -> ccase_t
 |          x: ccase_t const &
 |      
 |      
 |      find(self, x) -> ccase_t
 |          x: ccase_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=ccase_t())
 |          x: ccase_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: ccase_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: ccase_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> ccase_t
 |          it: qvector< ccase_t >::iterator
 |          x: ccase_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: ccase_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: ccase_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< ccase_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_ccase_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class cdg_insn_iterator_t in module ida_hexrays:

class cdg_insn_iterator_t(__builtin__.object)
 |  Proxy of C++ cdg_insn_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, mba_) -> cdg_insn_iterator_t
 |          mba_: mba_t const *
 |      
 |      
 |      __init__(self, r) -> cdg_insn_iterator_t
 |          r: cdg_insn_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  dslot_with_xrefs(self, *args)
 |      dslot_with_xrefs(self) -> bool
 |  
 |  has_dslot(self, *args)
 |      has_dslot(self) -> bool
 |  
 |  is_severed_dslot(self, *args)
 |      is_severed_dslot(self) -> bool
 |  
 |  next(self, *args)
 |      next(self, ins) -> merror_t
 |          @param ins (C++: insn_t  *)
 |  
 |  ok(self, *args)
 |      ok(self) -> bool
 |  
 |  start(self, *args)
 |      start(self, rng)
 |          @param rng (C++: const  range_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dslot
 |      cdg_insn_iterator_t_dslot_get(self) -> ea_t
 |  
 |  dslot_insn
 |      cdg_insn_iterator_t_dslot_insn_get(self) -> insn_t *
 |  
 |  ea
 |      cdg_insn_iterator_t_ea_get(self) -> ea_t
 |  
 |  end
 |      cdg_insn_iterator_t_end_get(self) -> ea_t
 |  
 |  is_likely_dslot
 |      cdg_insn_iterator_t_is_likely_dslot_get(self) -> bool
 |  
 |  mba
 |      cdg_insn_iterator_t_mba_get(self) -> mba_t
 |  
 |  severed_branch
 |      cdg_insn_iterator_t_severed_branch_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cdg_insn_iterator_t>
 |      delete_cdg_insn_iterator_t(self)

Help on class cdo_t in module ida_hexrays:

class cdo_t(cloop_t)
 |  Proxy of C++ cdo_t class.
 |  
 |  Method resolution order:
 |      cdo_t
 |      cloop_t
 |      ceinsn_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: cdo_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: cdo_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: cdo_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cdo_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: cdo_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: cdo_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: cdo_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: cdo_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cdo_t>
 |      delete_cdo_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cloop_t:
 |  
 |  assign(self, *args)
 |      assign(self, r) -> cloop_t
 |          @param r (C++: const  cloop_t  &)
 |  
 |  cleanup(self, *args)
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cloop_t:
 |  
 |  body
 |      cloop_t_body_get(self) -> cinsn_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on class ceinsn_t in module ida_hexrays:

class ceinsn_t(__builtin__.object)
 |  Proxy of C++ ceinsn_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ceinsn_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ceinsn_t>
 |      delete_ceinsn_t(self)

Help on function cexpr_operands in module ida_hexrays:

cexpr_operands(self)
    return a dictionary with the operands of a cexpr_t.

Help on class cexpr_t in module ida_hexrays:

class cexpr_t(citem_t)
 |  Proxy of C++ cexpr_t class.
 |  
 |  Method resolution order:
 |      cexpr_t
 |      citem_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: cexpr_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: cexpr_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: cexpr_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cexpr_t
 |          cop: enum ctype_t
 |          _x: cexpr_t *
 |      
 |      
 |      __init__(self, cop, _x, _y) -> cexpr_t
 |          cop: enum ctype_t
 |          _x: cexpr_t *
 |          _y: cexpr_t *
 |      
 |      
 |      __init__(self, cop, _x, _y, _z) -> cexpr_t
 |          cop: enum ctype_t
 |          _x: cexpr_t *
 |          _y: cexpr_t *
 |          _z: cexpr_t *
 |      
 |      
 |      __init__(self, r) -> cexpr_t
 |          r: cexpr_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: cexpr_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: cexpr_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: cexpr_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  _get_a(self, *args)
 |      _get_a(self) -> carglist_t
 |  
 |  _get_fpc(self, *args)
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_helper(self, *args)
 |      _get_helper(self) -> char *
 |  
 |  _get_insn(self, *args)
 |      _get_insn(self) -> cinsn_t
 |  
 |  _get_m(self, *args)
 |      _get_m(self) -> int
 |  
 |  _get_n(self, *args)
 |      _get_n(self) -> cnumber_t
 |  
 |  _get_obj_ea(self, *args)
 |      _get_obj_ea(self) -> ea_t
 |  
 |  _get_ptrsize(self, *args)
 |      _get_ptrsize(self) -> int
 |  
 |  _get_refwidth(self, *args)
 |      _get_refwidth(self) -> int
 |  
 |  _get_string(self, *args)
 |      _get_string(self) -> char *
 |  
 |  _get_x(self, *args)
 |      _get_x(self) -> cexpr_t
 |  
 |  _get_y(self, *args)
 |      _get_y(self) -> cexpr_t
 |  
 |  _get_z(self, *args)
 |      _get_z(self) -> cexpr_t
 |  
 |  _register(self, *args)
 |      _register(self)
 |  
 |  _replace_by(self, *args)
 |      _replace_by(self, r)
 |          r: cexpr_t *
 |  
 |  _set_a(self, *args)
 |      _set_a(self, _v)
 |          _v: carglist_t *
 |  
 |  _set_fpc(self, *args)
 |      _set_fpc(self, _v)
 |          _v: fnumber_t *
 |  
 |  _set_helper(self, *args)
 |      _set_helper(self, _v)
 |          _v: char *
 |  
 |  _set_insn(self, *args)
 |      _set_insn(self, _v)
 |          _v: cinsn_t *
 |  
 |  _set_m(self, *args)
 |      _set_m(self, _v)
 |          _v: int
 |  
 |  _set_n(self, *args)
 |      _set_n(self, _v)
 |          _v: cnumber_t *
 |  
 |  _set_obj_ea(self, *args)
 |      _set_obj_ea(self, _v)
 |          _v: ea_t
 |  
 |  _set_ptrsize(self, *args)
 |      _set_ptrsize(self, _v)
 |          _v: int
 |  
 |  _set_refwidth(self, *args)
 |      _set_refwidth(self, _v)
 |          _v: int
 |  
 |  _set_string(self, *args)
 |      _set_string(self, _v)
 |          _v: char *
 |  
 |  _set_x(self, *args)
 |      _set_x(self, _v)
 |          _v: cexpr_t *
 |  
 |  _set_y(self, *args)
 |      _set_y(self, _v)
 |          _v: cexpr_t *
 |  
 |  _set_z(self, *args)
 |      _set_z(self, _v)
 |          _v: cexpr_t *
 |  
 |  assign(self, *args)
 |      assign(self, r) -> cexpr_t
 |          @param r (C++: const  cexpr_t  &)
 |  
 |  calc_type(self, *args)
 |      Calculate the type of the expression. Use this function to calculate
 |      the expression type when a new expression is built
 |      
 |      calc_type(self, recursive)
 |          @param recursive: if true, types of all children expression will be
 |                            calculated before calculating our type (C++: bool)
 |  
 |  cleanup(self, *args)
 |      Cleanup the expression. This function properly deletes all children
 |      and sets the item type to cot_empty.
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: cexpr_t const &
 |  
 |  contains_comma(self, *args)
 |      Does the expression contain a comma operator?
 |      
 |      contains_comma(self, times=1) -> bool
 |          @param times (C++: int)
 |  
 |  contains_comma_or_insn_or_label(self, *args)
 |      Does the expression contain a comma operator or an embedded statement
 |      operator or a label?
 |      
 |      contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
 |          @param maxcommas (C++: int)
 |  
 |  contains_insn(self, *args)
 |      Does the expression contain an embedded statement operator?
 |      
 |      contains_insn(self, times=1) -> bool
 |          @param times (C++: int)
 |  
 |  contains_insn_or_label(self, *args)
 |      Does the expression contain an embedded statement operator or a label?
 |  
 |  contains_operator(self, *args)
 |      Check if the expression contains the specified operator.
 |      
 |      contains_operator(self, needed_op, times=1) -> bool
 |          @param needed_op: operator code to search for (C++: ctype_t)
 |          @param times: how many times the operator code should be present (C++:
 |                        int)
 |          @return: true if the expression has at least TIMES children with
 |                   NEEDED_OP
 |  
 |  cpadone(self, *args)
 |      Pointer arithmetic correction done for this expression?
 |  
 |  equal_effect(self, *args)
 |      Compare two expressions. This function tries to compare two
 |      expressions in an 'intelligent' manner. For example, it knows about
 |      commutitive operators and can ignore useless casts.
 |      
 |      equal_effect(self, r) -> bool
 |          @param r: the expression to compare against the current expression
 |                    (C++: const  cexpr_t  &)
 |          @return: true expressions can be considered equal
 |  
 |  find_num_op(self, *args)
 |      Find the operand with a numeric value.
 |  
 |  find_op(self, *args)
 |      Find the child with the specified operator.
 |      
 |      find_op(self, _op) -> cexpr_t
 |          @param _op (C++: ctype_t)
 |      
 |      
 |      find_op(self, _op) -> cexpr_t
 |          @param _op (C++: ctype_t)
 |  
 |  get_1num_op(self, *args)
 |      Get pointers to operands. at last one operand should be a number o1
 |      will be pointer to the number
 |      
 |      get_1num_op(self, o1, o2) -> bool
 |          @param o1 (C++: cexpr_t  **)
 |          @param o2 (C++: cexpr_t  **)
 |  
 |  get_const_value(self, *args)
 |      Get expression value.
 |  
 |  get_high_nbit_bound(self, *args)
 |      Get max number of bits that can really be used by the expression. For
 |      example, x % 16 can yield only 4 non-zero bits, higher bits are zero
 |  
 |  get_low_nbit_bound(self, *args)
 |      Get min number of bits that are certainly required to represent the
 |      expression. For example, constant 16 always uses 5 bits: 10000.
 |  
 |  get_ptr_or_array(self, *args)
 |      Find pointer or array child.
 |  
 |  get_type_sign(self, *args)
 |      Get expression sign.
 |  
 |  get_v(self, *args)
 |      get_v(self) -> var_ref_t
 |  
 |  has_side_effects(self, *args)
 |      Check if the expression has side effects. Calls, pre/post inc/dec, and
 |      assignments have side effects.
 |  
 |  is_call_arg_of(self, *args)
 |      Is call argument?
 |      
 |      is_call_arg_of(self, parent) -> bool
 |          @param parent (C++: const  citem_t  *)
 |          @return: true if our expression is a call argument of the specified
 |                   parent expression.
 |  
 |  is_call_object_of(self, *args)
 |      Is call object?
 |      
 |      is_call_object_of(self, parent) -> bool
 |          @param parent (C++: const  citem_t  *)
 |          @return: true if our expression is the call object of the specified
 |                   parent expression.
 |  
 |  is_child_of(self, *args)
 |      Verify if the specified item is our parent.
 |      
 |      is_child_of(self, parent) -> bool
 |          @param parent: possible parent item (C++: const  citem_t  *)
 |          @return: true if the specified item is our parent
 |  
 |  is_const_value(self, *args)
 |      Check if the expression is a number with the specified value.
 |      
 |      is_const_value(self, _v) -> bool
 |          @param _v (C++: uint64)
 |  
 |  is_cstr(self, *args)
 |      is_cstr(self) -> bool
 |  
 |  is_fpop(self, *args)
 |      is_fpop(self) -> bool
 |  
 |  is_jumpout(self, *args)
 |      is_jumpout(self) -> bool
 |  
 |  is_negative_const(self, *args)
 |      Check if the expression is a negative number.
 |  
 |  is_nice_cond(self, *args)
 |      Is nice condition?. Nice condition is a nice expression of the boolean
 |      type.
 |  
 |  is_nice_expr(self, *args)
 |      Is nice expression? Nice expressions do not contain comma operators,
 |      embedded statements, or labels.
 |  
 |  is_non_negative_const(self, *args)
 |      Check if the expression is a non-negative number.
 |  
 |  is_non_zero_const(self, *args)
 |      Check if the expression is a non-zero number.
 |  
 |  is_odd_lvalue(self, *args)
 |      is_odd_lvalue(self) -> bool
 |  
 |  is_type_signed(self, *args)
 |      Is expression signed?
 |  
 |  is_type_unsigned(self, *args)
 |      Is expression unsigned?
 |  
 |  is_undef_val(self, *args)
 |      is_undef_val(self) -> bool
 |  
 |  is_vftable(self, *args)
 |      is_vftable(self) -> bool
 |  
 |  is_zero_const(self, *args)
 |      Check if the expression is a zero.
 |  
 |  maybe_ptr(self, *args)
 |      May the expression be a pointer?
 |  
 |  numval(self, *args)
 |      Get numeric value of the expression. This function can be called only
 |      on cot_num expressions!
 |  
 |  print1(self, *args)
 |      Print expression into one line.
 |      
 |      print1(self, func)
 |          @param func: parent function. This argument is used to find out the
 |                       referenced variable names. (C++: const  cfunc_t  *)
 |  
 |  put_number(self, *args)
 |      Assign a number to the expression.
 |      
 |      put_number(self, func, value, nbytes, sign=no_sign)
 |          @param func: current function (C++: cfunc_t  *)
 |          @param value: number value (C++: uint64)
 |          @param nbytes: size of the number in bytes (C++: int)
 |          @param sign: number sign (C++: type_sign_t)
 |  
 |  requires_lvalue(self, *args)
 |      Check if the expression requires an lvalue.
 |      
 |      requires_lvalue(self, child) -> bool
 |          @param child: The function will check if this child of our expression
 |                        must be an lvalue. (C++: const  cexpr_t  *)
 |          @return: true if child must be an lvalue.
 |  
 |  set_cpadone(self, *args)
 |      set_cpadone(self)
 |  
 |  set_v(self, *args)
 |      set_v(self, v)
 |          v: var_ref_t const *
 |  
 |  set_vftable(self, *args)
 |      set_vftable(self)
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: cexpr_t  &)
 |  
 |  theother(self, *args)
 |      Get the other operand. This function returns the other operand (not
 |      the specified one) for binary expressions.
 |      
 |      theother(self, what) -> cexpr_t
 |          @param what (C++: const  cexpr_t  *)
 |      
 |      
 |      theother(self, what) -> cexpr_t
 |          @param what (C++: const  cexpr_t  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  a
 |  
 |  exflags
 |      cexpr_t_exflags_get(self) -> uint32
 |  
 |  fpc
 |  
 |  helper
 |  
 |  insn
 |  
 |  m
 |  
 |  n
 |  
 |  obj_ea
 |  
 |  operands
 |      return a dictionary with the operands of a cexpr_t.
 |  
 |  opname
 |  
 |  ptrsize
 |  
 |  refwidth
 |  
 |  string
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      cexpr_t_type_get(self) -> tinfo_t
 |  
 |  v
 |  
 |  x
 |  
 |  y
 |  
 |  z
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cexpr_t>
 |      delete_cexpr_t(self)
 |  
 |  op_to_typename = {0: 'empty', 1: 'comma', 2: 'asg', 3: 'asgbor', 4: 'a...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args)
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args)
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _get_op(self, *args)
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args)
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args)
 |      _set_op(self, v)
 |          v: enum ctype_t
 |  
 |  contains_expr(self, *args)
 |      Does the item contain an expression?
 |      
 |      contains_expr(self, e) -> bool
 |          @param e (C++: const  cexpr_t  *)
 |  
 |  contains_label(self, *args)
 |      Does the item contain a label?
 |  
 |  find_closest_addr(self, *args)
 |      find_closest_addr(self, _ea) -> citem_t
 |          @param _ea (C++: ea_t)
 |  
 |  find_parent_of(self, *args)
 |      Find parent of the specified item.
 |      
 |      find_parent_of(self, sitem) -> citem_t
 |          @param sitem: Item to find the parent of. The search will be performed
 |                        among the children of the item pointed by  this . (C++:
 |                        const  citem_t  *)
 |          @return: NULL if not found
 |      
 |      
 |      find_parent_of(self, item) -> citem_t
 |          item: citem_t const *
 |          @return: NULL if not found
 |  
 |  is_expr(self, *args)
 |      Is an expression?
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cexpr
 |      citem_t_cexpr_get(self) -> cexpr_t
 |  
 |  cinsn
 |      citem_t_cinsn_get(self) -> cinsn_t
 |  
 |  ea
 |      citem_t_ea_get(self) -> ea_t
 |  
 |  index
 |      citem_t_index_get(self) -> int
 |  
 |  label_num
 |      citem_t_label_num_get(self) -> int
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on class cfor_t in module ida_hexrays:

class cfor_t(cloop_t)
 |  Proxy of C++ cfor_t class.
 |  
 |  Method resolution order:
 |      cfor_t
 |      cloop_t
 |      ceinsn_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: cfor_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: cfor_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: cfor_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cfor_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: cfor_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: cfor_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: cfor_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: cfor_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  init
 |      cfor_t_init_get(self) -> cexpr_t
 |  
 |  step
 |      cfor_t_step_get(self) -> cexpr_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cfor_t>
 |      delete_cfor_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cloop_t:
 |  
 |  assign(self, *args)
 |      assign(self, r) -> cloop_t
 |          @param r (C++: const  cloop_t  &)
 |  
 |  cleanup(self, *args)
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cloop_t:
 |  
 |  body
 |      cloop_t_body_get(self) -> cinsn_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on class cfunc_parentee_t in module ida_hexrays:

class cfunc_parentee_t(ctree_parentee_t)
 |  Proxy of C++ cfunc_parentee_t class.
 |  
 |  Method resolution order:
 |      cfunc_parentee_t
 |      ctree_parentee_t
 |      ctree_visitor_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, f, post=False) -> cfunc_parentee_t
 |          f: cfunc_t *
 |          post: bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  calc_rvalue_type(self, *args)
 |      Calculate rvalue type. This function tries to determine the type of
 |      the specified item based on its context. For example, if the current
 |      expression is the right side of an assignment operator, the type of
 |      its left side will be returned. This function can be used to determine
 |      the 'best' type of the specified expression.
 |      
 |      calc_rvalue_type(self, target, e) -> bool
 |          @param target: 'best' type of the expression will be returned here
 |                         (C++: tinfo_t  *)
 |          @param e: expression to determine the desired type (C++: const
 |                    cexpr_t  *)
 |          @return: false if failed
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  func
 |      cfunc_parentee_t_func_get(self) -> cfunc_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cfunc_parentee_t>
 |      delete_cfunc_parentee_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctree_parentee_t:
 |  
 |  recalc_parent_types(self, *args)
 |      Recalculate types of parent node. If a node type has been changed, the
 |      visitor must recalculate all parent types, otherwise the ctree becomes
 |      inconsistent. If during this recalculation a parent node is
 |      added/deleted, this function returns true. In this case it is
 |      recommended to restart the traversal because the information about
 |      parent nodes is stale.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctree_visitor_t:
 |  
 |  apply_to(self, *args)
 |      Traverse ctree. The traversal will start at the specified item and
 |      continue until of one the visit_...() functions return a non-zero
 |      value.
 |      
 |      apply_to(self, item, parent) -> int
 |          @param item: root of the ctree to traverse (C++: citem_t  *)
 |          @param parent: parent of the specified item. can be specified as NULL.
 |                         (C++: citem_t  *)
 |          @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  apply_to_exprs(self, *args)
 |      Traverse only expressions. The traversal will start at the specified
 |      item and continue until of one the visit_...() functions return a non-
 |      zero value.
 |      
 |      apply_to_exprs(self, item, parent) -> int
 |          @param item: root of the ctree to traverse (C++: citem_t  *)
 |          @param parent: parent of the specified item. can be specified as NULL.
 |                         (C++: citem_t  *)
 |          @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  clr_prune(self, *args)
 |      Do not prune children. This is an internal function, no need to call
 |      it.
 |  
 |  clr_restart(self, *args)
 |      Do not restart. This is an internal function, no need to call it.
 |  
 |  is_postorder(self, *args)
 |      Should the leave...() functions be called?
 |  
 |  leave_expr(self, *args)
 |      Visit an expression after having visited its children This is a
 |      visitor function which should be overridden by a derived class to do
 |      some useful work. This visitor performs post-order traserval, i.e. an
 |      item is visited after its children.
 |      
 |      leave_expr(self, arg0) -> int
 |          arg0: cexpr_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  leave_insn(self, *args)
 |      Visit a statement after having visited its children This is a visitor
 |      function which should be overridden by a derived class to do some
 |      useful work. This visitor performs post-order traserval, i.e. an item
 |      is visited after its children.
 |      
 |      leave_insn(self, arg0) -> int
 |          arg0: cinsn_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  maintain_parents(self, *args)
 |      Should the parent information by maintained?
 |  
 |  must_prune(self, *args)
 |      Should the traversal skip the children of the current item?
 |  
 |  must_restart(self, *args)
 |      Should the traversal restart?
 |  
 |  only_insns(self, *args)
 |      Should all expressions be automatically pruned?
 |  
 |  parent_expr(self, *args)
 |      Get parent of the current item as an expression.
 |  
 |  parent_insn(self, *args)
 |      Get parent of the current item as a statement.
 |  
 |  prune_now(self, *args)
 |      Prune children. This function may be called by a visitor() to skip all
 |      children of the current item.
 |  
 |  set_restart(self, *args)
 |      Restart the travesal. Meaningful only in 'apply_to_exprs()'
 |  
 |  visit_expr(self, *args)
 |      Visit an expression. This is a visitor function which should be
 |      overridden by a derived class to do some useful work. This visitor
 |      performs pre-order traserval, i.e. an item is visited before its
 |      children.
 |      
 |      visit_expr(self, arg0) -> int
 |          arg0: cexpr_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  visit_insn(self, *args)
 |      Visit a statement. This is a visitor function which should be
 |      overridden by a derived class to do some useful work. This visitor
 |      performs pre-order traserval, i.e. an item is visited before its
 |      children.
 |      
 |      visit_insn(self, arg0) -> int
 |          arg0: cinsn_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ctree_visitor_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cv_flags
 |      ctree_visitor_t_cv_flags_get(self) -> int
 |  
 |  parents
 |      ctree_visitor_t_parents_get(self) -> ctree_items_t

Help on class cfunc_t in module ida_hexrays:

class cfunc_t(__builtin__.object)
 |  Proxy of C++ cfunc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args)
 |      __str__(self) -> qstring
 |  
 |  build_c_tree(self, *args)
 |      Generate the function body. This function (re)generates the function
 |      body from the underlying microcode.
 |  
 |  del_orphan_cmts(self, *args)
 |      Delete all orphan comments. The 'save_user_cmts()' function must be
 |      called after this call.
 |  
 |  find_item_coords(self, *args)
 |      find_item_coords(self, item, px, py) -> bool
 |          @param item (C++: const  citem_t  *)
 |          @param px (C++: int *)
 |          @param py (C++: int *)
 |      
 |      
 |      find_item_coords(self, item) -> PyObject *
 |          @param item (C++: const  citem_t  *)
 |  
 |  find_label(self, *args)
 |      Find the label.
 |      
 |      find_label(self, label) -> citem_t
 |          @param label (C++: int)
 |          @return: pointer to the ctree item with the specified label number.
 |  
 |  gather_derefs(self, *args)
 |      gather_derefs(self, ci, udm=None) -> bool
 |          @param ci (C++: const  ctree_item_t  &)
 |          @param udm (C++: udt_type_data_t  *)
 |  
 |  get_boundaries(self, *args)
 |      Get pointer to map of instruction boundaries. This function
 |      initializes the boundary map if not done yet.
 |  
 |  get_eamap(self, *args)
 |      Get pointer to ea->insn map. This function initializes eamap if not
 |      done yet.
 |  
 |  get_func_type(self, *args)
 |      Get the function type.
 |      
 |      get_func_type(self, type) -> bool
 |          @param type: variable where the function type is returned (C++:
 |                       tinfo_t  *)
 |          @return: false if failure
 |  
 |  get_line_item(self, *args)
 |      Get ctree item for the specified cursor position.
 |      'vdui_t::get_current_item()'
 |      
 |      get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
 |          @param line: line of decompilation text (element of  sv ) (C++: const
 |                       char *)
 |          @param x: x cursor coordinate in the line (C++: int)
 |          @param is_ctree_line: does the line belong to statement area? (if not,
 |                                it is assumed to belong to the declaration area)
 |                                (C++: bool)
 |          @param phead: ptr to the first item on the line (used to attach block
 |                        comments). May be NULL (C++: ctree_item_t  *)
 |          @param pitem: ptr to the current item. May be NULL (C++: ctree_item_t
 |                        *)
 |          @param ptail: ptr to the last item on the line (used to attach
 |                        indented comments). May be NULL (C++: ctree_item_t  *)
 |          @return: false if failed to get the current item
 |  
 |  get_lvars(self, *args)
 |      Get vector of local variables.
 |  
 |  get_pseudocode(self, *args)
 |      Get pointer to decompilation output: the pseudocode. This function
 |      generates pseudocode if not done yet.
 |  
 |  get_stkoff_delta(self, *args)
 |      Get stack offset delta. The local variable stack offsets retrieved by
 |      v.location.stkoff() should be adjusted before being used as stack
 |      frame offsets in IDA.
 |  
 |  get_user_cmt(self, *args)
 |      Retrieve a user defined comment.
 |      
 |      get_user_cmt(self, loc, rt) -> char const *
 |          @param loc: ctree location (C++: const  treeloc_t  &)
 |          @param rt: should already retrieved comments retrieved again? (C++:
 |                     cmt_retrieval_type_t)
 |          @return: pointer to the comment string or NULL
 |  
 |  get_user_iflags(self, *args)
 |      Retrieve citem iflags.
 |      
 |      get_user_iflags(self, loc) -> int32
 |          @param loc: citem locator (C++: const  citem_locator_t  &)
 |          @return: ctree item iflags bits  or 0
 |  
 |  get_user_union_selection(self, *args)
 |      Retrieve a user defined union field selection.
 |      
 |      get_user_union_selection(self, ea, path) -> bool
 |          @param ea: address (C++: ea_t)
 |          @param path: out: path describing the union selection. (C++: intvec_t
 |                       *)
 |          @return: pointer to the path or NULL
 |  
 |  get_warnings(self, *args)
 |      Get information about decompilation warnings.
 |  
 |  has_orphan_cmts(self, *args)
 |      Check if there are orphan comments.
 |  
 |  locked(self, *args)
 |      locked(self) -> bool
 |  
 |  print_dcl(self, *args)
 |      Print function prototype.
 |  
 |  print_func(self, *args)
 |      Print function text.
 |      
 |      print_func(self, vp)
 |          @param vp: printer helper class to receive the generated text. (C++:
 |                     vc_printer_t  &)
 |  
 |  refresh_func_ctext(self, *args)
 |      Refresh ctext after a ctree modification. This function informs the
 |      decompiler that ctree ( 'body' ) have been modified and ctext ( 'sv' )
 |      does not correspond to it anymore. It also refreshes the pseudocode
 |      windows if there is any.
 |  
 |  release(self, *args)
 |      release(self)
 |  
 |  remove_unused_labels(self, *args)
 |      Remove unused labels. This function check what labels are really used
 |      by the function and removes the unused ones.
 |  
 |  save_user_cmts(self, *args)
 |      Save user-defined comments into the database.
 |  
 |  save_user_iflags(self, *args)
 |      Save user-defined iflags into the database.
 |  
 |  save_user_labels(self, *args)
 |      Save user-defined labels into the database.
 |  
 |  save_user_numforms(self, *args)
 |      Save user-defined number formats into the database.
 |  
 |  save_user_unions(self, *args)
 |      Save user-defined union field selections into the database.
 |  
 |  set_user_cmt(self, *args)
 |      Set a user defined comment. This function stores the specified comment
 |      in the 'cfunc_t' structure. The 'save_user_cmts()' function must be
 |      called after it.
 |      
 |      set_user_cmt(self, loc, cmt)
 |          @param loc: ctree location (C++: const  treeloc_t  &)
 |          @param cmt: new comment. if empty or NULL, then an existing comment is
 |                      deleted. (C++: const char *)
 |  
 |  set_user_iflags(self, *args)
 |      Set citem iflags.
 |      
 |      set_user_iflags(self, loc, iflags)
 |          @param loc: citem locator (C++: const  citem_locator_t  &)
 |          @param iflags: new iflags (C++: int32)
 |  
 |  set_user_union_selection(self, *args)
 |      Set a union field selection. The 'save_user_unions()' function must be
 |      called after calling this function.
 |      
 |      set_user_union_selection(self, ea, path)
 |          @param ea: address (C++: ea_t)
 |          @param path: in: path describing the union selection. (C++: const
 |                       intvec_t  &)
 |  
 |  verify(self, *args)
 |      Verify the ctree. This function verifies the ctree. If the ctree is
 |      malformed, an internal error is generated. Use it to verify the ctree
 |      after your modifications.
 |      
 |      verify(self, aul, even_without_debugger)
 |          @param aul: Are unused labels acceptable? (C++: allow_unused_labels_t)
 |          @param even_without_debugger: if false and there is no debugger, the
 |                                        verification will be skipped (C++: bool)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  argidx
 |      cfunc_t_argidx_get(self) -> intvec_t
 |  
 |  arguments
 |  
 |  body
 |      cfunc_t_body_get(self) -> cinsn_t
 |  
 |  boundaries
 |      Get pointer to map of instruction boundaries. This function
 |      initializes the boundary map if not done yet.
 |  
 |  eamap
 |      Get pointer to ea->insn map. This function initializes eamap if not
 |      done yet.
 |  
 |  entry_ea
 |      cfunc_t_entry_ea_get(self) -> ea_t
 |  
 |  hdrlines
 |      cfunc_t_hdrlines_get(self) -> int
 |  
 |  lvars
 |      Get vector of local variables.
 |  
 |  maturity
 |      cfunc_t_maturity_get(self) -> ctree_maturity_t
 |  
 |  mba
 |      cfunc_t_mba_get(self) -> mba_t
 |  
 |  numforms
 |      cfunc_t_numforms_get(self) -> user_numforms_t
 |  
 |  pseudocode
 |      Get pointer to decompilation output: the pseudocode. This function
 |      generates pseudocode if not done yet.
 |  
 |  refcnt
 |      cfunc_t_refcnt_get(self) -> int
 |  
 |  statebits
 |      cfunc_t_statebits_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  treeitems
 |      cfunc_t_treeitems_get(self) -> ctree_items_t
 |  
 |  type
 |      Get the function's return type tinfo_t object.
 |  
 |  user_cmts
 |      cfunc_t_user_cmts_get(self) -> user_cmts_t
 |  
 |  user_iflags
 |      cfunc_t_user_iflags_get(self) -> user_iflags_t
 |  
 |  user_labels
 |      cfunc_t_user_labels_get(self) -> user_labels_t
 |  
 |  user_unions
 |      cfunc_t_user_unions_get(self) -> user_unions_t
 |  
 |  warnings
 |      Get information about decompilation warnings.
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cfunc_t>
 |      delete_cfunc_t(self)

Help on function cfunc_type in module ida_hexrays:

cfunc_type(self)
    Get the function's return type tinfo_t object.

Help on class cfuncptr_t in module ida_hexrays:

class cfuncptr_t(__builtin__.object)
 |  Proxy of C++ qrefcnt_t< cfunc_t > class.
 |  
 |  Methods defined here:
 |  
 |  __deref__(self, *args)
 |      __deref__(self) -> cfunc_t
 |  
 |  __eq__ lambda self, other
 |  
 |  __init__(self, *args)
 |      __init__(self, p) -> cfuncptr_t
 |          p: cfunc_t *
 |      
 |      
 |      __init__(self, r) -> cfuncptr_t
 |          r: qrefcnt_t< cfunc_t > const &
 |  
 |  __ptrval__(self, *args)
 |      __ptrval__(self) -> size_t
 |  
 |  __ref__(self, *args)
 |      __ref__(self) -> cfunc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__ lambda self
 |  
 |  build_c_tree(self, *args)
 |      build_c_tree(self)
 |  
 |  del_orphan_cmts(self, *args)
 |      del_orphan_cmts(self) -> int
 |  
 |  find_item_coords(self, *args)
 |      find_item_coords(self, item, px, py) -> bool
 |          item: citem_t const *
 |          px: int *
 |          py: int *
 |      
 |      
 |      find_item_coords(self, item) -> PyObject *
 |          item: citem_t const *
 |  
 |  find_label(self, *args)
 |      find_label(self, label) -> citem_t
 |          label: int
 |  
 |  gather_derefs(self, *args)
 |      gather_derefs(self, ci, udm=None) -> bool
 |          ci: ctree_item_t const &
 |          udm: udt_type_data_t *
 |  
 |  get_boundaries(self, *args)
 |      get_boundaries(self) -> boundaries_t
 |  
 |  get_eamap(self, *args)
 |      get_eamap(self) -> eamap_t
 |  
 |  get_func_type(self, *args)
 |      get_func_type(self, type) -> bool
 |          type: tinfo_t *
 |  
 |  get_line_item(self, *args)
 |      get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
 |          line: char const *
 |          x: int
 |          is_ctree_line: bool
 |          phead: ctree_item_t *
 |          pitem: ctree_item_t *
 |          ptail: ctree_item_t *
 |  
 |  get_lvars(self, *args)
 |      get_lvars(self) -> lvars_t
 |  
 |  get_pseudocode(self, *args)
 |      get_pseudocode(self) -> strvec_t
 |  
 |  get_stkoff_delta(self, *args)
 |      get_stkoff_delta(self) -> sval_t
 |  
 |  get_user_cmt(self, *args)
 |      get_user_cmt(self, loc, rt) -> char const *
 |          loc: treeloc_t const &
 |          rt: enum cmt_retrieval_type_t
 |  
 |  get_user_iflags(self, *args)
 |      get_user_iflags(self, loc) -> int32
 |          loc: citem_locator_t const &
 |  
 |  get_user_union_selection(self, *args)
 |      get_user_union_selection(self, ea, path) -> bool
 |          ea: ea_t
 |          path: intvec_t *
 |  
 |  get_warnings(self, *args)
 |      get_warnings(self) -> hexwarns_t
 |  
 |  has_orphan_cmts(self, *args)
 |      has_orphan_cmts(self) -> bool
 |  
 |  locked(self, *args)
 |      locked(self) -> bool
 |  
 |  print_dcl(self, *args)
 |      print_dcl(self)
 |  
 |  print_func(self, *args)
 |      print_func(self, vp)
 |          vp: vc_printer_t &
 |  
 |  refresh_func_ctext(self, *args)
 |      refresh_func_ctext(self)
 |  
 |  release(self, *args)
 |      release(self)
 |  
 |  remove_unused_labels(self, *args)
 |      remove_unused_labels(self)
 |  
 |  reset(self, *args)
 |      reset(self)
 |  
 |  save_user_cmts(self, *args)
 |      save_user_cmts(self)
 |  
 |  save_user_iflags(self, *args)
 |      save_user_iflags(self)
 |  
 |  save_user_labels(self, *args)
 |      save_user_labels(self)
 |  
 |  save_user_numforms(self, *args)
 |      save_user_numforms(self)
 |  
 |  save_user_unions(self, *args)
 |      save_user_unions(self)
 |  
 |  set_user_cmt(self, *args)
 |      set_user_cmt(self, loc, cmt)
 |          loc: treeloc_t const &
 |          cmt: char const *
 |  
 |  set_user_iflags(self, *args)
 |      set_user_iflags(self, loc, iflags)
 |          loc: citem_locator_t const &
 |          iflags: int32
 |  
 |  set_user_union_selection(self, *args)
 |      set_user_union_selection(self, ea, path)
 |          ea: ea_t
 |          path: intvec_t const &
 |  
 |  verify(self, *args)
 |      verify(self, aul, even_without_debugger)
 |          aul: enum allow_unused_labels_t
 |          even_without_debugger: bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  argidx
 |      cfuncptr_t_argidx_get(self) -> intvec_t
 |  
 |  arguments
 |  
 |  body
 |      cfuncptr_t_body_get(self) -> cinsn_t
 |  
 |  boundaries
 |  
 |  eamap
 |  
 |  entry_ea
 |      cfuncptr_t_entry_ea_get(self) -> ea_t
 |  
 |  hdrlines
 |      cfuncptr_t_hdrlines_get(self) -> int
 |  
 |  lvars
 |  
 |  maturity
 |      cfuncptr_t_maturity_get(self) -> ctree_maturity_t
 |  
 |  mba
 |      cfuncptr_t_mba_get(self) -> mba_t
 |  
 |  numforms
 |      cfuncptr_t_numforms_get(self) -> user_numforms_t
 |  
 |  pseudocode
 |  
 |  refcnt
 |      cfuncptr_t_refcnt_get(self) -> int
 |  
 |  statebits
 |      cfuncptr_t_statebits_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  treeitems
 |      cfuncptr_t_treeitems_get(self) -> ctree_items_t
 |  
 |  type
 |  
 |  user_cmts
 |      cfuncptr_t_user_cmts_get(self) -> user_cmts_t
 |  
 |  user_iflags
 |      cfuncptr_t_user_iflags_get(self) -> user_iflags_t
 |  
 |  user_labels
 |      cfuncptr_t_user_labels_get(self) -> user_labels_t
 |  
 |  user_unions
 |      cfuncptr_t_user_unions_get(self) -> user_unions_t
 |  
 |  warnings
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cfuncptr_t>
 |      delete_cfuncptr_t(self)

Help on class cgoto_t in module ida_hexrays:

class cgoto_t(__builtin__.object)
 |  Proxy of C++ cgoto_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: cgoto_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: cgoto_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: cgoto_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cgoto_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: cgoto_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: cgoto_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: cgoto_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: cgoto_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  label_num
 |      cgoto_t_label_num_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cgoto_t>
 |      delete_cgoto_t(self)

Help on class chain_keeper_t in module ida_hexrays:

class chain_keeper_t(__builtin__.object)
 |  Proxy of C++ chain_keeper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _gc) -> chain_keeper_t
 |          _gc: graph_chains_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  back(self, *args)
 |      back(self) -> block_chains_t
 |  
 |  for_all_chains(self, *args)
 |      for_all_chains(self, cv, gca) -> int
 |          @param cv (C++: chain_visitor_t  &)
 |          @param gca (C++: int)
 |  
 |  front(self, *args)
 |      front(self) -> block_chains_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_chain_keeper_t>
 |      delete_chain_keeper_t(self)

Help on class chain_t in module ida_hexrays:

class chain_t(ida_pro.intvec_t)
 |  Proxy of C++ chain_t class.
 |  
 |  Method resolution order:
 |      chain_t
 |      ida_pro.intvec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> chain_t
 |          t: mopt_t
 |          off: sval_t
 |          w: int
 |          v: int
 |      
 |      
 |      __init__(self, _k, w=1) -> chain_t
 |          _k: voff_t const &
 |          w: int
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: chain_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self)
 |  
 |  append_list(self, *args)
 |      Append the contents of the chain to the specified list of locations.
 |      
 |      append_list(self, list)
 |          @param list (C++: mlist_t  *)
 |  
 |  clear_varnum(self, *args)
 |      clear_varnum(self)
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  endoff(self, *args)
 |      endoff(self) -> voff_t
 |  
 |  get_reg(self, *args)
 |      get_reg(self) -> mreg_t
 |  
 |  get_stkoff(self, *args)
 |      get_stkoff(self) -> sval_t
 |  
 |  includes(self, *args)
 |      includes(self, r) -> bool
 |          @param r (C++: const  chain_t  &)
 |  
 |  is_fake(self, *args)
 |      is_fake(self) -> bool
 |  
 |  is_inited(self, *args)
 |      is_inited(self) -> bool
 |  
 |  is_overlapped(self, *args)
 |      is_overlapped(self) -> bool
 |  
 |  is_passreg(self, *args)
 |      is_passreg(self) -> bool
 |  
 |  is_reg(self, *args)
 |      is_reg(self) -> bool
 |  
 |  is_replaced(self, *args)
 |      is_replaced(self) -> bool
 |  
 |  is_stkoff(self, *args)
 |      is_stkoff(self) -> bool
 |  
 |  is_term(self, *args)
 |      is_term(self) -> bool
 |  
 |  key(self, *args)
 |      key(self) -> voff_t
 |  
 |  overlap(self, *args)
 |      overlap(self, r) -> bool
 |          @param r (C++: const  chain_t  &)
 |  
 |  set_inited(self, *args)
 |      set_inited(self, b)
 |          @param b (C++: bool)
 |  
 |  set_overlapped(self, *args)
 |      set_overlapped(self, b)
 |          @param b (C++: bool)
 |  
 |  set_replaced(self, *args)
 |      set_replaced(self, b)
 |          @param b (C++: bool)
 |  
 |  set_term(self, *args)
 |      set_term(self, b)
 |          @param b (C++: bool)
 |  
 |  set_value(self, *args)
 |      set_value(self, r)
 |          @param r (C++: const  chain_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  flags
 |      chain_t_flags_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  varnum
 |      chain_t_varnum_get(self) -> int
 |  
 |  width
 |      chain_t_width_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_chain_t>
 |      delete_chain_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_pro.intvec_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< int > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> int const &
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< int > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: int const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: int const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: int const &
 |  
 |  append = push_back(self, *args)
 |      push_back(self, x)
 |          x: int const &
 |  
 |  at = __getitem__(self, *args)
 |      __getitem__(self, i) -> int const &
 |          i: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< int >::iterator
 |      begin(self) -> qvector< int >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< int >::iterator
 |      end(self) -> qvector< int >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< int >::iterator
 |          it: qvector< int >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< int >::iterator
 |          first: qvector< int >::iterator
 |          last: qvector< int >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> int *
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< int >::iterator
 |          x: int const &
 |      
 |      
 |      find(self, x) -> qvector< int >::const_iterator
 |          x: int const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: int const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: int *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< int >::iterator
 |          it: qvector< int >::iterator
 |          x: int const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: int const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: int const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< int > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_pro.intvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class chain_visitor_t in module ida_hexrays:

class chain_visitor_t(__builtin__.object)
 |  Proxy of C++ chain_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> chain_visitor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_chain(self, *args)
 |      visit_chain(self, nblock, ch) -> int
 |          @param nblock (C++: int)
 |          @param ch (C++: chain_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  parent
 |      chain_visitor_t_parent_get(self) -> block_chains_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_chain_visitor_t>
 |      delete_chain_visitor_t(self)

Help on function checkout_hexrays_license in module ida_hexrays:

checkout_hexrays_license(*args)
    Check out a floating decompiler license. This function will display a
    dialog box if the license is not available. For non-floating licenses
    this function is effectively no-op. It is not necessary to call this
    function before decompiling. If the license was not checked out, the
    decompiler will automatically do it. This function can be used to
    check out a license in advance and ensure that a license is available.
    
    checkout_hexrays_license(silent) -> bool
        @param silent: silently fail if the license cannot be checked out.
                       (C++: bool)
        @return: false if failed

Help on class cif_t in module ida_hexrays:

class cif_t(ceinsn_t)
 |  Proxy of C++ cif_t class.
 |  
 |  Method resolution order:
 |      cif_t
 |      ceinsn_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: cif_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: cif_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: cif_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cif_t
 |          r: cif_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: cif_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: cif_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: cif_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  assign(self, *args)
 |      assign(self, r) -> cif_t
 |          @param r (C++: const  cif_t  &)
 |  
 |  cleanup(self, *args)
 |      cleanup(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: cif_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ielse
 |      cif_t_ielse_get(self) -> cinsn_t
 |  
 |  ithen
 |      cif_t_ithen_get(self) -> cinsn_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cif_t>
 |      delete_cif_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on function cinsn_details in module ida_hexrays:

cinsn_details(self)
    return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.

Help on class cinsn_t in module ida_hexrays:

class cinsn_t(citem_t)
 |  Proxy of C++ cinsn_t class.
 |  
 |  Method resolution order:
 |      cinsn_t
 |      citem_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: cinsn_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: cinsn_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: cinsn_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cinsn_t
 |          r: cinsn_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: cinsn_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: cinsn_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: cinsn_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  _get_casm(self, *args)
 |      _get_casm(self) -> casm_t
 |  
 |  _get_cblock(self, *args)
 |      _get_cblock(self) -> cblock_t
 |  
 |  _get_cdo(self, *args)
 |      _get_cdo(self) -> cdo_t
 |  
 |  _get_cexpr(self, *args)
 |      _get_cexpr(self) -> cexpr_t
 |  
 |  _get_cfor(self, *args)
 |      _get_cfor(self) -> cfor_t
 |  
 |  _get_cgoto(self, *args)
 |      _get_cgoto(self) -> cgoto_t
 |  
 |  _get_cif(self, *args)
 |      _get_cif(self) -> cif_t
 |  
 |  _get_creturn(self, *args)
 |      _get_creturn(self) -> creturn_t
 |  
 |  _get_cswitch(self, *args)
 |      _get_cswitch(self) -> cswitch_t
 |  
 |  _get_cwhile(self, *args)
 |      _get_cwhile(self) -> cwhile_t
 |  
 |  _print(self, *args)
 |      _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
 |          indent: int
 |          vp: vc_printer_t &
 |          use_curly: enum use_curly_t
 |  
 |  _register(self, *args)
 |      _register(self)
 |  
 |  _replace_by(self, *args)
 |      _replace_by(self, r)
 |          r: cinsn_t *
 |  
 |  _set_casm(self, *args)
 |      _set_casm(self, _v)
 |          _v: casm_t *
 |  
 |  _set_cblock(self, *args)
 |      _set_cblock(self, _v)
 |          _v: cblock_t *
 |  
 |  _set_cdo(self, *args)
 |      _set_cdo(self, _v)
 |          _v: cdo_t *
 |  
 |  _set_cexpr(self, *args)
 |      _set_cexpr(self, _v)
 |          _v: cexpr_t *
 |  
 |  _set_cfor(self, *args)
 |      _set_cfor(self, _v)
 |          _v: cfor_t *
 |  
 |  _set_cgoto(self, *args)
 |      _set_cgoto(self, _v)
 |          _v: cgoto_t *
 |  
 |  _set_cif(self, *args)
 |      _set_cif(self, _v)
 |          _v: cif_t *
 |  
 |  _set_creturn(self, *args)
 |      _set_creturn(self, _v)
 |          _v: creturn_t *
 |  
 |  _set_cswitch(self, *args)
 |      _set_cswitch(self, _v)
 |          _v: cswitch_t *
 |  
 |  _set_cwhile(self, *args)
 |      _set_cwhile(self, _v)
 |          _v: cwhile_t *
 |  
 |  assign(self, *args)
 |      assign(self, r) -> cinsn_t
 |          @param r (C++: const  cinsn_t  &)
 |  
 |  cleanup(self, *args)
 |      Cleanup the statement. This function properly deletes all children and
 |      sets the item type to cit_empty.
 |  
 |  collect_free_breaks(self, *args)
 |      Collect free 'break' statements. This function finds all free 'break'
 |      statements within the current statement. A 'break' statement is free
 |      if it does not have a loop or switch parent that that is also within
 |      the current statement.
 |      
 |      collect_free_breaks(self, breaks) -> bool
 |          @param breaks: pointer to the variable where the vector of all found
 |                         free  break  statements is returned. This argument can
 |                         be NULL. (C++: cinsnptrvec_t  *)
 |          @return: true if some free  break  statements have been found
 |  
 |  collect_free_continues(self, *args)
 |      Collect free 'continue' statements. This function finds all free
 |      'continue' statements within the current statement. A 'continue'
 |      statement is free if it does not have a loop parent that that is also
 |      within the current statement.
 |      
 |      collect_free_continues(self, continues) -> bool
 |          @param continues: pointer to the variable where the vector of all
 |                            found free  continue  statements is returned. This
 |                            argument can be NULL. (C++: cinsnptrvec_t  *)
 |          @return: true if some free  continue  statements have been found
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: cinsn_t const &
 |  
 |  contains_free_break(self, *args)
 |      Check if the statement has free 'break' statements.
 |  
 |  contains_free_continue(self, *args)
 |      Check if the statement has free 'continue' statements.
 |  
 |  contains_insn(self, *args)
 |      Check if the statement contains a statement of the specified type.
 |      
 |      contains_insn(self, type, times=1) -> bool
 |          @param type: statement opcode to look for (C++: ctype_t)
 |          @param times: how many times TYPE should be present (C++: int)
 |          @return: true if the statement has at least TIMES children with opcode
 |                   == TYPE
 |  
 |  create_if(self, *args)
 |      Create a new if-statement. The current statement must be a block. The
 |      new statement will be appended to it.
 |      
 |      create_if(self, cnd) -> cif_t
 |          @param cnd: if condition. It will be deleted after being copied. (C++:
 |                      cexpr_t  *)
 |  
 |  is_epilog(self)
 |  
 |  is_ordinary_flow(self, *args)
 |      Check if the statement passes execution to the next statement.
 |  
 |  new_insn(self, *args)
 |      Create a new statement. The current statement must be a block. The new
 |      statement will be appended to it.
 |      
 |      new_insn(self, insn_ea) -> cinsn_t
 |          @param insn_ea: statement address (C++: ea_t)
 |  
 |  print1(self, *args)
 |      Print the statement into one line. Currently this function is not
 |      available.
 |      
 |      print1(self, func)
 |          @param func: parent function. This argument is used to find out the
 |                       referenced variable names. (C++: const  cfunc_t  *)
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: cinsn_t  &)
 |  
 |  zero(self, *args)
 |      Overwrite with zeroes without cleaning memory or deleting children.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  insn_is_epilog(*args)
 |      insn_is_epilog(insn) -> bool
 |          insn: cinsn_t const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  casm
 |  
 |  cblock
 |  
 |  cdo
 |  
 |  cexpr
 |  
 |  cfor
 |  
 |  cgoto
 |  
 |  cif
 |  
 |  creturn
 |  
 |  cswitch
 |  
 |  cwhile
 |  
 |  details
 |      return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.
 |  
 |  opname
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cinsn_t>
 |      delete_cinsn_t(self)
 |  
 |  op_to_typename = {70: 'empty', 71: 'block', 72: 'expr', 73: 'if', 74: ...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args)
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args)
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _get_op(self, *args)
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args)
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args)
 |      _set_op(self, v)
 |          v: enum ctype_t
 |  
 |  contains_expr(self, *args)
 |      Does the item contain an expression?
 |      
 |      contains_expr(self, e) -> bool
 |          @param e (C++: const  cexpr_t  *)
 |  
 |  contains_label(self, *args)
 |      Does the item contain a label?
 |  
 |  find_closest_addr(self, *args)
 |      find_closest_addr(self, _ea) -> citem_t
 |          @param _ea (C++: ea_t)
 |  
 |  find_parent_of(self, *args)
 |      Find parent of the specified item.
 |      
 |      find_parent_of(self, sitem) -> citem_t
 |          @param sitem: Item to find the parent of. The search will be performed
 |                        among the children of the item pointed by  this . (C++:
 |                        const  citem_t  *)
 |          @return: NULL if not found
 |      
 |      
 |      find_parent_of(self, item) -> citem_t
 |          item: citem_t const *
 |          @return: NULL if not found
 |  
 |  is_expr(self, *args)
 |      Is an expression?
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cinsn
 |      citem_t_cinsn_get(self) -> cinsn_t
 |  
 |  ea
 |      citem_t_ea_get(self) -> ea_t
 |  
 |  index
 |      citem_t_index_get(self) -> int
 |  
 |  label_num
 |      citem_t_label_num_get(self) -> int
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on function cinsn_t_insn_is_epilog in module ida_hexrays:

cinsn_t_insn_is_epilog(*args)
    cinsn_t_insn_is_epilog(insn) -> bool
        insn: cinsn_t const *

Help on class cinsnptrvec_t in module ida_hexrays:

class cinsnptrvec_t(__builtin__.object)
 |  Proxy of C++ qvector< cinsn_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< cinsn_t * > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> cinsn_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cinsnptrvec_t
 |          x: qvector< cinsn_t * > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< cinsn_t * > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: cinsn_t *const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: cinsn_t *const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: cinsn_t *const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< cinsn_t * >::iterator
 |      begin(self) -> qvector< cinsn_t * >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< cinsn_t * >::iterator
 |      end(self) -> qvector< cinsn_t * >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< cinsn_t * >::iterator
 |          it: qvector< cinsn_t * >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< cinsn_t * >::iterator
 |          first: qvector< cinsn_t * >::iterator
 |          last: qvector< cinsn_t * >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> cinsn_t **
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< cinsn_t * >::iterator
 |          x: cinsn_t *const &
 |      
 |      
 |      find(self, x) -> qvector< cinsn_t * >::const_iterator
 |          x: cinsn_t *const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: cinsn_t *const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: cinsn_t **
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< cinsn_t * >::iterator
 |          it: qvector< cinsn_t * >::iterator
 |          x: cinsn_t *const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: cinsn_t *const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: cinsn_t *const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< cinsn_t * > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cinsnptrvec_t>
 |      delete_cinsnptrvec_t(self)

Help on class citem_cmt_t in module ida_hexrays:

class citem_cmt_t(__builtin__.object)
 |  Proxy of C++ citem_cmt_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> citem_cmt_t
 |          s: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args)
 |      __str__(self) -> char const *
 |  
 |  c_str(self, *args)
 |      c_str(self) -> char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  used
 |      citem_cmt_t_used_get(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_citem_cmt_t>
 |      delete_citem_cmt_t(self)

Help on class citem_locator_t in module ida_hexrays:

class citem_locator_t(__builtin__.object)
 |  Proxy of C++ citem_locator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: citem_locator_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: citem_locator_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: citem_locator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea, _op) -> citem_locator_t
 |          _ea: ea_t
 |          _op: enum ctype_t
 |      
 |      
 |      __init__(self, i) -> citem_locator_t
 |          i: citem_t const *
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: citem_locator_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: citem_locator_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: citem_locator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: citem_locator_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      citem_locator_t_ea_get(self) -> ea_t
 |  
 |  op
 |      citem_locator_t_op_get(self) -> ctype_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_citem_locator_t>
 |      delete_citem_locator_t(self)

Help on class citem_t in module ida_hexrays:

class citem_t(__builtin__.object)
 |  Proxy of C++ citem_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> citem_t
 |          o: enum ctype_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args)
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args)
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _get_op(self, *args)
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args)
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args)
 |      _set_op(self, v)
 |          v: enum ctype_t
 |  
 |  contains_expr(self, *args)
 |      Does the item contain an expression?
 |      
 |      contains_expr(self, e) -> bool
 |          @param e (C++: const  cexpr_t  *)
 |  
 |  contains_label(self, *args)
 |      Does the item contain a label?
 |  
 |  find_closest_addr(self, *args)
 |      find_closest_addr(self, _ea) -> citem_t
 |          @param _ea (C++: ea_t)
 |  
 |  find_parent_of(self, *args)
 |      Find parent of the specified item.
 |      
 |      find_parent_of(self, sitem) -> citem_t
 |          @param sitem: Item to find the parent of. The search will be performed
 |                        among the children of the item pointed by  this . (C++:
 |                        const  citem_t  *)
 |          @return: NULL if not found
 |      
 |      
 |      find_parent_of(self, item) -> citem_t
 |          item: citem_t const *
 |          @return: NULL if not found
 |  
 |  is_expr(self, *args)
 |      Is an expression?
 |  
 |  print1(self, *args)
 |      Print item into one line.
 |      
 |      print1(self, func)
 |          @param func: parent function. This argument is used to find out the
 |                       referenced variable names. (C++: const  cfunc_t  *)
 |          @return: length of the generated text.
 |  
 |  replace_by(self, o)
 |  
 |  swap(self, *args)
 |      Swap two 'citem_t' .
 |      
 |      swap(self, r)
 |          @param r (C++: citem_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cexpr
 |      citem_t_cexpr_get(self) -> cexpr_t
 |  
 |  cinsn
 |      citem_t_cinsn_get(self) -> cinsn_t
 |  
 |  ea
 |      citem_t_ea_get(self) -> ea_t
 |  
 |  index
 |      citem_t_index_get(self) -> int
 |  
 |  label_num
 |      citem_t_label_num_get(self) -> int
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_citem_t>
 |      delete_citem_t(self)

Help on function citem_to_specific_type in module ida_hexrays:

citem_to_specific_type(self)
    cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on function clear_cached_cfuncs in module ida_hexrays:

clear_cached_cfuncs(*args)
    Flush all cached decompilation results.

Help on class cloop_t in module ida_hexrays:

class cloop_t(ceinsn_t)
 |  Proxy of C++ cloop_t class.
 |  
 |  Method resolution order:
 |      cloop_t
 |      ceinsn_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cloop_t
 |          b: cinsn_t *
 |      
 |      
 |      __init__(self, r) -> cloop_t
 |          r: cloop_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  assign(self, *args)
 |      assign(self, r) -> cloop_t
 |          @param r (C++: const  cloop_t  &)
 |  
 |  cleanup(self, *args)
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  body
 |      cloop_t_body_get(self) -> cinsn_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cloop_t>
 |      delete_cloop_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on function close_hexrays_waitbox in module ida_hexrays:

close_hexrays_waitbox(*args)
    Close the waitbox displayed by the decompiler. Useful if
    DECOMP_NO_HIDE was used during decompilation.

Help on function close_pseudocode in module ida_hexrays:

close_pseudocode(*args)
    Close pseudocode window.
    
    close_pseudocode(f) -> bool
        @param f: pointer to window (C++: TWidget *)
        @return: false if failed

Help on class cnumber_t in module ida_hexrays:

class cnumber_t(__builtin__.object)
 |  Proxy of C++ cnumber_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: cnumber_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: cnumber_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: cnumber_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _opnum=0) -> cnumber_t
 |          _opnum: int
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: cnumber_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: cnumber_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: cnumber_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self, type, parent=None, nice_stroff=None)
 |          type: tinfo_t const &
 |          parent: citem_t const *
 |          nice_stroff: bool *
 |  
 |  assign(self, *args)
 |      Assign new value
 |      
 |      assign(self, v, nbytes, sign)
 |          @param v: new value (C++: uint64)
 |          @param nbytes: size of the new value in bytes (C++: int)
 |          @param sign: sign of the value (C++: type_sign_t)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: cnumber_t const &
 |  
 |  value(self, *args)
 |      Get value. This function will properly extend the number sign to
 |      64bits depending on the type sign.
 |      
 |      value(self, type) -> uint64
 |          @param type (C++: const  tinfo_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  _value
 |      cnumber_t__value_get(self) -> uint64
 |  
 |  nf
 |      cnumber_t_nf_get(self) -> number_format_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cnumber_t>
 |      delete_cnumber_t(self)

Help on class codegen_t in module ida_hexrays:

class codegen_t(__builtin__.object)
 |  Proxy of C++ codegen_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  analyze_prolog(self, *args)
 |      Analyze prolog/epilog of the function to decompile. If prolog is
 |      found, allocate and fill 'mba->pi' structure.
 |      
 |      analyze_prolog(self, fc, reachable) -> merror_t
 |          @param fc: flow chart (C++: const class  qflow_chart_t  &)
 |          @param reachable: bitmap of reachable blocks (C++: const class
 |                            bitset_t  &)
 |          @return: error code
 |  
 |  emit(self, *args)
 |      Emit one microinstruction. The L, R, D arguments usually mean the
 |      register number. However, they depend on CODE. For example:for m_goto
 |      and m_jcnd L is the target addressfor m_ldc L is the constant value to
 |      load
 |      
 |      emit(self, code, width, l, r, d, offsize) -> minsn_t
 |          @param code (C++: mcode_t)
 |          @param width (C++: int)
 |          @param l (C++: uval_t)
 |          @param r (C++: uval_t)
 |          @param d (C++: uval_t)
 |          @param offsize (C++: int)
 |          @return: created microinstruction. can be NULL if the instruction got
 |                   immediately optimized away.
 |      
 |      
 |      emit(self, code, l, r, d) -> minsn_t
 |          @param code (C++: mcode_t)
 |          @param l (C++: uval_t)
 |          @param r (C++: uval_t)
 |          @param d (C++: uval_t)
 |          @return: created microinstruction. can be NULL if the instruction got
 |                   immediately optimized away.
 |  
 |  emit_micro_mvm(self, *args)
 |      Emit one microinstruction. This variant takes a data type not a size.
 |      
 |      emit_micro_mvm(self, code, dtype, l, r, d, offsize) -> minsn_t
 |          @param code (C++: mcode_t)
 |          @param dtype (C++: op_dtype_t)
 |          @param l (C++: uval_t)
 |          @param r (C++: uval_t)
 |          @param d (C++: uval_t)
 |          @param offsize (C++: int)
 |  
 |  gen_micro(self, *args)
 |      Generate microcode for one instruction. The instruction is in INSN
 |  
 |  load_operand(self, *args)
 |      Generate microcode to load one operand.
 |      
 |      load_operand(self, opnum) -> mreg_t
 |          @param opnum (C++: int)
 |  
 |  microgen_completed(self, *args)
 |      This method is called when the microcode generation is done.
 |  
 |  prepare_gen_micro(self, *args)
 |      Setup internal data to handle new instruction This method should be
 |      called before calling 'gen_micro()' The instruction is in INSN
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ignore_micro
 |      codegen_t_ignore_micro_get(self) -> char
 |  
 |  ii
 |      codegen_t_ii_get(self) -> cdg_insn_iterator_t
 |  
 |  insn
 |      codegen_t_insn_get(self) -> insn_t *
 |  
 |  mb
 |      codegen_t_mb_get(self) -> mblock_t
 |  
 |  mba
 |      codegen_t_mba_get(self) -> mba_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_codegen_t>
 |      delete_codegen_t(self)

Help on function convert_to_user_call in module ida_hexrays:

convert_to_user_call(*args)
    try to generate user-defined call for an instruction
    
    convert_to_user_call(udc, cdg) -> merror_t
        @param udc (C++: const  udcall_t  &)
        @param cdg (C++: codegen_t  &)
        @return: Microcode error codes  code: MERR_OK - user-defined call
                 generated else - error (MERR_INSN == inacceptable udc.tif)

Help on function create_field_name in module ida_hexrays:

create_field_name(*args)
    create_field_name(type, offset=BADADDR) -> qstring
        @param type (C++: const  tinfo_t  &)
        @param offset (C++: uval_t)

Help on function create_helper in module ida_hexrays:

create_helper(*args)

Help on function create_typedef in module ida_hexrays:

create_typedef(*args)
    Create a reference to a named type.
    
    create_typedef(name) -> tinfo_t
        @param name: type name (C++: const char *)
        @return: type which refers to the specified ordinal. For example, if n
                 is 1, the type info which refers to ordinal type 1 is
                 created.
    
    
    create_typedef(n) -> tinfo_t
        n: int
        @return: type which refers to the specified ordinal. For example, if n
                 is 1, the type info which refers to ordinal type 1 is
                 created.

Help on class creturn_t in module ida_hexrays:

class creturn_t(ceinsn_t)
 |  Proxy of C++ creturn_t class.
 |  
 |  Method resolution order:
 |      creturn_t
 |      ceinsn_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: creturn_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: creturn_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: creturn_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> creturn_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: creturn_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: creturn_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: creturn_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: creturn_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_creturn_t>
 |      delete_creturn_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on class cswitch_t in module ida_hexrays:

class cswitch_t(ceinsn_t)
 |  Proxy of C++ cswitch_t class.
 |  
 |  Method resolution order:
 |      cswitch_t
 |      ceinsn_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: cswitch_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: cswitch_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: cswitch_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cswitch_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: cswitch_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: cswitch_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: cswitch_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: cswitch_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cases
 |      cswitch_t_cases_get(self) -> ccases_t
 |  
 |  mvnf
 |      cswitch_t_mvnf_get(self) -> cnumber_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cswitch_t>
 |      delete_cswitch_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on class ctext_position_t in module ida_hexrays:

class ctext_position_t(__builtin__.object)
 |  Proxy of C++ ctext_position_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _lnnum=-1, _x=0, _y=0) -> ctext_position_t
 |          _lnnum: int
 |          _x: int
 |          _y: int
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: ctext_position_t const &
 |  
 |  in_ctree(self, *args)
 |      Is the cursor in the variable/type declaration area?
 |      
 |      in_ctree(self, hdrlines) -> bool
 |          @param hdrlines: Number of lines of the declaration area (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      ctext_position_t_lnnum_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      ctext_position_t_x_get(self) -> int
 |  
 |  y
 |      ctext_position_t_y_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ctext_position_t>
 |      delete_ctext_position_t(self)

Help on class ctree_anchor_t in module ida_hexrays:

class ctree_anchor_t(__builtin__.object)
 |  Proxy of C++ ctree_anchor_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ctree_anchor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_index(self, *args)
 |      get_index(self) -> int
 |  
 |  get_itp(self, *args)
 |      get_itp(self) -> item_preciser_t
 |  
 |  is_blkcmt_anchor(self, *args)
 |      is_blkcmt_anchor(self) -> bool
 |  
 |  is_citem_anchor(self, *args)
 |      is_citem_anchor(self) -> bool
 |  
 |  is_itp_anchor(self, *args)
 |      is_itp_anchor(self) -> bool
 |  
 |  is_lvar_anchor(self, *args)
 |      is_lvar_anchor(self) -> bool
 |  
 |  is_valid_anchor(self, *args)
 |      is_valid_anchor(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      ctree_anchor_t_value_get(self) -> uval_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ctree_anchor_t>
 |      delete_ctree_anchor_t(self)

Help on class ctree_item_t in module ida_hexrays:

class ctree_item_t(__builtin__.object)
 |  Proxy of C++ ctree_item_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ctree_item_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _get_e(self, *args)
 |      _get_e(self) -> cexpr_t
 |  
 |  _get_f(self, *args)
 |      _get_f(self) -> cfunc_t
 |  
 |  _get_i(self, *args)
 |      _get_i(self) -> cinsn_t
 |  
 |  _get_it(self, *args)
 |      _get_it(self) -> citem_t
 |  
 |  _get_l(self, *args)
 |      _get_l(self) -> lvar_t
 |  
 |  get_ea(self, *args)
 |      Get address of the current item. Each ctree item has an address.
 |  
 |  get_label_num(self, *args)
 |      Get label number of the current item.
 |      
 |      get_label_num(self, gln_flags) -> int
 |          @param gln_flags: Combination of  get_label_num control  bits (C++:
 |                            int)
 |          @return: -1 if failed or no label
 |  
 |  get_lvar(self, *args)
 |      Get pointer to local variable. If the current item is a local
 |      variable, this function will return pointer to its definition.
 |  
 |  get_memptr(self, *args)
 |      Get pointer to structure member. If the current item is a structure
 |      field, this function will return pointer to its definition.
 |      
 |      get_memptr(self, p_sptr=None) -> member_t *
 |          @param p_sptr: pointer to the variable where the pointer to the parent
 |                         structure is returned. This parameter can be NULL.
 |                         (C++: struc_t  **)
 |          @return: NULL if failed
 |  
 |  is_citem(self, *args)
 |      Is the current item is a ctree item?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  citype
 |      ctree_item_t_citype_get(self) -> cursor_item_type_t
 |  
 |  e
 |  
 |  f
 |  
 |  i
 |  
 |  it
 |  
 |  l
 |  
 |  loc
 |      ctree_item_t_loc_get(self) -> treeloc_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ctree_item_t>
 |      delete_ctree_item_t(self)

Help on class ctree_items_t in module ida_hexrays:

class ctree_items_t(__builtin__.object)
 |  Proxy of C++ qvector< citem_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< citem_t * > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> citem_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ctree_items_t
 |          x: qvector< citem_t * > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< citem_t * > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: citem_t *const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: citem_t *const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: citem_t *const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< citem_t * >::iterator
 |      begin(self) -> qvector< citem_t * >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< citem_t * >::iterator
 |      end(self) -> qvector< citem_t * >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< citem_t * >::iterator
 |          it: qvector< citem_t * >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< citem_t * >::iterator
 |          first: qvector< citem_t * >::iterator
 |          last: qvector< citem_t * >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> citem_t **
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< citem_t * >::iterator
 |          x: citem_t *const &
 |      
 |      
 |      find(self, x) -> qvector< citem_t * >::const_iterator
 |          x: citem_t *const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: citem_t *const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: citem_t **
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< citem_t * >::iterator
 |          it: qvector< citem_t * >::iterator
 |          x: citem_t *const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: citem_t *const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: citem_t *const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< citem_t * > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ctree_items_t>
 |      delete_ctree_items_t(self)

Help on class ctree_parentee_t in module ida_hexrays:

class ctree_parentee_t(ctree_visitor_t)
 |  Proxy of C++ ctree_parentee_t class.
 |  
 |  Method resolution order:
 |      ctree_parentee_t
 |      ctree_visitor_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, post=False) -> ctree_parentee_t
 |          post: bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  recalc_parent_types(self, *args)
 |      Recalculate types of parent node. If a node type has been changed, the
 |      visitor must recalculate all parent types, otherwise the ctree becomes
 |      inconsistent. If during this recalculation a parent node is
 |      added/deleted, this function returns true. In this case it is
 |      recommended to restart the traversal because the information about
 |      parent nodes is stale.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ctree_parentee_t>
 |      delete_ctree_parentee_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctree_visitor_t:
 |  
 |  apply_to(self, *args)
 |      Traverse ctree. The traversal will start at the specified item and
 |      continue until of one the visit_...() functions return a non-zero
 |      value.
 |      
 |      apply_to(self, item, parent) -> int
 |          @param item: root of the ctree to traverse (C++: citem_t  *)
 |          @param parent: parent of the specified item. can be specified as NULL.
 |                         (C++: citem_t  *)
 |          @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  apply_to_exprs(self, *args)
 |      Traverse only expressions. The traversal will start at the specified
 |      item and continue until of one the visit_...() functions return a non-
 |      zero value.
 |      
 |      apply_to_exprs(self, item, parent) -> int
 |          @param item: root of the ctree to traverse (C++: citem_t  *)
 |          @param parent: parent of the specified item. can be specified as NULL.
 |                         (C++: citem_t  *)
 |          @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  clr_prune(self, *args)
 |      Do not prune children. This is an internal function, no need to call
 |      it.
 |  
 |  clr_restart(self, *args)
 |      Do not restart. This is an internal function, no need to call it.
 |  
 |  is_postorder(self, *args)
 |      Should the leave...() functions be called?
 |  
 |  leave_expr(self, *args)
 |      Visit an expression after having visited its children This is a
 |      visitor function which should be overridden by a derived class to do
 |      some useful work. This visitor performs post-order traserval, i.e. an
 |      item is visited after its children.
 |      
 |      leave_expr(self, arg0) -> int
 |          arg0: cexpr_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  leave_insn(self, *args)
 |      Visit a statement after having visited its children This is a visitor
 |      function which should be overridden by a derived class to do some
 |      useful work. This visitor performs post-order traserval, i.e. an item
 |      is visited after its children.
 |      
 |      leave_insn(self, arg0) -> int
 |          arg0: cinsn_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  maintain_parents(self, *args)
 |      Should the parent information by maintained?
 |  
 |  must_prune(self, *args)
 |      Should the traversal skip the children of the current item?
 |  
 |  must_restart(self, *args)
 |      Should the traversal restart?
 |  
 |  only_insns(self, *args)
 |      Should all expressions be automatically pruned?
 |  
 |  parent_expr(self, *args)
 |      Get parent of the current item as an expression.
 |  
 |  parent_insn(self, *args)
 |      Get parent of the current item as a statement.
 |  
 |  prune_now(self, *args)
 |      Prune children. This function may be called by a visitor() to skip all
 |      children of the current item.
 |  
 |  set_restart(self, *args)
 |      Restart the travesal. Meaningful only in 'apply_to_exprs()'
 |  
 |  visit_expr(self, *args)
 |      Visit an expression. This is a visitor function which should be
 |      overridden by a derived class to do some useful work. This visitor
 |      performs pre-order traserval, i.e. an item is visited before its
 |      children.
 |      
 |      visit_expr(self, arg0) -> int
 |          arg0: cexpr_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  visit_insn(self, *args)
 |      Visit a statement. This is a visitor function which should be
 |      overridden by a derived class to do some useful work. This visitor
 |      performs pre-order traserval, i.e. an item is visited before its
 |      children.
 |      
 |      visit_insn(self, arg0) -> int
 |          arg0: cinsn_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ctree_visitor_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cv_flags
 |      ctree_visitor_t_cv_flags_get(self) -> int
 |  
 |  parents
 |      ctree_visitor_t_parents_get(self) -> ctree_items_t

Help on class ctree_visitor_t in module ida_hexrays:

class ctree_visitor_t(__builtin__.object)
 |  Proxy of C++ ctree_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags) -> ctree_visitor_t
 |          _flags: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  apply_to(self, *args)
 |      Traverse ctree. The traversal will start at the specified item and
 |      continue until of one the visit_...() functions return a non-zero
 |      value.
 |      
 |      apply_to(self, item, parent) -> int
 |          @param item: root of the ctree to traverse (C++: citem_t  *)
 |          @param parent: parent of the specified item. can be specified as NULL.
 |                         (C++: citem_t  *)
 |          @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  apply_to_exprs(self, *args)
 |      Traverse only expressions. The traversal will start at the specified
 |      item and continue until of one the visit_...() functions return a non-
 |      zero value.
 |      
 |      apply_to_exprs(self, item, parent) -> int
 |          @param item: root of the ctree to traverse (C++: citem_t  *)
 |          @param parent: parent of the specified item. can be specified as NULL.
 |                         (C++: citem_t  *)
 |          @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  clr_prune(self, *args)
 |      Do not prune children. This is an internal function, no need to call
 |      it.
 |  
 |  clr_restart(self, *args)
 |      Do not restart. This is an internal function, no need to call it.
 |  
 |  is_postorder(self, *args)
 |      Should the leave...() functions be called?
 |  
 |  leave_expr(self, *args)
 |      Visit an expression after having visited its children This is a
 |      visitor function which should be overridden by a derived class to do
 |      some useful work. This visitor performs post-order traserval, i.e. an
 |      item is visited after its children.
 |      
 |      leave_expr(self, arg0) -> int
 |          arg0: cexpr_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  leave_insn(self, *args)
 |      Visit a statement after having visited its children This is a visitor
 |      function which should be overridden by a derived class to do some
 |      useful work. This visitor performs post-order traserval, i.e. an item
 |      is visited after its children.
 |      
 |      leave_insn(self, arg0) -> int
 |          arg0: cinsn_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  maintain_parents(self, *args)
 |      Should the parent information by maintained?
 |  
 |  must_prune(self, *args)
 |      Should the traversal skip the children of the current item?
 |  
 |  must_restart(self, *args)
 |      Should the traversal restart?
 |  
 |  only_insns(self, *args)
 |      Should all expressions be automatically pruned?
 |  
 |  parent_expr(self, *args)
 |      Get parent of the current item as an expression.
 |  
 |  parent_insn(self, *args)
 |      Get parent of the current item as a statement.
 |  
 |  prune_now(self, *args)
 |      Prune children. This function may be called by a visitor() to skip all
 |      children of the current item.
 |  
 |  set_restart(self, *args)
 |      Restart the travesal. Meaningful only in 'apply_to_exprs()'
 |  
 |  visit_expr(self, *args)
 |      Visit an expression. This is a visitor function which should be
 |      overridden by a derived class to do some useful work. This visitor
 |      performs pre-order traserval, i.e. an item is visited before its
 |      children.
 |      
 |      visit_expr(self, arg0) -> int
 |          arg0: cexpr_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  visit_insn(self, *args)
 |      Visit a statement. This is a visitor function which should be
 |      overridden by a derived class to do some useful work. This visitor
 |      performs pre-order traserval, i.e. an item is visited before its
 |      children.
 |      
 |      visit_insn(self, arg0) -> int
 |          arg0: cinsn_t *
 |          @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cv_flags
 |      ctree_visitor_t_cv_flags_get(self) -> int
 |  
 |  parents
 |      ctree_visitor_t_parents_get(self) -> ctree_items_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ctree_visitor_t>
 |      delete_ctree_visitor_t(self)

Help on class cwhile_t in module ida_hexrays:

class cwhile_t(cloop_t)
 |  Proxy of C++ cwhile_t class.
 |  
 |  Method resolution order:
 |      cwhile_t
 |      cloop_t
 |      ceinsn_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: cwhile_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: cwhile_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: cwhile_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cwhile_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: cwhile_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: cwhile_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: cwhile_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: cwhile_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cwhile_t>
 |      delete_cwhile_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cloop_t:
 |  
 |  assign(self, *args)
 |      assign(self, r) -> cloop_t
 |          @param r (C++: const  cloop_t  &)
 |  
 |  cleanup(self, *args)
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cloop_t:
 |  
 |  body
 |      cloop_t_body_get(self) -> cinsn_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      ceinsn_t_expr_get(self) -> cexpr_t

Help on function debug_hexrays_ctree in module ida_hexrays:

debug_hexrays_ctree(*args)
    debug_hexrays_ctree(msg)
        msg: char const *

Help on function decompile in module ida_hexrays:

decompile(ea, hf=None, flags=0)
    # ---------------------------------------------------------------------

Help on function decompile_func in module ida_hexrays:

decompile_func(*args)
    Decompile a function. Multiple decompilations of the same function
    return the same object.
    
    decompile_func(pfn, hf, decomp_flags=0) -> cfuncptr_t
        @param pfn: pointer to function to decompile (C++: func_t  *)
        @param hf: extended error information (if failed) (C++:
                   hexrays_failure_t  *)
        @param decomp_flags: bitwise combination of  decompile() flags ...
                             bits (C++: int)
        @return: pointer to the decompilation result (a reference counted
                 pointer). NULL if failed.

Help on function decompile_many in module ida_hexrays:

decompile_many(*args)
    Batch decompilation. Decompile all or the specified functions
    
    decompile_many(outfile, funcaddrs, flags) -> bool
        @param outfile: name of the output file (C++: const char *)
        @param funcaddrs: list of functions to decompile. If NULL or empty,
                          then decompile all nonlib functions (C++: const
                          eavec_t  *)
        @param flags: Batch decompilation bits (C++: int)
        @return: true if no internal error occurred and the user has not
                 cancelled decompilation

Help on function dereference in module ida_hexrays:

dereference(e, ptrsize, is_float=False)

Help on function dstr in module ida_hexrays:

dstr(*args)
    Print the specified type info. This function can be used from a
    debugger by typing "tif->dstr()"
    
    dstr(tif) -> char const *
        @param tif (C++: const  tinfo_t  *)

Help on function dummy_ptrtype in module ida_hexrays:

dummy_ptrtype(*args)
    Generate a dummy pointer type
    
    dummy_ptrtype(ptrsize, isfp) -> tinfo_t
        @param ptrsize: size of pointed object (C++: int)
        @param isfp: is floating point object? (C++: bool)

Help on function eamap_begin in module ida_hexrays:

eamap_begin(*args)
    Get iterator pointing to the beginning of eamap_t.
    
    eamap_begin(map) -> eamap_iterator_t
        @param map (C++: const eamap_t *)

Help on function eamap_clear in module ida_hexrays:

eamap_clear(*args)
    Clear eamap_t.
    
    eamap_clear(map)
        @param map (C++: eamap_t *)

Help on function eamap_end in module ida_hexrays:

eamap_end(*args)
    Get iterator pointing to the end of eamap_t.
    
    eamap_end(map) -> eamap_iterator_t
        @param map (C++: const eamap_t *)

Help on function eamap_erase in module ida_hexrays:

eamap_erase(*args)
    Erase current element from eamap_t.
    
    eamap_erase(map, p)
        @param map (C++: eamap_t *)
        @param p (C++: eamap_iterator_t)

Help on function eamap_find in module ida_hexrays:

eamap_find(*args)
    Find the specified key in eamap_t.
    
    eamap_find(map, key) -> eamap_iterator_t
        @param map (C++: const eamap_t *)
        @param key (C++: const ea_t &)

Help on function eamap_first in module ida_hexrays:

eamap_first(*args)
    Get reference to the current map key.
    
    eamap_first(p) -> ea_t const &
        @param p (C++: eamap_iterator_t)

Help on function eamap_free in module ida_hexrays:

eamap_free(*args)
    Delete eamap_t instance.
    
    eamap_free(map)
        @param map (C++: eamap_t *)

Help on function eamap_insert in module ida_hexrays:

eamap_insert(*args)
    Insert new (ea_t, cinsnptrvec_t) pair into eamap_t.
    
    eamap_insert(map, key, val) -> eamap_iterator_t
        @param map (C++: eamap_t *)
        @param key (C++: const ea_t &)
        @param val (C++: const  cinsnptrvec_t  &)

Help on class eamap_iterator_t in module ida_hexrays:

class eamap_iterator_t(__builtin__.object)
 |  Proxy of C++ eamap_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, p) -> bool
 |          p: eamap_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> eamap_iterator_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, p) -> bool
 |          p: eamap_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      eamap_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_eamap_iterator_t>
 |      delete_eamap_iterator_t(self)

Help on function eamap_new in module ida_hexrays:

eamap_new(*args)
    Create a new eamap_t instance.

Help on function eamap_next in module ida_hexrays:

eamap_next(*args)
    Move to the next element.
    
    eamap_next(p) -> eamap_iterator_t
        @param p (C++: eamap_iterator_t)

Help on function eamap_prev in module ida_hexrays:

eamap_prev(*args)
    Move to the previous element.
    
    eamap_prev(p) -> eamap_iterator_t
        @param p (C++: eamap_iterator_t)

Help on function eamap_second in module ida_hexrays:

eamap_second(*args)
    Get reference to the current map value.
    
    eamap_second(p) -> cinsnptrvec_t
        @param p (C++: eamap_iterator_t)

Help on function eamap_size in module ida_hexrays:

eamap_size(*args)
    Get size of eamap_t.
    
    eamap_size(map) -> size_t
        @param map (C++: eamap_t *)

Help on class eamap_t in module ida_hexrays:

class eamap_t(__builtin__.object)
 |  Proxy of C++ std::map< ea_t,cinsnptrvec_t > class.
 |  
 |  Methods defined here:
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> eamap_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  at(self, *args)
 |      at(self, _Keyval) -> cinsnptrvec_t
 |          _Keyval: unsigned-ea-like-numeric-type const &↗
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __begin = <built-in function eamap_begin>
 |      eamap_begin(map) -> eamap_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t const *
 |  
 |  __clear = <built-in function eamap_clear>
 |      eamap_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t *
 |  
 |  __end = <built-in function eamap_end>
 |      eamap_end(map) -> eamap_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t const *
 |  
 |  __erase = <built-in function eamap_erase>
 |      eamap_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t *
 |      p: eamap_iterator_t
 |  
 |  __find = <built-in function eamap_find>
 |      eamap_find(map, key) -> eamap_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t const *
 |      key: ea_t const &
 |  
 |  __first = <built-in function eamap_first>
 |      eamap_first(p) -> ea_t const &
 |      
 |      Parameters
 |      ----------
 |      p: eamap_iterator_t
 |  
 |  __insert = <built-in function eamap_insert>
 |      eamap_insert(map, key, val) -> eamap_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t *
 |      key: ea_t const &
 |      val: cinsnptrvec_t const &
 |  
 |  __next = <built-in function eamap_next>
 |      eamap_next(p) -> eamap_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: eamap_iterator_t
 |  
 |  __second = <built-in function eamap_second>
 |      eamap_second(p) -> cinsnptrvec_t
 |      
 |      Parameters
 |      ----------
 |      p: eamap_iterator_t
 |  
 |  __size = <built-in function eamap_size>
 |      eamap_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t *
 |  
 |  __swig_destroy__ = <built-in function delete_eamap_t>
 |      delete_eamap_t(self)
 |  
 |  keytype = <type 'long'>
 |      long(x=0) -> long
 |      long(x, base=10) -> long
 |      
 |      Convert a number or string to a long integer, or return 0L if no arguments
 |      are given.  If x is floating point, the conversion truncates towards zero.
 |      
 |      If x is not a number or if base is given, then x must be a string or
 |      Unicode object representing an integer literal in the given base.  The
 |      literal can be preceded by '+' or '-' and be surrounded by whitespace.
 |      The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to
 |      interpret the base from the string as an integer literal.
 |      >>> int('0b100', base=0)
 |      4L
 |  
 |  valuetype = <class 'ida_hexrays.cinsnptrvec_t'>
 |      Proxy of C++ qvector< cinsn_t * > class.

Help on class fnum_array in module ida_hexrays:

class fnum_array(__builtin__.object)
 |  Proxy of C++ wrapped_array_t< uint16,6 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> unsigned short const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> fnum_array
 |          data: unsigned short (&)[6]
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: unsigned short const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  data
 |      fnum_array_data_get(self) -> unsigned short (&)[6]
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_fnum_array>
 |      delete_fnum_array(self)

Help on class fnumber_t in module ida_hexrays:

class fnumber_t(__builtin__.object)
 |  Proxy of C++ fnumber_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: fnumber_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: fnumber_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: fnumber_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> fnumber_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: fnumber_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: fnumber_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: fnumber_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _fnumber_t__get_fnum = __get_fnum(self, *args)
 |      __get_fnum(self) -> fnum_array
 |  
 |  _print(self, *args)
 |      _print(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: fnumber_t const &
 |  
 |  dereference_const_uint16(self, *args)
 |      dereference_const_uint16(self) -> uint16 const *
 |  
 |  dereference_uint16(self, *args)
 |      dereference_uint16(self) -> uint16 *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fnum
 |      __get_fnum(self) -> fnum_array
 |  
 |  nbytes
 |      fnumber_t_nbytes_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_fnumber_t>
 |      delete_fnumber_t(self)

Help on class gco_info_t in module ida_hexrays:

class gco_info_t(__builtin__.object)
 |  Proxy of C++ gco_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> gco_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  append_to_list(self, *args)
 |      Append operand info to LIST. This function converts IDA register
 |      number or stack offset to a decompiler list.
 |      
 |      append_to_list(self, list, mba) -> bool
 |          @param list: list to append to (C++: mlist_t  *)
 |          @param mba: microcode object (C++: const  mba_t  *)
 |  
 |  is_def(self, *args)
 |      is_def(self) -> bool
 |  
 |  is_reg(self, *args)
 |      is_reg(self) -> bool
 |  
 |  is_use(self, *args)
 |      is_use(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      gco_info_t_flags_get(self) -> int
 |  
 |  name
 |      gco_info_t_name_get(self) -> qstring *
 |  
 |  size
 |      gco_info_t_size_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_gco_info_t>
 |      delete_gco_info_t(self)

Help on function gen_microcode in module ida_hexrays:

gen_microcode(*args)
    Generate microcode of an arbitrary code snippet
    
    gen_microcode(mbr, hf, retlist=None, decomp_flags=0, reqmat=MMAT_GLBOPT3) -> mba_t
        @param mbr: snippet ranges (C++: const  mba_ranges_t  &)
        @param hf: extended error information (if failed) (C++:
                   hexrays_failure_t  *)
        @param retlist: list of registers the snippet returns (C++: const
                        mlist_t  *)
        @param decomp_flags: bitwise combination of  decompile() flags ...
                             bits (C++: int)
        @param reqmat: required microcode maturity (C++: mba_maturity_t)
        @return: pointer to the microcode, NULL if failed.

Help on function get_ctype_name in module ida_hexrays:

get_ctype_name(*args)
    get_ctype_name(op) -> char const *
        @param op (C++: ctype_t)

Help on function get_current_operand in module ida_hexrays:

get_current_operand(*args)
    Get the instruction operand under the cursor. This function determines
    the operand that is under the cursor in the active disassembly
    listing. If the operand refers to a register or stack variable, it
    returns true.
    
    get_current_operand(out) -> bool
        @param out (C++: gco_info_t  *)

Help on function get_float_type in module ida_hexrays:

get_float_type(*args)
    Get a type of a floating point value with the specified width
    
    get_float_type(width) -> tinfo_t
        @param width: width of the desired type (C++: int)
        @return: type info object

Help on function get_hexrays_version in module ida_hexrays:

get_hexrays_version(*args)
    Get decompiler version. The returned string is of the form
    <major>.<minor>.<revision>.<build-date>

Help on function get_int_type_by_width_and_sign in module ida_hexrays:

get_int_type_by_width_and_sign(*args)
    Create a type info by width and sign. Returns a simple type (examples:
    int, short) with the given width and sign.
    
    get_int_type_by_width_and_sign(srcwidth, sign) -> tinfo_t
        @param srcwidth: size of the type in bytes (C++: int)
        @param sign: sign of the type (C++: type_sign_t)

Help on function get_member_type in module ida_hexrays:

get_member_type(*args)
    Get type of a structure field. This function performs validity checks
    of the field type. Wrong types are rejected.
    
    get_member_type(mptr, type) -> bool
        @param mptr: structure field (C++: const  member_t  *)
        @param type: pointer to the variable where the type is returned. This
                     parameter can be NULL. (C++: tinfo_t  *)
        @return: false if failed

Help on function get_merror_desc in module ida_hexrays:

get_merror_desc(*args)
    Get textual description of an error code
    
    get_merror_desc(code, mba) -> str
        @param code: Microcode error codes (C++: merror_t)
        @param mba: the microcode array (C++: mba_t  *)
        @return: the error address

Help on function get_mreg_name in module ida_hexrays:

get_mreg_name(*args)
    Get the microregister name.
    
    get_mreg_name(reg, width, ud=None) -> str
        @param reg (C++: mreg_t)
        @param width: size of microregister in bytes. may be bigger than the
                      real register size. (C++: int)
        @param ud: reserved, must be nullptr (C++: void *)
        @return: width of the printed register. this value may be less than
                 the WIDTH argument.

Help on function get_op_signness in module ida_hexrays:

get_op_signness(*args)
    Get operator sign. Meaningful for sign-dependent operators, like
    cot_sdiv.
    
    get_op_signness(op) -> type_sign_t
        @param op (C++: ctype_t)

Help on function get_signed_mcode in module ida_hexrays:

get_signed_mcode(*args)
    get_signed_mcode(code) -> mcode_t
        @param code (C++: mcode_t)

Help on function get_temp_regs in module ida_hexrays:

get_temp_regs(*args)
    Get list of temporary registers. Tempregs are temporary registers that
    are used during code generation. They do not map to regular processor
    registers. They are used only to store temporary values during
    execution of one instruction. Tempregs may not be used to pass a value
    from one block to another. In other words, at the end of a block all
    tempregs must be dead.

Help on function get_type in module ida_hexrays:

get_type(*args)
    Get a global type. Global types are types of addressable objects and
    struct/union/enum types
    
    get_type(id, tif, guess) -> bool
        @param id: address or id of the object (C++: uval_t)
        @param tif: buffer for the answer (C++: tinfo_t  *)
        @param guess: what kind of types to consider (C++: type_source_t)
        @return: success

Help on function get_unk_type in module ida_hexrays:

get_unk_type(*args)
    Create a partial type info by width. Returns a partially defined type
    (examples: _DWORD, _BYTE) with the given width.
    
    get_unk_type(size) -> tinfo_t
        @param size: size of the type in bytes (C++: int)

Help on function get_unsigned_mcode in module ida_hexrays:

get_unsigned_mcode(*args)
    get_unsigned_mcode(code) -> mcode_t
        @param code (C++: mcode_t)

Help on function get_widget_vdui in module ida_hexrays:

get_widget_vdui(*args)
    Get the 'vdui_t' instance associated to the TWidget
    
    get_widget_vdui(f) -> vdui_t
        @param f: pointer to window (C++: TWidget *)
        @return: a  vdui_t  *, or NULL

Help on function getb_reginsn in module ida_hexrays:

getb_reginsn(*args)
    Skip assertions backward.
    
    getb_reginsn(ins) -> minsn_t
        @param ins (C++: const  minsn_t  *)

Help on function getf_reginsn in module ida_hexrays:

getf_reginsn(*args)
    Skip assertions forward.
    
    getf_reginsn(ins) -> minsn_t
        @param ins (C++: const  minsn_t  *)

Help on class graph_chains_t in module ida_hexrays:

class graph_chains_t(block_chains_vec_t)
 |  Proxy of C++ graph_chains_t class.
 |  
 |  Method resolution order:
 |      graph_chains_t
 |      block_chains_vec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_chains_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  acquire(self, *args)
 |      Lock the chains.
 |  
 |  for_all_chains(self, *args)
 |      Visit all chains
 |      
 |      for_all_chains(self, cv, gca_flags) -> int
 |          @param cv: chain visitor (C++: chain_visitor_t  &)
 |          @param gca_flags: combination of GCA_ bits (C++: int)
 |  
 |  is_locked(self, *args)
 |      Are the chains locked? It is a good idea to lock the chains before
 |      using them. This ensures that they won't be recalculated and
 |      reallocated during the use. See the 'chain_keeper_t' class for that.
 |  
 |  release(self, *args)
 |      Unlock the chains.
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: graph_chains_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_graph_chains_t>
 |      delete_graph_chains_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from block_chains_vec_t:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> block_chains_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: block_chains_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> block_chains_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> block_chains_t
 |      begin(self) -> block_chains_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> block_chains_t
 |      end(self) -> block_chains_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> block_chains_t
 |          it: qvector< block_chains_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> block_chains_t
 |          first: qvector< block_chains_t >::iterator
 |          last: qvector< block_chains_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> block_chains_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=block_chains_t())
 |          x: block_chains_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: block_chains_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> block_chains_t
 |          it: qvector< block_chains_t >::iterator
 |          x: block_chains_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: block_chains_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: block_chains_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from block_chains_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function has_cached_cfunc in module ida_hexrays:

has_cached_cfunc(*args)
    Do we have a cached decompilation result for 'ea'?
    
    has_cached_cfunc(ea) -> bool
        @param ea (C++: ea_t)

Help on function has_mcode_seloff in module ida_hexrays:

has_mcode_seloff(*args)
    has_mcode_seloff(op) -> bool
        @param op (C++: mcode_t)

Help on function hexrays_alloc in module ida_hexrays:

hexrays_alloc(*args)
    hexrays_alloc(size) -> void *
        @param size (C++: size_t)

Help on class hexrays_failure_t in module ida_hexrays:

class hexrays_failure_t(__builtin__.object)
 |  Proxy of C++ hexrays_failure_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hexrays_failure_t
 |          c: enum merror_t
 |          ea: ea_t
 |          buf: char const *
 |      
 |      
 |      __init__(self, c, ea, buf) -> hexrays_failure_t
 |          c: enum merror_t
 |          ea: ea_t
 |          buf: qstring const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__ lambda self
 |  
 |  desc(self, *args)
 |      desc(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  code
 |      hexrays_failure_t_code_get(self) -> merror_t
 |  
 |  errea
 |      hexrays_failure_t_errea_get(self) -> ea_t
 |  
 |  str
 |      hexrays_failure_t_str_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_hexrays_failure_t>
 |      delete_hexrays_failure_t(self)

Help on function hexrays_free in module ida_hexrays:

hexrays_free(*args)
    hexrays_free(ptr)
        @param ptr (C++: void *)

Help on class hexwarn_t in module ida_hexrays:

class hexwarn_t(__builtin__.object)
 |  Proxy of C++ hexwarn_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: hexwarn_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: hexwarn_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: hexwarn_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hexwarn_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: hexwarn_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: hexwarn_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: hexwarn_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: hexwarn_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      hexwarn_t_ea_get(self) -> ea_t
 |  
 |  id
 |      hexwarn_t_id_get(self) -> warnid_t
 |  
 |  text
 |      hexwarn_t_text_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_hexwarn_t>
 |      delete_hexwarn_t(self)

Help on class hexwarns_t in module ida_hexrays:

class hexwarns_t(__builtin__.object)
 |  Proxy of C++ qvector< hexwarn_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< hexwarn_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> hexwarn_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hexwarns_t
 |          x: qvector< hexwarn_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< hexwarn_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: hexwarn_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: hexwarn_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: hexwarn_t const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> hexwarn_t
 |      begin(self) -> hexwarn_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> hexwarn_t
 |      end(self) -> hexwarn_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> hexwarn_t
 |          it: qvector< hexwarn_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> hexwarn_t
 |          first: qvector< hexwarn_t >::iterator
 |          last: qvector< hexwarn_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> hexwarn_t
 |  
 |  find(self, *args)
 |      find(self, x) -> hexwarn_t
 |          x: hexwarn_t const &
 |      
 |      
 |      find(self, x) -> hexwarn_t
 |          x: hexwarn_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=hexwarn_t())
 |          x: hexwarn_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: hexwarn_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: hexwarn_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> hexwarn_t
 |          it: qvector< hexwarn_t >::iterator
 |          x: hexwarn_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: hexwarn_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: hexwarn_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< hexwarn_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_hexwarns_t>
 |      delete_hexwarns_t(self)

Help on class history_item_t in module ida_hexrays:

class history_item_t(ctext_position_t)
 |  Proxy of C++ history_item_t class.
 |  
 |  Method resolution order:
 |      history_item_t
 |      ctext_position_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea=BADADDR, _lnnum=-1, _x=0, _y=0) -> history_item_t
 |          _ea: ea_t
 |          _lnnum: int
 |          _x: int
 |          _y: int
 |      
 |      
 |      __init__(self, _ea, p) -> history_item_t
 |          _ea: ea_t
 |          p: ctext_position_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ea
 |      history_item_t_ea_get(self) -> ea_t
 |  
 |  end
 |      history_item_t_end_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_history_item_t>
 |      delete_history_item_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctext_position_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: ctext_position_t const &
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: ctext_position_t const &
 |  
 |  in_ctree(self, *args)
 |      Is the cursor in the variable/type declaration area?
 |      
 |      in_ctree(self, hdrlines) -> bool
 |          @param hdrlines: Number of lines of the declaration area (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ctext_position_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      ctext_position_t_lnnum_get(self) -> int
 |  
 |  x
 |      ctext_position_t_x_get(self) -> int
 |  
 |  y
 |      ctext_position_t_y_get(self) -> int

Help on class history_t in module ida_hexrays:

class history_t(qvector_history_t)
 |  Proxy of C++ qstack< history_item_t > class.
 |  
 |  Method resolution order:
 |      history_t
 |      qvector_history_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> history_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  append = push_back(self, *args)
 |      push_back(self, x)
 |          x: history_item_t const &
 |  
 |  at = __getitem__(self, *args)
 |      __getitem__(self, i) -> history_item_t
 |          i: size_t
 |  
 |  pop(self, *args)
 |      pop(self) -> history_item_t
 |  
 |  push(self, *args)
 |      push(self, v)
 |          v: history_item_t const &
 |  
 |  top(self, *args)
 |      top(self) -> history_item_t
 |      top(self) -> history_item_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_history_t>
 |      delete_history_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_history_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< history_item_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> history_item_t
 |          i: size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< history_item_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: history_item_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: history_item_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: history_item_t const &
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> history_item_t
 |      begin(self) -> history_item_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> history_item_t
 |      end(self) -> history_item_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> history_item_t
 |          it: qvector< history_item_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> history_item_t
 |          first: qvector< history_item_t >::iterator
 |          last: qvector< history_item_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> history_item_t
 |  
 |  find(self, *args)
 |      find(self, x) -> history_item_t
 |          x: history_item_t const &
 |      
 |      
 |      find(self, x) -> history_item_t
 |          x: history_item_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=history_item_t())
 |          x: history_item_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: history_item_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: history_item_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> history_item_t
 |          it: qvector< history_item_t >::iterator
 |          x: history_item_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: history_item_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: history_item_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< history_item_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_history_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function init_hexrays_plugin in module ida_hexrays:

init_hexrays_plugin(*args)
    Initialize your plugin for hex-rays decompiler. This function must be
    called before calling any other decompiler function. It initializes
    the pointer to the dispatcher.
    
    init_hexrays_plugin(flags=0) -> bool
        @param flags: reserved, must be 0 (C++: int)
        @return: true if the decompiler exists and the dispatcher pointer is
                 ready to use.

Help on function install_hexrays_callback in module ida_hexrays:

install_hexrays_callback(callback)
    Deprecated. Please use Hexrays_Hooks instead

Help on function install_microcode_filter in module ida_hexrays:

install_microcode_filter(*args)
    register/unregister non-standard microcode generator
    
    install_microcode_filter(filter, install=True) -> bool
        @param filter: - microcode generator object (C++: microcode_filter_t
                       *)
        @param install: - TRUE - register the object, FALSE - unregister (C++:
                        bool)
        @return: success

Help on function is_additive in module ida_hexrays:

is_additive(*args)
    Is additive operator?
    
    is_additive(op) -> bool
        @param op (C++: ctype_t)

Help on function is_assignment in module ida_hexrays:

is_assignment(*args)
    Is assignment operator?
    
    is_assignment(op) -> bool
        @param op (C++: ctype_t)

Help on function is_binary in module ida_hexrays:

is_binary(*args)
    Is binary operator?
    
    is_binary(op) -> bool
        @param op (C++: ctype_t)

Help on function is_bitop in module ida_hexrays:

is_bitop(*args)
    Is bit related operator?
    
    is_bitop(op) -> bool
        @param op (C++: ctype_t)

Help on function is_bool_type in module ida_hexrays:

is_bool_type(*args)
    Is a boolean type?
    
    is_bool_type(type) -> bool
        @param type (C++: const  tinfo_t  &)
        @return: true if the type is a boolean type

Help on function is_break_consumer in module ida_hexrays:

is_break_consumer(*args)
    Does a break statement influence the specified statement code?
    
    is_break_consumer(op) -> bool
        @param op (C++: ctype_t)

Help on function is_commutative in module ida_hexrays:

is_commutative(*args)
    Is commutative operator?
    
    is_commutative(op) -> bool
        @param op (C++: ctype_t)

Help on function is_inplace_def in module ida_hexrays:

is_inplace_def(*args)
    Is struct/union/enum definition (not declaration)?
    
    is_inplace_def(type) -> bool
        @param type (C++: const  tinfo_t  &)

Help on function is_kreg in module ida_hexrays:

is_kreg(*args)
    Is a kernel register? Kernel registers are temporary registers that
    can be used freely. They may be used to store values that cross
    instruction or basic block boundaries. Kernel registers do not map to
    regular processor registers. See also 'mba_t::alloc_kreg()'
    
    is_kreg(r) -> bool
        @param r (C++: mreg_t)

Help on function is_logical in module ida_hexrays:

is_logical(*args)
    Is logical operator?
    
    is_logical(op) -> bool
        @param op (C++: ctype_t)

Help on function is_loop in module ida_hexrays:

is_loop(*args)
    Is loop statement code?
    
    is_loop(op) -> bool
        @param op (C++: ctype_t)

Help on function is_lvalue in module ida_hexrays:

is_lvalue(*args)
    Is Lvalue operator?
    
    is_lvalue(op) -> bool
        @param op (C++: ctype_t)

Help on function is_may_access in module ida_hexrays:

is_may_access(*args)
    is_may_access(maymust) -> bool
        @param maymust (C++: maymust_t)

Help on function is_mcode_addsub in module ida_hexrays:

is_mcode_addsub(*args)
    is_mcode_addsub(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_call in module ida_hexrays:

is_mcode_call(*args)
    is_mcode_call(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_commutative in module ida_hexrays:

is_mcode_commutative(*args)
    is_mcode_commutative(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_convertible_to_jmp in module ida_hexrays:

is_mcode_convertible_to_jmp(*args)
    is_mcode_convertible_to_jmp(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_convertible_to_set in module ida_hexrays:

is_mcode_convertible_to_set(*args)
    is_mcode_convertible_to_set(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_divmod in module ida_hexrays:

is_mcode_divmod(*args)
    is_mcode_divmod(op) -> bool
        @param op (C++: mcode_t)

Help on function is_mcode_fpu in module ida_hexrays:

is_mcode_fpu(*args)
    is_mcode_fpu(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_j1 in module ida_hexrays:

is_mcode_j1(*args)
    is_mcode_j1(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_jcond in module ida_hexrays:

is_mcode_jcond(*args)
    is_mcode_jcond(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_propagatable in module ida_hexrays:

is_mcode_propagatable(*args)
    May opcode be propagated? Such opcodes can be used in sub-instructions
    (nested instructions) There is a handful of non-propagatable opcodes,
    like jumps, ret, nop, etc All other regular opcodes are propagatable
    and may appear in a nested instruction.
    
    is_mcode_propagatable(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_set in module ida_hexrays:

is_mcode_set(*args)
    is_mcode_set(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_set1 in module ida_hexrays:

is_mcode_set1(*args)
    is_mcode_set1(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_shift in module ida_hexrays:

is_mcode_shift(*args)
    is_mcode_shift(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_mcode_xdsu in module ida_hexrays:

is_mcode_xdsu(*args)
    is_mcode_xdsu(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on function is_multiplicative in module ida_hexrays:

is_multiplicative(*args)
    Is multiplicative operator?
    
    is_multiplicative(op) -> bool
        @param op (C++: ctype_t)

Help on function is_nonbool_type in module ida_hexrays:

is_nonbool_type(*args)
    Is definitely a non-boolean type?
    
    is_nonbool_type(type) -> bool
        @param type (C++: const  tinfo_t  &)
        @return: true if the type is a non-boolean type (non bool and well
                 defined)

Help on function is_paf in module ida_hexrays:

is_paf(*args)
    Is a pointer, array, or function type?
    
    is_paf(t) -> bool
        @param t (C++: type_t)

Help on function is_prepost in module ida_hexrays:

is_prepost(*args)
    Is pre/post increment/decrement operator?
    
    is_prepost(op) -> bool
        @param op (C++: ctype_t)

Help on function is_ptr_or_array in module ida_hexrays:

is_ptr_or_array(*args)
    Is a pointer or array type?
    
    is_ptr_or_array(t) -> bool
        @param t (C++: type_t)

Help on function is_relational in module ida_hexrays:

is_relational(*args)
    Is comparison operator?
    
    is_relational(op) -> bool
        @param op (C++: ctype_t)

Help on function is_signed_mcode in module ida_hexrays:

is_signed_mcode(*args)
    is_signed_mcode(code) -> bool
        @param code (C++: mcode_t)

Help on function is_small_udt in module ida_hexrays:

is_small_udt(*args)
    Is a small structure or union?
    
    is_small_udt(tif) -> bool
        @param tif (C++: const  tinfo_t  &)
        @return: true if the type is a small UDT (user defined type). Small
                 UDTs fit into a register (or pair or registers) as a rule.

Help on function is_type_correct in module ida_hexrays:

is_type_correct(*args)
    Verify a type string.
    
    is_type_correct(ptr) -> bool
        @param ptr (C++: const  type_t  *)
        @return: true if type string is correct

Help on function is_unary in module ida_hexrays:

is_unary(*args)
    Is unary operator?
    
    is_unary(op) -> bool
        @param op (C++: ctype_t)

Help on function is_unsigned_mcode in module ida_hexrays:

is_unsigned_mcode(*args)
    is_unsigned_mcode(code) -> bool
        @param code (C++: mcode_t)

Help on class iterator in module ida_hexrays:

class iterator(__builtin__.object)
 |  Proxy of C++ bitset_t::iterator class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, n) -> bool
 |          n: bitset_t::iterator const &
 |  
 |  __init__(self, *args)
 |      __init__(self, n=-1) -> iterator
 |          n: int
 |  
 |  __ne__(self, *args)
 |      __ne__(self, n) -> bool
 |          n: bitset_t::iterator const &
 |  
 |  __ref__(self, *args)
 |      __ref__(self) -> int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_iterator>
 |      delete_iterator(self)

Help on class ivl_t in module ida_hexrays:

class ivl_t(uval_ivl_t)
 |  Proxy of C++ ivl_t class.
 |  
 |  Method resolution order:
 |      ivl_t
 |      uval_ivl_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: ivl_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: ivl_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: ivl_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _off, _size) -> ivl_t
 |          _off: uval_t
 |          _size: uval_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: ivl_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: ivl_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: ivl_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: ivl_t const &
 |  
 |  contains(self, *args)
 |      contains(self, off2) -> bool
 |          @param off2 (C++: uval_t)
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  extend_to_cover(self, *args)
 |      extend_to_cover(self, r) -> bool
 |          @param r (C++: const  ivl_t  &)
 |  
 |  includes(self, *args)
 |      includes(self, ivl) -> bool
 |          @param ivl (C++: const  ivl_t  &)
 |  
 |  intersect(self, *args)
 |      intersect(self, r)
 |          @param r (C++: const  ivl_t  &)
 |  
 |  overlap(self, *args)
 |      overlap(self, ivl) -> bool
 |          @param ivl (C++: const  ivl_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ivl_t>
 |      delete_ivl_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from uval_ivl_t:
 |  
 |  end(self, *args)
 |      end(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  last(self, *args)
 |      last(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  valid(self, *args)
 |      valid(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from uval_ivl_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      uval_ivl_t_off_get(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  size
 |      uval_ivl_t_size_get(self) -> unsigned-ea-like-numeric-type↗

Help on class ivl_with_name_t in module ida_hexrays:

class ivl_with_name_t(__builtin__.object)
 |  Proxy of C++ ivl_with_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ivl_with_name_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ivl
 |      ivl_with_name_t_ivl_get(self) -> ivl_t
 |  
 |  part
 |      ivl_with_name_t_part_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  whole
 |      ivl_with_name_t_whole_get(self) -> char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ivl_with_name_t>
 |      delete_ivl_with_name_t(self)

Help on class ivlset_t in module ida_hexrays:

class ivlset_t(uval_ivl_ivlset_t)
 |  Proxy of C++ ivlset_t class.
 |  
 |  Method resolution order:
 |      ivlset_t
 |      uval_ivl_ivlset_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: ivlset_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: ivlset_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: ivlset_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ivlset_t
 |          ivl: ivl_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: ivlset_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: ivlset_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: ivlset_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self)
 |  
 |  add(self, *args)
 |      add(self, ivl) -> bool
 |          @param ivl (C++: const  ivl_t  &)
 |      
 |      
 |      add(self, ea, size) -> bool
 |          ea: ea_t
 |          size: asize_t
 |      
 |      
 |      add(self, ivs) -> bool
 |          ivs: ivlset_t const &
 |  
 |  addmasked(self, *args)
 |      addmasked(self, ivs, mask) -> bool
 |          @param ivs (C++: const  ivlset_t  &)
 |          @param mask (C++: const  ivl_t  &)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: ivlset_t const &
 |  
 |  contains(self, *args)
 |      contains(self, off) -> bool
 |          @param off (C++: uval_t)
 |  
 |  count(self, *args)
 |      count(self) -> asize_t
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  has_common(self, *args)
 |      has_common(self, ivl, strict=False) -> bool
 |          @param ivl (C++: const  ivl_t  &)
 |          @param strict (C++: bool)
 |      
 |      
 |      has_common(self, ivs) -> bool
 |          ivs: ivlset_t const &
 |  
 |  includes(self, *args)
 |      includes(self, ivs) -> bool
 |          @param ivs (C++: const  ivlset_t  &)
 |  
 |  intersect(self, *args)
 |      intersect(self, ivs) -> bool
 |          @param ivs (C++: const  ivlset_t  &)
 |  
 |  sub(self, *args)
 |      sub(self, ivl) -> bool
 |          @param ivl (C++: const  ivl_t  &)
 |      
 |      
 |      sub(self, ea, size) -> bool
 |          ea: ea_t
 |          size: asize_t
 |      
 |      
 |      sub(self, ivs) -> bool
 |          ivs: ivlset_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ivlset_t>
 |      delete_ivlset_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from uval_ivl_ivlset_t:
 |  
 |  all_values(self, *args)
 |      all_values(self) -> bool
 |  
 |  begin(self, *args)
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator↗
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator↗
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  getivl(self, *args)
 |      getivl(self, idx) -> ivl_t
 |          idx: int
 |  
 |  lastivl(self, *args)
 |      lastivl(self) -> ivl_t
 |  
 |  nivls(self, *args)
 |      nivls(self) -> size_t
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  set_all_values(self, *args)
 |      set_all_values(self)
 |  
 |  single_value(self, *args)
 |      single_value(self) -> bool
 |          v: unsigned-ea-like-numeric-type↗
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: ivlset_tpl< ivl_t,uval_t > &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from uval_ivl_ivlset_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function jcnd2set in module ida_hexrays:

jcnd2set(*args)
    jcnd2set(code) -> mcode_t
        @param code (C++: mcode_t)

Help on function lexcompare in module ida_hexrays:

lexcompare(*args)
    lexcompare(a, b) -> int
        a: mop_t const &
        b: mop_t const &

Help on function lnot in module ida_hexrays:

lnot(e)

Help on class lvar_locator_t in module ida_hexrays:

class lvar_locator_t(__builtin__.object)
 |  Proxy of C++ lvar_locator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_locator_t
 |          loc: vdloc_t const &
 |          ea: ea_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: lvar_locator_t const &
 |  
 |  get_reg1(self, *args)
 |      Get the register number of the variable.
 |  
 |  get_reg2(self, *args)
 |      Get the number of the second register (works only for ALOC_REG2 lvars)
 |  
 |  get_scattered(self, *args)
 |      Get information about scattered variable.
 |  
 |  get_stkoff(self, *args)
 |      Get offset of the varialbe in the stack frame.
 |  
 |  is_reg1(self, *args)
 |      Is variable located on one register?
 |  
 |  is_reg2(self, *args)
 |      Is variable located on two registers?
 |  
 |  is_reg_var(self, *args)
 |      Is variable located on register(s)?
 |  
 |  is_scattered(self, *args)
 |      Is variable scattered?
 |  
 |  is_stk_var(self, *args)
 |      Is variable located on the stack?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  defea
 |      lvar_locator_t_defea_get(self) -> ea_t
 |  
 |  location
 |      lvar_locator_t_location_get(self) -> vdloc_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lvar_locator_t>
 |      delete_lvar_locator_t(self)

Help on function lvar_mapping_begin in module ida_hexrays:

lvar_mapping_begin(*args)
    Get iterator pointing to the beginning of lvar_mapping_t.
    
    lvar_mapping_begin(map) -> lvar_mapping_iterator_t
        @param map (C++: const lvar_mapping_t *)

Help on function lvar_mapping_clear in module ida_hexrays:

lvar_mapping_clear(*args)
    Clear lvar_mapping_t.
    
    lvar_mapping_clear(map)
        @param map (C++: lvar_mapping_t *)

Help on function lvar_mapping_end in module ida_hexrays:

lvar_mapping_end(*args)
    Get iterator pointing to the end of lvar_mapping_t.
    
    lvar_mapping_end(map) -> lvar_mapping_iterator_t
        @param map (C++: const lvar_mapping_t *)

Help on function lvar_mapping_erase in module ida_hexrays:

lvar_mapping_erase(*args)
    Erase current element from lvar_mapping_t.
    
    lvar_mapping_erase(map, p)
        @param map (C++: lvar_mapping_t *)
        @param p (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_find in module ida_hexrays:

lvar_mapping_find(*args)
    Find the specified key in lvar_mapping_t.
    
    lvar_mapping_find(map, key) -> lvar_mapping_iterator_t
        @param map (C++: const lvar_mapping_t *)
        @param key (C++: const  lvar_locator_t  &)

Help on function lvar_mapping_first in module ida_hexrays:

lvar_mapping_first(*args)
    Get reference to the current map key.
    
    lvar_mapping_first(p) -> lvar_locator_t
        @param p (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_free in module ida_hexrays:

lvar_mapping_free(*args)
    Delete lvar_mapping_t instance.
    
    lvar_mapping_free(map)
        @param map (C++: lvar_mapping_t *)

Help on function lvar_mapping_insert in module ida_hexrays:

lvar_mapping_insert(*args)
    Insert new ( 'lvar_locator_t' , 'lvar_locator_t' ) pair into
    lvar_mapping_t.
    
    lvar_mapping_insert(map, key, val) -> lvar_mapping_iterator_t
        @param map (C++: lvar_mapping_t *)
        @param key (C++: const  lvar_locator_t  &)
        @param val (C++: const  lvar_locator_t  &)

Help on class lvar_mapping_iterator_t in module ida_hexrays:

class lvar_mapping_iterator_t(__builtin__.object)
 |  Proxy of C++ lvar_mapping_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, p) -> bool
 |          p: lvar_mapping_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_mapping_iterator_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, p) -> bool
 |          p: lvar_mapping_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      lvar_mapping_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lvar_mapping_iterator_t>
 |      delete_lvar_mapping_iterator_t(self)

Help on function lvar_mapping_new in module ida_hexrays:

lvar_mapping_new(*args)
    Create a new lvar_mapping_t instance.

Help on function lvar_mapping_next in module ida_hexrays:

lvar_mapping_next(*args)
    Move to the next element.
    
    lvar_mapping_next(p) -> lvar_mapping_iterator_t
        @param p (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_prev in module ida_hexrays:

lvar_mapping_prev(*args)
    Move to the previous element.
    
    lvar_mapping_prev(p) -> lvar_mapping_iterator_t
        @param p (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_second in module ida_hexrays:

lvar_mapping_second(*args)
    Get reference to the current map value.
    
    lvar_mapping_second(p) -> lvar_locator_t
        @param p (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_size in module ida_hexrays:

lvar_mapping_size(*args)
    Get size of lvar_mapping_t.
    
    lvar_mapping_size(map) -> size_t
        @param map (C++: lvar_mapping_t *)

Help on class lvar_mapping_t in module ida_hexrays:

class lvar_mapping_t(__builtin__.object)
 |  Proxy of C++ std::map< lvar_locator_t,lvar_locator_t > class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_mapping_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  at(self, *args)
 |      at(self, _Keyval) -> lvar_locator_t
 |          _Keyval: lvar_locator_t const &
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lvar_mapping_t>
 |      delete_lvar_mapping_t(self)

Help on class lvar_ref_t in module ida_hexrays:

class lvar_ref_t(__builtin__.object)
 |  Proxy of C++ lvar_ref_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: lvar_ref_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: lvar_ref_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: lvar_ref_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, m, i, o=0) -> lvar_ref_t
 |          m: mba_t *
 |          i: int
 |          o: sval_t
 |      
 |      
 |      __init__(self, r) -> lvar_ref_t
 |          r: lvar_ref_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: lvar_ref_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: lvar_ref_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: lvar_ref_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: lvar_ref_t const &
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: lvar_ref_t  &)
 |  
 |  var(self, *args)
 |      Retrieve the referenced variable.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  idx
 |      lvar_ref_t_idx_get(self) -> int
 |  
 |  mba
 |      lvar_ref_t_mba_get(self) -> mba_t
 |  
 |  off
 |      lvar_ref_t_off_get(self) -> sval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lvar_ref_t>
 |      delete_lvar_ref_t(self)

Help on class lvar_saved_info_t in module ida_hexrays:

class lvar_saved_info_t(__builtin__.object)
 |  Proxy of C++ lvar_saved_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: lvar_saved_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_saved_info_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: lvar_saved_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear_keep(self, *args)
 |      clear_keep(self)
 |  
 |  clr_forced_lvar(self, *args)
 |      clr_forced_lvar(self)
 |  
 |  clr_nomap_lvar(self, *args)
 |      clr_nomap_lvar(self)
 |  
 |  clr_noptr_lvar(self, *args)
 |      clr_noptr_lvar(self)
 |  
 |  has_info(self, *args)
 |      has_info(self) -> bool
 |  
 |  is_forced_lvar(self, *args)
 |      is_forced_lvar(self) -> bool
 |  
 |  is_kept(self, *args)
 |      is_kept(self) -> bool
 |  
 |  is_nomap_lvar(self, *args)
 |      is_nomap_lvar(self) -> bool
 |  
 |  is_noptr_lvar(self, *args)
 |      is_noptr_lvar(self) -> bool
 |  
 |  set_forced_lvar(self, *args)
 |      set_forced_lvar(self)
 |  
 |  set_keep(self, *args)
 |      set_keep(self)
 |  
 |  set_nomap_lvar(self, *args)
 |      set_nomap_lvar(self)
 |  
 |  set_noptr_lvar(self, *args)
 |      set_noptr_lvar(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      lvar_saved_info_t_cmt_get(self) -> qstring *
 |  
 |  flags
 |      lvar_saved_info_t_flags_get(self) -> int
 |  
 |  ll
 |      lvar_saved_info_t_ll_get(self) -> lvar_locator_t
 |  
 |  name
 |      lvar_saved_info_t_name_get(self) -> qstring *
 |  
 |  size
 |      lvar_saved_info_t_size_get(self) -> ssize_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      lvar_saved_info_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lvar_saved_info_t>
 |      delete_lvar_saved_info_t(self)

Help on class lvar_saved_infos_t in module ida_hexrays:

class lvar_saved_infos_t(__builtin__.object)
 |  Proxy of C++ qvector< lvar_saved_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< lvar_saved_info_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> lvar_saved_info_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_saved_infos_t
 |          x: qvector< lvar_saved_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< lvar_saved_info_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: lvar_saved_info_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: lvar_saved_info_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: lvar_saved_info_t const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> lvar_saved_info_t
 |      begin(self) -> lvar_saved_info_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> lvar_saved_info_t
 |      end(self) -> lvar_saved_info_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> lvar_saved_info_t
 |          it: qvector< lvar_saved_info_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> lvar_saved_info_t
 |          first: qvector< lvar_saved_info_t >::iterator
 |          last: qvector< lvar_saved_info_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> lvar_saved_info_t
 |  
 |  find(self, *args)
 |      find(self, x) -> lvar_saved_info_t
 |          x: lvar_saved_info_t const &
 |      
 |      
 |      find(self, x) -> lvar_saved_info_t
 |          x: lvar_saved_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=lvar_saved_info_t())
 |          x: lvar_saved_info_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: lvar_saved_info_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: lvar_saved_info_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> lvar_saved_info_t
 |          it: qvector< lvar_saved_info_t >::iterator
 |          x: lvar_saved_info_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: lvar_saved_info_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: lvar_saved_info_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< lvar_saved_info_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lvar_saved_infos_t>
 |      delete_lvar_saved_infos_t(self)

Help on class lvar_t in module ida_hexrays:

class lvar_t(lvar_locator_t)
 |  Proxy of C++ lvar_t class.
 |  
 |  Method resolution order:
 |      lvar_t
 |      lvar_locator_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  accepts_type(self, *args)
 |      Check if the variable accept the specified type. Some types are
 |      forbidden (void, function types, wrong arrays, etc)
 |      
 |      accepts_type(self, t, may_change_thisarg=False) -> bool
 |          @param t (C++: const  tinfo_t  &)
 |          @param may_change_thisarg (C++: bool)
 |  
 |  append_list(self, *args)
 |      Append local variable to mlist.
 |      
 |      append_list(self, lst, pad_if_scattered=False)
 |          @param lst: list to append to (C++: mlist_t  *)
 |          @param pad_if_scattered (C++: bool)
 |  
 |  clear_used(self, *args)
 |      clear_used(self)
 |  
 |  clr_arg_var(self, *args)
 |      clr_arg_var(self)
 |  
 |  clr_automapped(self, *args)
 |      clr_automapped(self)
 |  
 |  clr_dummy_arg(self, *args)
 |      clr_dummy_arg(self)
 |  
 |  clr_fake_var(self, *args)
 |      clr_fake_var(self)
 |  
 |  clr_floating_var(self, *args)
 |      clr_floating_var(self)
 |  
 |  clr_forced_var(self, *args)
 |      clr_forced_var(self)
 |  
 |  clr_mapdst_var(self, *args)
 |      clr_mapdst_var(self)
 |  
 |  clr_mreg_done(self, *args)
 |      clr_mreg_done(self)
 |  
 |  clr_noptr_var(self, *args)
 |      clr_noptr_var(self)
 |  
 |  clr_notarg(self, *args)
 |      clr_notarg(self)
 |  
 |  clr_overlapped_var(self, *args)
 |      clr_overlapped_var(self)
 |  
 |  clr_spoiled_var(self, *args)
 |      clr_spoiled_var(self)
 |  
 |  clr_thisarg(self, *args)
 |      clr_thisarg(self)
 |  
 |  clr_unknown_width(self, *args)
 |      clr_unknown_width(self)
 |  
 |  clr_used_byref(self, *args)
 |      clr_used_byref(self)
 |  
 |  clr_user_info(self, *args)
 |      clr_user_info(self)
 |  
 |  clr_user_name(self, *args)
 |      clr_user_name(self)
 |  
 |  clr_user_type(self, *args)
 |      clr_user_type(self)
 |  
 |  has_common(self, *args)
 |      Do variables overlap?
 |      
 |      has_common(self, v) -> bool
 |          @param v (C++: const  lvar_t  &)
 |  
 |  has_common_bit(self, *args)
 |      Does the variable overlap with the specified location?
 |      
 |      has_common_bit(self, loc, width2) -> bool
 |          @param loc (C++: const  vdloc_t  &)
 |          @param width2 (C++: asize_t)
 |  
 |  has_regname(self, *args)
 |      Has a register name? (like _RAX)
 |  
 |  is_aliasable(self, *args)
 |      Is the variable aliasable?
 |      
 |      is_aliasable(self, mba) -> bool
 |          @param mba: ptr to the current  mba_t  Aliasable variables may be
 |                      modified indirectly (through a pointer) (C++: const  mba_t
 |                      *)
 |  
 |  is_automapped(self, *args)
 |      Was the variable automatically mapped to another variable?
 |  
 |  is_dummy_arg(self, *args)
 |      Is a dummy argument (added to fill a hole in the argument list)
 |  
 |  is_forced_var(self, *args)
 |      Is a forced variable?
 |  
 |  is_noptr_var(self, *args)
 |      Variable type should not be a pointer.
 |  
 |  is_notarg(self, *args)
 |      Is a local variable? (local variable cannot be an input argument)
 |  
 |  is_thisarg(self, *args)
 |      Is 'this' argument of a C++ member function?
 |  
 |  is_used_byref(self, *args)
 |      Was the address of the variable taken?
 |  
 |  set_arg_var(self, *args)
 |      set_arg_var(self)
 |  
 |  set_automapped(self, *args)
 |      set_automapped(self)
 |  
 |  set_dummy_arg(self, *args)
 |      set_dummy_arg(self)
 |  
 |  set_fake_var(self, *args)
 |      set_fake_var(self)
 |  
 |  set_final_lvar_type(self, *args)
 |      Set final variable type.
 |      
 |      set_final_lvar_type(self, t)
 |          @param t (C++: const  tinfo_t  &)
 |  
 |  set_floating_var(self, *args)
 |      set_floating_var(self)
 |  
 |  set_forced_var(self, *args)
 |      set_forced_var(self)
 |  
 |  set_lvar_type(self, *args)
 |      Set variable type Note: this function does not modify the idb, only
 |      the lvar instance in the memory. For permanent changes see
 |      modify_user_lvars() Also, the variable type is not considered as final
 |      by the decompiler and may be modified later by the type derivation. In
 |      some cases set_final_var_type() may work better, but it does not do
 |      persistent changes to the database neither.
 |      
 |      set_lvar_type(self, t, may_fail=False) -> bool
 |          @param t: new type (C++: const  tinfo_t  &)
 |          @param may_fail: if false and type is bad, interr (C++: bool)
 |          @return: success
 |  
 |  set_mapdst_var(self, *args)
 |      set_mapdst_var(self)
 |  
 |  set_mreg_done(self, *args)
 |      set_mreg_done(self)
 |  
 |  set_non_typed(self, *args)
 |      set_non_typed(self)
 |  
 |  set_noptr_var(self, *args)
 |      set_noptr_var(self)
 |  
 |  set_notarg(self, *args)
 |      set_notarg(self)
 |  
 |  set_overlapped_var(self, *args)
 |      set_overlapped_var(self)
 |  
 |  set_spoiled_var(self, *args)
 |      set_spoiled_var(self)
 |  
 |  set_thisarg(self, *args)
 |      set_thisarg(self)
 |  
 |  set_typed(self, *args)
 |      set_typed(self)
 |  
 |  set_unknown_width(self, *args)
 |      set_unknown_width(self)
 |  
 |  set_used(self, *args)
 |      set_used(self)
 |  
 |  set_used_byref(self, *args)
 |      set_used_byref(self)
 |  
 |  set_user_name(self, *args)
 |      set_user_name(self)
 |  
 |  set_user_type(self, *args)
 |      set_user_type(self)
 |  
 |  set_width(self, *args)
 |      Change the variable width. We call the variable size 'width', it is
 |      represents the number of bytes. This function may change the variable
 |      type using 'set_lvar_type()' .
 |      
 |      set_width(self, w, svw_flags=0) -> bool
 |          @param w: new width (C++: int)
 |          @param svw_flags: combination of SVW_... bits (C++: int)
 |          @return: success
 |  
 |  type(self, *args)
 |      Get variable type.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cmt
 |      lvar_t_cmt_get(self) -> qstring *
 |  
 |  defblk
 |      lvar_t_defblk_get(self) -> int
 |  
 |  divisor
 |      lvar_t_divisor_get(self) -> uint64
 |  
 |  has_nice_name
 |      Does the variable have a nice name?
 |  
 |  has_user_info
 |      Has any user-defined information?
 |  
 |  has_user_name
 |      Has user-defined name?
 |  
 |  has_user_type
 |      Has user-defined type?
 |  
 |  is_arg_var
 |      Is the function argument?
 |  
 |  is_fake_var
 |      Is fake return variable?
 |  
 |  is_floating_var
 |      Used by a fpu insn?
 |  
 |  is_mapdst_var
 |      Other variable(s) map to this var?
 |  
 |  is_overlapped_var
 |      Is overlapped variable?
 |  
 |  is_result_var
 |      Is the function result?
 |  
 |  is_spoiled_var
 |      Is spoiled var? (meaningful only during lvar allocation)
 |  
 |  is_unknown_width
 |      Do we know the width of the variable?
 |  
 |  mreg_done
 |      Have corresponding microregs been replaced by references to this
 |      variable?
 |  
 |  name
 |      lvar_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  tif
 |      lvar_t_tif_get(self) -> tinfo_t
 |  
 |  typed
 |      Has the variable a type?
 |  
 |  used
 |      Is the variable used in the code?
 |  
 |  width
 |      lvar_t_width_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lvar_t>
 |      delete_lvar_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from lvar_locator_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: lvar_locator_t const &
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: lvar_locator_t const &
 |  
 |  get_reg1(self, *args)
 |      Get the register number of the variable.
 |  
 |  get_reg2(self, *args)
 |      Get the number of the second register (works only for ALOC_REG2 lvars)
 |  
 |  get_scattered(self, *args)
 |      Get information about scattered variable.
 |  
 |  get_stkoff(self, *args)
 |      Get offset of the varialbe in the stack frame.
 |  
 |  is_reg1(self, *args)
 |      Is variable located on one register?
 |  
 |  is_reg2(self, *args)
 |      Is variable located on two registers?
 |  
 |  is_reg_var(self, *args)
 |      Is variable located on register(s)?
 |  
 |  is_scattered(self, *args)
 |      Is variable scattered?
 |  
 |  is_stk_var(self, *args)
 |      Is variable located on the stack?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from lvar_locator_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  defea
 |      lvar_locator_t_defea_get(self) -> ea_t
 |  
 |  location
 |      lvar_locator_t_location_get(self) -> vdloc_t

Help on class lvar_uservec_t in module ida_hexrays:

class lvar_uservec_t(__builtin__.object)
 |  Proxy of C++ lvar_uservec_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_uservec_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  find_info(self, *args)
 |      find saved user settings for given var
 |      
 |      find_info(self, vloc) -> lvar_saved_info_t
 |          @param vloc (C++: const  lvar_locator_t  &)
 |  
 |  keep_info(self, *args)
 |      Preserve user settings for given var.
 |      
 |      keep_info(self, v)
 |          @param v (C++: const  lvar_t  &)
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: lvar_uservec_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lmaps
 |      lvar_uservec_t_lmaps_get(self) -> lvar_mapping_t
 |  
 |  lvvec
 |      lvar_uservec_t_lvvec_get(self) -> lvar_saved_infos_t
 |  
 |  stkoff_delta
 |      lvar_uservec_t_stkoff_delta_get(self) -> uval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ulv_flags
 |      lvar_uservec_t_ulv_flags_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lvar_uservec_t>
 |      delete_lvar_uservec_t(self)

Help on class lvars_t in module ida_hexrays:

class lvars_t(qvector_lvar_t)
 |  Proxy of C++ lvars_t class.
 |  
 |  Method resolution order:
 |      lvars_t
 |      qvector_lvar_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvars_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  find(self, *args)
 |      Find variable at the specified location.
 |      
 |      find(self, ll) -> lvar_t
 |          @param ll: variable location (C++: const  lvar_locator_t  &)
 |          @return: pointer to variable or NULL
 |  
 |  find_input_lvar(self, *args)
 |      Find input variable at the specified location.
 |      
 |      find_input_lvar(self, argloc, _size) -> int
 |          @param argloc: variable location (C++: const  vdloc_t  &)
 |          @param _size: variable size (C++: int)
 |          @return: -1 if failed, otherwise the index into the variables vector.
 |  
 |  find_lvar(self, *args)
 |      Find variable at the specified location.
 |      
 |      find_lvar(self, location, width, defblk=-1) -> int
 |          @param location: variable location (C++: const  vdloc_t  &)
 |          @param width: variable size (C++: int)
 |          @param defblk: definition block of the lvar. -1 means any block (C++:
 |                         int)
 |          @return: -1 if failed, otherwise the index into the variables vector.
 |  
 |  find_stkvar(self, *args)
 |      Find stack variable at the specified location.
 |      
 |      find_stkvar(self, spoff, width) -> int
 |          @param spoff: offset from the minimal sp (C++: sval_t)
 |          @param width: variable size (C++: int)
 |          @return: -1 if failed, otherwise the index into the variables vector.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lvars_t>
 |      delete_lvars_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_lvar_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< lvar_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> lvar_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< lvar_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: lvar_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: lvar_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: lvar_t const &
 |  
 |  append = push_back(self, *args)
 |      push_back(self, x)
 |          x: lvar_t const &
 |  
 |  at = __getitem__(self, *args)
 |      __getitem__(self, i) -> lvar_t
 |          i: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> lvar_t
 |      begin(self) -> lvar_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> lvar_t
 |      end(self) -> lvar_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> lvar_t
 |          it: qvector< lvar_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> lvar_t
 |          first: qvector< lvar_t >::iterator
 |          last: qvector< lvar_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> lvar_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=lvar_t())
 |          x: lvar_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: lvar_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: lvar_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> lvar_t
 |          it: qvector< lvar_t >::iterator
 |          x: lvar_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: lvar_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: lvar_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< lvar_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_lvar_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function make_num in module ida_hexrays:

make_num(*args)

Help on function make_pointer in module ida_hexrays:

make_pointer(*args)
    Create a pointer type. This function performs the following
    conversion: "type" -> "type*"
    
    make_pointer(type) -> tinfo_t
        @param type: object type. (C++: const  tinfo_t  &)
        @return: "type*". for example, if 'char' is passed as the argument,

Help on function make_ref in module ida_hexrays:

make_ref(e)

Help on function mark_cfunc_dirty in module ida_hexrays:

mark_cfunc_dirty(*args)
    Flush the cached decompilation results. Erases a cache entry for the
    specified function.
    
    mark_cfunc_dirty(ea, close_views=False) -> bool
        @param ea: function to erase from the cache (C++: ea_t)
        @param close_views: close pseudocode windows that show the function
                            (C++: bool)
        @return: if a cache entry existed.

Help on class mba_range_iterator_t in module ida_hexrays:

class mba_range_iterator_t(__builtin__.object)
 |  Proxy of C++ mba_range_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mba_range_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  chunk(self, *args)
 |      chunk(self) -> range_t
 |  
 |  is_snippet(self, *args)
 |      is_snippet(self) -> bool
 |  
 |  next(self, *args)
 |      next(self) -> bool
 |  
 |  set(self, *args)
 |      set(self, mbr) -> bool
 |          @param mbr (C++: const  mba_ranges_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fii
 |      mba_range_iterator_t_fii_get(self) -> func_tail_iterator_t
 |  
 |  rii
 |      mba_range_iterator_t_rii_get(self) -> range_chunk_iterator_t *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mba_range_iterator_t>
 |      delete_mba_range_iterator_t(self)

Help on class mba_ranges_t in module ida_hexrays:

class mba_ranges_t(__builtin__.object)
 |  Proxy of C++ mba_ranges_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _pfn=None) -> mba_ranges_t
 |          _pfn: func_t *
 |      
 |      
 |      __init__(self, r) -> mba_ranges_t
 |          r: rangevec_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  is_fragmented(self, *args)
 |      is_fragmented(self) -> bool
 |  
 |  is_snippet(self, *args)
 |      is_snippet(self) -> bool
 |  
 |  start(self, *args)
 |      start(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  pfn
 |      mba_ranges_t_pfn_get(self) -> func_t *
 |  
 |  ranges
 |      mba_ranges_t_ranges_get(self) -> rangevec_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mba_ranges_t>
 |      delete_mba_ranges_t(self)

Help on class mba_t in module ida_hexrays:

class mba_t(__builtin__.object)
 |  Proxy of C++ mba_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  _print(self, *args)
 |      _print(self, vp)
 |          vp: vd_printer_t &
 |  
 |  _register(self, *args)
 |      _register(self)
 |  
 |  alloc_fict_ea(self, *args)
 |      Allocate a fictional address. This function can be used to allocate a
 |      new unique address for a new instruction, if re-using any existing
 |      address leads to conflicts. For example, if the last instruction of
 |      the function modifies R0 and falls through to the next function, it
 |      will be a tail call: LDM R0!, {R4,R7} end of the function start of
 |      another function In this case R0 generates two different lvars at the
 |      same address:one modified by LDManother that represents the return
 |      value from the tail call Another example: a third-party plugin makes a
 |      copy of an instruction. This may lead to the generation of two
 |      variables at the same address. Example 3: fictional addresses can be
 |      used for new instructions created while modifying the microcode. This
 |      function can be used to allocate a new unique address for a new
 |      instruction or a variable. The fictional address is selected from an
 |      unallocated address range.
 |      
 |      alloc_fict_ea(self, real_ea) -> ea_t
 |          @param real_ea (C++: ea_t)
 |          @return: a unique fictional address
 |  
 |  alloc_kreg(self, *args)
 |      Allocate a kernel register.
 |      
 |      alloc_kreg(self, size, check_size=True) -> mreg_t
 |          @param size: size of the register in bytes (C++: size_t)
 |          @param check_size: if true, only the sizes that correspond to a size
 |                             of a basic type will be accepted. (C++: bool)
 |          @return: allocated register. mr_none means failure.
 |  
 |  alloc_lvars(self, *args)
 |      Allocate local variables. Must be called only immediately after
 |      'optimize_global()' , with no modifications to the microcode. Converts
 |      registers, stack variables, and similar operands into mop_l. This call
 |      will not fail because all necessary checks were performed in
 |      'optimize_global()' . After this call the microcode reaches its final
 |      state.
 |  
 |  analyze_calls(self, *args)
 |      Analyze calls and determine calling conventions.
 |      
 |      analyze_calls(self, acflags) -> int
 |          @param acflags: permitted actions that are necessary for successful
 |                          detection of calling conventions. See  Bits for
 |                          analyze_calls() (C++: int)
 |          @return: number of calls. -1 means error.
 |  
 |  arg(self, *args)
 |      Get input argument of the decompiled function.
 |      
 |      arg(self, n) -> lvar_t
 |          @param n: argument number (0..nargs-1) (C++: int)
 |      
 |      
 |      arg(self, n) -> lvar_t
 |          @param n: argument number (0..nargs-1) (C++: int)
 |  
 |  argbase(self, *args)
 |      argbase(self) -> sval_t
 |  
 |  argidx_ok(self, *args)
 |      argidx_ok(self) -> bool
 |  
 |  argidx_sorted(self, *args)
 |      argidx_sorted(self) -> bool
 |  
 |  bad_call_sp_detected(self, *args)
 |      bad_call_sp_detected(self) -> bool
 |  
 |  build_graph(self, *args)
 |      Build control flow graph. This function may be called only once. It
 |      calculates the type of each basic block and the adjacency list.
 |      'optimize_local()' calls this function if necessary. You need to call
 |      this function only before MMAT_LOCOPT.
 |  
 |  calc_shins_flags(self, *args)
 |      calc_shins_flags(self) -> int
 |  
 |  callinfo_built(self, *args)
 |      callinfo_built(self) -> bool
 |  
 |  chain_varnums_ok(self, *args)
 |      chain_varnums_ok(self) -> bool
 |  
 |  clr_cdtr(self, *args)
 |      clr_cdtr(self)
 |  
 |  clr_mba_flags(self, *args)
 |      clr_mba_flags(self, f)
 |          @param f (C++: int)
 |  
 |  clr_mba_flags2(self, *args)
 |      clr_mba_flags2(self, f)
 |          @param f (C++: int)
 |  
 |  code16_bit_removed(self, *args)
 |      code16_bit_removed(self) -> bool
 |  
 |  combine_blocks(self, *args)
 |      Combine blocks. This function merges blocks constituting linear flow.
 |      It calls 'remove_empty_blocks()' as well.
 |  
 |  common_stkvars_stkargs(self, *args)
 |      common_stkvars_stkargs(self) -> bool
 |  
 |  copy_block(self, *args)
 |      Make a copy of a block. This function makes a simple copy of the
 |      block. It does not fix the predecessor and successor lists, they must
 |      be fixed if necessary.
 |      
 |      copy_block(self, blk, new_serial, cpblk_flags=3) -> mblock_t
 |          @param blk: block to copy (C++: mblock_t  *)
 |          @param new_serial: position of the copied block (C++: int)
 |          @param cpblk_flags: combination of  Batch decompilation bits ... bits
 |                              (C++: int)
 |          @return: pointer to the new copy
 |  
 |  deleted_pairs(self, *args)
 |      deleted_pairs(self) -> bool
 |  
 |  display_numaddrs(self, *args)
 |      display_numaddrs(self) -> bool
 |  
 |  display_valnums(self, *args)
 |      display_valnums(self) -> bool
 |  
 |  dump(self, *args)
 |      Dump microcode to a file. The file will be created in the directory
 |      pointed by IDA_DUMPDIR envvar. Dump will be created only if IDA is run
 |      under debugger.
 |  
 |  dump_mba(self, *args)
 |      dump_mba(self, _verify, title)
 |          @param _verify (C++: bool)
 |          @param title (C++: const char *)
 |  
 |  find_mop(self, *args)
 |      Find an operand in the microcode. This function tries to find the
 |      operand that matches LIST. Any operand that overlaps with LIST is
 |      considered as a match.
 |      
 |      find_mop(self, ctx, ea, is_dest, list) -> mop_t
 |          @param ctx: context information for the result (C++: op_parent_info_t
 |                      *)
 |          @param ea: desired address of the operand (C++: ea_t)
 |          @param is_dest: search for destination operand? this argument may be
 |                          ignored if the exact match could not be found (C++:
 |                          bool)
 |          @param list: list of locations the correspond to the operand (C++:
 |                       const  mlist_t  &)
 |          @return: pointer to the operand or NULL.
 |  
 |  for_all_insns(self, *args)
 |      Visit all instructions. This function visits all instruction and
 |      subinstructions.
 |      
 |      for_all_insns(self, mv) -> int
 |          @param mv: instruction visitor (C++: minsn_visitor_t  &)
 |          @return: non-zero value returned by mv.visit_mop() or zero
 |  
 |  for_all_ops(self, *args)
 |      Visit all operands of all instructions.
 |      
 |      for_all_ops(self, mv) -> int
 |          @param mv: operand visitor (C++: mop_visitor_t  &)
 |          @return: non-zero value returned by mv.visit_mop() or zero
 |  
 |  for_all_topinsns(self, *args)
 |      Visit all top level instructions.
 |      
 |      for_all_topinsns(self, mv) -> int
 |          @param mv: instruction visitor (C++: minsn_visitor_t  &)
 |          @return: non-zero value returned by mv.visit_mop() or zero
 |  
 |  free_kreg(self, *args)
 |      Free a kernel register. If wrong arguments are passed, this function
 |      will generate an internal error.
 |      
 |      free_kreg(self, reg, size)
 |          @param reg: a previously allocated kernel register (C++: mreg_t)
 |          @param size: size of the register in bytes (C++: size_t)
 |  
 |  generated_asserts(self, *args)
 |      generated_asserts(self) -> bool
 |  
 |  get_args_region(self, *args)
 |      get_args_region(self) -> ivl_t
 |  
 |  get_curfunc(self, *args)
 |      get_curfunc(self) -> func_t *
 |  
 |  get_graph(self, *args)
 |      Get control graph. Call 'build_graph()' if you need the graph before
 |      MMAT_LOCOPT.
 |  
 |  get_ida_argloc(self, *args)
 |      get_ida_argloc(self, v) -> argloc_t
 |          @param v (C++: const  lvar_t  &)
 |  
 |  get_lvars_region(self, *args)
 |      get_lvars_region(self) -> ivl_t
 |  
 |  get_mba_flags(self, *args)
 |      get_mba_flags(self) -> int
 |  
 |  get_mba_flags2(self, *args)
 |      get_mba_flags2(self) -> int
 |  
 |  get_mblock(self, *args)
 |      Get basic block by its serial number.
 |      
 |      get_mblock(self, n) -> mblock_t
 |          @param n (C++: int)
 |      
 |      
 |      get_mblock(self, n) -> mblock_t
 |          @param n (C++: int)
 |  
 |  get_shadow_region(self, *args)
 |      get_shadow_region(self) -> ivl_t
 |  
 |  get_stack_region(self, *args)
 |      get_stack_region(self) -> ivl_t
 |  
 |  get_std_region(self, *args)
 |      Get information about various memory regions. We map the stack frame
 |      to the global memory, to some unused range.
 |      
 |      get_std_region(self, idx) -> ivl_t
 |          @param idx (C++: memreg_index_t)
 |  
 |  graph_insns(self, *args)
 |      graph_insns(self) -> bool
 |  
 |  has_bad_sp(self, *args)
 |      has_bad_sp(self) -> bool
 |  
 |  has_over_chains(self, *args)
 |      has_over_chains(self) -> bool
 |  
 |  has_passregs(self, *args)
 |      has_passregs(self) -> bool
 |  
 |  idaloc2vd(self, *args)
 |      idaloc2vd(self, loc, width) -> vdloc_t
 |          @param loc (C++: const  argloc_t  &)
 |          @param width (C++: int)
 |  
 |  insert_block(self, *args)
 |      Insert a block in the middle of the mbl array. The very first block of
 |      microcode must be empty, it is the entry block. The very last block of
 |      microcode must be BLT_STOP, it is the exit block. Therefore inserting
 |      a new block before the entry point or after the exit block is not a
 |      good idea.
 |      
 |      insert_block(self, bblk) -> mblock_t
 |          @param bblk: the new block will be inserted before BBLK (C++: int)
 |          @return: ptr to the new block
 |  
 |  is_cdtr(self, *args)
 |      is_cdtr(self) -> bool
 |  
 |  is_ctr(self, *args)
 |      is_ctr(self) -> bool
 |  
 |  is_dtr(self, *args)
 |      is_dtr(self) -> bool
 |  
 |  is_pattern(self, *args)
 |      is_pattern(self) -> bool
 |  
 |  is_snippet(self, *args)
 |      is_snippet(self) -> bool
 |  
 |  is_stkarg(self, *args)
 |      is_stkarg(self, v) -> bool
 |          @param v (C++: const  lvar_t  &)
 |  
 |  is_thunk(self, *args)
 |      is_thunk(self) -> bool
 |  
 |  loaded_gdl(self, *args)
 |      loaded_gdl(self) -> bool
 |  
 |  lvar_names_ok(self, *args)
 |      lvar_names_ok(self) -> bool
 |  
 |  lvars_allocated(self, *args)
 |      lvars_allocated(self) -> bool
 |  
 |  lvars_renamed(self, *args)
 |      lvars_renamed(self) -> bool
 |  
 |  map_fict_ea(self, *args)
 |      Resolve a fictional address. This function provides a reverse of the
 |      mapping made by 'alloc_fict_ea()' .
 |      
 |      map_fict_ea(self, fict_ea) -> ea_t
 |          @param fict_ea: fictional definition address (C++: ea_t)
 |          @return: the real instruction address
 |  
 |  mark_chains_dirty(self, *args)
 |      Mark the microcode use-def chains dirty. Call this function is any
 |      inter-block data dependencies got changed because of your
 |      modifications to the microcode. Failing to do so may cause an internal
 |      error.
 |  
 |  may_refine_rettype(self, *args)
 |      may_refine_rettype(self) -> bool
 |  
 |  optimize_global(self, *args)
 |      Optimize microcode globally. This function applies various
 |      optimization methods until we reach the fixed point. After that it
 |      preallocates lvars unless reqmat forbids it.
 |  
 |  optimize_local(self, *args)
 |      Optimize each basic block locally
 |      
 |      optimize_local(self, locopt_bits) -> int
 |          @param locopt_bits: combination of  Bits for optimize_local()  bits
 |                              (C++: int)
 |          @return: number of changes. 0 means nothing changed This function is
 |                   called by the decompiler, usually there is no need to call it
 |                   explicitly.
 |  
 |  optimized(self, *args)
 |      optimized(self) -> bool
 |  
 |  precise_defeas(self, *args)
 |      precise_defeas(self) -> bool
 |  
 |  propagated_asserts(self, *args)
 |      propagated_asserts(self) -> bool
 |  
 |  really_alloc(self, *args)
 |      really_alloc(self) -> bool
 |  
 |  regargs_is_not_aligned(self, *args)
 |      regargs_is_not_aligned(self) -> bool
 |  
 |  remove_block(self, *args)
 |      Delete a block.
 |      
 |      remove_block(self, blk) -> bool
 |          @param blk: block to delete (C++: mblock_t  *)
 |          @return: true if at least one of the other blocks became empty or
 |                   unreachable
 |  
 |  remove_empty_blocks(self, *args)
 |      Delete all empty blocks.
 |  
 |  returns_fpval(self, *args)
 |      returns_fpval(self) -> bool
 |  
 |  rtype_refined(self, *args)
 |      rtype_refined(self) -> bool
 |  
 |  save_snapshot(self, *args)
 |      Create and save microcode snapshot.
 |      
 |      save_snapshot(self, description)
 |          @param description (C++: const char *)
 |  
 |  saverest_done(self, *args)
 |      saverest_done(self) -> bool
 |  
 |  serialize(self, *args)
 |      Serialize mbl array into a sequence of bytes.
 |  
 |  set_mba_flags(self, *args)
 |      set_mba_flags(self, f)
 |          @param f (C++: int)
 |  
 |  set_mba_flags2(self, *args)
 |      set_mba_flags2(self, f)
 |          @param f (C++: int)
 |  
 |  short_display(self, *args)
 |      short_display(self) -> bool
 |  
 |  should_beautify(self, *args)
 |      should_beautify(self) -> bool
 |  
 |  show_reduction(self, *args)
 |      show_reduction(self) -> bool
 |  
 |  stkoff_ida2vd(self, *args)
 |      stkoff_ida2vd(self, off) -> sval_t
 |          @param off (C++: sval_t)
 |  
 |  stkoff_vd2ida(self, *args)
 |      stkoff_vd2ida(self, off) -> sval_t
 |          @param off (C++: sval_t)
 |  
 |  term(self, *args)
 |      term(self)
 |  
 |  use_frame(self, *args)
 |      use_frame(self) -> bool
 |  
 |  use_wingraph32(self, *args)
 |      use_wingraph32(self) -> bool
 |  
 |  valranges_done(self, *args)
 |      valranges_done(self) -> bool
 |  
 |  vd2idaloc(self, *args)
 |      vd2idaloc(self, loc, width, spd) -> argloc_t
 |          @param loc (C++: const  vdloc_t  &)
 |          @param width (C++: int)
 |          spd: sval_t
 |      
 |      
 |      vd2idaloc(self, loc, width) -> argloc_t
 |          @param loc (C++: const  vdloc_t  &)
 |          @param width (C++: int)
 |  
 |  verify(self, *args)
 |      Verify microcode consistency.
 |      
 |      verify(self, always)
 |          @param always: if false, the check will be performed only if ida runs
 |                         under debugger If any inconsistency is discovered, an
 |                         internal error will be generated. We strongly recommend
 |                         you to call this function before returing control to
 |                         the decompiler from your callbacks, in the case if you
 |                         modified the microcode. (C++: bool)
 |  
 |  write_to_const_detected(self, *args)
 |      write_to_const_detected(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  deserialize(*args)
 |      deserialize(bytes) -> mba_t
 |          bytes: uchar const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  aliased_args
 |      mba_t_aliased_args_get(self) -> ivl_t
 |  
 |  aliased_memory
 |      mba_t_aliased_memory_get(self) -> ivlset_t
 |  
 |  aliased_vars
 |      mba_t_aliased_vars_get(self) -> ivl_t
 |  
 |  argidx
 |      mba_t_argidx_get(self) -> intvec_t
 |  
 |  blocks
 |      mba_t_blocks_get(self) -> mblock_t
 |  
 |  cc
 |      mba_t_cc_get(self) -> cm_t
 |  
 |  consumed_argregs
 |      mba_t_consumed_argregs_get(self) -> rlist_t
 |  
 |  entry_ea
 |      mba_t_entry_ea_get(self) -> ea_t
 |  
 |  error_ea
 |      mba_t_error_ea_get(self) -> ea_t
 |  
 |  error_strarg
 |      mba_t_error_strarg_get(self) -> qstring *
 |  
 |  final_type
 |      mba_t_final_type_get(self) -> bool
 |  
 |  first_epilog_ea
 |      mba_t_first_epilog_ea_get(self) -> ea_t
 |  
 |  fpd
 |      mba_t_fpd_get(self) -> sval_t
 |  
 |  frregs
 |      mba_t_frregs_get(self) -> sval_t
 |  
 |  frsize
 |      mba_t_frsize_get(self) -> sval_t
 |  
 |  fti_flags
 |      mba_t_fti_flags_get(self) -> int
 |  
 |  fullsize
 |      mba_t_fullsize_get(self) -> sval_t
 |  
 |  gotoff_stkvars
 |      mba_t_gotoff_stkvars_get(self) -> ivlset_t
 |  
 |  idb_node
 |      mba_t_idb_node_get(self) -> netnode
 |  
 |  idb_spoiled
 |      mba_t_idb_spoiled_get(self) -> reginfovec_t
 |  
 |  idb_type
 |      mba_t_idb_type_get(self) -> tinfo_t
 |  
 |  inargoff
 |      mba_t_inargoff_get(self) -> sval_t
 |  
 |  label
 |      mba_t_label_get(self) -> qstring *
 |  
 |  last_prolog_ea
 |      mba_t_last_prolog_ea_get(self) -> ea_t
 |  
 |  maturity
 |      mba_t_maturity_get(self) -> mba_maturity_t
 |  
 |  mbr
 |      mba_t_mbr_get(self) -> mba_ranges_t
 |  
 |  minargref
 |      mba_t_minargref_get(self) -> sval_t
 |  
 |  minstkref
 |      mba_t_minstkref_get(self) -> sval_t
 |  
 |  minstkref_ea
 |      mba_t_minstkref_ea_get(self) -> ea_t
 |  
 |  natural
 |      mba_t_natural_get(self) -> mblock_t **
 |  
 |  nodel_memory
 |      mba_t_nodel_memory_get(self) -> mlist_t
 |  
 |  notes
 |      mba_t_notes_get(self) -> hexwarns_t
 |  
 |  npurged
 |      mba_t_npurged_get(self) -> int
 |  
 |  occurred_warns
 |      mba_t_occurred_warns_get(self) -> uchar [32]
 |  
 |  pfn_flags
 |      mba_t_pfn_flags_get(self) -> int
 |  
 |  qty
 |      mba_t_qty_get(self) -> int
 |  
 |  reqmat
 |      mba_t_reqmat_get(self) -> mba_maturity_t
 |  
 |  restricted_memory
 |      mba_t_restricted_memory_get(self) -> ivlset_t
 |  
 |  retsize
 |      mba_t_retsize_get(self) -> int
 |  
 |  retvaridx
 |      mba_t_retvaridx_get(self) -> int
 |  
 |  shadow_args
 |      mba_t_shadow_args_get(self) -> int
 |  
 |  spd_adjust
 |      mba_t_spd_adjust_get(self) -> sval_t
 |  
 |  spoiled_list
 |      mba_t_spoiled_list_get(self) -> mlist_t
 |  
 |  stacksize
 |      mba_t_stacksize_get(self) -> sval_t
 |  
 |  std_ivls
 |      mba_t_std_ivls_get(self) -> ivl_with_name_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  tmpstk_size
 |      mba_t_tmpstk_size_get(self) -> sval_t
 |  
 |  vars
 |      mba_t_vars_get(self) -> lvars_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mba_t>
 |      delete_mba_t(self)

Help on function mba_t_deserialize in module ida_hexrays:

mba_t_deserialize(*args)
    mba_t_deserialize(bytes) -> mba_t
        bytes: uchar const *

Help on class mbl_graph_t in module ida_hexrays:

class mbl_graph_t(simple_graph_t)
 |  Proxy of C++ mbl_graph_t class.
 |  
 |  Method resolution order:
 |      mbl_graph_t
 |      simple_graph_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_chain_stamp(self, *args)
 |      get_chain_stamp(self) -> int
 |  
 |  get_du(self, *args)
 |      Get def-use chains.
 |      
 |      get_du(self, gctype) -> graph_chains_t
 |          @param gctype (C++: gctype_t)
 |  
 |  get_mblock(self, *args)
 |      get_mblock(self, n) -> mblock_t
 |          @param n (C++: int)
 |  
 |  get_ud(self, *args)
 |      Get use-def chains.
 |      
 |      get_ud(self, gctype) -> graph_chains_t
 |          @param gctype (C++: gctype_t)
 |  
 |  is_du_chain_dirty(self, *args)
 |      Is the def-use chain of the specified kind dirty?
 |      
 |      is_du_chain_dirty(self, gctype) -> bool
 |          @param gctype (C++: gctype_t)
 |  
 |  is_redefined_globally(self, *args)
 |      Is LIST redefined in the graph?
 |      
 |      is_redefined_globally(self, list, b1, b2, m1, m2, maymust=MAY_ACCESS) -> bool
 |          @param list (C++: const  mlist_t  &)
 |          @param b1 (C++: int)
 |          @param b2 (C++: int)
 |          @param m1 (C++: const  minsn_t  *)
 |          @param m2 (C++: const  minsn_t  *)
 |          @param maymust (C++: maymust_t)
 |  
 |  is_ud_chain_dirty(self, *args)
 |      Is the use-def chain of the specified kind dirty?
 |      
 |      is_ud_chain_dirty(self, gctype) -> bool
 |          @param gctype (C++: gctype_t)
 |  
 |  is_used_globally(self, *args)
 |      Is LIST used in the graph?
 |      
 |      is_used_globally(self, list, b1, b2, m1, m2, maymust=MAY_ACCESS) -> bool
 |          @param list (C++: const  mlist_t  &)
 |          @param b1 (C++: int)
 |          @param b2 (C++: int)
 |          @param m1 (C++: const  minsn_t  *)
 |          @param m2 (C++: const  minsn_t  *)
 |          @param maymust (C++: maymust_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from simple_graph_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  colored_gdl_edges
 |      simple_graph_t_colored_gdl_edges_get(self) -> bool
 |  
 |  title
 |      simple_graph_t_title_get(self) -> qstring *

Help on class mblock_t in module ida_hexrays:

class mblock_t(__builtin__.object)
 |  Proxy of C++ mblock_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self, vp)
 |          vp: vd_printer_t &
 |  
 |  append_def_list(self, *args)
 |      Append def-list of an operand. This function calculates list of
 |      locations that may or must be modified by the operand and appends it
 |      to LIST.
 |      
 |      append_def_list(self, list, op, maymust)
 |          @param list: ptr to the output buffer. we will append to it. (C++:
 |                       mlist_t  *)
 |          @param op: operand to calculate the def list of (C++: const  mop_t  &)
 |          @param maymust: should we calculate 'may-def' or 'must-def' list? see
 |                          maymust_t for more details. (C++: maymust_t)
 |  
 |  append_use_list(self, *args)
 |      Append use-list of an operand. This function calculates list of
 |      locations that may or must be used by the operand and appends it to
 |      LIST.
 |      
 |      append_use_list(self, list, op, maymust, mask=bitrange_t(0, USHRT_MAX))
 |          @param list: ptr to the output buffer. we will append to it. (C++:
 |                       mlist_t  *)
 |          @param op: operand to calculate the use list of (C++: const  mop_t  &)
 |          @param maymust: should we calculate 'may-use' or 'must-use' list? see
 |                          maymust_t for more details. (C++: maymust_t)
 |          @param mask: if only part of the operand should be considered, a
 |                       bitmask can be used to specify which part. example:
 |                       op=AX,mask=0xFF means that we will consider only AL.
 |                       (C++: bitrange_t)
 |  
 |  build_def_list(self, *args)
 |      Build def-list of an instruction. This function calculates list of
 |      locations that may or must be modified by the instruction. Examples:
 |      "stx ebx.4, ds.2, eax.4", may-list: all aliasable memory "stx ebx.4,
 |      ds.2, eax.4", must-list: empty Since STX uses EAX for indirect access,
 |      it may modify any aliasable memory. On the other hand, we cannot tell
 |      for sure which memory cells will be modified, this is why the must-
 |      list is empty.
 |      
 |      build_def_list(self, ins, maymust) -> mlist_t
 |          @param ins: instruction to calculate the def list of (C++: const
 |                      minsn_t  &)
 |          @param maymust: should we calculate 'may-def' or 'must-def' list? see
 |                          maymust_t for more details. (C++: maymust_t)
 |          @return: the calculated def-list
 |  
 |  build_lists(self, *args)
 |      Build def-use lists and eliminate deads.
 |      
 |      build_lists(self, kill_deads) -> int
 |          @param kill_deads: do delete dead instructions? (C++: bool)
 |          @return: the number of eliminated instructions Better mblock_t::call
 |                   make_lists_ready() rather than this function.
 |  
 |  build_use_list(self, *args)
 |      Build use-list of an instruction. This function calculates list of
 |      locations that may or must be used by the instruction. Examples: "ldx
 |      ds.2, eax.4, ebx.4", may-list: all aliasable memory "ldx ds.2, eax.4,
 |      ebx.4", must-list: empty Since LDX uses EAX for indirect access, it
 |      may access any aliasable memory. On the other hand, we cannot tell for
 |      sure which memory cells will be accessed, this is why the must-list is
 |      empty.
 |      
 |      build_use_list(self, ins, maymust) -> mlist_t
 |          @param ins: instruction to calculate the use list of (C++: const
 |                      minsn_t  &)
 |          @param maymust: should we calculate 'may-use' or 'must-use' list? see
 |                          maymust_t for more details. (C++: maymust_t)
 |          @return: the calculated use-list
 |  
 |  dump(self, *args)
 |      Dump block info. This function is useful for debugging, see
 |      'mba_t::dump' for info
 |  
 |  dump_block(self, *args)
 |      dump_block(self, title)
 |          @param title (C++: const char *)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  find_access(self, *args)
 |      Find the instruction that accesses the specified operand. This
 |      function search inside one block.
 |      
 |      find_access(self, op, parent, mend, fdflags) -> minsn_t
 |          @param op: operand to search for (C++: const  mop_t  &)
 |          @param parent (C++: minsn_t  **)
 |          @param mend (C++: const  minsn_t  *)
 |          @param fdflags (C++: int)
 |          @return: the instruction that accesses the operand. this instruction
 |                   may be a sub-instruction. to find out the top level
 |                   instruction, check out *p_i1. NULL means 'not found'.
 |  
 |  find_def(self, *args)
 |      find_def(self, op, p_i1, i2, fdflags) -> minsn_t
 |          @param op (C++: const  mop_t  &)
 |          @param p_i1 (C++: minsn_t  **)
 |          @param i2 (C++: const  minsn_t  *)
 |          @param fdflags (C++: int)
 |  
 |  find_first_use(self, *args)
 |      Find the first insn that uses the specified list in the insn range.
 |      
 |      find_first_use(self, list, i1, i2, maymust=MAY_ACCESS) -> minsn_t
 |          @param list: list of locations. LIST may be modified by the function:
 |                       redefined locations will be removed from it. (C++:
 |                       mlist_t  *)
 |          @param i1: starting instruction of the range (must be a top level
 |                     insn) (C++: const  minsn_t  *)
 |          @param i2: end instruction of the range (must be a top level insn) i2
 |                     is excluded from the range. it can be specified as NULL. i1
 |                     and i2 must belong to the same block. (C++: const  minsn_t
 |                     *)
 |          @param maymust: should we search in 'may-access' or 'must-access'
 |                          mode? (C++: maymust_t)
 |          @return: pointer to such instruction or NULL. Upon return LIST will
 |                   contain only locations not redefined by insns [i1..result]
 |  
 |  find_redefinition(self, *args)
 |      Find the first insn that redefines any part of the list in the insn
 |      range.
 |      
 |      find_redefinition(self, list, i1, i2, maymust=MAY_ACCESS) -> minsn_t
 |          @param list: list of locations to check. (C++: const  mlist_t  &)
 |          @param i1: starting instruction of the range (must be a top level
 |                     insn) (C++: const  minsn_t  *)
 |          @param i2: end instruction of the range (must be a top level insn) i2
 |                     is excluded from the range. it can be specified as NULL. i1
 |                     and i2 must belong to the same block. (C++: const  minsn_t
 |                     *)
 |          @param maymust: should we search in 'may-access' or 'must-access'
 |                          mode? (C++: maymust_t)
 |          @return: pointer to such instruction or NULL.
 |  
 |  find_use(self, *args)
 |      find_use(self, op, p_i1, i2, fdflags) -> minsn_t
 |          @param op (C++: const  mop_t  &)
 |          @param p_i1 (C++: minsn_t  **)
 |          @param i2 (C++: const  minsn_t  *)
 |          @param fdflags (C++: int)
 |  
 |  for_all_insns(self, *args)
 |      Visit all instructions. This function visits subinstructions too.
 |      
 |      for_all_insns(self, mv) -> int
 |          @param mv: instruction visitor (C++: minsn_visitor_t  &)
 |          @return: zero or the value returned by mv.visit_insn() See also
 |                   mba_t::for_all_topinsns()
 |  
 |  for_all_ops(self, *args)
 |      Visit all operands. This function visit subinstruction operands too.
 |      
 |      for_all_ops(self, mv) -> int
 |          @param mv: operand visitor (C++: mop_visitor_t  &)
 |          @return: zero or the value returned by mv.visit_mop()
 |  
 |  for_all_uses(self, *args)
 |      Visit all operands that use LIST.
 |      
 |      for_all_uses(self, list, i1, i2, mmv) -> int
 |          @param list: ptr to the list of locations. it may be modified: parts
 |                       that get redefined by the instructions in [i1,i2) will be
 |                       deleted. (C++: mlist_t  *)
 |          @param i1: starting instruction. must be a top level insn. (C++:
 |                     minsn_t  *)
 |          @param i2: ending instruction (excluded). must be a top level insn.
 |                     (C++: minsn_t  *)
 |          @param mmv: operand visitor (C++: mlist_mop_visitor_t  &)
 |          @return: zero or the value returned by mmv.visit_mop()
 |  
 |  get_reginsn_qty(self, *args)
 |      Calculate number of register instructions in the block. Assertions are
 |      skipped by this function.
 |  
 |  get_valranges(self, *args)
 |      Find possible values for a block.
 |      
 |      get_valranges(self, res, vivl, vrflags) -> bool
 |          @param res: set of value ranges (C++: valrng_t  *)
 |          @param vivl: what to search for (C++: const  vivl_t  &)
 |          @param vrflags: combination of  bits for get_valranges  bits (C++:
 |                          int)
 |      
 |      
 |      get_valranges(self, res, vivl, m, vrflags) -> bool
 |          @param res: set of value ranges (C++: valrng_t  *)
 |          @param vivl: what to search for (C++: const  vivl_t  &)
 |          m: minsn_t const *
 |          @param vrflags: combination of  bits for get_valranges  bits (C++:
 |                          int)
 |  
 |  insert_into_block(self, *args)
 |      Insert instruction into the doubly linked list
 |      
 |      insert_into_block(self, nm, om) -> minsn_t
 |          @param nm: new instruction (C++: minsn_t  *)
 |          @param om: existing instruction, part of the doubly linked list if
 |                     NULL, then the instruction will be inserted at the
 |                     beginning of the list NM will be inserted immediately after
 |                     OM (C++: minsn_t  *)
 |          @return: pointer to NM
 |  
 |  is_branch(self, *args)
 |      is_branch(self) -> bool
 |  
 |  is_call_block(self, *args)
 |      is_call_block(self) -> bool
 |  
 |  is_nway(self, *args)
 |      is_nway(self) -> bool
 |  
 |  is_redefined(self, *args)
 |      Is the list redefined by the specified instructions?
 |      
 |      is_redefined(self, list, i1, i2, maymust=MAY_ACCESS) -> bool
 |          @param list: list of locations to check. (C++: const  mlist_t  &)
 |          @param i1: starting instruction of the range (must be a top level
 |                     insn) (C++: const  minsn_t  *)
 |          @param i2: end instruction of the range (must be a top level insn) i2
 |                     is excluded from the range. it can be specified as NULL. i1
 |                     and i2 must belong to the same block. (C++: const  minsn_t
 |                     *)
 |          @param maymust: should we search in 'may-access' or 'must-access'
 |                          mode? (C++: maymust_t)
 |  
 |  is_rhs_redefined(self, *args)
 |      Is the right hand side of the instruction redefined the insn range?
 |      "right hand side" corresponds to the source operands of the
 |      instruction.
 |      
 |      is_rhs_redefined(self, ins, i1, i2) -> bool
 |          @param ins: instruction to consider (C++: const  minsn_t  *)
 |          @param i1: starting instruction of the range (must be a top level
 |                     insn) (C++: const  minsn_t  *)
 |          @param i2: end instruction of the range (must be a top level insn) i2
 |                     is excluded from the range. it can be specified as NULL. i1
 |                     and i2 must belong to the same block. (C++: const  minsn_t
 |                     *)
 |  
 |  is_simple_goto_block(self, *args)
 |      is_simple_goto_block(self) -> bool
 |  
 |  is_simple_jcnd_block(self, *args)
 |      is_simple_jcnd_block(self) -> bool
 |  
 |  is_unknown_call(self, *args)
 |      is_unknown_call(self) -> bool
 |  
 |  is_used(self, *args)
 |      Is the list used by the specified instruction range?
 |      
 |      is_used(self, list, i1, i2, maymust=MAY_ACCESS) -> bool
 |          @param list: list of locations. LIST may be modified by the function:
 |                       redefined locations will be removed from it. (C++:
 |                       mlist_t  *)
 |          @param i1: starting instruction of the range (must be a top level
 |                     insn) (C++: const  minsn_t  *)
 |          @param i2: end instruction of the range (must be a top level insn) i2
 |                     is excluded from the range. it can be specified as NULL. i1
 |                     and i2 must belong to the same block. (C++: const  minsn_t
 |                     *)
 |          @param maymust: should we search in 'may-access' or 'must-access'
 |                          mode? (C++: maymust_t)
 |  
 |  lists_dirty(self, *args)
 |      lists_dirty(self) -> bool
 |  
 |  lists_ready(self, *args)
 |      lists_ready(self) -> bool
 |  
 |  make_lists_ready(self, *args)
 |      make_lists_ready(self) -> int
 |  
 |  make_nop(self, *args)
 |      Erase the instruction (convert it to nop) and mark the lists dirty.
 |      This is the recommended function to use because it also marks the
 |      block use-def lists dirty.
 |      
 |      make_nop(self, m)
 |          @param m (C++: minsn_t  *)
 |  
 |  mark_lists_dirty(self, *args)
 |      mark_lists_dirty(self)
 |  
 |  needs_propagation(self, *args)
 |      needs_propagation(self) -> bool
 |  
 |  npred(self, *args)
 |      Get number of block predecessors.
 |  
 |  nsucc(self, *args)
 |      Get number of block successors.
 |  
 |  optimize_block(self, *args)
 |      Optimize a basic block. Usually there is no need to call this function
 |      explicitly because the decompiler will call it itself if
 |      'optinsn_t::func' or 'optblock_t::func' return non-zero.
 |  
 |  optimize_insn(self, *args)
 |      Optimize one instruction in the context of the block.
 |      
 |      optimize_insn(self, m, optflags=0x0002|0x0004) -> int
 |          @param m: pointer to a top level instruction (C++: minsn_t  *)
 |          @param optflags: combination of  optimization flags  bits (C++: int)
 |          @return: number of changes made to the block This function may change
 |                   other instructions in the block too. However, it will not
 |                   destroy top level instructions (it may convert them to
 |                   nop's). This function performs only intrablock modifications.
 |                   See also  minsn_t::optimize_solo()
 |  
 |  optimize_useless_jump(self, *args)
 |      Remove a jump at the end of the block if it is useless. This function
 |      preserves any side effects when removing a useless jump. Both
 |      conditional and unconditional jumps are handled (and jtbl too). This
 |      function deletes useless jumps, not only replaces them with a nop.
 |      (please note that \optimize_insn does not handle useless jumps).
 |  
 |  pred(self, *args)
 |      pred(self, n) -> int
 |          @param n (C++: int)
 |  
 |  preds(self)
 |      Iterates the list of predecessor blocks
 |  
 |  remove_from_block(self, *args)
 |      Remove instruction from the doubly linked list
 |      
 |      remove_from_block(self, m) -> minsn_t
 |          @param m: instruction to remove The removed instruction is not
 |                    deleted, the caller gets its ownership (C++: minsn_t  *)
 |          @return: pointer to the next instruction
 |  
 |  request_demote64(self, *args)
 |      request_demote64(self)
 |  
 |  request_propagation(self, *args)
 |      request_propagation(self)
 |  
 |  succ(self, *args)
 |      succ(self, n) -> int
 |          @param n (C++: int)
 |  
 |  succs(self)
 |      Iterates the list of successor blocks
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dead_at_start
 |      mblock_t_dead_at_start_get(self) -> mlist_t
 |  
 |  dnu
 |      mblock_t_dnu_get(self) -> mlist_t
 |  
 |  end
 |      mblock_t_end_get(self) -> ea_t
 |  
 |  flags
 |      mblock_t_flags_get(self) -> uint32
 |  
 |  head
 |      mblock_t_head_get(self) -> minsn_t
 |  
 |  maxbsp
 |      mblock_t_maxbsp_get(self) -> sval_t
 |  
 |  maybdef
 |      mblock_t_maybdef_get(self) -> mlist_t
 |  
 |  maybuse
 |      mblock_t_maybuse_get(self) -> mlist_t
 |  
 |  mba
 |      mblock_t_mba_get(self) -> mba_t
 |  
 |  minbargref
 |      mblock_t_minbargref_get(self) -> sval_t
 |  
 |  minbstkref
 |      mblock_t_minbstkref_get(self) -> sval_t
 |  
 |  mustbdef
 |      mblock_t_mustbdef_get(self) -> mlist_t
 |  
 |  mustbuse
 |      mblock_t_mustbuse_get(self) -> mlist_t
 |  
 |  nextb
 |      mblock_t_nextb_get(self) -> mblock_t
 |  
 |  predset
 |      mblock_t_predset_get(self) -> intvec_t
 |  
 |  prevb
 |      mblock_t_prevb_get(self) -> mblock_t
 |  
 |  serial
 |      mblock_t_serial_get(self) -> int
 |  
 |  start
 |      mblock_t_start_get(self) -> ea_t
 |  
 |  succset
 |      mblock_t_succset_get(self) -> intvec_t
 |  
 |  tail
 |      mblock_t_tail_get(self) -> minsn_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      mblock_t_type_get(self) -> mblock_type_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mblock_t>
 |      delete_mblock_t(self)

Help on class mcallarg_t in module ida_hexrays:

class mcallarg_t(mop_t)
 |  Proxy of C++ mcallarg_t class.
 |  
 |  Method resolution order:
 |      mcallarg_t
 |      mop_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mcallarg_t
 |          rarg: mop_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self, shins_flags=0x04|0x02)
 |          shins_flags: int
 |  
 |  copy_mop(self, *args)
 |      copy_mop(self, op)
 |          @param op (C++: const  mop_t  &)
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  make_int(self, *args)
 |      make_int(self, val, val_ea, opno=0)
 |          @param val (C++: int)
 |          @param val_ea (C++: ea_t)
 |          @param opno (C++: int)
 |  
 |  make_uint(self, *args)
 |      make_uint(self, val, val_ea, opno=0)
 |          @param val (C++: int)
 |          @param val_ea (C++: ea_t)
 |          @param opno (C++: int)
 |  
 |  set_regarg(self, *args)
 |      set_regarg(self, mr, sz, tif)
 |          @param mr (C++: mreg_t)
 |          @param sz (C++: int)
 |          @param tif (C++: const  tinfo_t  &)
 |      
 |      
 |      set_regarg(self, mr, tif)
 |          @param mr (C++: mreg_t)
 |          @param tif (C++: const  tinfo_t  &)
 |      
 |      
 |      set_regarg(self, mr, dt, sign=type_unsigned)
 |          @param mr (C++: mreg_t)
 |          dt: char
 |          sign: type_sign_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  argloc
 |      mcallarg_t_argloc_get(self) -> argloc_t
 |  
 |  ea
 |      mcallarg_t_ea_get(self) -> ea_t
 |  
 |  name
 |      mcallarg_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      mcallarg_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mcallarg_t>
 |      delete_mcallarg_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from mop_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, rop) -> bool
 |          rop: mop_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, rop) -> bool
 |          rop: mop_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, rop) -> bool
 |          rop: mop_t const &
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_t(self)
 |  
 |  _get_a(self, *args)
 |      _get_a(self) -> mop_addr_t
 |  
 |  _get_b(self, *args)
 |      _get_b(self) -> int
 |  
 |  _get_c(self, *args)
 |      _get_c(self) -> mcases_t
 |  
 |  _get_cstr(self, *args)
 |      _get_cstr(self) -> char const *
 |  
 |  _get_d(self, *args)
 |      _get_d(self) -> minsn_t
 |  
 |  _get_f(self, *args)
 |      _get_f(self) -> mcallinfo_t
 |  
 |  _get_fpc(self, *args)
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_g(self, *args)
 |      _get_g(self) -> ea_t
 |  
 |  _get_helper(self, *args)
 |      _get_helper(self) -> char const *
 |  
 |  _get_l(self, *args)
 |      _get_l(self) -> lvar_ref_t
 |  
 |  _get_nnn(self, *args)
 |      _get_nnn(self) -> mnumber_t
 |  
 |  _get_pair(self, *args)
 |      _get_pair(self) -> mop_pair_t
 |  
 |  _get_r(self, *args)
 |      _get_r(self) -> mreg_t
 |  
 |  _get_s(self, *args)
 |      _get_s(self) -> stkvar_ref_t
 |  
 |  _get_scif(self, *args)
 |      _get_scif(self) -> scif_t
 |  
 |  _get_t(self, *args)
 |      _get_t(self) -> mopt_t
 |  
 |  _make_blkref(self, *args)
 |      Create a block reference operand without erasing previous data.
 |      
 |      _make_blkref(self, blknum)
 |          @param blknum: block number Note: this function does not erase the
 |                         previous contents of the operand; call erase() if
 |                         necessary (C++: int)
 |  
 |  _make_callinfo(self, *args)
 |      Create a call info operand without erasing previous data.
 |      
 |      _make_callinfo(self, fi)
 |          @param fi: callinfo Note: this function does not erase the previous
 |                     contents of the operand; call erase() if necessary (C++:
 |                     mcallinfo_t  *)
 |  
 |  _make_cases(self, *args)
 |      Create a 'switch cases' operand without erasing previous data. Note:
 |      this function does not erase the previous contents of the operand;
 |      call erase() if necessary
 |      
 |      _make_cases(self, _cases)
 |          @param _cases (C++: mcases_t  *)
 |  
 |  _make_gvar(self, *args)
 |      Create a global variable operand without erasing previous data.
 |      
 |      _make_gvar(self, ea)
 |          @param ea: address of the variable Note: this function does not erase
 |                     the previous contents of the operand; call erase() if
 |                     necessary (C++: ea_t)
 |  
 |  _make_insn(self, *args)
 |      Create a nested instruction without erasing previous data.
 |      
 |      _make_insn(self, ins)
 |          @param ins (C++: minsn_t  *)
 |  
 |  _make_lvar(self, *args)
 |      Create a local variable operand.
 |      
 |      _make_lvar(self, mba, idx, off=0)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param idx: index into mba->vars (C++: int)
 |          @param off: offset from the beginning of the variable Note: this
 |                      function does not erase the previous contents of the
 |                      operand; call erase() if necessary (C++: sval_t)
 |  
 |  _make_pair(self, *args)
 |      Create a pair operand without erasing previous data. Note: this
 |      function does not erase the previous contents of the operand; call
 |      erase() if necessary
 |      
 |      _make_pair(self, _pair)
 |          @param _pair (C++: mop_pair_t  *)
 |  
 |  _make_reg(self, *args)
 |      Create a register operand without erasing previous data.
 |      
 |      _make_reg(self, reg)
 |          @param reg: micro register number Note: this function does not erase
 |                      the previous contents of the operand; call erase() if
 |                      necessary (C++: mreg_t)
 |      
 |      
 |      _make_reg(self, reg, _size)
 |          @param reg: micro register number Note: this function does not erase
 |                      the previous contents of the operand; call erase() if
 |                      necessary (C++: mreg_t)
 |          _size: int
 |  
 |  _make_stkvar(self, *args)
 |      Create a stack variable operand.
 |      
 |      _make_stkvar(self, mba, off)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param off: decompiler stkoff Note: this function does not erase the
 |                      previous contents of the operand; call erase() if
 |                      necessary (C++: sval_t)
 |  
 |  _make_strlit(self, *args)
 |      Create a constant string operand.
 |      
 |      _make_strlit(self, str)
 |          @param str (C++: const char *)
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _mop_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args)
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _mop_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args)
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args)
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _register(self, *args)
 |      _register(self)
 |  
 |  _set_a(self, *args)
 |      _set_a(self, _v)
 |          _v: mop_addr_t *
 |  
 |  _set_b(self, *args)
 |      _set_b(self, _v)
 |          _v: int
 |  
 |  _set_c(self, *args)
 |      _set_c(self, _v)
 |          _v: mcases_t *
 |  
 |  _set_cstr(self, *args)
 |      _set_cstr(self, _v)
 |          _v: char const *
 |  
 |  _set_d(self, *args)
 |      _set_d(self, _v)
 |          _v: minsn_t *
 |  
 |  _set_f(self, *args)
 |      _set_f(self, _v)
 |          _v: mcallinfo_t *
 |  
 |  _set_fpc(self, *args)
 |      _set_fpc(self, _v)
 |          _v: fnumber_t *
 |  
 |  _set_g(self, *args)
 |      _set_g(self, _v)
 |          _v: ea_t
 |  
 |  _set_helper(self, *args)
 |      _set_helper(self, _v)
 |          _v: char const *
 |  
 |  _set_l(self, *args)
 |      _set_l(self, _v)
 |          _v: lvar_ref_t *
 |  
 |  _set_nnn(self, *args)
 |      _set_nnn(self, _v)
 |          _v: mnumber_t *
 |  
 |  _set_pair(self, *args)
 |      _set_pair(self, _v)
 |          _v: mop_pair_t *
 |  
 |  _set_r(self, *args)
 |      _set_r(self, _v)
 |          _v: mreg_t
 |  
 |  _set_s(self, *args)
 |      _set_s(self, _v)
 |          _v: stkvar_ref_t *
 |  
 |  _set_scif(self, *args)
 |      _set_scif(self, _v)
 |          _v: scif_t *
 |  
 |  _set_t(self, *args)
 |      _set_t(self, v)
 |          v: mopt_t
 |  
 |  apply_ld_mcode(self, *args)
 |      Apply a unary opcode to the operand.
 |      
 |      apply_ld_mcode(self, mcode, ea, newsize)
 |          @param mcode: opcode to apply. it must accept 'l' and 'd' operands but
 |                        not 'r'. examples: m_low/m_high/m_xds/m_xdu (C++:
 |                        mcode_t)
 |          @param ea: value of  minsn_t::ea  for the newly created insruction
 |                     (C++: ea_t)
 |          @param newsize: new operand size Example: apply_ld_mcode(m_low) will
 |                          convert op => low(op) (C++: int)
 |  
 |  apply_xds(self, *args)
 |      apply_xds(self, ea, newsize)
 |          @param ea (C++: ea_t)
 |          @param newsize (C++: int)
 |  
 |  apply_xdu(self, *args)
 |      apply_xdu(self, ea, newsize)
 |          @param ea (C++: ea_t)
 |          @param newsize (C++: int)
 |  
 |  assign(self, *args)
 |      assign(self, rop) -> mop_t
 |          @param rop (C++: const  mop_t  &)
 |  
 |  change_size(self, *args)
 |      Change the operand size. Examples: change_size(AL.1, 2) -> AX.2
 |      change_size(qword_00000008.8, 4) -> dword_00000008.4
 |      change_size(xdu.8(op.4), 4) -> op.4 change_size(#0x12345678.4, 1) ->
 |      #0x78.1
 |      
 |      change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
 |          @param nsize: new operand size (C++: int)
 |          @param sideff: may modify the database because of the size change?
 |                         (C++: side_effect_t)
 |          @return: success
 |  
 |  create_from_insn(self, *args)
 |      Create operand from an instruction. This function creates a nested
 |      instruction that can be used as an operand. Example: if m="add x,y,z",
 |      our operand will be (t=mop_d,d=m). The destination operand of 'add'
 |      (z) is lost.
 |      
 |      create_from_insn(self, m)
 |          @param m: instruction to embed into operand. may not be NULL. (C++:
 |                    const  minsn_t  *)
 |  
 |  create_from_ivlset(self, *args)
 |      Create operand from 'ivlset_t' . Example: if IVS contains
 |      [glbvar..glbvar+4), our operand will be (t=mop_v, g=&glbvar, size=4)
 |      
 |      create_from_ivlset(self, mba, ivs, fullsize) -> bool
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param ivs: set of memory intervals (C++: const  ivlset_t  &)
 |          @param fullsize: mba->fullsize (C++: sval_t)
 |          @return: success
 |  
 |  create_from_mlist(self, *args)
 |      Create operand from 'mlist_t' . Example: if LST contains 4 bits for
 |      R0.4, our operand will be (t=mop_r, r=R0, size=4)
 |      
 |      create_from_mlist(self, mba, lst, fullsize) -> bool
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param lst: list of locations (C++: const  mlist_t  &)
 |          @param fullsize: mba->fullsize (C++: sval_t)
 |          @return: success
 |  
 |  create_from_scattered_vdloc(self, *args)
 |      Create operand from scattered 'vdloc_t' . Example: if LOC is
 |      (ALOC_DIST, {EAX.4, EDX.4}) and TYPE is _LARGE_INTEGER, our operand
 |      will be (t=mop_sc, scif={EAX.4, EDX.4})
 |      
 |      create_from_scattered_vdloc(self, mba, name, type, loc)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param name: name of the operand, if available (C++: const char *)
 |          @param type: type of the operand, must be present (C++: tinfo_t)
 |          @param loc: a scattered location (C++: const  vdloc_t  &)
 |          @return: success
 |  
 |  create_from_vdloc(self, *args)
 |      Create operand from 'vdloc_t' . Example: if LOC contains
 |      (type=ALOC_REG1, r=R0), our operand will be (t=mop_r, r=R0,
 |      size=_SIZE)
 |      
 |      create_from_vdloc(self, mba, loc, _size)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param loc: location (C++: const  vdloc_t  &)
 |          @param _size (C++: int)
 |          @return: success
 |  
 |  double_size(self, *args)
 |      double_size(self, sideff=WITH_SIDEFF) -> bool
 |          @param sideff (C++: side_effect_t)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  equal_mops(self, *args)
 |      Compare operands. This is the main comparison function for operands.
 |      
 |      equal_mops(self, rop, eqflags) -> bool
 |          @param rop: operand to compare with (C++: const  mop_t  &)
 |          @param eqflags: combination of  comparison bits  bits (C++: int)
 |  
 |  erase(self, *args)
 |      erase(self)
 |  
 |  erase_but_keep_size(self, *args)
 |      erase_but_keep_size(self)
 |  
 |  for_all_ops(self, *args)
 |      Visit the operand and all its sub-operands. This function visits the
 |      current operand as well.
 |      
 |      for_all_ops(self, mv, type=None, is_target=False) -> int
 |          @param mv: visitor object (C++: mop_visitor_t  &)
 |          @param type: operand type (C++: const  tinfo_t  *)
 |          @param is_target: is a destination operand? (C++: bool)
 |  
 |  for_all_scattered_submops(self, *args)
 |      Visit all sub-operands of a scattered operand. This function does not
 |      visit the current operand, only its sub-operands. All sub-operands are
 |      synthetic and are destroyed after the visitor. This function works
 |      only with scattered operands.
 |      
 |      for_all_scattered_submops(self, sv) -> int
 |          @param sv: visitor object (C++: scif_visitor_t  &)
 |  
 |  get_insn(self, *args)
 |      Get subinstruction of the operand. If the operand has a subinstruction
 |      with the specified opcode, return it.
 |      
 |      get_insn(self, code) -> minsn_t
 |          @param code: desired opcode (C++: mcode_t)
 |          @return: pointer to the instruction or NULL
 |      
 |      
 |      get_insn(self, code) -> minsn_t
 |          @param code: desired opcode (C++: mcode_t)
 |          @return: pointer to the instruction or NULL
 |  
 |  get_stkoff(self, *args)
 |      Get the referenced stack offset. This function can also handle mop_sc
 |      if it is entirely mapped into a continuous stack region.
 |      
 |      get_stkoff(self, p_off) -> bool
 |          @param p_off: the output buffer (C++: sval_t  *)
 |          @return: success
 |  
 |  get_stkvar(self, *args)
 |      Retrieve the referenced stack variable.
 |      
 |      get_stkvar(self, p_off) -> member_t *
 |          @param p_off: if specified, will hold IDA stkoff after the call. (C++:
 |                        uval_t  *)
 |          @return: pointer to the stack variable
 |  
 |  has_side_effects(self, *args)
 |      Has any side effects?
 |      
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |          @param include_ldx_and_divs: consider ldx/div/mod as having side
 |                                       effects? (C++: bool)
 |  
 |  is01(self, *args)
 |      Are the possible values of the operand only 0 and 1? This function
 |      returns true for 0/1 constants, bit registers, the result of 'set'
 |      insns, etc.
 |  
 |  is_arglist(self, *args)
 |      Is a list of arguments?
 |  
 |  is_bit_reg(self, *args)
 |      is_bit_reg(self, reg) -> bool
 |          reg: mreg_t
 |  
 |  is_cc(self, *args)
 |      Is a condition code?
 |  
 |  is_ccflags(self, *args)
 |      is_ccflags(self) -> bool
 |  
 |  is_constant(self, *args)
 |      Retrieve value of a constant integer operand.
 |      
 |      is_constant(self, is_signed=True) -> bool
 |          @param is_signed: should treat the value as signed (C++: bool)
 |          @return: true if the operand is mop_n
 |  
 |  is_equal_to(self, *args)
 |      is_equal_to(self, n, is_signed=True) -> bool
 |          @param n (C++: uint64)
 |          @param is_signed (C++: bool)
 |  
 |  is_extended_from(self, *args)
 |      Does the high part of the operand consist of zero or sign bytes?
 |      
 |      is_extended_from(self, nbytes, is_signed) -> bool
 |          @param nbytes (C++: int)
 |          @param is_signed (C++: bool)
 |  
 |  is_glbaddr(self, *args)
 |      Is address of a global memory cell?
 |      
 |      is_glbaddr(self) -> bool
 |          ea: ea_t
 |  
 |  is_impptr_done(self, *args)
 |      is_impptr_done(self) -> bool
 |  
 |  is_insn(self, *args)
 |      Is a sub-instruction?
 |      
 |      is_insn(self) -> bool
 |          code: enum mcode_t
 |  
 |  is_kreg(self, *args)
 |      Is a kernel register?
 |  
 |  is_lowaddr(self, *args)
 |      is_lowaddr(self) -> bool
 |  
 |  is_mob(self, *args)
 |      Is a block reference to the specified block?
 |      
 |      is_mob(self, serial) -> bool
 |          @param serial (C++: int)
 |  
 |  is_negative_constant(self, *args)
 |      is_negative_constant(self) -> bool
 |  
 |  is_one(self, *args)
 |      is_one(self) -> bool
 |  
 |  is_positive_constant(self, *args)
 |      is_positive_constant(self) -> bool
 |  
 |  is_reg(self, *args)
 |      Is a register operand? See also get_mreg_name()
 |      
 |      is_reg(self) -> bool
 |          _r: mreg_t
 |      
 |      
 |      is_reg(self, _r, _size) -> bool
 |          _r: mreg_t
 |          _size: int
 |  
 |  is_scattered(self, *args)
 |      Is a scattered operand?
 |  
 |  is_sign_extended_from(self, *args)
 |      Does the high part of the operand consist of the sign bytes?
 |      
 |      is_sign_extended_from(self, nbytes) -> bool
 |          @param nbytes: number of bytes that were sign extended. the remaining
 |                         size-nbytes high bytes must be sign bytes Example:
 |                         is_sign_extended_from(xds.4(op.1), 1) -> true because
 |                         the high 3 bytes are certainly sign bits (C++: int)
 |  
 |  is_stkaddr(self, *args)
 |      Is address of a stack variable?
 |  
 |  is_udt(self, *args)
 |      is_udt(self) -> bool
 |  
 |  is_undef_val(self, *args)
 |      is_undef_val(self) -> bool
 |  
 |  is_zero(self, *args)
 |      is_zero(self) -> bool
 |  
 |  is_zero_extended_from(self, *args)
 |      Does the high part of the operand consist of zero bytes?
 |      
 |      is_zero_extended_from(self, nbytes) -> bool
 |          @param nbytes: number of bytes that were zero extended. the remaining
 |                         size-nbytes high bytes must be zero Example:
 |                         is_zero_extended_from(xdu.8(op.1), 2) -> true because
 |                         the high 6 bytes are certainly zero (C++: int)
 |  
 |  lexcompare(self, *args)
 |      lexcompare(self, rop) -> int
 |          @param rop (C++: const  mop_t  &)
 |  
 |  make_blkref(self, *args)
 |      Create a global variable operand.
 |      
 |      make_blkref(self, blknum)
 |          @param blknum (C++: int)
 |  
 |  make_first_half(self, *args)
 |      Make the first part of the operand. This function does not care about
 |      the memory endianness
 |      
 |      make_first_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  make_fpnum(self, *args)
 |      Create a floating point constant operand.
 |      
 |      make_fpnum(self, bytes, _size) -> bool
 |          @param bytes: pointer to the floating point value as used by the
 |                        current processor (e.g. for x86 it must be in IEEE 754)
 |                        (C++: const void *)
 |          @param _size: number of bytes occupied by the constant. (C++: size_t)
 |          @return: success
 |  
 |  make_gvar(self, *args)
 |      Create a global variable operand.
 |      
 |      make_gvar(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  make_helper(self, *args)
 |      Create a helper operand. A helper operand usually keeps a built-in
 |      function name like "va_start" It is essentially just an arbitrary
 |      identifier without any additional info.
 |      
 |      make_helper(self, name)
 |          @param name (C++: const char *)
 |  
 |  make_high_half(self, *args)
 |      Make the high part of the operand. This function takes into account
 |      the memory endianness (byte sex)
 |      
 |      make_high_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  make_insn(self, *args)
 |      Create a nested instruction.
 |      
 |      make_insn(self, ins)
 |          @param ins (C++: minsn_t  *)
 |  
 |  make_low_half(self, *args)
 |      Make the low part of the operand. This function takes into account the
 |      memory endianness (byte sex)
 |      
 |      make_low_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  make_number(self, *args)
 |      Create an integer constant operand.
 |      
 |      make_number(self, _value, _size, _ea=BADADDR, opnum=0)
 |          @param _value: value to store in the operand (C++: uint64)
 |          @param _size: size of the value in bytes (1,2,4,8) (C++: int)
 |          @param _ea: address of the processor instruction that made the value
 |                      (C++: ea_t)
 |          @param opnum: operand number of the processor instruction (C++: int)
 |  
 |  make_reg(self, *args)
 |      Create a register operand.
 |      
 |      make_reg(self, reg)
 |          @param reg (C++: mreg_t)
 |      
 |      
 |      make_reg(self, reg, _size)
 |          @param reg (C++: mreg_t)
 |          _size: int
 |  
 |  make_reg_pair(self, *args)
 |      Create pair of registers.
 |      
 |      make_reg_pair(self, loreg, hireg, halfsize)
 |          @param loreg: register holding the low part of the value (C++: int)
 |          @param hireg: register holding the high part of the value (C++: int)
 |          @param halfsize: the size of each of loreg/hireg (C++: int)
 |  
 |  make_second_half(self, *args)
 |      Make the second part of the operand. This function does not care about
 |      the memory endianness
 |      
 |      make_second_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  may_use_aliased_memory(self, *args)
 |      Is it possible for the operand to use aliased memory?
 |  
 |  preserve_side_effects(self, *args)
 |      Move subinstructions with side effects out of the operand. If we
 |      decide to delete an instruction operand, it is a good idea to call
 |      this function. Alternatively we should skip such operands by calling
 |      'mop_t::has_side_effects()' For example, if we transform: jnz x, x,
 |      @blk => goto @blk then we must call this function before deleting the
 |      X operands.
 |      
 |      preserve_side_effects(self, blk, top, moved_calls=None) -> bool
 |          @param blk: current block (C++: mblock_t  *)
 |          @param top: top level instruction that contains our operand (C++:
 |                      minsn_t  *)
 |          @param moved_calls: pointer to the boolean that will track if all side
 |                              effects get handled correctly. must be false
 |                              initially. (C++: bool *)
 |          @return: false failed to preserve a side effect, it is not safe to
 |                   delete the operand true no side effects or successfully
 |                   preserved them
 |  
 |  probably_floating(self, *args)
 |      probably_floating(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  set_impptr_done(self, *args)
 |      set_impptr_done(self)
 |  
 |  set_lowaddr(self, *args)
 |      set_lowaddr(self)
 |  
 |  set_udt(self, *args)
 |      set_udt(self)
 |  
 |  set_undef_val(self, *args)
 |      set_undef_val(self)
 |  
 |  shift_mop(self, *args)
 |      Shift the operand. This function shifts only the beginning of the
 |      operand. The operand size will be changed. Examples: shift_mop(AH.1,
 |      -1) -> AX.2 shift_mop(qword_00000008.8, 4) -> dword_0000000C.4
 |      shift_mop(xdu.8(op.4), 4) -> #0.4 shift_mop(#0x12345678.4, 3) -> #12.1
 |      
 |      shift_mop(self, offset) -> bool
 |          @param offset: shift count (the number of bytes to shift) (C++: int)
 |          @return: success
 |  
 |  signed_value(self, *args)
 |      signed_value(self) -> int64
 |  
 |  swap(self, *args)
 |      swap(self, rop)
 |          @param rop (C++: mop_t  &)
 |  
 |  unsigned_value(self, *args)
 |      unsigned_value(self) -> uint64
 |  
 |  value(self, *args)
 |      Retrieve value of a constant integer operand. These functions can be
 |      called only for mop_n operands. See 'is_constant()' that can be called
 |      on any operand.
 |      
 |      value(self, is_signed) -> uint64
 |          @param is_signed (C++: bool)
 |  
 |  zero(self, *args)
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from mop_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a
 |  
 |  b
 |  
 |  c
 |  
 |  cstr
 |  
 |  d
 |  
 |  f
 |  
 |  fpc
 |  
 |  g
 |  
 |  helper
 |  
 |  l
 |  
 |  meminfo
 |  
 |  nnn
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  oprops
 |      mop_t_oprops_get(self) -> uint8
 |  
 |  pair
 |  
 |  r
 |  
 |  s
 |  
 |  scif
 |  
 |  size
 |      mop_t_size_get(self) -> int
 |  
 |  t
 |      _get_t(self) -> mopt_t
 |  
 |  valnum
 |      mop_t_valnum_get(self) -> uint16

Help on class mcallargs_t in module ida_hexrays:

class mcallargs_t(__builtin__.object)
 |  Proxy of C++ qvector< mcallarg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< mcallarg_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> mcallarg_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mcallargs_t
 |          x: qvector< mcallarg_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< mcallarg_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: mcallarg_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: mcallarg_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: mcallarg_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> mcallarg_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> mcallarg_t
 |      begin(self) -> mcallarg_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> mcallarg_t
 |      end(self) -> mcallarg_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> mcallarg_t
 |          it: qvector< mcallarg_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> mcallarg_t
 |          first: qvector< mcallarg_t >::iterator
 |          last: qvector< mcallarg_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> mcallarg_t
 |  
 |  find(self, *args)
 |      find(self, x) -> mcallarg_t
 |          x: mcallarg_t const &
 |      
 |      
 |      find(self, x) -> mcallarg_t
 |          x: mcallarg_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=mcallarg_t())
 |          x: mcallarg_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: mcallarg_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: mcallarg_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> mcallarg_t
 |          it: qvector< mcallarg_t >::iterator
 |          x: mcallarg_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: mcallarg_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: mcallarg_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< mcallarg_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mcallargs_t>
 |      delete_mcallargs_t(self)

Help on class mcallinfo_t in module ida_hexrays:

class mcallinfo_t(__builtin__.object)
 |  Proxy of C++ mcallinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _callee=BADADDR, _sargs=0) -> mcallinfo_t
 |          _callee: ea_t
 |          _sargs: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self, size=-1, shins_flags=0x04|0x02)
 |          size: int
 |          shins_flags: int
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  get_type(self, *args)
 |      get_type(self) -> tinfo_t
 |  
 |  is_vararg(self, *args)
 |      is_vararg(self) -> bool
 |  
 |  lexcompare(self, *args)
 |      lexcompare(self, f) -> int
 |          @param f (C++: const  mcallinfo_t  &)
 |  
 |  set_type(self, *args)
 |      set_type(self, type) -> bool
 |          @param type (C++: const  tinfo_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  args
 |      mcallinfo_t_args_get(self) -> mcallargs_t
 |  
 |  call_spd
 |      mcallinfo_t_call_spd_get(self) -> int
 |  
 |  callee
 |      mcallinfo_t_callee_get(self) -> ea_t
 |  
 |  cc
 |      mcallinfo_t_cc_get(self) -> cm_t
 |  
 |  dead_regs
 |      mcallinfo_t_dead_regs_get(self) -> mlist_t
 |  
 |  flags
 |      mcallinfo_t_flags_get(self) -> int
 |  
 |  fti_attrs
 |      mcallinfo_t_fti_attrs_get(self) -> type_attrs_t
 |  
 |  pass_regs
 |      mcallinfo_t_pass_regs_get(self) -> mlist_t
 |  
 |  retregs
 |      mcallinfo_t_retregs_get(self) -> mopvec_t
 |  
 |  return_argloc
 |      mcallinfo_t_return_argloc_get(self) -> argloc_t
 |  
 |  return_regs
 |      mcallinfo_t_return_regs_get(self) -> mlist_t
 |  
 |  return_type
 |      mcallinfo_t_return_type_get(self) -> tinfo_t
 |  
 |  role
 |      mcallinfo_t_role_get(self) -> funcrole_t
 |  
 |  solid_args
 |      mcallinfo_t_solid_args_get(self) -> int
 |  
 |  spoiled
 |      mcallinfo_t_spoiled_get(self) -> mlist_t
 |  
 |  stkargs_top
 |      mcallinfo_t_stkargs_top_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  visible_memory
 |      mcallinfo_t_visible_memory_get(self) -> ivlset_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mcallinfo_t>
 |      delete_mcallinfo_t(self)

Help on class mcases_t in module ida_hexrays:

class mcases_t(__builtin__.object)
 |  Proxy of C++ mcases_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: mcases_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: mcases_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: mcases_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mcases_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: mcases_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: mcases_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: mcases_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: mcases_t const &
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  resize(self, *args)
 |      resize(self, s)
 |          @param s (C++: int)
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: mcases_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  targets
 |      mcases_t_targets_get(self) -> intvec_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  values
 |      mcases_t_values_get(self) -> casevec_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mcases_t>
 |      delete_mcases_t(self)

Help on function mcode_modifies_d in module ida_hexrays:

mcode_modifies_d(*args)
    mcode_modifies_d(mcode) -> bool
        @param mcode (C++: mcode_t)

Help on class microcode_filter_t in module ida_hexrays:

class microcode_filter_t(__builtin__.object)
 |  Proxy of C++ microcode_filter_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> microcode_filter_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  apply(self, *args)
 |      generate microcode for an instruction
 |      
 |      apply(self, cdg) -> merror_t
 |          @param cdg (C++: codegen_t  &)
 |          @return: MERR_... code: MERR_OK - user-defined call generated, go to
 |                   the next instruction MERR_INSN - not generated - the caller
 |                   should try the standard way else - error
 |  
 |  match(self, *args)
 |      check if the filter object is to be appied
 |      
 |      match(self, cdg) -> bool
 |          @param cdg (C++: codegen_t  &)
 |          @return: success
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_microcode_filter_t>
 |      delete_microcode_filter_t(self)

Help on class minsn_t in module ida_hexrays:

class minsn_t(__builtin__.object)
 |  Proxy of C++ minsn_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea) -> minsn_t
 |          _ea: ea_t
 |      
 |      
 |      __init__(self, m) -> minsn_t
 |          m: minsn_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, ri) -> bool
 |          ri: minsn_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _make_nop(self, *args)
 |      Convert instruction to nop. This function erases all info but the
 |      prev/next fields. In most cases it is better to use
 |      'mblock_t::make_nop()' , which also marks the block lists as dirty.
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _minsn_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args)
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _minsn_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args)
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args)
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _print(self, *args)
 |      _print(self, shins_flags=0x04|0x02)
 |          shins_flags: int
 |  
 |  _register(self, *args)
 |      _register(self)
 |  
 |  clr_assert(self, *args)
 |      clr_assert(self)
 |  
 |  clr_combinable(self, *args)
 |      clr_combinable(self)
 |  
 |  clr_combined(self, *args)
 |      clr_combined(self)
 |  
 |  clr_fpinsn(self, *args)
 |      clr_fpinsn(self)
 |  
 |  clr_ignlowsrc(self, *args)
 |      clr_ignlowsrc(self)
 |  
 |  clr_multimov(self, *args)
 |      clr_multimov(self)
 |  
 |  clr_noret_icall(self, *args)
 |      clr_noret_icall(self)
 |  
 |  clr_propagatable(self, *args)
 |      clr_propagatable(self)
 |  
 |  clr_tailcall(self, *args)
 |      clr_tailcall(self)
 |  
 |  contains_call(self, *args)
 |      Does the instruction contain a call?
 |      
 |      contains_call(self, with_helpers=False) -> bool
 |          @param with_helpers (C++: bool)
 |  
 |  contains_opcode(self, *args)
 |      Does the instruction have the specified opcode? This function searches
 |      subinstructions as well.
 |      
 |      contains_opcode(self, mcode) -> bool
 |          @param mcode: opcode to search for. (C++: mcode_t)
 |  
 |  dstr(self, *args)
 |      Get displayable text without tags in a static buffer.
 |  
 |  equal_insns(self, *args)
 |      Compare instructions. This is the main comparison function for
 |      instructions.
 |      
 |      equal_insns(self, m, eqflags) -> bool
 |          @param m: instruction to compare with (C++: const  minsn_t  &)
 |          @param eqflags: combination of  comparison bits  bits (C++: int)
 |  
 |  find_call(self, *args)
 |      Find a call instruction. Check for the current instruction and its
 |      subinstructions.
 |      
 |      find_call(self, with_helpers=False) -> minsn_t
 |          @param with_helpers: consider helper calls as well? (C++: bool)
 |  
 |  find_ins_op(self, *args)
 |      Find an operand that is a subinsruction with the specified opcode.
 |      This function checks only the 'l' and 'r' operands of the current
 |      insn.
 |      
 |      find_ins_op(self, op=m_nop) -> minsn_t
 |          @param op: opcode to search for (C++: mcode_t)
 |          @return: &l or &r or NULL
 |  
 |  find_num_op(self, *args)
 |      Find a numeric operand of the current instruction. This function
 |      checks only the 'l' and 'r' operands of the current insn.
 |  
 |  find_opcode(self, *args)
 |      Find a (sub)insruction with the specified opcode.
 |      
 |      find_opcode(self, mcode) -> minsn_t
 |          @param mcode: opcode to search for. (C++: mcode_t)
 |      
 |      
 |      find_opcode(self, mcode) -> minsn_t
 |          @param mcode: opcode to search for. (C++: mcode_t)
 |  
 |  for_all_insns(self, *args)
 |      Visit all instructions. This function visits the instruction itself
 |      and all its subinstructions.
 |      
 |      for_all_insns(self, mv) -> int
 |          @param mv: instruction visitor (C++: minsn_visitor_t  &)
 |          @return: non-zero value returned by mv.visit_mop() or zero
 |  
 |  for_all_ops(self, *args)
 |      Visit all instruction operands. This function visits subinstruction
 |      operands as well.
 |      
 |      for_all_ops(self, mv) -> int
 |          @param mv: operand visitor (C++: mop_visitor_t  &)
 |          @return: non-zero value returned by mv.visit_mop() or zero
 |  
 |  get_role(self, *args)
 |      Get the function role of a call.
 |  
 |  get_split_size(self, *args)
 |      get_split_size(self) -> int
 |  
 |  has_side_effects(self, *args)
 |      Does the instruction have a side effect?
 |      
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |          @param include_ldx_and_divs: consider ldx/div/mod as having side
 |                                       effects? stx is always considered as
 |                                       having side effects. Apart from ldx/std
 |                                       only call may have side effects. (C++:
 |                                       bool)
 |  
 |  is_after(self, *args)
 |      Is the instruction after the specified one?
 |      
 |      is_after(self, m) -> bool
 |          @param m: the instruction to compare against in the list (C++: const
 |                    minsn_t  *)
 |  
 |  is_alloca(self, *args)
 |      is_alloca(self) -> bool
 |  
 |  is_assert(self, *args)
 |      is_assert(self) -> bool
 |  
 |  is_between(self, *args)
 |      Is the instruction in the specified range of instructions?
 |      
 |      is_between(self, m1, m2) -> bool
 |          @param m1: beginning of the range in the doubly linked list (C++:
 |                     const  minsn_t  *)
 |          @param m2: end of the range in the doubly linked list (excluded, may
 |                     be NULL) This function assumes that m1 and m2 belong to the
 |                     same basic block and they are top level instructions. (C++:
 |                     const  minsn_t  *)
 |  
 |  is_bswap(self, *args)
 |      is_bswap(self) -> bool
 |  
 |  is_cleaning_pop(self, *args)
 |      is_cleaning_pop(self) -> bool
 |  
 |  is_combinable(self, *args)
 |      is_combinable(self) -> bool
 |  
 |  is_combined(self, *args)
 |      is_combined(self) -> bool
 |  
 |  is_extstx(self, *args)
 |      is_extstx(self) -> bool
 |  
 |  is_farcall(self, *args)
 |      is_farcall(self) -> bool
 |  
 |  is_fpinsn(self, *args)
 |      is_fpinsn(self) -> bool
 |  
 |  is_helper(self, *args)
 |      Is a helper call with the specified name? Helper calls usually have
 |      well-known function names (see 'Well known function names' ) but they
 |      may have any other name. The decompiler does not assume any special
 |      meaning for non-well-known names.
 |      
 |      is_helper(self, name) -> bool
 |          @param name (C++: const char *)
 |  
 |  is_ignlowsrc(self, *args)
 |      is_ignlowsrc(self) -> bool
 |  
 |  is_inverted_jx(self, *args)
 |      is_inverted_jx(self) -> bool
 |  
 |  is_like_move(self, *args)
 |      is_like_move(self) -> bool
 |  
 |  is_mbarrier(self, *args)
 |      is_mbarrier(self) -> bool
 |  
 |  is_memcpy(self, *args)
 |      is_memcpy(self) -> bool
 |  
 |  is_memset(self, *args)
 |      is_memset(self) -> bool
 |  
 |  is_mov(self, *args)
 |      is_mov(self) -> bool
 |  
 |  is_multimov(self, *args)
 |      is_multimov(self) -> bool
 |  
 |  is_noret_call(self, *args)
 |      Is a non-returing call?
 |      
 |      is_noret_call(self, ignore_noret_icall=False) -> bool
 |          @param ignore_noret_icall: if set, indirect calls to noret functions
 |                                     will return false (C++: bool)
 |  
 |  is_optional(self, *args)
 |      is_optional(self) -> bool
 |  
 |  is_persistent(self, *args)
 |      is_persistent(self) -> bool
 |  
 |  is_propagatable(self, *args)
 |      is_propagatable(self) -> bool
 |  
 |  is_readflags(self, *args)
 |      is_readflags(self) -> bool
 |  
 |  is_tailcall(self, *args)
 |      is_tailcall(self) -> bool
 |  
 |  is_unknown_call(self, *args)
 |      Is an unknown call? Unknown calls are calls without the argument list
 |      ( 'mcallinfo_t' ). Usually the argument lists are determined by
 |      'mba_t::analyze_calls()' . Unknown calls exist until the MMAT_CALLS
 |      maturity level. See also mblock_t::is_call_block
 |  
 |  is_wild_match(self, *args)
 |      is_wild_match(self) -> bool
 |  
 |  lexcompare(self, *args)
 |      lexcompare(self, ri) -> int
 |          @param ri (C++: const  minsn_t  &)
 |  
 |  may_use_aliased_memory(self, *args)
 |      Is it possible for the instruction to use aliased memory?
 |  
 |  modifes_d(self, *args)
 |      Does the instruction modify its 'd' operand? Some instructions (e.g.
 |      m_stx) do not modify the 'd' operand.
 |  
 |  modifies_pair_mop(self, *args)
 |      modifies_pair_mop(self) -> bool
 |  
 |  optimize_solo(self, *args)
 |      Optimize one instruction without context. This function does not have
 |      access to the instruction context (the previous and next instructions
 |      in the list, the block number, etc). It performs only basic
 |      optimizations that are available without this info.
 |      
 |      optimize_solo(self, optflags=0) -> int
 |          @param optflags: combination of  optimization flags  bits (C++: int)
 |          @return: number of changes, 0-unchanged See also
 |                   mblock_t::optimize_insn()
 |  
 |  optimize_subtree(self, *args)
 |      Optimize instruction in its context. Do not use this function, use
 |      mblock_t::optimize()
 |      
 |      optimize_subtree(self, blk, top, parent, converted_call, optflags=0x0002) -> int
 |          @param blk (C++: mblock_t  *)
 |          @param top (C++: minsn_t  *)
 |          @param parent (C++: minsn_t  *)
 |          @param converted_call (C++: ea_t *)
 |          @param optflags (C++: int)
 |  
 |  replace_by(self, o)
 |  
 |  set_assert(self, *args)
 |      set_assert(self)
 |  
 |  set_cleaning_pop(self, *args)
 |      set_cleaning_pop(self)
 |  
 |  set_combinable(self, *args)
 |      set_combinable(self)
 |  
 |  set_extstx(self, *args)
 |      set_extstx(self)
 |  
 |  set_farcall(self, *args)
 |      set_farcall(self)
 |  
 |  set_fpinsn(self, *args)
 |      set_fpinsn(self)
 |  
 |  set_ignlowsrc(self, *args)
 |      set_ignlowsrc(self)
 |  
 |  set_inverted_jx(self, *args)
 |      set_inverted_jx(self)
 |  
 |  set_mbarrier(self, *args)
 |      set_mbarrier(self)
 |  
 |  set_multimov(self, *args)
 |      set_multimov(self)
 |  
 |  set_noret_icall(self, *args)
 |      set_noret_icall(self)
 |  
 |  set_optional(self, *args)
 |      set_optional(self)
 |  
 |  set_persistent(self, *args)
 |      set_persistent(self)
 |  
 |  set_split_size(self, *args)
 |      set_split_size(self, s)
 |          @param s (C++: int)
 |  
 |  set_tailcall(self, *args)
 |      set_tailcall(self)
 |  
 |  set_wild_match(self, *args)
 |      set_wild_match(self)
 |  
 |  setaddr(self, *args)
 |      Change the instruction address. This function modifies subinstructions
 |      as well.
 |      
 |      setaddr(self, new_ea)
 |          @param new_ea (C++: ea_t)
 |  
 |  swap(self, *args)
 |      Swap two instructions. The prev/next fields are not modified by this
 |      function because it would corrupt the doubly linked list.
 |      
 |      swap(self, m)
 |          @param m (C++: minsn_t  &)
 |  
 |  was_noret_icall(self, *args)
 |      was_noret_icall(self) -> bool
 |  
 |  was_split(self, *args)
 |      was_split(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  d
 |      minsn_t_d_get(self) -> mop_t
 |  
 |  ea
 |      minsn_t_ea_get(self) -> ea_t
 |  
 |  iprops
 |      minsn_t_iprops_get(self) -> int
 |  
 |  l
 |      minsn_t_l_get(self) -> mop_t
 |  
 |  meminfo
 |  
 |  next
 |      minsn_t_next_get(self) -> minsn_t
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  opcode
 |      minsn_t_opcode_get(self) -> mcode_t
 |  
 |  prev
 |      minsn_t_prev_get(self) -> minsn_t
 |  
 |  r
 |      minsn_t_r_get(self) -> mop_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_minsn_t>
 |      delete_minsn_t(self)

Help on class minsn_visitor_t in module ida_hexrays:

class minsn_visitor_t(op_parent_info_t)
 |  Proxy of C++ minsn_visitor_t class.
 |  
 |  Method resolution order:
 |      minsn_visitor_t
 |      op_parent_info_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba=None, _blk=None, _topins=None) -> minsn_visitor_t
 |          _mba: mba_t *
 |          _blk: mblock_t *
 |          _topins: minsn_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_minsn(self, *args)
 |      visit_minsn(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_minsn_visitor_t>
 |      delete_minsn_visitor_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from op_parent_info_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blk
 |      op_parent_info_t_blk_get(self) -> mblock_t
 |  
 |  curins
 |      op_parent_info_t_curins_get(self) -> minsn_t
 |  
 |  mba
 |      op_parent_info_t_mba_get(self) -> mba_t
 |  
 |  topins
 |      op_parent_info_t_topins_get(self) -> minsn_t

Help on class mlist_mop_visitor_t in module ida_hexrays:

class mlist_mop_visitor_t(__builtin__.object)
 |  Proxy of C++ mlist_mop_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mlist_mop_visitor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_mop(self, *args)
 |      visit_mop(self, op) -> int
 |          @param op (C++: mop_t  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  changed
 |      mlist_mop_visitor_t_changed_get(self) -> bool
 |  
 |  curins
 |      mlist_mop_visitor_t_curins_get(self) -> minsn_t
 |  
 |  list
 |      mlist_mop_visitor_t_list_get(self) -> mlist_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  topins
 |      mlist_mop_visitor_t_topins_get(self) -> minsn_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mlist_mop_visitor_t>
 |      delete_mlist_mop_visitor_t(self)

Help on class mlist_t in module ida_hexrays:

class mlist_t(__builtin__.object)
 |  Proxy of C++ mlist_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: mlist_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: mlist_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: mlist_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mlist_t
 |          ivl: ivl_t const &
 |      
 |      
 |      __init__(self, r, size) -> mlist_t
 |          r: mreg_t
 |          size: int
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: mlist_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: mlist_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: mlist_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self)
 |  
 |  add(self, *args)
 |      add(self, r, size) -> bool
 |          @param r (C++: mreg_t)
 |          @param size (C++: int)
 |      
 |      
 |      add(self, r) -> bool
 |          @param r (C++: mreg_t)
 |      
 |      
 |      add(self, ivl) -> bool
 |          ivl: ivl_t const &
 |      
 |      
 |      add(self, lst) -> bool
 |          lst: mlist_t const &
 |  
 |  addmem(self, *args)
 |      addmem(self, ea, size) -> bool
 |          @param ea (C++: ea_t)
 |          @param size (C++: asize_t)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: mlist_t const &
 |  
 |  count(self, *args)
 |      count(self) -> asize_t
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  has(self, *args)
 |      has(self, r) -> bool
 |          @param r (C++: mreg_t)
 |  
 |  has_all(self, *args)
 |      has_all(self, r, size) -> bool
 |          @param r (C++: mreg_t)
 |          @param size (C++: int)
 |  
 |  has_any(self, *args)
 |      has_any(self, r, size) -> bool
 |          @param r (C++: mreg_t)
 |          @param size (C++: int)
 |  
 |  has_common(self, *args)
 |      has_common(self, lst) -> bool
 |          @param lst (C++: const  mlist_t  &)
 |  
 |  has_memory(self, *args)
 |      has_memory(self) -> bool
 |  
 |  includes(self, *args)
 |      includes(self, lst) -> bool
 |          @param lst (C++: const  mlist_t  &)
 |  
 |  intersect(self, *args)
 |      intersect(self, lst) -> bool
 |          @param lst (C++: const  mlist_t  &)
 |  
 |  is_subset_of(self, *args)
 |      is_subset_of(self, lst) -> bool
 |          @param lst (C++: const  mlist_t  &)
 |  
 |  sub(self, *args)
 |      sub(self, r, size) -> bool
 |          @param r (C++: mreg_t)
 |          @param size (C++: int)
 |      
 |      
 |      sub(self, ivl) -> bool
 |          ivl: ivl_t const &
 |      
 |      
 |      sub(self, lst) -> bool
 |          lst: mlist_t const &
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: mlist_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  mem
 |      mlist_t_mem_get(self) -> ivlset_t
 |  
 |  reg
 |      mlist_t_reg_get(self) -> rlist_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mlist_t>
 |      delete_mlist_t(self)

Help on class mnumber_t in module ida_hexrays:

class mnumber_t(operand_locator_t)
 |  Proxy of C++ mnumber_t class.
 |  
 |  Method resolution order:
 |      mnumber_t
 |      operand_locator_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: mnumber_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: mnumber_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: mnumber_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, v, _ea=BADADDR, n=0) -> mnumber_t
 |          v: uint64
 |          _ea: ea_t
 |          n: int
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: mnumber_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: mnumber_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: mnumber_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: mnumber_t const &
 |  
 |  update_value(self, *args)
 |      update_value(self, val64)
 |          @param val64 (C++: uint64)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  org_value
 |      mnumber_t_org_value_get(self) -> uint64
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      mnumber_t_value_get(self) -> uint64
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mnumber_t>
 |      delete_mnumber_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from operand_locator_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      operand_locator_t_ea_get(self) -> ea_t
 |  
 |  opnum
 |      operand_locator_t_opnum_get(self) -> int

Help on function modify_user_lvar_info in module ida_hexrays:

modify_user_lvar_info(*args)
    Modify saved local variable settings of one variable.
    
    modify_user_lvar_info(func_ea, mli_flags, info) -> bool
        @param func_ea (C++: ea_t)
        @param mli_flags: bits that specify which attrs defined by INFO are to
                          be set (C++: uint)
        @param info: local variable info attrs (C++: const  lvar_saved_info_t
                     &)
        @return: true if modified, false if invalid MLI_FLAGS passed

Help on function modify_user_lvars in module ida_hexrays:

modify_user_lvars(*args)
    Modify saved local variable settings.
    
    modify_user_lvars(entry_ea, mlv) -> bool
        @param entry_ea: function start address (C++: ea_t)
        @param mlv: local variable modifier (C++: user_lvar_modifier_t  &)
        @return: true if modified variables

Help on class mop_addr_t in module ida_hexrays:

class mop_addr_t(mop_t)
 |  Proxy of C++ mop_addr_t class.
 |  
 |  Method resolution order:
 |      mop_addr_t
 |      mop_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mop_addr_t
 |          ra: mop_addr_t const &
 |      
 |      
 |      __init__(self, ra, isz, osz) -> mop_addr_t
 |          ra: mop_t const &
 |          isz: int
 |          osz: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  lexcompare(self, *args)
 |      lexcompare(self, ra) -> int
 |          @param ra (C++: const  mop_addr_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  insize
 |      mop_addr_t_insize_get(self) -> int
 |  
 |  outsize
 |      mop_addr_t_outsize_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mop_addr_t>
 |      delete_mop_addr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from mop_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, rop) -> bool
 |          rop: mop_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, rop) -> bool
 |          rop: mop_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, rop) -> bool
 |          rop: mop_t const &
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_t(self)
 |  
 |  _get_a(self, *args)
 |      _get_a(self) -> mop_addr_t
 |  
 |  _get_b(self, *args)
 |      _get_b(self) -> int
 |  
 |  _get_c(self, *args)
 |      _get_c(self) -> mcases_t
 |  
 |  _get_cstr(self, *args)
 |      _get_cstr(self) -> char const *
 |  
 |  _get_d(self, *args)
 |      _get_d(self) -> minsn_t
 |  
 |  _get_f(self, *args)
 |      _get_f(self) -> mcallinfo_t
 |  
 |  _get_fpc(self, *args)
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_g(self, *args)
 |      _get_g(self) -> ea_t
 |  
 |  _get_helper(self, *args)
 |      _get_helper(self) -> char const *
 |  
 |  _get_l(self, *args)
 |      _get_l(self) -> lvar_ref_t
 |  
 |  _get_nnn(self, *args)
 |      _get_nnn(self) -> mnumber_t
 |  
 |  _get_pair(self, *args)
 |      _get_pair(self) -> mop_pair_t
 |  
 |  _get_r(self, *args)
 |      _get_r(self) -> mreg_t
 |  
 |  _get_s(self, *args)
 |      _get_s(self) -> stkvar_ref_t
 |  
 |  _get_scif(self, *args)
 |      _get_scif(self) -> scif_t
 |  
 |  _get_t(self, *args)
 |      _get_t(self) -> mopt_t
 |  
 |  _make_blkref(self, *args)
 |      Create a block reference operand without erasing previous data.
 |      
 |      _make_blkref(self, blknum)
 |          @param blknum: block number Note: this function does not erase the
 |                         previous contents of the operand; call erase() if
 |                         necessary (C++: int)
 |  
 |  _make_callinfo(self, *args)
 |      Create a call info operand without erasing previous data.
 |      
 |      _make_callinfo(self, fi)
 |          @param fi: callinfo Note: this function does not erase the previous
 |                     contents of the operand; call erase() if necessary (C++:
 |                     mcallinfo_t  *)
 |  
 |  _make_cases(self, *args)
 |      Create a 'switch cases' operand without erasing previous data. Note:
 |      this function does not erase the previous contents of the operand;
 |      call erase() if necessary
 |      
 |      _make_cases(self, _cases)
 |          @param _cases (C++: mcases_t  *)
 |  
 |  _make_gvar(self, *args)
 |      Create a global variable operand without erasing previous data.
 |      
 |      _make_gvar(self, ea)
 |          @param ea: address of the variable Note: this function does not erase
 |                     the previous contents of the operand; call erase() if
 |                     necessary (C++: ea_t)
 |  
 |  _make_insn(self, *args)
 |      Create a nested instruction without erasing previous data.
 |      
 |      _make_insn(self, ins)
 |          @param ins (C++: minsn_t  *)
 |  
 |  _make_lvar(self, *args)
 |      Create a local variable operand.
 |      
 |      _make_lvar(self, mba, idx, off=0)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param idx: index into mba->vars (C++: int)
 |          @param off: offset from the beginning of the variable Note: this
 |                      function does not erase the previous contents of the
 |                      operand; call erase() if necessary (C++: sval_t)
 |  
 |  _make_pair(self, *args)
 |      Create a pair operand without erasing previous data. Note: this
 |      function does not erase the previous contents of the operand; call
 |      erase() if necessary
 |      
 |      _make_pair(self, _pair)
 |          @param _pair (C++: mop_pair_t  *)
 |  
 |  _make_reg(self, *args)
 |      Create a register operand without erasing previous data.
 |      
 |      _make_reg(self, reg)
 |          @param reg: micro register number Note: this function does not erase
 |                      the previous contents of the operand; call erase() if
 |                      necessary (C++: mreg_t)
 |      
 |      
 |      _make_reg(self, reg, _size)
 |          @param reg: micro register number Note: this function does not erase
 |                      the previous contents of the operand; call erase() if
 |                      necessary (C++: mreg_t)
 |          _size: int
 |  
 |  _make_stkvar(self, *args)
 |      Create a stack variable operand.
 |      
 |      _make_stkvar(self, mba, off)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param off: decompiler stkoff Note: this function does not erase the
 |                      previous contents of the operand; call erase() if
 |                      necessary (C++: sval_t)
 |  
 |  _make_strlit(self, *args)
 |      Create a constant string operand.
 |      
 |      _make_strlit(self, str)
 |          @param str (C++: const char *)
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _mop_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args)
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _mop_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args)
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args)
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _print(self, *args)
 |      _print(self, shins_flags=0x04|0x02)
 |          shins_flags: int
 |  
 |  _register(self, *args)
 |      _register(self)
 |  
 |  _set_a(self, *args)
 |      _set_a(self, _v)
 |          _v: mop_addr_t *
 |  
 |  _set_b(self, *args)
 |      _set_b(self, _v)
 |          _v: int
 |  
 |  _set_c(self, *args)
 |      _set_c(self, _v)
 |          _v: mcases_t *
 |  
 |  _set_cstr(self, *args)
 |      _set_cstr(self, _v)
 |          _v: char const *
 |  
 |  _set_d(self, *args)
 |      _set_d(self, _v)
 |          _v: minsn_t *
 |  
 |  _set_f(self, *args)
 |      _set_f(self, _v)
 |          _v: mcallinfo_t *
 |  
 |  _set_fpc(self, *args)
 |      _set_fpc(self, _v)
 |          _v: fnumber_t *
 |  
 |  _set_g(self, *args)
 |      _set_g(self, _v)
 |          _v: ea_t
 |  
 |  _set_helper(self, *args)
 |      _set_helper(self, _v)
 |          _v: char const *
 |  
 |  _set_l(self, *args)
 |      _set_l(self, _v)
 |          _v: lvar_ref_t *
 |  
 |  _set_nnn(self, *args)
 |      _set_nnn(self, _v)
 |          _v: mnumber_t *
 |  
 |  _set_pair(self, *args)
 |      _set_pair(self, _v)
 |          _v: mop_pair_t *
 |  
 |  _set_r(self, *args)
 |      _set_r(self, _v)
 |          _v: mreg_t
 |  
 |  _set_s(self, *args)
 |      _set_s(self, _v)
 |          _v: stkvar_ref_t *
 |  
 |  _set_scif(self, *args)
 |      _set_scif(self, _v)
 |          _v: scif_t *
 |  
 |  _set_t(self, *args)
 |      _set_t(self, v)
 |          v: mopt_t
 |  
 |  apply_ld_mcode(self, *args)
 |      Apply a unary opcode to the operand.
 |      
 |      apply_ld_mcode(self, mcode, ea, newsize)
 |          @param mcode: opcode to apply. it must accept 'l' and 'd' operands but
 |                        not 'r'. examples: m_low/m_high/m_xds/m_xdu (C++:
 |                        mcode_t)
 |          @param ea: value of  minsn_t::ea  for the newly created insruction
 |                     (C++: ea_t)
 |          @param newsize: new operand size Example: apply_ld_mcode(m_low) will
 |                          convert op => low(op) (C++: int)
 |  
 |  apply_xds(self, *args)
 |      apply_xds(self, ea, newsize)
 |          @param ea (C++: ea_t)
 |          @param newsize (C++: int)
 |  
 |  apply_xdu(self, *args)
 |      apply_xdu(self, ea, newsize)
 |          @param ea (C++: ea_t)
 |          @param newsize (C++: int)
 |  
 |  assign(self, *args)
 |      assign(self, rop) -> mop_t
 |          @param rop (C++: const  mop_t  &)
 |  
 |  change_size(self, *args)
 |      Change the operand size. Examples: change_size(AL.1, 2) -> AX.2
 |      change_size(qword_00000008.8, 4) -> dword_00000008.4
 |      change_size(xdu.8(op.4), 4) -> op.4 change_size(#0x12345678.4, 1) ->
 |      #0x78.1
 |      
 |      change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
 |          @param nsize: new operand size (C++: int)
 |          @param sideff: may modify the database because of the size change?
 |                         (C++: side_effect_t)
 |          @return: success
 |  
 |  create_from_insn(self, *args)
 |      Create operand from an instruction. This function creates a nested
 |      instruction that can be used as an operand. Example: if m="add x,y,z",
 |      our operand will be (t=mop_d,d=m). The destination operand of 'add'
 |      (z) is lost.
 |      
 |      create_from_insn(self, m)
 |          @param m: instruction to embed into operand. may not be NULL. (C++:
 |                    const  minsn_t  *)
 |  
 |  create_from_ivlset(self, *args)
 |      Create operand from 'ivlset_t' . Example: if IVS contains
 |      [glbvar..glbvar+4), our operand will be (t=mop_v, g=&glbvar, size=4)
 |      
 |      create_from_ivlset(self, mba, ivs, fullsize) -> bool
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param ivs: set of memory intervals (C++: const  ivlset_t  &)
 |          @param fullsize: mba->fullsize (C++: sval_t)
 |          @return: success
 |  
 |  create_from_mlist(self, *args)
 |      Create operand from 'mlist_t' . Example: if LST contains 4 bits for
 |      R0.4, our operand will be (t=mop_r, r=R0, size=4)
 |      
 |      create_from_mlist(self, mba, lst, fullsize) -> bool
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param lst: list of locations (C++: const  mlist_t  &)
 |          @param fullsize: mba->fullsize (C++: sval_t)
 |          @return: success
 |  
 |  create_from_scattered_vdloc(self, *args)
 |      Create operand from scattered 'vdloc_t' . Example: if LOC is
 |      (ALOC_DIST, {EAX.4, EDX.4}) and TYPE is _LARGE_INTEGER, our operand
 |      will be (t=mop_sc, scif={EAX.4, EDX.4})
 |      
 |      create_from_scattered_vdloc(self, mba, name, type, loc)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param name: name of the operand, if available (C++: const char *)
 |          @param type: type of the operand, must be present (C++: tinfo_t)
 |          @param loc: a scattered location (C++: const  vdloc_t  &)
 |          @return: success
 |  
 |  create_from_vdloc(self, *args)
 |      Create operand from 'vdloc_t' . Example: if LOC contains
 |      (type=ALOC_REG1, r=R0), our operand will be (t=mop_r, r=R0,
 |      size=_SIZE)
 |      
 |      create_from_vdloc(self, mba, loc, _size)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param loc: location (C++: const  vdloc_t  &)
 |          @param _size (C++: int)
 |          @return: success
 |  
 |  double_size(self, *args)
 |      double_size(self, sideff=WITH_SIDEFF) -> bool
 |          @param sideff (C++: side_effect_t)
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  equal_mops(self, *args)
 |      Compare operands. This is the main comparison function for operands.
 |      
 |      equal_mops(self, rop, eqflags) -> bool
 |          @param rop: operand to compare with (C++: const  mop_t  &)
 |          @param eqflags: combination of  comparison bits  bits (C++: int)
 |  
 |  erase(self, *args)
 |      erase(self)
 |  
 |  erase_but_keep_size(self, *args)
 |      erase_but_keep_size(self)
 |  
 |  for_all_ops(self, *args)
 |      Visit the operand and all its sub-operands. This function visits the
 |      current operand as well.
 |      
 |      for_all_ops(self, mv, type=None, is_target=False) -> int
 |          @param mv: visitor object (C++: mop_visitor_t  &)
 |          @param type: operand type (C++: const  tinfo_t  *)
 |          @param is_target: is a destination operand? (C++: bool)
 |  
 |  for_all_scattered_submops(self, *args)
 |      Visit all sub-operands of a scattered operand. This function does not
 |      visit the current operand, only its sub-operands. All sub-operands are
 |      synthetic and are destroyed after the visitor. This function works
 |      only with scattered operands.
 |      
 |      for_all_scattered_submops(self, sv) -> int
 |          @param sv: visitor object (C++: scif_visitor_t  &)
 |  
 |  get_insn(self, *args)
 |      Get subinstruction of the operand. If the operand has a subinstruction
 |      with the specified opcode, return it.
 |      
 |      get_insn(self, code) -> minsn_t
 |          @param code: desired opcode (C++: mcode_t)
 |          @return: pointer to the instruction or NULL
 |      
 |      
 |      get_insn(self, code) -> minsn_t
 |          @param code: desired opcode (C++: mcode_t)
 |          @return: pointer to the instruction or NULL
 |  
 |  get_stkoff(self, *args)
 |      Get the referenced stack offset. This function can also handle mop_sc
 |      if it is entirely mapped into a continuous stack region.
 |      
 |      get_stkoff(self, p_off) -> bool
 |          @param p_off: the output buffer (C++: sval_t  *)
 |          @return: success
 |  
 |  get_stkvar(self, *args)
 |      Retrieve the referenced stack variable.
 |      
 |      get_stkvar(self, p_off) -> member_t *
 |          @param p_off: if specified, will hold IDA stkoff after the call. (C++:
 |                        uval_t  *)
 |          @return: pointer to the stack variable
 |  
 |  has_side_effects(self, *args)
 |      Has any side effects?
 |      
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |          @param include_ldx_and_divs: consider ldx/div/mod as having side
 |                                       effects? (C++: bool)
 |  
 |  is01(self, *args)
 |      Are the possible values of the operand only 0 and 1? This function
 |      returns true for 0/1 constants, bit registers, the result of 'set'
 |      insns, etc.
 |  
 |  is_arglist(self, *args)
 |      Is a list of arguments?
 |  
 |  is_bit_reg(self, *args)
 |      is_bit_reg(self, reg) -> bool
 |          reg: mreg_t
 |  
 |  is_cc(self, *args)
 |      Is a condition code?
 |  
 |  is_ccflags(self, *args)
 |      is_ccflags(self) -> bool
 |  
 |  is_constant(self, *args)
 |      Retrieve value of a constant integer operand.
 |      
 |      is_constant(self, is_signed=True) -> bool
 |          @param is_signed: should treat the value as signed (C++: bool)
 |          @return: true if the operand is mop_n
 |  
 |  is_equal_to(self, *args)
 |      is_equal_to(self, n, is_signed=True) -> bool
 |          @param n (C++: uint64)
 |          @param is_signed (C++: bool)
 |  
 |  is_extended_from(self, *args)
 |      Does the high part of the operand consist of zero or sign bytes?
 |      
 |      is_extended_from(self, nbytes, is_signed) -> bool
 |          @param nbytes (C++: int)
 |          @param is_signed (C++: bool)
 |  
 |  is_glbaddr(self, *args)
 |      Is address of a global memory cell?
 |      
 |      is_glbaddr(self) -> bool
 |          ea: ea_t
 |  
 |  is_impptr_done(self, *args)
 |      is_impptr_done(self) -> bool
 |  
 |  is_insn(self, *args)
 |      Is a sub-instruction?
 |      
 |      is_insn(self) -> bool
 |          code: enum mcode_t
 |  
 |  is_kreg(self, *args)
 |      Is a kernel register?
 |  
 |  is_lowaddr(self, *args)
 |      is_lowaddr(self) -> bool
 |  
 |  is_mob(self, *args)
 |      Is a block reference to the specified block?
 |      
 |      is_mob(self, serial) -> bool
 |          @param serial (C++: int)
 |  
 |  is_negative_constant(self, *args)
 |      is_negative_constant(self) -> bool
 |  
 |  is_one(self, *args)
 |      is_one(self) -> bool
 |  
 |  is_positive_constant(self, *args)
 |      is_positive_constant(self) -> bool
 |  
 |  is_reg(self, *args)
 |      Is a register operand? See also get_mreg_name()
 |      
 |      is_reg(self) -> bool
 |          _r: mreg_t
 |      
 |      
 |      is_reg(self, _r, _size) -> bool
 |          _r: mreg_t
 |          _size: int
 |  
 |  is_scattered(self, *args)
 |      Is a scattered operand?
 |  
 |  is_sign_extended_from(self, *args)
 |      Does the high part of the operand consist of the sign bytes?
 |      
 |      is_sign_extended_from(self, nbytes) -> bool
 |          @param nbytes: number of bytes that were sign extended. the remaining
 |                         size-nbytes high bytes must be sign bytes Example:
 |                         is_sign_extended_from(xds.4(op.1), 1) -> true because
 |                         the high 3 bytes are certainly sign bits (C++: int)
 |  
 |  is_stkaddr(self, *args)
 |      Is address of a stack variable?
 |  
 |  is_udt(self, *args)
 |      is_udt(self) -> bool
 |  
 |  is_undef_val(self, *args)
 |      is_undef_val(self) -> bool
 |  
 |  is_zero(self, *args)
 |      is_zero(self) -> bool
 |  
 |  is_zero_extended_from(self, *args)
 |      Does the high part of the operand consist of zero bytes?
 |      
 |      is_zero_extended_from(self, nbytes) -> bool
 |          @param nbytes: number of bytes that were zero extended. the remaining
 |                         size-nbytes high bytes must be zero Example:
 |                         is_zero_extended_from(xdu.8(op.1), 2) -> true because
 |                         the high 6 bytes are certainly zero (C++: int)
 |  
 |  make_blkref(self, *args)
 |      Create a global variable operand.
 |      
 |      make_blkref(self, blknum)
 |          @param blknum (C++: int)
 |  
 |  make_first_half(self, *args)
 |      Make the first part of the operand. This function does not care about
 |      the memory endianness
 |      
 |      make_first_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  make_fpnum(self, *args)
 |      Create a floating point constant operand.
 |      
 |      make_fpnum(self, bytes, _size) -> bool
 |          @param bytes: pointer to the floating point value as used by the
 |                        current processor (e.g. for x86 it must be in IEEE 754)
 |                        (C++: const void *)
 |          @param _size: number of bytes occupied by the constant. (C++: size_t)
 |          @return: success
 |  
 |  make_gvar(self, *args)
 |      Create a global variable operand.
 |      
 |      make_gvar(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  make_helper(self, *args)
 |      Create a helper operand. A helper operand usually keeps a built-in
 |      function name like "va_start" It is essentially just an arbitrary
 |      identifier without any additional info.
 |      
 |      make_helper(self, name)
 |          @param name (C++: const char *)
 |  
 |  make_high_half(self, *args)
 |      Make the high part of the operand. This function takes into account
 |      the memory endianness (byte sex)
 |      
 |      make_high_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  make_insn(self, *args)
 |      Create a nested instruction.
 |      
 |      make_insn(self, ins)
 |          @param ins (C++: minsn_t  *)
 |  
 |  make_low_half(self, *args)
 |      Make the low part of the operand. This function takes into account the
 |      memory endianness (byte sex)
 |      
 |      make_low_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  make_number(self, *args)
 |      Create an integer constant operand.
 |      
 |      make_number(self, _value, _size, _ea=BADADDR, opnum=0)
 |          @param _value: value to store in the operand (C++: uint64)
 |          @param _size: size of the value in bytes (1,2,4,8) (C++: int)
 |          @param _ea: address of the processor instruction that made the value
 |                      (C++: ea_t)
 |          @param opnum: operand number of the processor instruction (C++: int)
 |  
 |  make_reg(self, *args)
 |      Create a register operand.
 |      
 |      make_reg(self, reg)
 |          @param reg (C++: mreg_t)
 |      
 |      
 |      make_reg(self, reg, _size)
 |          @param reg (C++: mreg_t)
 |          _size: int
 |  
 |  make_reg_pair(self, *args)
 |      Create pair of registers.
 |      
 |      make_reg_pair(self, loreg, hireg, halfsize)
 |          @param loreg: register holding the low part of the value (C++: int)
 |          @param hireg: register holding the high part of the value (C++: int)
 |          @param halfsize: the size of each of loreg/hireg (C++: int)
 |  
 |  make_second_half(self, *args)
 |      Make the second part of the operand. This function does not care about
 |      the memory endianness
 |      
 |      make_second_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  may_use_aliased_memory(self, *args)
 |      Is it possible for the operand to use aliased memory?
 |  
 |  preserve_side_effects(self, *args)
 |      Move subinstructions with side effects out of the operand. If we
 |      decide to delete an instruction operand, it is a good idea to call
 |      this function. Alternatively we should skip such operands by calling
 |      'mop_t::has_side_effects()' For example, if we transform: jnz x, x,
 |      @blk => goto @blk then we must call this function before deleting the
 |      X operands.
 |      
 |      preserve_side_effects(self, blk, top, moved_calls=None) -> bool
 |          @param blk: current block (C++: mblock_t  *)
 |          @param top: top level instruction that contains our operand (C++:
 |                      minsn_t  *)
 |          @param moved_calls: pointer to the boolean that will track if all side
 |                              effects get handled correctly. must be false
 |                              initially. (C++: bool *)
 |          @return: false failed to preserve a side effect, it is not safe to
 |                   delete the operand true no side effects or successfully
 |                   preserved them
 |  
 |  probably_floating(self, *args)
 |      probably_floating(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  set_impptr_done(self, *args)
 |      set_impptr_done(self)
 |  
 |  set_lowaddr(self, *args)
 |      set_lowaddr(self)
 |  
 |  set_udt(self, *args)
 |      set_udt(self)
 |  
 |  set_undef_val(self, *args)
 |      set_undef_val(self)
 |  
 |  shift_mop(self, *args)
 |      Shift the operand. This function shifts only the beginning of the
 |      operand. The operand size will be changed. Examples: shift_mop(AH.1,
 |      -1) -> AX.2 shift_mop(qword_00000008.8, 4) -> dword_0000000C.4
 |      shift_mop(xdu.8(op.4), 4) -> #0.4 shift_mop(#0x12345678.4, 3) -> #12.1
 |      
 |      shift_mop(self, offset) -> bool
 |          @param offset: shift count (the number of bytes to shift) (C++: int)
 |          @return: success
 |  
 |  signed_value(self, *args)
 |      signed_value(self) -> int64
 |  
 |  swap(self, *args)
 |      swap(self, rop)
 |          @param rop (C++: mop_t  &)
 |  
 |  unsigned_value(self, *args)
 |      unsigned_value(self) -> uint64
 |  
 |  value(self, *args)
 |      Retrieve value of a constant integer operand. These functions can be
 |      called only for mop_n operands. See 'is_constant()' that can be called
 |      on any operand.
 |      
 |      value(self, is_signed) -> uint64
 |          @param is_signed (C++: bool)
 |  
 |  zero(self, *args)
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from mop_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a
 |  
 |  b
 |  
 |  c
 |  
 |  cstr
 |  
 |  d
 |  
 |  f
 |  
 |  fpc
 |  
 |  g
 |  
 |  helper
 |  
 |  l
 |  
 |  meminfo
 |  
 |  nnn
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  oprops
 |      mop_t_oprops_get(self) -> uint8
 |  
 |  pair
 |  
 |  r
 |  
 |  s
 |  
 |  scif
 |  
 |  size
 |      mop_t_size_get(self) -> int
 |  
 |  t
 |      _get_t(self) -> mopt_t
 |  
 |  valnum
 |      mop_t_valnum_get(self) -> uint16

Help on class mop_pair_t in module ida_hexrays:

class mop_pair_t(__builtin__.object)
 |  Proxy of C++ mop_pair_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mop_pair_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hop
 |      mop_pair_t_hop_get(self) -> mop_t
 |  
 |  lop
 |      mop_pair_t_lop_get(self) -> mop_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mop_pair_t>
 |      delete_mop_pair_t(self)

Help on class mop_t in module ida_hexrays:

class mop_t(__builtin__.object)
 |  Proxy of C++ mop_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, rop) -> bool
 |          rop: mop_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mop_t
 |          rop: mop_t const &
 |      
 |      
 |      __init__(self, _r, _s) -> mop_t
 |          _r: mreg_t
 |          _s: int
 |  
 |  __lt__(self, *args)
 |      __lt__(self, rop) -> bool
 |          rop: mop_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, rop) -> bool
 |          rop: mop_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_t(self)
 |  
 |  _get_a(self, *args)
 |      _get_a(self) -> mop_addr_t
 |  
 |  _get_b(self, *args)
 |      _get_b(self) -> int
 |  
 |  _get_c(self, *args)
 |      _get_c(self) -> mcases_t
 |  
 |  _get_cstr(self, *args)
 |      _get_cstr(self) -> char const *
 |  
 |  _get_d(self, *args)
 |      _get_d(self) -> minsn_t
 |  
 |  _get_f(self, *args)
 |      _get_f(self) -> mcallinfo_t
 |  
 |  _get_fpc(self, *args)
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_g(self, *args)
 |      _get_g(self) -> ea_t
 |  
 |  _get_helper(self, *args)
 |      _get_helper(self) -> char const *
 |  
 |  _get_l(self, *args)
 |      _get_l(self) -> lvar_ref_t
 |  
 |  _get_nnn(self, *args)
 |      _get_nnn(self) -> mnumber_t
 |  
 |  _get_pair(self, *args)
 |      _get_pair(self) -> mop_pair_t
 |  
 |  _get_r(self, *args)
 |      _get_r(self) -> mreg_t
 |  
 |  _get_s(self, *args)
 |      _get_s(self) -> stkvar_ref_t
 |  
 |  _get_scif(self, *args)
 |      _get_scif(self) -> scif_t
 |  
 |  _get_t(self, *args)
 |      _get_t(self) -> mopt_t
 |  
 |  _make_blkref(self, *args)
 |      Create a block reference operand without erasing previous data.
 |      
 |      _make_blkref(self, blknum)
 |          @param blknum: block number Note: this function does not erase the
 |                         previous contents of the operand; call erase() if
 |                         necessary (C++: int)
 |  
 |  _make_callinfo(self, *args)
 |      Create a call info operand without erasing previous data.
 |      
 |      _make_callinfo(self, fi)
 |          @param fi: callinfo Note: this function does not erase the previous
 |                     contents of the operand; call erase() if necessary (C++:
 |                     mcallinfo_t  *)
 |  
 |  _make_cases(self, *args)
 |      Create a 'switch cases' operand without erasing previous data. Note:
 |      this function does not erase the previous contents of the operand;
 |      call erase() if necessary
 |      
 |      _make_cases(self, _cases)
 |          @param _cases (C++: mcases_t  *)
 |  
 |  _make_gvar(self, *args)
 |      Create a global variable operand without erasing previous data.
 |      
 |      _make_gvar(self, ea)
 |          @param ea: address of the variable Note: this function does not erase
 |                     the previous contents of the operand; call erase() if
 |                     necessary (C++: ea_t)
 |  
 |  _make_insn(self, *args)
 |      Create a nested instruction without erasing previous data.
 |      
 |      _make_insn(self, ins)
 |          @param ins (C++: minsn_t  *)
 |  
 |  _make_lvar(self, *args)
 |      Create a local variable operand.
 |      
 |      _make_lvar(self, mba, idx, off=0)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param idx: index into mba->vars (C++: int)
 |          @param off: offset from the beginning of the variable Note: this
 |                      function does not erase the previous contents of the
 |                      operand; call erase() if necessary (C++: sval_t)
 |  
 |  _make_pair(self, *args)
 |      Create a pair operand without erasing previous data. Note: this
 |      function does not erase the previous contents of the operand; call
 |      erase() if necessary
 |      
 |      _make_pair(self, _pair)
 |          @param _pair (C++: mop_pair_t  *)
 |  
 |  _make_reg(self, *args)
 |      Create a register operand without erasing previous data.
 |      
 |      _make_reg(self, reg)
 |          @param reg: micro register number Note: this function does not erase
 |                      the previous contents of the operand; call erase() if
 |                      necessary (C++: mreg_t)
 |      
 |      
 |      _make_reg(self, reg, _size)
 |          @param reg: micro register number Note: this function does not erase
 |                      the previous contents of the operand; call erase() if
 |                      necessary (C++: mreg_t)
 |          _size: int
 |  
 |  _make_stkvar(self, *args)
 |      Create a stack variable operand.
 |      
 |      _make_stkvar(self, mba, off)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param off: decompiler stkoff Note: this function does not erase the
 |                      previous contents of the operand; call erase() if
 |                      necessary (C++: sval_t)
 |  
 |  _make_strlit(self, *args)
 |      Create a constant string operand.
 |      
 |      _make_strlit(self, str)
 |          @param str (C++: const char *)
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _mop_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args)
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _mop_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args)
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args)
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _print(self, *args)
 |      _print(self, shins_flags=0x04|0x02)
 |          shins_flags: int
 |  
 |  _register(self, *args)
 |      _register(self)
 |  
 |  _set_a(self, *args)
 |      _set_a(self, _v)
 |          _v: mop_addr_t *
 |  
 |  _set_b(self, *args)
 |      _set_b(self, _v)
 |          _v: int
 |  
 |  _set_c(self, *args)
 |      _set_c(self, _v)
 |          _v: mcases_t *
 |  
 |  _set_cstr(self, *args)
 |      _set_cstr(self, _v)
 |          _v: char const *
 |  
 |  _set_d(self, *args)
 |      _set_d(self, _v)
 |          _v: minsn_t *
 |  
 |  _set_f(self, *args)
 |      _set_f(self, _v)
 |          _v: mcallinfo_t *
 |  
 |  _set_fpc(self, *args)
 |      _set_fpc(self, _v)
 |          _v: fnumber_t *
 |  
 |  _set_g(self, *args)
 |      _set_g(self, _v)
 |          _v: ea_t
 |  
 |  _set_helper(self, *args)
 |      _set_helper(self, _v)
 |          _v: char const *
 |  
 |  _set_l(self, *args)
 |      _set_l(self, _v)
 |          _v: lvar_ref_t *
 |  
 |  _set_nnn(self, *args)
 |      _set_nnn(self, _v)
 |          _v: mnumber_t *
 |  
 |  _set_pair(self, *args)
 |      _set_pair(self, _v)
 |          _v: mop_pair_t *
 |  
 |  _set_r(self, *args)
 |      _set_r(self, _v)
 |          _v: mreg_t
 |  
 |  _set_s(self, *args)
 |      _set_s(self, _v)
 |          _v: stkvar_ref_t *
 |  
 |  _set_scif(self, *args)
 |      _set_scif(self, _v)
 |          _v: scif_t *
 |  
 |  _set_t(self, *args)
 |      _set_t(self, v)
 |          v: mopt_t
 |  
 |  apply_ld_mcode(self, *args)
 |      Apply a unary opcode to the operand.
 |      
 |      apply_ld_mcode(self, mcode, ea, newsize)
 |          @param mcode: opcode to apply. it must accept 'l' and 'd' operands but
 |                        not 'r'. examples: m_low/m_high/m_xds/m_xdu (C++:
 |                        mcode_t)
 |          @param ea: value of  minsn_t::ea  for the newly created insruction
 |                     (C++: ea_t)
 |          @param newsize: new operand size Example: apply_ld_mcode(m_low) will
 |                          convert op => low(op) (C++: int)
 |  
 |  apply_xds(self, *args)
 |      apply_xds(self, ea, newsize)
 |          @param ea (C++: ea_t)
 |          @param newsize (C++: int)
 |  
 |  apply_xdu(self, *args)
 |      apply_xdu(self, ea, newsize)
 |          @param ea (C++: ea_t)
 |          @param newsize (C++: int)
 |  
 |  assign(self, *args)
 |      assign(self, rop) -> mop_t
 |          @param rop (C++: const  mop_t  &)
 |  
 |  change_size(self, *args)
 |      Change the operand size. Examples: change_size(AL.1, 2) -> AX.2
 |      change_size(qword_00000008.8, 4) -> dword_00000008.4
 |      change_size(xdu.8(op.4), 4) -> op.4 change_size(#0x12345678.4, 1) ->
 |      #0x78.1
 |      
 |      change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
 |          @param nsize: new operand size (C++: int)
 |          @param sideff: may modify the database because of the size change?
 |                         (C++: side_effect_t)
 |          @return: success
 |  
 |  create_from_insn(self, *args)
 |      Create operand from an instruction. This function creates a nested
 |      instruction that can be used as an operand. Example: if m="add x,y,z",
 |      our operand will be (t=mop_d,d=m). The destination operand of 'add'
 |      (z) is lost.
 |      
 |      create_from_insn(self, m)
 |          @param m: instruction to embed into operand. may not be NULL. (C++:
 |                    const  minsn_t  *)
 |  
 |  create_from_ivlset(self, *args)
 |      Create operand from 'ivlset_t' . Example: if IVS contains
 |      [glbvar..glbvar+4), our operand will be (t=mop_v, g=&glbvar, size=4)
 |      
 |      create_from_ivlset(self, mba, ivs, fullsize) -> bool
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param ivs: set of memory intervals (C++: const  ivlset_t  &)
 |          @param fullsize: mba->fullsize (C++: sval_t)
 |          @return: success
 |  
 |  create_from_mlist(self, *args)
 |      Create operand from 'mlist_t' . Example: if LST contains 4 bits for
 |      R0.4, our operand will be (t=mop_r, r=R0, size=4)
 |      
 |      create_from_mlist(self, mba, lst, fullsize) -> bool
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param lst: list of locations (C++: const  mlist_t  &)
 |          @param fullsize: mba->fullsize (C++: sval_t)
 |          @return: success
 |  
 |  create_from_scattered_vdloc(self, *args)
 |      Create operand from scattered 'vdloc_t' . Example: if LOC is
 |      (ALOC_DIST, {EAX.4, EDX.4}) and TYPE is _LARGE_INTEGER, our operand
 |      will be (t=mop_sc, scif={EAX.4, EDX.4})
 |      
 |      create_from_scattered_vdloc(self, mba, name, type, loc)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param name: name of the operand, if available (C++: const char *)
 |          @param type: type of the operand, must be present (C++: tinfo_t)
 |          @param loc: a scattered location (C++: const  vdloc_t  &)
 |          @return: success
 |  
 |  create_from_vdloc(self, *args)
 |      Create operand from 'vdloc_t' . Example: if LOC contains
 |      (type=ALOC_REG1, r=R0), our operand will be (t=mop_r, r=R0,
 |      size=_SIZE)
 |      
 |      create_from_vdloc(self, mba, loc, _size)
 |          @param mba: pointer to microcode (C++: mba_t  *)
 |          @param loc: location (C++: const  vdloc_t  &)
 |          @param _size (C++: int)
 |          @return: success
 |  
 |  double_size(self, *args)
 |      double_size(self, sideff=WITH_SIDEFF) -> bool
 |          @param sideff (C++: side_effect_t)
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  equal_mops(self, *args)
 |      Compare operands. This is the main comparison function for operands.
 |      
 |      equal_mops(self, rop, eqflags) -> bool
 |          @param rop: operand to compare with (C++: const  mop_t  &)
 |          @param eqflags: combination of  comparison bits  bits (C++: int)
 |  
 |  erase(self, *args)
 |      erase(self)
 |  
 |  erase_but_keep_size(self, *args)
 |      erase_but_keep_size(self)
 |  
 |  for_all_ops(self, *args)
 |      Visit the operand and all its sub-operands. This function visits the
 |      current operand as well.
 |      
 |      for_all_ops(self, mv, type=None, is_target=False) -> int
 |          @param mv: visitor object (C++: mop_visitor_t  &)
 |          @param type: operand type (C++: const  tinfo_t  *)
 |          @param is_target: is a destination operand? (C++: bool)
 |  
 |  for_all_scattered_submops(self, *args)
 |      Visit all sub-operands of a scattered operand. This function does not
 |      visit the current operand, only its sub-operands. All sub-operands are
 |      synthetic and are destroyed after the visitor. This function works
 |      only with scattered operands.
 |      
 |      for_all_scattered_submops(self, sv) -> int
 |          @param sv: visitor object (C++: scif_visitor_t  &)
 |  
 |  get_insn(self, *args)
 |      Get subinstruction of the operand. If the operand has a subinstruction
 |      with the specified opcode, return it.
 |      
 |      get_insn(self, code) -> minsn_t
 |          @param code: desired opcode (C++: mcode_t)
 |          @return: pointer to the instruction or NULL
 |      
 |      
 |      get_insn(self, code) -> minsn_t
 |          @param code: desired opcode (C++: mcode_t)
 |          @return: pointer to the instruction or NULL
 |  
 |  get_stkoff(self, *args)
 |      Get the referenced stack offset. This function can also handle mop_sc
 |      if it is entirely mapped into a continuous stack region.
 |      
 |      get_stkoff(self, p_off) -> bool
 |          @param p_off: the output buffer (C++: sval_t  *)
 |          @return: success
 |  
 |  get_stkvar(self, *args)
 |      Retrieve the referenced stack variable.
 |      
 |      get_stkvar(self, p_off) -> member_t *
 |          @param p_off: if specified, will hold IDA stkoff after the call. (C++:
 |                        uval_t  *)
 |          @return: pointer to the stack variable
 |  
 |  has_side_effects(self, *args)
 |      Has any side effects?
 |      
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |          @param include_ldx_and_divs: consider ldx/div/mod as having side
 |                                       effects? (C++: bool)
 |  
 |  is01(self, *args)
 |      Are the possible values of the operand only 0 and 1? This function
 |      returns true for 0/1 constants, bit registers, the result of 'set'
 |      insns, etc.
 |  
 |  is_arglist(self, *args)
 |      Is a list of arguments?
 |  
 |  is_bit_reg(self, *args)
 |      is_bit_reg(self, reg) -> bool
 |          reg: mreg_t
 |  
 |  is_cc(self, *args)
 |      Is a condition code?
 |  
 |  is_ccflags(self, *args)
 |      is_ccflags(self) -> bool
 |  
 |  is_constant(self, *args)
 |      Retrieve value of a constant integer operand.
 |      
 |      is_constant(self, is_signed=True) -> bool
 |          @param is_signed: should treat the value as signed (C++: bool)
 |          @return: true if the operand is mop_n
 |  
 |  is_equal_to(self, *args)
 |      is_equal_to(self, n, is_signed=True) -> bool
 |          @param n (C++: uint64)
 |          @param is_signed (C++: bool)
 |  
 |  is_extended_from(self, *args)
 |      Does the high part of the operand consist of zero or sign bytes?
 |      
 |      is_extended_from(self, nbytes, is_signed) -> bool
 |          @param nbytes (C++: int)
 |          @param is_signed (C++: bool)
 |  
 |  is_glbaddr(self, *args)
 |      Is address of a global memory cell?
 |      
 |      is_glbaddr(self) -> bool
 |          ea: ea_t
 |  
 |  is_impptr_done(self, *args)
 |      is_impptr_done(self) -> bool
 |  
 |  is_insn(self, *args)
 |      Is a sub-instruction?
 |      
 |      is_insn(self) -> bool
 |          code: enum mcode_t
 |  
 |  is_kreg(self, *args)
 |      Is a kernel register?
 |  
 |  is_lowaddr(self, *args)
 |      is_lowaddr(self) -> bool
 |  
 |  is_mob(self, *args)
 |      Is a block reference to the specified block?
 |      
 |      is_mob(self, serial) -> bool
 |          @param serial (C++: int)
 |  
 |  is_negative_constant(self, *args)
 |      is_negative_constant(self) -> bool
 |  
 |  is_one(self, *args)
 |      is_one(self) -> bool
 |  
 |  is_positive_constant(self, *args)
 |      is_positive_constant(self) -> bool
 |  
 |  is_reg(self, *args)
 |      Is a register operand? See also get_mreg_name()
 |      
 |      is_reg(self) -> bool
 |          _r: mreg_t
 |      
 |      
 |      is_reg(self, _r, _size) -> bool
 |          _r: mreg_t
 |          _size: int
 |  
 |  is_scattered(self, *args)
 |      Is a scattered operand?
 |  
 |  is_sign_extended_from(self, *args)
 |      Does the high part of the operand consist of the sign bytes?
 |      
 |      is_sign_extended_from(self, nbytes) -> bool
 |          @param nbytes: number of bytes that were sign extended. the remaining
 |                         size-nbytes high bytes must be sign bytes Example:
 |                         is_sign_extended_from(xds.4(op.1), 1) -> true because
 |                         the high 3 bytes are certainly sign bits (C++: int)
 |  
 |  is_stkaddr(self, *args)
 |      Is address of a stack variable?
 |  
 |  is_udt(self, *args)
 |      is_udt(self) -> bool
 |  
 |  is_undef_val(self, *args)
 |      is_undef_val(self) -> bool
 |  
 |  is_zero(self, *args)
 |      is_zero(self) -> bool
 |  
 |  is_zero_extended_from(self, *args)
 |      Does the high part of the operand consist of zero bytes?
 |      
 |      is_zero_extended_from(self, nbytes) -> bool
 |          @param nbytes: number of bytes that were zero extended. the remaining
 |                         size-nbytes high bytes must be zero Example:
 |                         is_zero_extended_from(xdu.8(op.1), 2) -> true because
 |                         the high 6 bytes are certainly zero (C++: int)
 |  
 |  lexcompare(self, *args)
 |      lexcompare(self, rop) -> int
 |          @param rop (C++: const  mop_t  &)
 |  
 |  make_blkref(self, *args)
 |      Create a global variable operand.
 |      
 |      make_blkref(self, blknum)
 |          @param blknum (C++: int)
 |  
 |  make_first_half(self, *args)
 |      Make the first part of the operand. This function does not care about
 |      the memory endianness
 |      
 |      make_first_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  make_fpnum(self, *args)
 |      Create a floating point constant operand.
 |      
 |      make_fpnum(self, bytes, _size) -> bool
 |          @param bytes: pointer to the floating point value as used by the
 |                        current processor (e.g. for x86 it must be in IEEE 754)
 |                        (C++: const void *)
 |          @param _size: number of bytes occupied by the constant. (C++: size_t)
 |          @return: success
 |  
 |  make_gvar(self, *args)
 |      Create a global variable operand.
 |      
 |      make_gvar(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  make_helper(self, *args)
 |      Create a helper operand. A helper operand usually keeps a built-in
 |      function name like "va_start" It is essentially just an arbitrary
 |      identifier without any additional info.
 |      
 |      make_helper(self, name)
 |          @param name (C++: const char *)
 |  
 |  make_high_half(self, *args)
 |      Make the high part of the operand. This function takes into account
 |      the memory endianness (byte sex)
 |      
 |      make_high_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  make_insn(self, *args)
 |      Create a nested instruction.
 |      
 |      make_insn(self, ins)
 |          @param ins (C++: minsn_t  *)
 |  
 |  make_low_half(self, *args)
 |      Make the low part of the operand. This function takes into account the
 |      memory endianness (byte sex)
 |      
 |      make_low_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  make_number(self, *args)
 |      Create an integer constant operand.
 |      
 |      make_number(self, _value, _size, _ea=BADADDR, opnum=0)
 |          @param _value: value to store in the operand (C++: uint64)
 |          @param _size: size of the value in bytes (1,2,4,8) (C++: int)
 |          @param _ea: address of the processor instruction that made the value
 |                      (C++: ea_t)
 |          @param opnum: operand number of the processor instruction (C++: int)
 |  
 |  make_reg(self, *args)
 |      Create a register operand.
 |      
 |      make_reg(self, reg)
 |          @param reg (C++: mreg_t)
 |      
 |      
 |      make_reg(self, reg, _size)
 |          @param reg (C++: mreg_t)
 |          _size: int
 |  
 |  make_reg_pair(self, *args)
 |      Create pair of registers.
 |      
 |      make_reg_pair(self, loreg, hireg, halfsize)
 |          @param loreg: register holding the low part of the value (C++: int)
 |          @param hireg: register holding the high part of the value (C++: int)
 |          @param halfsize: the size of each of loreg/hireg (C++: int)
 |  
 |  make_second_half(self, *args)
 |      Make the second part of the operand. This function does not care about
 |      the memory endianness
 |      
 |      make_second_half(self, width) -> bool
 |          @param width: the desired size of the operand part in bytes (C++: int)
 |          @return: success
 |  
 |  may_use_aliased_memory(self, *args)
 |      Is it possible for the operand to use aliased memory?
 |  
 |  preserve_side_effects(self, *args)
 |      Move subinstructions with side effects out of the operand. If we
 |      decide to delete an instruction operand, it is a good idea to call
 |      this function. Alternatively we should skip such operands by calling
 |      'mop_t::has_side_effects()' For example, if we transform: jnz x, x,
 |      @blk => goto @blk then we must call this function before deleting the
 |      X operands.
 |      
 |      preserve_side_effects(self, blk, top, moved_calls=None) -> bool
 |          @param blk: current block (C++: mblock_t  *)
 |          @param top: top level instruction that contains our operand (C++:
 |                      minsn_t  *)
 |          @param moved_calls: pointer to the boolean that will track if all side
 |                              effects get handled correctly. must be false
 |                              initially. (C++: bool *)
 |          @return: false failed to preserve a side effect, it is not safe to
 |                   delete the operand true no side effects or successfully
 |                   preserved them
 |  
 |  probably_floating(self, *args)
 |      probably_floating(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  set_impptr_done(self, *args)
 |      set_impptr_done(self)
 |  
 |  set_lowaddr(self, *args)
 |      set_lowaddr(self)
 |  
 |  set_udt(self, *args)
 |      set_udt(self)
 |  
 |  set_undef_val(self, *args)
 |      set_undef_val(self)
 |  
 |  shift_mop(self, *args)
 |      Shift the operand. This function shifts only the beginning of the
 |      operand. The operand size will be changed. Examples: shift_mop(AH.1,
 |      -1) -> AX.2 shift_mop(qword_00000008.8, 4) -> dword_0000000C.4
 |      shift_mop(xdu.8(op.4), 4) -> #0.4 shift_mop(#0x12345678.4, 3) -> #12.1
 |      
 |      shift_mop(self, offset) -> bool
 |          @param offset: shift count (the number of bytes to shift) (C++: int)
 |          @return: success
 |  
 |  signed_value(self, *args)
 |      signed_value(self) -> int64
 |  
 |  swap(self, *args)
 |      swap(self, rop)
 |          @param rop (C++: mop_t  &)
 |  
 |  unsigned_value(self, *args)
 |      unsigned_value(self) -> uint64
 |  
 |  value(self, *args)
 |      Retrieve value of a constant integer operand. These functions can be
 |      called only for mop_n operands. See 'is_constant()' that can be called
 |      on any operand.
 |      
 |      value(self, is_signed) -> uint64
 |          @param is_signed (C++: bool)
 |  
 |  zero(self, *args)
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a
 |  
 |  b
 |  
 |  c
 |  
 |  cstr
 |  
 |  d
 |  
 |  f
 |  
 |  fpc
 |  
 |  g
 |  
 |  helper
 |  
 |  l
 |  
 |  meminfo
 |  
 |  nnn
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  oprops
 |      mop_t_oprops_get(self) -> uint8
 |  
 |  pair
 |  
 |  r
 |  
 |  s
 |  
 |  scif
 |  
 |  size
 |      mop_t_size_get(self) -> int
 |  
 |  t
 |      _get_t(self) -> mopt_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  valnum
 |      mop_t_valnum_get(self) -> uint16
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mop_t>
 |      delete_mop_t(self)

Help on class mop_visitor_t in module ida_hexrays:

class mop_visitor_t(op_parent_info_t)
 |  Proxy of C++ mop_visitor_t class.
 |  
 |  Method resolution order:
 |      mop_visitor_t
 |      op_parent_info_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba=None, _blk=None, _topins=None) -> mop_visitor_t
 |          _mba: mba_t *
 |          _blk: mblock_t *
 |          _topins: minsn_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_mop(self, *args)
 |      visit_mop(self, op, type, is_target) -> int
 |          @param op (C++: mop_t  *)
 |          @param type (C++: const  tinfo_t  *)
 |          @param is_target (C++: bool)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  prune
 |      mop_visitor_t_prune_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mop_visitor_t>
 |      delete_mop_visitor_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from op_parent_info_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blk
 |      op_parent_info_t_blk_get(self) -> mblock_t
 |  
 |  curins
 |      op_parent_info_t_curins_get(self) -> minsn_t
 |  
 |  mba
 |      op_parent_info_t_mba_get(self) -> mba_t
 |  
 |  topins
 |      op_parent_info_t_topins_get(self) -> minsn_t

Help on class mopvec_t in module ida_hexrays:

class mopvec_t(__builtin__.object)
 |  Proxy of C++ qvector< mop_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< mop_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> mop_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mopvec_t
 |          x: qvector< mop_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< mop_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: mop_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: mop_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: mop_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> mop_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> mop_t
 |      begin(self) -> mop_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> mop_t
 |      end(self) -> mop_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> mop_t
 |          it: qvector< mop_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> mop_t
 |          first: qvector< mop_t >::iterator
 |          last: qvector< mop_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> mop_t
 |  
 |  find(self, *args)
 |      find(self, x) -> mop_t
 |          x: mop_t const &
 |      
 |      
 |      find(self, x) -> mop_t
 |          x: mop_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=mop_t())
 |          x: mop_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: mop_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: mop_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> mop_t
 |          it: qvector< mop_t >::iterator
 |          x: mop_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: mop_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: mop_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< mop_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_mopvec_t>
 |      delete_mopvec_t(self)

Help on function mreg2reg in module ida_hexrays:

mreg2reg(*args)
    Map a microregister to a processor register.
    
    mreg2reg(reg, width) -> int
        @param reg: microregister number (C++: mreg_t)
        @param width: size of microregister in bytes (C++: int)
        @return: processor register id or -1

Help on function must_mcode_close_block in module ida_hexrays:

must_mcode_close_block(*args)
    Must an instruction with the given opcode be the last one in a block?
    Such opcodes are called closing opcodes.
    
    must_mcode_close_block(mcode, including_calls) -> bool
        @param mcode: instruction opcode (C++: mcode_t)
        @param including_calls: should m_call/m_icall be considered as the
                                closing opcodes? If this function returns
                                true, the opcode cannot appear in the middle
                                of a block. Calls are a special case: unknown
                                calls (is_unknown_call) are considered as
                                closing opcodes. (C++: bool)

Help on function negate_mcode_relation in module ida_hexrays:

negate_mcode_relation(*args)
    negate_mcode_relation(code) -> mcode_t
        @param code (C++: mcode_t)

Help on function negated_relation in module ida_hexrays:

negated_relation(*args)
    Negate a comparison operator. For example, cot_sge becomes cot_slt.
    
    negated_relation(op) -> ctype_t
        @param op (C++: ctype_t)

Help on function new_block in module ida_hexrays:

new_block()

Help on class number_format_t in module ida_hexrays:

class number_format_t(__builtin__.object)
 |  Proxy of C++ number_format_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _opnum=0) -> number_format_t
 |          _opnum: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_radix(self, *args)
 |      Get number radix
 |  
 |  has_unmutable_type(self, *args)
 |      has_unmutable_type(self) -> bool
 |  
 |  is_char(self, *args)
 |      Is a character constant?
 |  
 |  is_dec(self, *args)
 |      Is a decimal number?
 |  
 |  is_enum(self, *args)
 |      Is a symbolic constant?
 |  
 |  is_fixed(self, *args)
 |      Is number representation fixed? Fixed representation cannot be
 |      modified by the decompiler
 |  
 |  is_hex(self, *args)
 |      Is a hexadecimal number?
 |  
 |  is_numop(self, *args)
 |      Is a number?
 |  
 |  is_oct(self, *args)
 |      Is a octal number?
 |  
 |  is_stroff(self, *args)
 |      Is a structure field offset?
 |  
 |  needs_to_be_inverted(self, *args)
 |      Does the number need to be negated or bitwise negated? Returns true if
 |      the user requested a negation but it is not done yet
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      number_format_t_flags_get(self) -> flags_t
 |  
 |  opnum
 |      number_format_t_opnum_get(self) -> char
 |  
 |  org_nbytes
 |      number_format_t_org_nbytes_get(self) -> char
 |  
 |  props
 |      number_format_t_props_get(self) -> char
 |  
 |  serial
 |      number_format_t_serial_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  type_name
 |      number_format_t_type_name_get(self) -> qstring *
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_number_format_t>
 |      delete_number_format_t(self)

Help on class op_parent_info_t in module ida_hexrays:

class op_parent_info_t(__builtin__.object)
 |  Proxy of C++ op_parent_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba=None, _blk=None, _topins=None) -> op_parent_info_t
 |          _mba: mba_t *
 |          _blk: mblock_t *
 |          _topins: minsn_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blk
 |      op_parent_info_t_blk_get(self) -> mblock_t
 |  
 |  curins
 |      op_parent_info_t_curins_get(self) -> minsn_t
 |  
 |  mba
 |      op_parent_info_t_mba_get(self) -> mba_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  topins
 |      op_parent_info_t_topins_get(self) -> minsn_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_op_parent_info_t>
 |      delete_op_parent_info_t(self)

Help on function op_uses_x in module ida_hexrays:

op_uses_x(*args)
    Does operator use the 'x' field of 'cexpr_t' ?
    
    op_uses_x(op) -> bool
        @param op (C++: ctype_t)

Help on function op_uses_y in module ida_hexrays:

op_uses_y(*args)
    Does operator use the 'y' field of 'cexpr_t' ?
    
    op_uses_y(op) -> bool
        @param op (C++: ctype_t)

Help on function op_uses_z in module ida_hexrays:

op_uses_z(*args)
    Does operator use the 'z' field of 'cexpr_t' ?
    
    op_uses_z(op) -> bool
        @param op (C++: ctype_t)

Help on function open_pseudocode in module ida_hexrays:

open_pseudocode(*args)
    Open pseudocode window. The specified function is decompiled and the
    pseudocode window is opened.
    
    open_pseudocode(ea, flags) -> vdui_t
        @param ea: function to decompile (C++: ea_t)
        @param flags: a combination of OPF_ flags (C++: int)
        @return: false if failed

Help on class operand_locator_t in module ida_hexrays:

class operand_locator_t(__builtin__.object)
 |  Proxy of C++ operand_locator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: operand_locator_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: operand_locator_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: operand_locator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea, _opnum) -> operand_locator_t
 |          _ea: ea_t
 |          _opnum: int
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: operand_locator_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: operand_locator_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: operand_locator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: operand_locator_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      operand_locator_t_ea_get(self) -> ea_t
 |  
 |  opnum
 |      operand_locator_t_opnum_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_operand_locator_t>
 |      delete_operand_locator_t(self)

Help on class operator_info_t in module ida_hexrays:

class operator_info_t(__builtin__.object)
 |  Proxy of C++ operator_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> operator_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fixtype
 |      operator_info_t_fixtype_get(self) -> uchar
 |  
 |  flags
 |      operator_info_t_flags_get(self) -> uchar
 |  
 |  precedence
 |      operator_info_t_precedence_get(self) -> uchar
 |  
 |  text
 |      operator_info_t_text_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  valency
 |      operator_info_t_valency_get(self) -> uchar
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_operator_info_t>
 |      delete_operator_info_t(self)

Help on class optblock_t in module ida_hexrays:

class optblock_t(__builtin__.object)
 |  Proxy of C++ optblock_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> optblock_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  func(self, *args)
 |      Optimize a block. This function usually performs the optimizations
 |      that require analyzing the entire block and/or its neighbors. For
 |      example it can recognize patterns and perform conversions like: b0:
 |      b0: ... ... jnz x, 0, @b2 => jnz x, 0, @b2 b1: b1: add x, 0, y mov x,
 |      y ... ...
 |      
 |      func(self, blk) -> int
 |          @param blk: Basic block to optimize as a whole. (C++: mblock_t  *)
 |          @return: number of changes made to the block. See also
 |                   mark_lists_dirty.
 |  
 |  install(self, *args)
 |      install(self)
 |  
 |  remove(self, *args)
 |      remove(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_optblock_t>
 |      delete_optblock_t(self)

Help on class optinsn_t in module ida_hexrays:

class optinsn_t(__builtin__.object)
 |  Proxy of C++ optinsn_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> optinsn_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  func(self, *args)
 |      Optimize an instruction.
 |      
 |      func(self, blk, ins, optflags) -> int
 |          @param blk: current basic block. maybe NULL, which means that the
 |                      instruction must be optimized without context (C++:
 |                      mblock_t  *)
 |          @param ins: instruction to optimize; it is always a top-level
 |                      instruction. the callback may not delete the instruction
 |                      but may convert it into nop (see  mblock_t::make_nop ). to
 |                      optimize sub-instructions, visit them using
 |                      minsn_visitor_t . sub-instructions may not be converted
 |                      into nop but can be converted to "mov x,x". for example:
 |                      add x,0,x => mov x,x this callback may change other
 |                      instructions in the block, but should do this with care,
 |                      e.g. to no break the propagation algorithm if called with
 |                      OPTI_NO_LDXOPT. (C++: minsn_t  *)
 |          @param optflags: combination of  optimization flags  bits (C++: int)
 |          @return: number of changes made to the instruction. if after this call
 |                   the instruction's use/def lists have changed, you must mark
 |                   the block level lists as dirty (see mark_lists_dirty)
 |  
 |  install(self, *args)
 |      install(self)
 |  
 |  remove(self, *args)
 |      remove(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_optinsn_t>
 |      delete_optinsn_t(self)

Help on function parse_user_call in module ida_hexrays:

parse_user_call(*args)
    Convert function type declaration into internal structure
    
    parse_user_call(udc, decl, silent) -> bool
        @param udc: - pointer to output structure (C++: udcall_t  *)
        @param decl: - function type declaration (C++: const char *)
        @param silent: - if TRUE: do not show warning in case of incorrect
                       type (C++: bool)
        @return: success

Help on function partial_type_num in module ida_hexrays:

partial_type_num(*args)
    Calculate number of partial subtypes.
    
    partial_type_num(type) -> int
        @param type (C++: const  tinfo_t  &)
        @return: number of partial subtypes. The bigger is this number, the
                 uglier is the type.

Help on function print_vdloc in module ida_hexrays:

print_vdloc(*args)
    Print vdloc. Since vdloc does not always carry the size info, we pass
    it as NBYTES..
    
    print_vdloc(loc, nbytes)
        @param loc (C++: const  vdloc_t  &)
        @param nbytes (C++: int)

Help on function property_op_to_typename in module ida_hexrays:

property_op_to_typename(self)

Help on class qlist_cinsn_t in module ida_hexrays:

class qlist_cinsn_t(__builtin__.object)
 |  Proxy of C++ qlist< cinsn_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, x) -> bool
 |          x: qlist< cinsn_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> cinsn_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qlist_cinsn_t
 |          x: qlist< cinsn_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, x) -> bool
 |          x: qlist< cinsn_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: cinsn_t const &
 |  
 |  at(self, index)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qlist_cinsn_t_iterator
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qlist_cinsn_t_iterator
 |  
 |  erase(self, *args)
 |      erase(self, p) -> qlist< cinsn_t >::iterator
 |          p: qlist< cinsn_t >::iterator
 |      
 |      
 |      erase(self, p1, p2)
 |          p1: qlist< cinsn_t >::iterator
 |          p2: qlist< cinsn_t >::iterator
 |      
 |      
 |      erase(self, p)
 |          p: qlist_cinsn_t_iterator
 |  
 |  find(self, item)
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  index(self, item)
 |  
 |  insert(self, *args)
 |      insert(self, p, x) -> qlist< cinsn_t >::iterator
 |          p: qlist< cinsn_t >::iterator
 |          x: cinsn_t const &
 |      
 |      
 |      insert(self, p) -> qlist< cinsn_t >::iterator
 |          p: qlist< cinsn_t >::iterator
 |      
 |      
 |      insert(self, i, v)
 |          i: size_t
 |          v: cinsn_t const &
 |      
 |      
 |      insert(self, p, x) -> qlist_cinsn_t_iterator
 |          p: qlist_cinsn_t_iterator
 |          x: cinsn_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  pop_front(self, *args)
 |      pop_front(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: cinsn_t const &
 |  
 |  push_front(self, *args)
 |      push_front(self, x)
 |          x: cinsn_t const &
 |  
 |  rbegin(self, *args)
 |      rbegin(self) -> qlist< cinsn_t >::reverse_iterator
 |      rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  remove(self, *args)
 |      remove(self, v) -> bool
 |          v: cinsn_t const &
 |  
 |  rend(self, *args)
 |      rend(self) -> qlist< cinsn_t >::reverse_iterator
 |      rend(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, x)
 |          x: qlist< cinsn_t > &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qlist_cinsn_t>
 |      delete_qlist_cinsn_t(self)

Help on class qlist_cinsn_t_iterator in module ida_hexrays:

class qlist_cinsn_t_iterator(__builtin__.object)
 |  Proxy of C++ qlist_cinsn_t_iterator class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, x) -> bool
 |          x: qlist_cinsn_t_iterator const *
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qlist_cinsn_t_iterator
 |  
 |  __ne__(self, *args)
 |      __ne__(self, x) -> bool
 |          x: qlist_cinsn_t_iterator const *
 |  
 |  __next__(self, *args)
 |      __next__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  next = __next__(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cur
 |      qlist_cinsn_t_iterator_cur_get(self) -> cinsn_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qlist_cinsn_t_iterator>
 |      delete_qlist_cinsn_t_iterator(self)

Help on class qstring_printer_t in module ida_hexrays:

class qstring_printer_t(vc_printer_t)
 |  Proxy of C++ qstring_printer_t class.
 |  
 |  Method resolution order:
 |      qstring_printer_t
 |      vc_printer_t
 |      vd_printer_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, f, tags) -> qstring_printer_t
 |          f: cfunc_t const *
 |          tags: bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self, indent, format) -> int
 |          indent: int
 |          format: char const *
 |  
 |  get_s(self, *args)
 |      get_s(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  s
 |  
 |  thisown
 |      The membership flag
 |  
 |  with_tags
 |      qstring_printer_t_with_tags_get(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vc_printer_t:
 |  
 |  __disown__(self)
 |  
 |  oneliner(self, *args)
 |      Are we generating one-line text representation?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vc_printer_t:
 |  
 |  func
 |      vc_printer_t_func_get(self) -> cfunc_t
 |  
 |  lastchar
 |      vc_printer_t_lastchar_get(self) -> char
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from vc_printer_t:
 |  
 |  __swig_destroy__ = <built-in function delete_vc_printer_t>
 |      delete_vc_printer_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vd_printer_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hdrlines
 |      vd_printer_t_hdrlines_get(self) -> int
 |  
 |  tmpbuf
 |      vd_printer_t_tmpbuf_get(self) -> qstring *

Help on function qswap in module ida_hexrays:

qswap(*args)
    qswap(a, b)
        a: cinsn_t &
        b: cinsn_t &

Help on class qvector_carg_t in module ida_hexrays:

class qvector_carg_t(__builtin__.object)
 |  Proxy of C++ qvector< carg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< carg_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> carg_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_carg_t
 |          x: qvector< carg_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< carg_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: carg_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: carg_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: carg_t const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> carg_t
 |      begin(self) -> carg_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> carg_t
 |      end(self) -> carg_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> carg_t
 |          it: qvector< carg_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> carg_t
 |          first: qvector< carg_t >::iterator
 |          last: qvector< carg_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> carg_t
 |  
 |  find(self, *args)
 |      find(self, x) -> carg_t
 |          x: carg_t const &
 |      
 |      
 |      find(self, x) -> carg_t
 |          x: carg_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=carg_t())
 |          x: carg_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: carg_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: carg_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> carg_t
 |          it: qvector< carg_t >::iterator
 |          x: carg_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: carg_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: carg_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< carg_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qvector_carg_t>
 |      delete_qvector_carg_t(self)

Help on class qvector_ccase_t in module ida_hexrays:

class qvector_ccase_t(__builtin__.object)
 |  Proxy of C++ qvector< ccase_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< ccase_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> ccase_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_ccase_t
 |          x: qvector< ccase_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< ccase_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: ccase_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: ccase_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: ccase_t const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> ccase_t
 |      begin(self) -> ccase_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> ccase_t
 |      end(self) -> ccase_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> ccase_t
 |          it: qvector< ccase_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> ccase_t
 |          first: qvector< ccase_t >::iterator
 |          last: qvector< ccase_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> ccase_t
 |  
 |  find(self, *args)
 |      find(self, x) -> ccase_t
 |          x: ccase_t const &
 |      
 |      
 |      find(self, x) -> ccase_t
 |          x: ccase_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=ccase_t())
 |          x: ccase_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: ccase_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: ccase_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> ccase_t
 |          it: qvector< ccase_t >::iterator
 |          x: ccase_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: ccase_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: ccase_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< ccase_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qvector_ccase_t>
 |      delete_qvector_ccase_t(self)

Help on class qvector_history_t in module ida_hexrays:

class qvector_history_t(__builtin__.object)
 |  Proxy of C++ qvector< history_item_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< history_item_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> history_item_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_history_t
 |          x: qvector< history_item_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< history_item_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: history_item_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: history_item_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: history_item_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> history_item_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> history_item_t
 |      begin(self) -> history_item_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> history_item_t
 |      end(self) -> history_item_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> history_item_t
 |          it: qvector< history_item_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> history_item_t
 |          first: qvector< history_item_t >::iterator
 |          last: qvector< history_item_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> history_item_t
 |  
 |  find(self, *args)
 |      find(self, x) -> history_item_t
 |          x: history_item_t const &
 |      
 |      
 |      find(self, x) -> history_item_t
 |          x: history_item_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=history_item_t())
 |          x: history_item_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: history_item_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: history_item_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> history_item_t
 |          it: qvector< history_item_t >::iterator
 |          x: history_item_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: history_item_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: history_item_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< history_item_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qvector_history_t>
 |      delete_qvector_history_t(self)

Help on class qvector_lvar_t in module ida_hexrays:

class qvector_lvar_t(__builtin__.object)
 |  Proxy of C++ qvector< lvar_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< lvar_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> lvar_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_lvar_t
 |          x: qvector< lvar_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< lvar_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: lvar_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: lvar_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: lvar_t const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> lvar_t
 |      begin(self) -> lvar_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> lvar_t
 |      end(self) -> lvar_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> lvar_t
 |          it: qvector< lvar_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> lvar_t
 |          first: qvector< lvar_t >::iterator
 |          last: qvector< lvar_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> lvar_t
 |  
 |  find(self, *args)
 |      find(self, x) -> lvar_t
 |          x: lvar_t const &
 |      
 |      
 |      find(self, x) -> lvar_t
 |          x: lvar_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=lvar_t())
 |          x: lvar_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: lvar_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: lvar_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> lvar_t
 |          it: qvector< lvar_t >::iterator
 |          x: lvar_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: lvar_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: lvar_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< lvar_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qvector_lvar_t>
 |      delete_qvector_lvar_t(self)

Help on function reg2mreg in module ida_hexrays:

reg2mreg(*args)
    Map a processor register to a microregister.
    
    reg2mreg(reg) -> mreg_t
        @param reg: processor register number (C++: int)
        @return: microregister register id or mr_none

Help on function remitem in module ida_hexrays:

remitem(*args)
    remitem(e)
        @param e (C++: const  citem_t  *)

Help on function remove_hexrays_callback in module ida_hexrays:

remove_hexrays_callback(callback)
    Deprecated. Please use Hexrays_Hooks instead

Help on function restore_user_cmts in module ida_hexrays:

restore_user_cmts(*args)
    Restore user defined comments from the database.
    
    restore_user_cmts(func_ea) -> user_cmts_t
        @param func_ea: the entry address of the function (C++: ea_t)
        @return: collection of user defined comments. The returned object must
                 be deleted by the caller using delete_user_cmts()

Help on function restore_user_defined_calls in module ida_hexrays:

restore_user_defined_calls(*args)
    Restore user defined function calls from the database.
    
    restore_user_defined_calls(udcalls, func_ea) -> bool
        @param udcalls: ptr to output buffer (C++: udcall_map_t *)
        @param func_ea: entry address of the function (C++: ea_t)
        @return: success

Help on function restore_user_iflags in module ida_hexrays:

restore_user_iflags(*args)
    Restore user defined citem iflags from the database.
    
    restore_user_iflags(func_ea) -> user_iflags_t
        @param func_ea: the entry address of the function (C++: ea_t)
        @return: collection of user defined iflags. The returned object must
                 be deleted by the caller using delete_user_iflags()

Help on function restore_user_labels in module ida_hexrays:

restore_user_labels(*args)
    Restore user defined labels from the database.
    
    restore_user_labels(func_ea) -> user_labels_t
        @param func_ea: the entry address of the function, ignored if FUNC !=
                        NULL (C++: ea_t)
        @return: collection of user defined labels. The returned object must
                 be deleted by the caller using delete_user_labels()

Help on function restore_user_labels2 in module ida_hexrays:

restore_user_labels2(*args)
    restore_user_labels2(func_ea, func=None) -> user_labels_t
        @param func_ea (C++: ea_t)
        @param func (C++: const  cfunc_t  *)

Help on function restore_user_lvar_settings in module ida_hexrays:

restore_user_lvar_settings(*args)
    Restore user defined local variable settings in the database.
    
    restore_user_lvar_settings(lvinf, func_ea) -> bool
        @param lvinf: ptr to output buffer (C++: lvar_uservec_t  *)
        @param func_ea: entry address of the function (C++: ea_t)
        @return: success

Help on function restore_user_numforms in module ida_hexrays:

restore_user_numforms(*args)
    Restore user defined number formats from the database.
    
    restore_user_numforms(func_ea) -> user_numforms_t
        @param func_ea: the entry address of the function (C++: ea_t)
        @return: collection of user defined number formats. The returned
                 object must be deleted by the caller using
                 delete_user_numforms()

Help on function restore_user_unions in module ida_hexrays:

restore_user_unions(*args)
    Restore user defined union field selections from the database.
    
    restore_user_unions(func_ea) -> user_unions_t
        @param func_ea: the entry address of the function (C++: ea_t)
        @return: collection of union field selections The returned object must
                 be deleted by the caller using delete_user_unions()

Help on class rlist_t in module ida_hexrays:

class rlist_t(bitset_t)
 |  Proxy of C++ rlist_t class.
 |  
 |  Method resolution order:
 |      rlist_t
 |      bitset_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rlist_t
 |          m: rlist_t const &
 |      
 |      
 |      __init__(self, reg, width) -> rlist_t
 |          reg: mreg_t
 |          width: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_rlist_t>
 |      delete_rlist_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from bitset_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __iter__(self)
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __len__ = count(self, *args)
 |      count(self) -> int
 |          bit: int
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: bitset_t const &
 |  
 |  add(self, *args)
 |      add(self, bit) -> bool
 |          @param bit (C++: int)
 |      
 |      
 |      add(self, bit, width) -> bool
 |          @param bit (C++: int)
 |          width: int
 |      
 |      
 |      add(self, ml) -> bool
 |          ml: bitset_t const &
 |  
 |  back(self, *args)
 |      back(self) -> int
 |  
 |  begin(self, *args)
 |      begin(self) -> iterator
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: bitset_t const &
 |  
 |  copy(self, *args)
 |      copy(self, m) -> bitset_t
 |          @param m (C++: const  bitset_t  &)
 |  
 |  count(self, *args)
 |      count(self) -> int
 |          bit: int
 |  
 |  cut_at(self, *args)
 |      cut_at(self, maxbit) -> bool
 |          @param maxbit (C++: int)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> iterator
 |  
 |  fill_with_ones(self, *args)
 |      fill_with_ones(self, maxbit)
 |          @param maxbit (C++: int)
 |  
 |  front(self, *args)
 |      front(self) -> int
 |  
 |  has(self, *args)
 |      has(self, bit) -> bool
 |          @param bit (C++: int)
 |  
 |  has_all(self, *args)
 |      has_all(self, bit, width) -> bool
 |          @param bit (C++: int)
 |          @param width (C++: int)
 |  
 |  has_any(self, *args)
 |      has_any(self, bit, width) -> bool
 |          @param bit (C++: int)
 |          @param width (C++: int)
 |  
 |  has_common(self, *args)
 |      has_common(self, ml) -> bool
 |          @param ml (C++: const  bitset_t  &)
 |  
 |  inc(self, *args)
 |      inc(self, p, n=1)
 |          @param p (C++: iterator  &)
 |          @param n (C++: int)
 |  
 |  includes(self, *args)
 |      includes(self, ml) -> bool
 |          @param ml (C++: const  bitset_t  &)
 |  
 |  intersect(self, *args)
 |      intersect(self, ml) -> bool
 |          @param ml (C++: const  bitset_t  &)
 |  
 |  is_subset_of(self, *args)
 |      is_subset_of(self, ml) -> bool
 |          @param ml (C++: const  bitset_t  &)
 |  
 |  itat(self, *args)
 |      itat(self, n) -> iterator
 |          @param n (C++: int)
 |  
 |  itv(self, *args)
 |      itv(self, it) -> int
 |          it: bitset_t::const_iterator
 |  
 |  last(self, *args)
 |      last(self) -> int
 |  
 |  shift_down(self, *args)
 |      shift_down(self, shift)
 |          @param shift (C++: int)
 |  
 |  sub(self, *args)
 |      sub(self, bit) -> bool
 |          @param bit (C++: int)
 |      
 |      
 |      sub(self, bit, width) -> bool
 |          @param bit (C++: int)
 |          width: int
 |      
 |      
 |      sub(self, ml) -> bool
 |          ml: bitset_t const &
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: bitset_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from bitset_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function save_user_cmts in module ida_hexrays:

save_user_cmts(*args)
    Save user defined comments into the database.
    
    save_user_cmts(func_ea, user_cmts)
        @param func_ea: the entry address of the function (C++: ea_t)
        @param user_cmts: collection of user defined comments (C++: const
                          user_cmts_t *)

Help on function save_user_defined_calls in module ida_hexrays:

save_user_defined_calls(*args)
    Save user defined local function calls into the database.
    
    save_user_defined_calls(func_ea, udcalls)
        @param func_ea: entry address of the function (C++: ea_t)
        @param udcalls: user-specified info about user defined function calls
                        (C++: const udcall_map_t &)

Help on function save_user_iflags in module ida_hexrays:

save_user_iflags(*args)
    Save user defined citem iflags into the database.
    
    save_user_iflags(func_ea, iflags)
        @param func_ea: the entry address of the function (C++: ea_t)
        @param iflags: collection of user defined citem iflags (C++: const
                       user_iflags_t *)

Help on function save_user_labels in module ida_hexrays:

save_user_labels(*args)
    Save user defined labels into the database.
    
    save_user_labels(func_ea, user_labels)
        @param func_ea: the entry address of the function, ignored if FUNC !=
                        NULL (C++: ea_t)
        @param user_labels: collection of user defined labels (C++: const
                            user_labels_t *)

Help on function save_user_labels2 in module ida_hexrays:

save_user_labels2(*args)
    save_user_labels2(func_ea, user_labels, func=None)
        @param func_ea (C++: ea_t)
        @param user_labels (C++: const user_labels_t *)
        @param func (C++: const  cfunc_t  *)

Help on function save_user_lvar_settings in module ida_hexrays:

save_user_lvar_settings(*args)
    Save user defined local variable settings into the database.
    
    save_user_lvar_settings(func_ea, lvinf)
        @param func_ea: entry address of the function (C++: ea_t)
        @param lvinf: user-specified info about local variables (C++: const
                      lvar_uservec_t  &)

Help on function save_user_numforms in module ida_hexrays:

save_user_numforms(*args)
    Save user defined number formats into the database.
    
    save_user_numforms(func_ea, numforms)
        @param func_ea: the entry address of the function (C++: ea_t)
        @param numforms: collection of user defined comments (C++: const
                         user_numforms_t *)

Help on function save_user_unions in module ida_hexrays:

save_user_unions(*args)
    Save user defined union field selections into the database.
    
    save_user_unions(func_ea, unions)
        @param func_ea: the entry address of the function (C++: ea_t)
        @param unions: collection of union field selections (C++: const
                       user_unions_t *)

Help on class scif_t in module ida_hexrays:

class scif_t(vdloc_t)
 |  Proxy of C++ scif_t class.
 |  
 |  Method resolution order:
 |      scif_t
 |      vdloc_t
 |      ida_typeinf.argloc_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba, n, tif) -> scif_t
 |          _mba: mba_t *
 |          n: qstring *
 |          tif: tinfo_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  mba
 |      scif_t_mba_get(self) -> mba_t
 |  
 |  name
 |      scif_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      scif_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_scif_t>
 |      delete_scif_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vdloc_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  _set_reg1(self, *args)
 |      _set_reg1(self, r1)
 |          @param r1 (C++: int)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: vdloc_t const &
 |  
 |  is_aliasable(self, *args)
 |      is_aliasable(self, mb, size) -> bool
 |          @param mb (C++: const  mba_t  *)
 |          @param size (C++: int)
 |  
 |  reg1(self, *args)
 |      reg1(self) -> int
 |  
 |  set_reg1(self, *args)
 |      set_reg1(self, r1)
 |          @param r1 (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_typeinf.argloc_t:
 |  
 |  _consume_rrel(self, *args)
 |      Use 'consume_rrel()'
 |      
 |      _consume_rrel(self, p) -> bool
 |          @param p (C++: rrel_t  *)
 |  
 |  _consume_scattered(self, *args)
 |      Use 'consume_scattered()'
 |      
 |      _consume_scattered(self, p) -> bool
 |          @param p (C++: scattered_aloc_t  *)
 |  
 |  _set_badloc(self, *args)
 |      Use 'set_badloc()'
 |  
 |  _set_biggest(self, *args)
 |      Set biggest element in internal union (careful - this function does
 |      not clean up!)
 |      
 |      _set_biggest(self, ct, data)
 |          @param ct (C++: argloc_type_t)
 |          @param data (C++: biggest_t)
 |  
 |  _set_custom(self, *args)
 |      Set custom argument location (careful - this function does not clean
 |      up!)
 |      
 |      _set_custom(self, ct, pdata)
 |          @param ct (C++: argloc_type_t)
 |          @param pdata (C++: void *)
 |  
 |  _set_ea(self, *args)
 |      Use set_ea
 |      
 |      _set_ea(self, _ea)
 |          @param _ea (C++: ea_t)
 |  
 |  _set_reg2(self, *args)
 |      Use 'set_reg2()'
 |      
 |      _set_reg2(self, _reg1, _reg2)
 |          @param _reg1 (C++: int)
 |          @param _reg2 (C++: int)
 |  
 |  _set_stkoff(self, *args)
 |      Use 'set_stkoff()'
 |      
 |      _set_stkoff(self, off)
 |          @param off (C++: sval_t)
 |  
 |  advance(self, *args)
 |      Move the location to point 'delta' bytes further.
 |      
 |      advance(self, delta) -> bool
 |          @param delta (C++: int)
 |  
 |  atype(self, *args)
 |      Get type ( 'Argument location types' )
 |  
 |  calc_offset(self, *args)
 |      Calculate offset that can be used to compare 2 similar arglocs.
 |  
 |  consume_rrel(self, *args)
 |      Set register-relative location - can't be NULL.
 |      
 |      consume_rrel(self, p)
 |          @param p (C++: rrel_t  *)
 |  
 |  consume_scattered(self, *args)
 |      Set distributed argument location.
 |      
 |      consume_scattered(self, p)
 |          @param p (C++: scattered_aloc_t  *)
 |  
 |  get_biggest(self, *args)
 |      Get largest element in internal union.
 |  
 |  get_custom(self, *args)
 |      Get custom argloc info. Use if 'atype()' == 'ALOC_CUSTOM'
 |  
 |  get_ea(self, *args)
 |      Get the global address. Use when 'atype()' == 'ALOC_STATIC'
 |  
 |  get_reginfo(self, *args)
 |      Get all register info. Use when 'atype()' == 'ALOC_REG1' or
 |      'ALOC_REG2'
 |  
 |  get_rrel(self, *args)
 |      Get register-relative info. Use when 'atype()' == 'ALOC_RREL'
 |  
 |  has_reg(self, *args)
 |      TRUE if argloc has a register part.
 |  
 |  has_stkoff(self, *args)
 |      TRUE if argloc has a stack part.
 |  
 |  is_badloc(self, *args)
 |      See 'ALOC_NONE' .
 |  
 |  is_custom(self, *args)
 |      See 'ALOC_CUSTOM' .
 |  
 |  is_ea(self, *args)
 |      See 'ALOC_STATIC' .
 |  
 |  is_fragmented(self, *args)
 |      'is_scattered()' || 'is_reg2()'
 |  
 |  is_mixed_scattered(self, *args)
 |      mixed scattered: consists of register and stack parts
 |  
 |  is_reg(self, *args)
 |      'is_reg1()' || 'is_reg2()'
 |  
 |  is_reg1(self, *args)
 |      See 'ALOC_REG1' .
 |  
 |  is_reg2(self, *args)
 |      See 'ALOC_REG2' .
 |  
 |  is_rrel(self, *args)
 |      See 'ALOC_RREL' .
 |  
 |  is_scattered(self, *args)
 |      See 'ALOC_DIST' .
 |  
 |  is_stkoff(self, *args)
 |      See 'ALOC_STACK' .
 |  
 |  justify_reg_high(self, *args)
 |      Set register offset to justify it to the upper part of _SLOTSIZE.
 |      
 |      justify_reg_high(self, size, _slotsize)
 |          @param size (C++: size_t)
 |          @param _slotsize (C++: size_t)
 |  
 |  justify_stkoff_right(self, *args)
 |      Set stack offset to right-justify it in _SLOTSIZE.
 |      
 |      justify_stkoff_right(self, size, _slotsize)
 |          @param size (C++: size_t)
 |          @param _slotsize (C++: size_t)
 |  
 |  reg2(self, *args)
 |      Get info for the second register. Use when 'atype()' == 'ALOC_REG2'
 |  
 |  regoff(self, *args)
 |      Get offset from the beginning of the register in bytes. Use when
 |      'atype()' == 'ALOC_REG1'
 |  
 |  scattered(self, *args)
 |      Get scattered argument info. Use when 'atype()' == 'ALOC_DIST'
 |  
 |  set_badloc(self, *args)
 |      Set to invalid location.
 |  
 |  set_ea(self, *args)
 |      Set static ea location.
 |      
 |      set_ea(self, _ea)
 |          @param _ea (C++: ea_t)
 |  
 |  set_reg2(self, *args)
 |      Set secondary register location.
 |      
 |      set_reg2(self, _reg1, _reg2)
 |          @param _reg1 (C++: int)
 |          @param _reg2 (C++: int)
 |  
 |  set_stkoff(self, *args)
 |      Set stack offset location.
 |      
 |      set_stkoff(self, off)
 |          @param off (C++: sval_t)
 |  
 |  stkoff(self, *args)
 |      Get the stack offset. Use if 'atype()' == 'ALOC_STACK'
 |  
 |  swap(self, *args)
 |      Assign this == r and r == this.
 |      
 |      swap(self, r)
 |          @param r (C++: argloc_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_typeinf.argloc_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class scif_visitor_t in module ida_hexrays:

class scif_visitor_t(__builtin__.object)
 |  Proxy of C++ scif_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> scif_visitor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_scif_mop(self, *args)
 |      visit_scif_mop(self, r, off) -> int
 |          @param r (C++: const  mop_t  &)
 |          @param off (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_scif_visitor_t>
 |      delete_scif_visitor_t(self)

Help on function select_udt_by_offset in module ida_hexrays:

select_udt_by_offset(*args)
    Select UDT
    
    select_udt_by_offset(udts, ops, applicator) -> int
        @param udts: list of UDT  tinfo_t  for the selection, if NULL or empty
                     then UDTs from the "Local types" will be used (C++: const
                     qvector <  tinfo_t  > *)
        @param ops: operands (C++: const  ui_stroff_ops_t  &)
        @param applicator (C++: ui_stroff_applicator_t  &)

Help on function send_database in module ida_hexrays:

send_database(*args)
    Send the database to Hex-Rays. This function sends the current
    database to the Hex-Rays server. The database is sent in the
    compressed form over an encrypted (SSL) connection.
    
    send_database(err, silent)
        @param err: failure description object. Empty  hexrays_failure_t
                    object can be used if error information is not available.
                    (C++: const  hexrays_failure_t  &)
        @param silent: if false, a dialog box will be displayed before sending
                       the database. (C++: bool)

Help on function set2jcnd in module ida_hexrays:

set2jcnd(*args)
    set2jcnd(code) -> mcode_t
        @param code (C++: mcode_t)

Help on function set_type in module ida_hexrays:

set_type(*args)
    Set a global type.
    
    set_type(id, tif, source, force=False) -> bool
        @param id: address or id of the object (C++: uval_t)
        @param tif: new type info (C++: const  tinfo_t  &)
        @param source: where the type comes from (C++: type_source_t)
        @param force: true means to set the type as is, false means to merge
                      the new type with the possibly existing old type info.
                      (C++: bool)
        @return: success

Help on class simple_graph_t in module ida_hexrays:

class simple_graph_t(__builtin__.object)
 |  Proxy of C++ simple_graph_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  colored_gdl_edges
 |      simple_graph_t_colored_gdl_edges_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  title
 |      simple_graph_t_title_get(self) -> qstring *

Help on class stkvar_ref_t in module ida_hexrays:

class stkvar_ref_t(__builtin__.object)
 |  Proxy of C++ stkvar_ref_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: stkvar_ref_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: stkvar_ref_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: stkvar_ref_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, m, o) -> stkvar_ref_t
 |          m: mba_t *
 |          o: sval_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: stkvar_ref_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: stkvar_ref_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: stkvar_ref_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: stkvar_ref_t const &
 |  
 |  get_stkvar(self, *args)
 |      Retrieve the referenced stack variable.
 |      
 |      get_stkvar(self, p_off=None) -> member_t *
 |          @param p_off: if specified, will hold IDA stkoff after the call. (C++:
 |                        uval_t  *)
 |          @return: pointer to the stack variable
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: stkvar_ref_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  mba
 |      stkvar_ref_t_mba_get(self) -> mba_t
 |  
 |  off
 |      stkvar_ref_t_off_get(self) -> sval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_stkvar_ref_t>
 |      delete_stkvar_ref_t(self)

Help on function swap_mcode_relation in module ida_hexrays:

swap_mcode_relation(*args)
    swap_mcode_relation(code) -> mcode_t
        @param code (C++: mcode_t)

Help on function swapped_relation in module ida_hexrays:

swapped_relation(*args)
    Swap a comparison operator. For example, cot_sge becomes cot_sle.
    
    swapped_relation(op) -> ctype_t
        @param op (C++: ctype_t)

Help on function term_hexrays_plugin in module ida_hexrays:

term_hexrays_plugin(*args)
    Stop working with hex-rays decompiler.

Help on class treeloc_t in module ida_hexrays:

class treeloc_t(__builtin__.object)
 |  Proxy of C++ treeloc_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: treeloc_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> treeloc_t
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: treeloc_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      treeloc_t_ea_get(self) -> ea_t
 |  
 |  itp
 |      treeloc_t_itp_get(self) -> item_preciser_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_treeloc_t>
 |      delete_treeloc_t(self)

Help on class udc_filter_t in module ida_hexrays:

class udc_filter_t(microcode_filter_t)
 |  Proxy of C++ udc_filter_t class.
 |  
 |  Method resolution order:
 |      udc_filter_t
 |      microcode_filter_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udc_filter_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  apply(self, *args)
 |      generate microcode for an instruction
 |      
 |      apply(self, cdg) -> merror_t
 |          @param cdg (C++: codegen_t  &)
 |          @return: MERR_... code: MERR_OK - user-defined call generated, go to
 |                   the next instruction MERR_INSN - not generated - the caller
 |                   should try the standard way else - error
 |  
 |  init(self, *args)
 |      init(self, decl) -> bool
 |          @param decl (C++: const char *)
 |  
 |  install(self, *args)
 |      install(self)
 |  
 |  match(self, *args)
 |      return true if the filter object should be appied to given instruction
 |      
 |      match(self, cdg) -> bool
 |          @param cdg (C++: codegen_t  &)
 |  
 |  remove(self, *args)
 |      remove(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_udc_filter_t>
 |      delete_udc_filter_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from microcode_filter_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function udcall_map_begin in module ida_hexrays:

udcall_map_begin(*args)
    Get iterator pointing to the beginning of udcall_map_t.
    
    udcall_map_begin(map) -> udcall_map_iterator_t
        @param map (C++: const udcall_map_t *)

Help on function udcall_map_clear in module ida_hexrays:

udcall_map_clear(*args)
    Clear udcall_map_t.
    
    udcall_map_clear(map)
        @param map (C++: udcall_map_t *)

Help on function udcall_map_end in module ida_hexrays:

udcall_map_end(*args)
    Get iterator pointing to the end of udcall_map_t.
    
    udcall_map_end(map) -> udcall_map_iterator_t
        @param map (C++: const udcall_map_t *)

Help on function udcall_map_erase in module ida_hexrays:

udcall_map_erase(*args)
    Erase current element from udcall_map_t.
    
    udcall_map_erase(map, p)
        @param map (C++: udcall_map_t *)
        @param p (C++: udcall_map_iterator_t)

Help on function udcall_map_find in module ida_hexrays:

udcall_map_find(*args)
    Find the specified key in udcall_map_t.
    
    udcall_map_find(map, key) -> udcall_map_iterator_t
        @param map (C++: const udcall_map_t *)
        @param key (C++: const ea_t &)

Help on function udcall_map_first in module ida_hexrays:

udcall_map_first(*args)
    Get reference to the current map key.
    
    udcall_map_first(p) -> ea_t const &
        @param p (C++: udcall_map_iterator_t)

Help on function udcall_map_free in module ida_hexrays:

udcall_map_free(*args)
    Delete udcall_map_t instance.
    
    udcall_map_free(map)
        @param map (C++: udcall_map_t *)

Help on function udcall_map_insert in module ida_hexrays:

udcall_map_insert(*args)
    Insert new (ea_t, 'udcall_t' ) pair into udcall_map_t.
    
    udcall_map_insert(map, key, val) -> udcall_map_iterator_t
        @param map (C++: udcall_map_t *)
        @param key (C++: const ea_t &)
        @param val (C++: const  udcall_t  &)

Help on class udcall_map_iterator_t in module ida_hexrays:

class udcall_map_iterator_t(__builtin__.object)
 |  Proxy of C++ udcall_map_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, p) -> bool
 |          p: udcall_map_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udcall_map_iterator_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, p) -> bool
 |          p: udcall_map_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      udcall_map_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_udcall_map_iterator_t>
 |      delete_udcall_map_iterator_t(self)

Help on function udcall_map_new in module ida_hexrays:

udcall_map_new(*args)
    Create a new udcall_map_t instance.

Help on function udcall_map_next in module ida_hexrays:

udcall_map_next(*args)
    Move to the next element.
    
    udcall_map_next(p) -> udcall_map_iterator_t
        @param p (C++: udcall_map_iterator_t)

Help on function udcall_map_prev in module ida_hexrays:

udcall_map_prev(*args)
    Move to the previous element.
    
    udcall_map_prev(p) -> udcall_map_iterator_t
        @param p (C++: udcall_map_iterator_t)

Help on function udcall_map_second in module ida_hexrays:

udcall_map_second(*args)
    Get reference to the current map value.
    
    udcall_map_second(p) -> udcall_t
        @param p (C++: udcall_map_iterator_t)

Help on function udcall_map_size in module ida_hexrays:

udcall_map_size(*args)
    Get size of udcall_map_t.
    
    udcall_map_size(map) -> size_t
        @param map (C++: udcall_map_t *)

Help on class udcall_t in module ida_hexrays:

class udcall_t(__builtin__.object)
 |  Proxy of C++ udcall_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: udcall_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: udcall_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: udcall_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udcall_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: udcall_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: udcall_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: udcall_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: udcall_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      udcall_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  tif
 |      udcall_t_tif_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_udcall_t>
 |      delete_udcall_t(self)

Help on class ui_stroff_applicator_t in module ida_hexrays:

class ui_stroff_applicator_t(__builtin__.object)
 |  Proxy of C++ ui_stroff_applicator_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_stroff_applicator_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  apply(self, *args)
 |      apply(self, opnum, path, top_tif, spath) -> bool
 |          @param opnum: operand ordinal number, see below (C++: size_t)
 |          @param path: path describing the union selection, maybe empty (C++:
 |                       const  intvec_t  &)
 |          @param top_tif: tinfo_t  of the selected toplevel UDT (C++: const
 |                          tinfo_t  &)
 |          @param spath: selected path (C++: const char *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ui_stroff_applicator_t>
 |      delete_ui_stroff_applicator_t(self)

Help on class ui_stroff_op_t in module ida_hexrays:

class ui_stroff_op_t(__builtin__.object)
 |  Proxy of C++ ui_stroff_op_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: ui_stroff_op_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_stroff_op_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: ui_stroff_op_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  offset
 |      ui_stroff_op_t_offset_get(self) -> uval_t
 |  
 |  text
 |      ui_stroff_op_t_text_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ui_stroff_op_t>
 |      delete_ui_stroff_op_t(self)

Help on class ui_stroff_ops_t in module ida_hexrays:

class ui_stroff_ops_t(__builtin__.object)
 |  Proxy of C++ qvector< ui_stroff_op_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< ui_stroff_op_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> ui_stroff_op_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_stroff_ops_t
 |          x: qvector< ui_stroff_op_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< ui_stroff_op_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: ui_stroff_op_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: ui_stroff_op_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: ui_stroff_op_t const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> ui_stroff_op_t
 |      begin(self) -> ui_stroff_op_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> ui_stroff_op_t
 |      end(self) -> ui_stroff_op_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> ui_stroff_op_t
 |          it: qvector< ui_stroff_op_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> ui_stroff_op_t
 |          first: qvector< ui_stroff_op_t >::iterator
 |          last: qvector< ui_stroff_op_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> ui_stroff_op_t
 |  
 |  find(self, *args)
 |      find(self, x) -> ui_stroff_op_t
 |          x: ui_stroff_op_t const &
 |      
 |      
 |      find(self, x) -> ui_stroff_op_t
 |          x: ui_stroff_op_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=ui_stroff_op_t())
 |          x: ui_stroff_op_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: ui_stroff_op_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: ui_stroff_op_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> ui_stroff_op_t
 |          it: qvector< ui_stroff_op_t >::iterator
 |          x: ui_stroff_op_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: ui_stroff_op_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: ui_stroff_op_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< ui_stroff_op_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ui_stroff_ops_t>
 |      delete_ui_stroff_ops_t(self)

Help on function user_cmts_begin in module ida_hexrays:

user_cmts_begin(*args)
    Get iterator pointing to the beginning of user_cmts_t.
    
    user_cmts_begin(map) -> user_cmts_iterator_t
        @param map (C++: const user_cmts_t *)

Help on function user_cmts_clear in module ida_hexrays:

user_cmts_clear(*args)
    Clear user_cmts_t.
    
    user_cmts_clear(map)
        @param map (C++: user_cmts_t *)

Help on function user_cmts_end in module ida_hexrays:

user_cmts_end(*args)
    Get iterator pointing to the end of user_cmts_t.
    
    user_cmts_end(map) -> user_cmts_iterator_t
        @param map (C++: const user_cmts_t *)

Help on function user_cmts_erase in module ida_hexrays:

user_cmts_erase(*args)
    Erase current element from user_cmts_t.
    
    user_cmts_erase(map, p)
        @param map (C++: user_cmts_t *)
        @param p (C++: user_cmts_iterator_t)

Help on function user_cmts_find in module ida_hexrays:

user_cmts_find(*args)
    Find the specified key in user_cmts_t.
    
    user_cmts_find(map, key) -> user_cmts_iterator_t
        @param map (C++: const user_cmts_t *)
        @param key (C++: const  treeloc_t  &)

Help on function user_cmts_first in module ida_hexrays:

user_cmts_first(*args)
    Get reference to the current map key.
    
    user_cmts_first(p) -> treeloc_t
        @param p (C++: user_cmts_iterator_t)

Help on function user_cmts_free in module ida_hexrays:

user_cmts_free(*args)
    Delete user_cmts_t instance.
    
    user_cmts_free(map)
        @param map (C++: user_cmts_t *)

Help on function user_cmts_insert in module ida_hexrays:

user_cmts_insert(*args)
    Insert new ( 'treeloc_t' , 'citem_cmt_t' ) pair into user_cmts_t.
    
    user_cmts_insert(map, key, val) -> user_cmts_iterator_t
        @param map (C++: user_cmts_t *)
        @param key (C++: const  treeloc_t  &)
        @param val (C++: const  citem_cmt_t  &)

Help on class user_cmts_iterator_t in module ida_hexrays:

class user_cmts_iterator_t(__builtin__.object)
 |  Proxy of C++ user_cmts_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, p) -> bool
 |          p: user_cmts_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_cmts_iterator_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, p) -> bool
 |          p: user_cmts_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      user_cmts_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_user_cmts_iterator_t>
 |      delete_user_cmts_iterator_t(self)

Help on function user_cmts_new in module ida_hexrays:

user_cmts_new(*args)
    Create a new user_cmts_t instance.

Help on function user_cmts_next in module ida_hexrays:

user_cmts_next(*args)
    Move to the next element.
    
    user_cmts_next(p) -> user_cmts_iterator_t
        @param p (C++: user_cmts_iterator_t)

Help on function user_cmts_prev in module ida_hexrays:

user_cmts_prev(*args)
    Move to the previous element.
    
    user_cmts_prev(p) -> user_cmts_iterator_t
        @param p (C++: user_cmts_iterator_t)

Help on function user_cmts_second in module ida_hexrays:

user_cmts_second(*args)
    Get reference to the current map value.
    
    user_cmts_second(p) -> citem_cmt_t
        @param p (C++: user_cmts_iterator_t)

Help on function user_cmts_size in module ida_hexrays:

user_cmts_size(*args)
    Get size of user_cmts_t.
    
    user_cmts_size(map) -> size_t
        @param map (C++: user_cmts_t *)

Help on class user_cmts_t in module ida_hexrays:

class user_cmts_t(__builtin__.object)
 |  Proxy of C++ std::map< treeloc_t,citem_cmt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_cmts_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  at(self, *args)
 |      at(self, _Keyval) -> citem_cmt_t
 |          _Keyval: treeloc_t const &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __begin = <built-in function user_cmts_begin>
 |      user_cmts_begin(map) -> user_cmts_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t const *
 |  
 |  __clear = <built-in function user_cmts_clear>
 |      user_cmts_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t *
 |  
 |  __end = <built-in function user_cmts_end>
 |      user_cmts_end(map) -> user_cmts_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t const *
 |  
 |  __erase = <built-in function user_cmts_erase>
 |      user_cmts_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t *
 |      p: user_cmts_iterator_t
 |  
 |  __find = <built-in function user_cmts_find>
 |      user_cmts_find(map, key) -> user_cmts_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t const *
 |      key: treeloc_t const &
 |  
 |  __first = <built-in function user_cmts_first>
 |      user_cmts_first(p) -> treeloc_t
 |      
 |      Parameters
 |      ----------
 |      p: user_cmts_iterator_t
 |  
 |  __insert = <built-in function user_cmts_insert>
 |      user_cmts_insert(map, key, val) -> user_cmts_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t *
 |      key: treeloc_t const &
 |      val: citem_cmt_t const &
 |  
 |  __next = <built-in function user_cmts_next>
 |      user_cmts_next(p) -> user_cmts_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_cmts_iterator_t
 |  
 |  __second = <built-in function user_cmts_second>
 |      user_cmts_second(p) -> citem_cmt_t
 |      
 |      Parameters
 |      ----------
 |      p: user_cmts_iterator_t
 |  
 |  __size = <built-in function user_cmts_size>
 |      user_cmts_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t *
 |  
 |  __swig_destroy__ = <built-in function delete_user_cmts_t>
 |      delete_user_cmts_t(self)
 |  
 |  keytype = <class 'ida_hexrays.treeloc_t'>
 |      Proxy of C++ treeloc_t class.
 |  
 |  valuetype = <class 'ida_hexrays.citem_cmt_t'>
 |      Proxy of C++ citem_cmt_t class.

Help on function user_iflags_begin in module ida_hexrays:

user_iflags_begin(*args)
    Get iterator pointing to the beginning of user_iflags_t.
    
    user_iflags_begin(map) -> user_iflags_iterator_t
        @param map (C++: const user_iflags_t *)

Help on function user_iflags_clear in module ida_hexrays:

user_iflags_clear(*args)
    Clear user_iflags_t.
    
    user_iflags_clear(map)
        @param map (C++: user_iflags_t *)

Help on function user_iflags_end in module ida_hexrays:

user_iflags_end(*args)
    Get iterator pointing to the end of user_iflags_t.
    
    user_iflags_end(map) -> user_iflags_iterator_t
        @param map (C++: const user_iflags_t *)

Help on function user_iflags_erase in module ida_hexrays:

user_iflags_erase(*args)
    Erase current element from user_iflags_t.
    
    user_iflags_erase(map, p)
        @param map (C++: user_iflags_t *)
        @param p (C++: user_iflags_iterator_t)

Help on function user_iflags_find in module ida_hexrays:

user_iflags_find(*args)
    Find the specified key in user_iflags_t.
    
    user_iflags_find(map, key) -> user_iflags_iterator_t
        @param map (C++: const user_iflags_t *)
        @param key (C++: const  citem_locator_t  &)

Help on function user_iflags_first in module ida_hexrays:

user_iflags_first(*args)
    Get reference to the current map key.
    
    user_iflags_first(p) -> citem_locator_t
        @param p (C++: user_iflags_iterator_t)

Help on function user_iflags_free in module ida_hexrays:

user_iflags_free(*args)
    Delete user_iflags_t instance.
    
    user_iflags_free(map)
        @param map (C++: user_iflags_t *)

Help on function user_iflags_insert in module ida_hexrays:

user_iflags_insert(*args)
    Insert new ( 'citem_locator_t' , int32) pair into user_iflags_t.
    
    user_iflags_insert(map, key, val) -> user_iflags_iterator_t
        @param map (C++: user_iflags_t *)
        @param key (C++: const  citem_locator_t  &)
        @param val (C++: const  int32  &)

Help on class user_iflags_iterator_t in module ida_hexrays:

class user_iflags_iterator_t(__builtin__.object)
 |  Proxy of C++ user_iflags_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, p) -> bool
 |          p: user_iflags_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_iflags_iterator_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, p) -> bool
 |          p: user_iflags_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      user_iflags_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_user_iflags_iterator_t>
 |      delete_user_iflags_iterator_t(self)

Help on function user_iflags_new in module ida_hexrays:

user_iflags_new(*args)
    Create a new user_iflags_t instance.

Help on function user_iflags_next in module ida_hexrays:

user_iflags_next(*args)
    Move to the next element.
    
    user_iflags_next(p) -> user_iflags_iterator_t
        @param p (C++: user_iflags_iterator_t)

Help on function user_iflags_prev in module ida_hexrays:

user_iflags_prev(*args)
    Move to the previous element.
    
    user_iflags_prev(p) -> user_iflags_iterator_t
        @param p (C++: user_iflags_iterator_t)

Help on function user_iflags_second in module ida_hexrays:

user_iflags_second(*args)
    Get reference to the current map value.
    
    user_iflags_second(p) -> int32 const &
        @param p (C++: user_iflags_iterator_t)

Help on function user_iflags_size in module ida_hexrays:

user_iflags_size(*args)
    Get size of user_iflags_t.
    
    user_iflags_size(map) -> size_t
        @param map (C++: user_iflags_t *)

Help on class user_iflags_t in module ida_hexrays:

class user_iflags_t(__builtin__.object)
 |  Proxy of C++ std::map< citem_locator_t,int32 > class.
 |  
 |  Methods defined here:
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_iflags_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  at(self, *args)
 |      at(self, _Keyval) -> int &
 |          _Keyval: citem_locator_t const &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __begin = <built-in function user_iflags_begin>
 |      user_iflags_begin(map) -> user_iflags_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t const *
 |  
 |  __clear = <built-in function user_iflags_clear>
 |      user_iflags_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t *
 |  
 |  __end = <built-in function user_iflags_end>
 |      user_iflags_end(map) -> user_iflags_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t const *
 |  
 |  __erase = <built-in function user_iflags_erase>
 |      user_iflags_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t *
 |      p: user_iflags_iterator_t
 |  
 |  __find = <built-in function user_iflags_find>
 |      user_iflags_find(map, key) -> user_iflags_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t const *
 |      key: citem_locator_t const &
 |  
 |  __first = <built-in function user_iflags_first>
 |      user_iflags_first(p) -> citem_locator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_iflags_iterator_t
 |  
 |  __insert = <built-in function user_iflags_insert>
 |      user_iflags_insert(map, key, val) -> user_iflags_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t *
 |      key: citem_locator_t const &
 |      val: int32 const &
 |  
 |  __next = <built-in function user_iflags_next>
 |      user_iflags_next(p) -> user_iflags_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_iflags_iterator_t
 |  
 |  __second = <built-in function user_iflags_second>
 |      user_iflags_second(p) -> int32 const &
 |      
 |      Parameters
 |      ----------
 |      p: user_iflags_iterator_t
 |  
 |  __size = <built-in function user_iflags_size>
 |      user_iflags_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t *
 |  
 |  __swig_destroy__ = <built-in function delete_user_iflags_t>
 |      delete_user_iflags_t(self)
 |  
 |  keytype = <class 'ida_hexrays.citem_locator_t'>
 |      Proxy of C++ citem_locator_t class.
 |  
 |  valuetype = <type 'int'>
 |      int(x=0) -> int or long
 |      int(x, base=10) -> int or long
 |      
 |      Convert a number or string to an integer, or return 0 if no arguments
 |      are given.  If x is floating point, the conversion truncates towards zero.
 |      If x is outside the integer range, the function returns a long instead.
 |      
 |      If x is not a number or if base is given, then x must be a string or
 |      Unicode object representing an integer literal in the given base.  The
 |      literal can be preceded by '+' or '-' and be surrounded by whitespace.
 |      The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to
 |      interpret the base from the string as an integer literal.
 |      >>> int('0b100', base=0)
 |      4

Help on function user_labels_begin in module ida_hexrays:

user_labels_begin(*args)
    Get iterator pointing to the beginning of user_labels_t.
    
    user_labels_begin(map) -> user_labels_iterator_t
        @param map (C++: const user_labels_t *)

Help on function user_labels_clear in module ida_hexrays:

user_labels_clear(*args)
    Clear user_labels_t.
    
    user_labels_clear(map)
        @param map (C++: user_labels_t *)

Help on function user_labels_end in module ida_hexrays:

user_labels_end(*args)
    Get iterator pointing to the end of user_labels_t.
    
    user_labels_end(map) -> user_labels_iterator_t
        @param map (C++: const user_labels_t *)

Help on function user_labels_erase in module ida_hexrays:

user_labels_erase(*args)
    Erase current element from user_labels_t.
    
    user_labels_erase(map, p)
        @param map (C++: user_labels_t *)
        @param p (C++: user_labels_iterator_t)

Help on function user_labels_find in module ida_hexrays:

user_labels_find(*args)
    Find the specified key in user_labels_t.
    
    user_labels_find(map, key) -> user_labels_iterator_t
        @param map (C++: const user_labels_t *)
        @param key (C++: const int &)

Help on function user_labels_first in module ida_hexrays:

user_labels_first(*args)
    Get reference to the current map key.
    
    user_labels_first(p) -> int const &
        @param p (C++: user_labels_iterator_t)

Help on function user_labels_free in module ida_hexrays:

user_labels_free(*args)
    Delete user_labels_t instance.
    
    user_labels_free(map)
        @param map (C++: user_labels_t *)

Help on function user_labels_insert in module ida_hexrays:

user_labels_insert(*args)
    Insert new (int, qstring) pair into user_labels_t.
    
    user_labels_insert(map, key, val) -> user_labels_iterator_t
        @param map (C++: user_labels_t *)
        @param key (C++: const int &)
        @param val (C++: const  qstring  &)

Help on class user_labels_iterator_t in module ida_hexrays:

class user_labels_iterator_t(__builtin__.object)
 |  Proxy of C++ user_labels_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, p) -> bool
 |          p: user_labels_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_labels_iterator_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, p) -> bool
 |          p: user_labels_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      user_labels_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_user_labels_iterator_t>
 |      delete_user_labels_iterator_t(self)

Help on function user_labels_new in module ida_hexrays:

user_labels_new(*args)
    Create a new user_labels_t instance.

Help on function user_labels_next in module ida_hexrays:

user_labels_next(*args)
    Move to the next element.
    
    user_labels_next(p) -> user_labels_iterator_t
        @param p (C++: user_labels_iterator_t)

Help on function user_labels_prev in module ida_hexrays:

user_labels_prev(*args)
    Move to the previous element.
    
    user_labels_prev(p) -> user_labels_iterator_t
        @param p (C++: user_labels_iterator_t)

Help on function user_labels_second in module ida_hexrays:

user_labels_second(*args)
    Get reference to the current map value.
    
    user_labels_second(p) -> qstring &
        @param p (C++: user_labels_iterator_t)

Help on function user_labels_size in module ida_hexrays:

user_labels_size(*args)
    Get size of user_labels_t.
    
    user_labels_size(map) -> size_t
        @param map (C++: user_labels_t *)

Help on class user_labels_t in module ida_hexrays:

class user_labels_t(__builtin__.object)
 |  Proxy of C++ std::map< int,qstring > class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_labels_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  at(self, *args)
 |      at(self, _Keyval) -> _qstring< char > &
 |          _Keyval: int const &
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_user_labels_t>
 |      delete_user_labels_t(self)

Help on class user_lvar_modifier_t in module ida_hexrays:

class user_lvar_modifier_t(__builtin__.object)
 |  Proxy of C++ user_lvar_modifier_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_lvar_modifier_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  modify_lvars(self, *args)
 |      Modify lvar settings. Returns: true-modified
 |      
 |      modify_lvars(self, lvinf) -> bool
 |          @param lvinf (C++: lvar_uservec_t  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_user_lvar_modifier_t>
 |      delete_user_lvar_modifier_t(self)

Help on function user_numforms_begin in module ida_hexrays:

user_numforms_begin(*args)
    Get iterator pointing to the beginning of user_numforms_t.
    
    user_numforms_begin(map) -> user_numforms_iterator_t
        @param map (C++: const user_numforms_t *)

Help on function user_numforms_clear in module ida_hexrays:

user_numforms_clear(*args)
    Clear user_numforms_t.
    
    user_numforms_clear(map)
        @param map (C++: user_numforms_t *)

Help on function user_numforms_end in module ida_hexrays:

user_numforms_end(*args)
    Get iterator pointing to the end of user_numforms_t.
    
    user_numforms_end(map) -> user_numforms_iterator_t
        @param map (C++: const user_numforms_t *)

Help on function user_numforms_erase in module ida_hexrays:

user_numforms_erase(*args)
    Erase current element from user_numforms_t.
    
    user_numforms_erase(map, p)
        @param map (C++: user_numforms_t *)
        @param p (C++: user_numforms_iterator_t)

Help on function user_numforms_find in module ida_hexrays:

user_numforms_find(*args)
    Find the specified key in user_numforms_t.
    
    user_numforms_find(map, key) -> user_numforms_iterator_t
        @param map (C++: const user_numforms_t *)
        @param key (C++: const  operand_locator_t  &)

Help on function user_numforms_first in module ida_hexrays:

user_numforms_first(*args)
    Get reference to the current map key.
    
    user_numforms_first(p) -> operand_locator_t
        @param p (C++: user_numforms_iterator_t)

Help on function user_numforms_free in module ida_hexrays:

user_numforms_free(*args)
    Delete user_numforms_t instance.
    
    user_numforms_free(map)
        @param map (C++: user_numforms_t *)

Help on function user_numforms_insert in module ida_hexrays:

user_numforms_insert(*args)
    Insert new ( 'operand_locator_t' , 'number_format_t' ) pair into
    user_numforms_t.
    
    user_numforms_insert(map, key, val) -> user_numforms_iterator_t
        @param map (C++: user_numforms_t *)
        @param key (C++: const  operand_locator_t  &)
        @param val (C++: const  number_format_t  &)

Help on class user_numforms_iterator_t in module ida_hexrays:

class user_numforms_iterator_t(__builtin__.object)
 |  Proxy of C++ user_numforms_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, p) -> bool
 |          p: user_numforms_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_numforms_iterator_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, p) -> bool
 |          p: user_numforms_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      user_numforms_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_user_numforms_iterator_t>
 |      delete_user_numforms_iterator_t(self)

Help on function user_numforms_new in module ida_hexrays:

user_numforms_new(*args)
    Create a new user_numforms_t instance.

Help on function user_numforms_next in module ida_hexrays:

user_numforms_next(*args)
    Move to the next element.
    
    user_numforms_next(p) -> user_numforms_iterator_t
        @param p (C++: user_numforms_iterator_t)

Help on function user_numforms_prev in module ida_hexrays:

user_numforms_prev(*args)
    Move to the previous element.
    
    user_numforms_prev(p) -> user_numforms_iterator_t
        @param p (C++: user_numforms_iterator_t)

Help on function user_numforms_second in module ida_hexrays:

user_numforms_second(*args)
    Get reference to the current map value.
    
    user_numforms_second(p) -> number_format_t
        @param p (C++: user_numforms_iterator_t)

Help on function user_numforms_size in module ida_hexrays:

user_numforms_size(*args)
    Get size of user_numforms_t.
    
    user_numforms_size(map) -> size_t
        @param map (C++: user_numforms_t *)

Help on class user_numforms_t in module ida_hexrays:

class user_numforms_t(__builtin__.object)
 |  Proxy of C++ std::map< operand_locator_t,number_format_t > class.
 |  
 |  Methods defined here:
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_numforms_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  at(self, *args)
 |      at(self, _Keyval) -> number_format_t
 |          _Keyval: operand_locator_t const &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __begin = <built-in function user_numforms_begin>
 |      user_numforms_begin(map) -> user_numforms_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t const *
 |  
 |  __clear = <built-in function user_numforms_clear>
 |      user_numforms_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t *
 |  
 |  __end = <built-in function user_numforms_end>
 |      user_numforms_end(map) -> user_numforms_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t const *
 |  
 |  __erase = <built-in function user_numforms_erase>
 |      user_numforms_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t *
 |      p: user_numforms_iterator_t
 |  
 |  __find = <built-in function user_numforms_find>
 |      user_numforms_find(map, key) -> user_numforms_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t const *
 |      key: operand_locator_t const &
 |  
 |  __first = <built-in function user_numforms_first>
 |      user_numforms_first(p) -> operand_locator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_numforms_iterator_t
 |  
 |  __insert = <built-in function user_numforms_insert>
 |      user_numforms_insert(map, key, val) -> user_numforms_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t *
 |      key: operand_locator_t const &
 |      val: number_format_t const &
 |  
 |  __next = <built-in function user_numforms_next>
 |      user_numforms_next(p) -> user_numforms_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_numforms_iterator_t
 |  
 |  __second = <built-in function user_numforms_second>
 |      user_numforms_second(p) -> number_format_t
 |      
 |      Parameters
 |      ----------
 |      p: user_numforms_iterator_t
 |  
 |  __size = <built-in function user_numforms_size>
 |      user_numforms_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t *
 |  
 |  __swig_destroy__ = <built-in function delete_user_numforms_t>
 |      delete_user_numforms_t(self)
 |  
 |  keytype = <class 'ida_hexrays.operand_locator_t'>
 |      Proxy of C++ operand_locator_t class.
 |  
 |  valuetype = <class 'ida_hexrays.number_format_t'>
 |      Proxy of C++ number_format_t class.

Help on function user_unions_begin in module ida_hexrays:

user_unions_begin(*args)
    Get iterator pointing to the beginning of user_unions_t.
    
    user_unions_begin(map) -> user_unions_iterator_t
        @param map (C++: const user_unions_t *)

Help on function user_unions_clear in module ida_hexrays:

user_unions_clear(*args)
    Clear user_unions_t.
    
    user_unions_clear(map)
        @param map (C++: user_unions_t *)

Help on function user_unions_end in module ida_hexrays:

user_unions_end(*args)
    Get iterator pointing to the end of user_unions_t.
    
    user_unions_end(map) -> user_unions_iterator_t
        @param map (C++: const user_unions_t *)

Help on function user_unions_erase in module ida_hexrays:

user_unions_erase(*args)
    Erase current element from user_unions_t.
    
    user_unions_erase(map, p)
        @param map (C++: user_unions_t *)
        @param p (C++: user_unions_iterator_t)

Help on function user_unions_find in module ida_hexrays:

user_unions_find(*args)
    Find the specified key in user_unions_t.
    
    user_unions_find(map, key) -> user_unions_iterator_t
        @param map (C++: const user_unions_t *)
        @param key (C++: const ea_t &)

Help on function user_unions_first in module ida_hexrays:

user_unions_first(*args)
    Get reference to the current map key.
    
    user_unions_first(p) -> ea_t const &
        @param p (C++: user_unions_iterator_t)

Help on function user_unions_free in module ida_hexrays:

user_unions_free(*args)
    Delete user_unions_t instance.
    
    user_unions_free(map)
        @param map (C++: user_unions_t *)

Help on function user_unions_insert in module ida_hexrays:

user_unions_insert(*args)
    Insert new (ea_t, intvec_t) pair into user_unions_t.
    
    user_unions_insert(map, key, val) -> user_unions_iterator_t
        @param map (C++: user_unions_t *)
        @param key (C++: const ea_t &)
        @param val (C++: const  intvec_t  &)

Help on class user_unions_iterator_t in module ida_hexrays:

class user_unions_iterator_t(__builtin__.object)
 |  Proxy of C++ user_unions_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, p) -> bool
 |          p: user_unions_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_unions_iterator_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, p) -> bool
 |          p: user_unions_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      user_unions_iterator_t_x_get(self) -> iterator_word
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_user_unions_iterator_t>
 |      delete_user_unions_iterator_t(self)

Help on function user_unions_new in module ida_hexrays:

user_unions_new(*args)
    Create a new user_unions_t instance.

Help on function user_unions_next in module ida_hexrays:

user_unions_next(*args)
    Move to the next element.
    
    user_unions_next(p) -> user_unions_iterator_t
        @param p (C++: user_unions_iterator_t)

Help on function user_unions_prev in module ida_hexrays:

user_unions_prev(*args)
    Move to the previous element.
    
    user_unions_prev(p) -> user_unions_iterator_t
        @param p (C++: user_unions_iterator_t)

Help on function user_unions_second in module ida_hexrays:

user_unions_second(*args)
    Get reference to the current map value.
    
    user_unions_second(p) -> intvec_t
        @param p (C++: user_unions_iterator_t)

Help on function user_unions_size in module ida_hexrays:

user_unions_size(*args)
    Get size of user_unions_t.
    
    user_unions_size(map) -> size_t
        @param map (C++: user_unions_t *)

Help on class user_unions_t in module ida_hexrays:

class user_unions_t(__builtin__.object)
 |  Proxy of C++ std::map< ea_t,intvec_t > class.
 |  
 |  Methods defined here:
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_unions_t
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args)
 |      size(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  at(self, *args)
 |      at(self, _Keyval) -> intvec_t
 |          _Keyval: unsigned-ea-like-numeric-type const &↗
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __begin = <built-in function user_unions_begin>
 |      user_unions_begin(map) -> user_unions_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t const *
 |  
 |  __clear = <built-in function user_unions_clear>
 |      user_unions_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t *
 |  
 |  __end = <built-in function user_unions_end>
 |      user_unions_end(map) -> user_unions_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t const *
 |  
 |  __erase = <built-in function user_unions_erase>
 |      user_unions_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t *
 |      p: user_unions_iterator_t
 |  
 |  __find = <built-in function user_unions_find>
 |      user_unions_find(map, key) -> user_unions_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t const *
 |      key: ea_t const &
 |  
 |  __first = <built-in function user_unions_first>
 |      user_unions_first(p) -> ea_t const &
 |      
 |      Parameters
 |      ----------
 |      p: user_unions_iterator_t
 |  
 |  __insert = <built-in function user_unions_insert>
 |      user_unions_insert(map, key, val) -> user_unions_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t *
 |      key: ea_t const &
 |      val: intvec_t const &
 |  
 |  __next = <built-in function user_unions_next>
 |      user_unions_next(p) -> user_unions_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_unions_iterator_t
 |  
 |  __second = <built-in function user_unions_second>
 |      user_unions_second(p) -> intvec_t
 |      
 |      Parameters
 |      ----------
 |      p: user_unions_iterator_t
 |  
 |  __size = <built-in function user_unions_size>
 |      user_unions_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t *
 |  
 |  __swig_destroy__ = <built-in function delete_user_unions_t>
 |      delete_user_unions_t(self)
 |  
 |  keytype = (<type 'int'>, <type 'long'>)
 |  
 |  valuetype = <class 'ida_pro.intvec_t'>
 |      Proxy of C++ qvector< int > class.

Help on class uval_ivl_ivlset_t in module ida_hexrays:

class uval_ivl_ivlset_t(__builtin__.object)
 |  Proxy of C++ ivlset_tpl< ivl_t,uval_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, v) -> bool
 |          v: ivl_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> uval_ivl_ivlset_t
 |          ivl: ivl_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, v) -> bool
 |          v: ivl_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  all_values(self, *args)
 |      all_values(self) -> bool
 |  
 |  begin(self, *args)
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator↗
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator↗
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator↗
 |  
 |  getivl(self, *args)
 |      getivl(self, idx) -> ivl_t
 |          idx: int
 |  
 |  lastivl(self, *args)
 |      lastivl(self) -> ivl_t
 |  
 |  nivls(self, *args)
 |      nivls(self) -> size_t
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  set_all_values(self, *args)
 |      set_all_values(self)
 |  
 |  single_value(self, *args)
 |      single_value(self) -> bool
 |          v: unsigned-ea-like-numeric-type↗
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: ivlset_tpl< ivl_t,uval_t > &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_uval_ivl_ivlset_t>
 |      delete_uval_ivl_ivlset_t(self)

Help on class uval_ivl_t in module ida_hexrays:

class uval_ivl_t(__builtin__.object)
 |  Proxy of C++ ivl_tpl< uval_t > class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _off, _size) -> uval_ivl_t
 |          _off: unsigned-ea-like-numeric-type↗
 |          _size: unsigned-ea-like-numeric-type↗
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  end(self, *args)
 |      end(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  last(self, *args)
 |      last(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  valid(self, *args)
 |      valid(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      uval_ivl_t_off_get(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  size
 |      uval_ivl_t_size_get(self) -> unsigned-ea-like-numeric-type↗
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_uval_ivl_t>
 |      delete_uval_ivl_t(self)

Help on class valrng_t in module ida_hexrays:

class valrng_t(__builtin__.object)
 |  Proxy of C++ valrng_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: valrng_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: valrng_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: valrng_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, size_=MAX_VLR_SIZE) -> valrng_t
 |          size_: int
 |      
 |      
 |      __init__(self, r) -> valrng_t
 |          r: valrng_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: valrng_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: valrng_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: valrng_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _deregister(self, *args)
 |      _deregister(self)
 |  
 |  _print(self, *args)
 |      _print(self)
 |  
 |  _register(self, *args)
 |      _register(self)
 |  
 |  all_values(self, *args)
 |      all_values(self) -> bool
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: valrng_t const &
 |  
 |  cvt_to_cmp(self, *args)
 |      cvt_to_cmp(self, strict) -> bool
 |          @param strict (C++: bool)
 |  
 |  cvt_to_single_value(self, *args)
 |      cvt_to_single_value(self) -> bool
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  get_size(self, *args)
 |      get_size(self) -> int
 |  
 |  has(self, *args)
 |      has(self, v) -> bool
 |          @param v (C++: uvlr_t)
 |  
 |  intersect_with(self, *args)
 |      intersect_with(self, r) -> bool
 |          @param r (C++: const  valrng_t  &)
 |  
 |  inverse(self, *args)
 |      inverse(self)
 |  
 |  is_unknown(self, *args)
 |      is_unknown(self) -> bool
 |  
 |  max_svalue(self, *args)
 |      max_svalue(self, size_) -> uvlr_t
 |          size_: int
 |  
 |  max_value(self, *args)
 |      max_value(self, size_) -> uvlr_t
 |          size_: int
 |  
 |  min_svalue(self, *args)
 |      min_svalue(self, size_) -> uvlr_t
 |          size_: int
 |  
 |  reduce_size(self, *args)
 |      reduce_size(self, new_size) -> bool
 |          @param new_size (C++: int)
 |  
 |  set_all(self, *args)
 |      set_all(self)
 |  
 |  set_cmp(self, *args)
 |      set_cmp(self, cmp, _value)
 |          @param cmp (C++: cmpop_t)
 |          @param _value (C++: uvlr_t)
 |  
 |  set_eq(self, *args)
 |      set_eq(self, v)
 |          @param v (C++: uvlr_t)
 |  
 |  set_none(self, *args)
 |      set_none(self)
 |  
 |  set_unk(self, *args)
 |      set_unk(self)
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: valrng_t  &)
 |  
 |  unite_with(self, *args)
 |      unite_with(self, r) -> bool
 |          @param r (C++: const  valrng_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_valrng_t>
 |      delete_valrng_t(self)

Help on class var_ref_t in module ida_hexrays:

class var_ref_t(__builtin__.object)
 |  Proxy of C++ var_ref_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: var_ref_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: var_ref_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: var_ref_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> var_ref_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: var_ref_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: var_ref_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: var_ref_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: var_ref_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  idx
 |      var_ref_t_idx_get(self) -> int
 |  
 |  mba
 |      var_ref_t_mba_get(self) -> mba_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_var_ref_t>
 |      delete_var_ref_t(self)

Help on class vc_printer_t in module ida_hexrays:

class vc_printer_t(vd_printer_t)
 |  Proxy of C++ vc_printer_t class.
 |  
 |  Method resolution order:
 |      vc_printer_t
 |      vd_printer_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, f) -> vc_printer_t
 |          f: cfunc_t const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  oneliner(self, *args)
 |      Are we generating one-line text representation?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  func
 |      vc_printer_t_func_get(self) -> cfunc_t
 |  
 |  lastchar
 |      vc_printer_t_lastchar_get(self) -> char
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_vc_printer_t>
 |      delete_vc_printer_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vd_printer_t:
 |  
 |  _print(self, *args)
 |      _print(self, indent, format) -> int
 |          indent: int
 |          format: char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vd_printer_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hdrlines
 |      vd_printer_t_hdrlines_get(self) -> int
 |  
 |  tmpbuf
 |      vd_printer_t_tmpbuf_get(self) -> qstring *

Help on class vd_failure_t in module ida_hexrays:

class vd_failure_t(__builtin__.object)
 |  Proxy of C++ vd_failure_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> vd_failure_t
 |          code: enum merror_t
 |          ea: ea_t
 |          buf: char const *
 |      
 |      
 |      __init__(self, code, ea, buf) -> vd_failure_t
 |          code: enum merror_t
 |          ea: ea_t
 |          buf: qstring const &
 |      
 |      
 |      __init__(self, _hf) -> vd_failure_t
 |          _hf: hexrays_failure_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  desc(self, *args)
 |      desc(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hf
 |      vd_failure_t_hf_get(self) -> hexrays_failure_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_vd_failure_t>
 |      delete_vd_failure_t(self)

Help on class vd_interr_t in module ida_hexrays:

class vd_interr_t(vd_failure_t)
 |  Proxy of C++ vd_interr_t class.
 |  
 |  Method resolution order:
 |      vd_interr_t
 |      vd_failure_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, ea, buf) -> vd_interr_t
 |          ea: ea_t
 |          buf: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_vd_interr_t>
 |      delete_vd_interr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vd_failure_t:
 |  
 |  desc(self, *args)
 |      desc(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vd_failure_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hf
 |      vd_failure_t_hf_get(self) -> hexrays_failure_t

Help on class vd_printer_t in module ida_hexrays:

class vd_printer_t(__builtin__.object)
 |  Proxy of C++ vd_printer_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> vd_printer_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self, indent, format) -> int
 |          indent: int
 |          format: char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hdrlines
 |      vd_printer_t_hdrlines_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  tmpbuf
 |      vd_printer_t_tmpbuf_get(self) -> qstring *
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_vd_printer_t>
 |      delete_vd_printer_t(self)

Help on class vdloc_t in module ida_hexrays:

class vdloc_t(ida_typeinf.argloc_t)
 |  Proxy of C++ vdloc_t class.
 |  
 |  Method resolution order:
 |      vdloc_t
 |      ida_typeinf.argloc_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> vdloc_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: vdloc_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _set_reg1(self, *args)
 |      _set_reg1(self, r1)
 |          @param r1 (C++: int)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: vdloc_t const &
 |  
 |  is_aliasable(self, *args)
 |      is_aliasable(self, mb, size) -> bool
 |          @param mb (C++: const  mba_t  *)
 |          @param size (C++: int)
 |  
 |  reg1(self, *args)
 |      reg1(self) -> int
 |  
 |  set_reg1(self, *args)
 |      set_reg1(self, r1)
 |          @param r1 (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_vdloc_t>
 |      delete_vdloc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_typeinf.argloc_t:
 |  
 |  _consume_rrel(self, *args)
 |      Use 'consume_rrel()'
 |      
 |      _consume_rrel(self, p) -> bool
 |          @param p (C++: rrel_t  *)
 |  
 |  _consume_scattered(self, *args)
 |      Use 'consume_scattered()'
 |      
 |      _consume_scattered(self, p) -> bool
 |          @param p (C++: scattered_aloc_t  *)
 |  
 |  _set_badloc(self, *args)
 |      Use 'set_badloc()'
 |  
 |  _set_biggest(self, *args)
 |      Set biggest element in internal union (careful - this function does
 |      not clean up!)
 |      
 |      _set_biggest(self, ct, data)
 |          @param ct (C++: argloc_type_t)
 |          @param data (C++: biggest_t)
 |  
 |  _set_custom(self, *args)
 |      Set custom argument location (careful - this function does not clean
 |      up!)
 |      
 |      _set_custom(self, ct, pdata)
 |          @param ct (C++: argloc_type_t)
 |          @param pdata (C++: void *)
 |  
 |  _set_ea(self, *args)
 |      Use set_ea
 |      
 |      _set_ea(self, _ea)
 |          @param _ea (C++: ea_t)
 |  
 |  _set_reg2(self, *args)
 |      Use 'set_reg2()'
 |      
 |      _set_reg2(self, _reg1, _reg2)
 |          @param _reg1 (C++: int)
 |          @param _reg2 (C++: int)
 |  
 |  _set_stkoff(self, *args)
 |      Use 'set_stkoff()'
 |      
 |      _set_stkoff(self, off)
 |          @param off (C++: sval_t)
 |  
 |  advance(self, *args)
 |      Move the location to point 'delta' bytes further.
 |      
 |      advance(self, delta) -> bool
 |          @param delta (C++: int)
 |  
 |  atype(self, *args)
 |      Get type ( 'Argument location types' )
 |  
 |  calc_offset(self, *args)
 |      Calculate offset that can be used to compare 2 similar arglocs.
 |  
 |  consume_rrel(self, *args)
 |      Set register-relative location - can't be NULL.
 |      
 |      consume_rrel(self, p)
 |          @param p (C++: rrel_t  *)
 |  
 |  consume_scattered(self, *args)
 |      Set distributed argument location.
 |      
 |      consume_scattered(self, p)
 |          @param p (C++: scattered_aloc_t  *)
 |  
 |  get_biggest(self, *args)
 |      Get largest element in internal union.
 |  
 |  get_custom(self, *args)
 |      Get custom argloc info. Use if 'atype()' == 'ALOC_CUSTOM'
 |  
 |  get_ea(self, *args)
 |      Get the global address. Use when 'atype()' == 'ALOC_STATIC'
 |  
 |  get_reginfo(self, *args)
 |      Get all register info. Use when 'atype()' == 'ALOC_REG1' or
 |      'ALOC_REG2'
 |  
 |  get_rrel(self, *args)
 |      Get register-relative info. Use when 'atype()' == 'ALOC_RREL'
 |  
 |  has_reg(self, *args)
 |      TRUE if argloc has a register part.
 |  
 |  has_stkoff(self, *args)
 |      TRUE if argloc has a stack part.
 |  
 |  is_badloc(self, *args)
 |      See 'ALOC_NONE' .
 |  
 |  is_custom(self, *args)
 |      See 'ALOC_CUSTOM' .
 |  
 |  is_ea(self, *args)
 |      See 'ALOC_STATIC' .
 |  
 |  is_fragmented(self, *args)
 |      'is_scattered()' || 'is_reg2()'
 |  
 |  is_mixed_scattered(self, *args)
 |      mixed scattered: consists of register and stack parts
 |  
 |  is_reg(self, *args)
 |      'is_reg1()' || 'is_reg2()'
 |  
 |  is_reg1(self, *args)
 |      See 'ALOC_REG1' .
 |  
 |  is_reg2(self, *args)
 |      See 'ALOC_REG2' .
 |  
 |  is_rrel(self, *args)
 |      See 'ALOC_RREL' .
 |  
 |  is_scattered(self, *args)
 |      See 'ALOC_DIST' .
 |  
 |  is_stkoff(self, *args)
 |      See 'ALOC_STACK' .
 |  
 |  justify_reg_high(self, *args)
 |      Set register offset to justify it to the upper part of _SLOTSIZE.
 |      
 |      justify_reg_high(self, size, _slotsize)
 |          @param size (C++: size_t)
 |          @param _slotsize (C++: size_t)
 |  
 |  justify_stkoff_right(self, *args)
 |      Set stack offset to right-justify it in _SLOTSIZE.
 |      
 |      justify_stkoff_right(self, size, _slotsize)
 |          @param size (C++: size_t)
 |          @param _slotsize (C++: size_t)
 |  
 |  reg2(self, *args)
 |      Get info for the second register. Use when 'atype()' == 'ALOC_REG2'
 |  
 |  regoff(self, *args)
 |      Get offset from the beginning of the register in bytes. Use when
 |      'atype()' == 'ALOC_REG1'
 |  
 |  scattered(self, *args)
 |      Get scattered argument info. Use when 'atype()' == 'ALOC_DIST'
 |  
 |  set_badloc(self, *args)
 |      Set to invalid location.
 |  
 |  set_ea(self, *args)
 |      Set static ea location.
 |      
 |      set_ea(self, _ea)
 |          @param _ea (C++: ea_t)
 |  
 |  set_reg2(self, *args)
 |      Set secondary register location.
 |      
 |      set_reg2(self, _reg1, _reg2)
 |          @param _reg1 (C++: int)
 |          @param _reg2 (C++: int)
 |  
 |  set_stkoff(self, *args)
 |      Set stack offset location.
 |      
 |      set_stkoff(self, off)
 |          @param off (C++: sval_t)
 |  
 |  stkoff(self, *args)
 |      Get the stack offset. Use if 'atype()' == 'ALOC_STACK'
 |  
 |  swap(self, *args)
 |      Assign this == r and r == this.
 |      
 |      swap(self, r)
 |          @param r (C++: argloc_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_typeinf.argloc_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class vdui_t in module ida_hexrays:

class vdui_t(__builtin__.object)
 |  Proxy of C++ vdui_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  calc_cmt_type(self, *args)
 |      Check if the specified line can have a comment. Due to the coordinate
 |      system for comments (http://www.hexblog.com/?p=60) some function lines
 |      cannot have comments. This function checks if a comment can be
 |      attached to the specified line.
 |      
 |      calc_cmt_type(self, lnnum, cmttype) -> cmt_type_t
 |          @param lnnum: line number (0 based) (C++: size_t)
 |          @param cmttype: comment types to check (C++: cmt_type_t)
 |          @return: possible comment types
 |  
 |  clear(self, *args)
 |      Clear the pseudocode window. It deletes the current function and
 |      microcode.
 |  
 |  collapse_item(self, *args)
 |      Collapse/uncollapse item. This function collapses the current item.
 |      
 |      collapse_item(self, hide) -> bool
 |          @param hide (C++: bool)
 |          @return: false if failed.
 |  
 |  collapse_lvars(self, *args)
 |      Collapse/uncollapse local variable declarations.
 |      
 |      collapse_lvars(self, hide) -> bool
 |          @param hide (C++: bool)
 |          @return: false if failed.
 |  
 |  ctree_to_disasm(self, *args)
 |      Jump to disassembly. This function jumps to the address in the
 |      disassembly window which corresponds to the current item. The current
 |      item is determined based on the current keyboard cursor position.
 |  
 |  del_orphan_cmts(self, *args)
 |      Delete all orphan comments. Delete all orphan comments and refresh the
 |      screen.
 |  
 |  edit_cmt(self, *args)
 |      Edit an indented comment. This function displays a dialog box and
 |      allows the user to edit the comment for the specified ctree location.
 |      
 |      edit_cmt(self, loc) -> bool
 |          @param loc: comment location (C++: const  treeloc_t  &)
 |          @return: false if failed or cancelled
 |  
 |  edit_func_cmt(self, *args)
 |      Edit a function comment. This function displays a dialog box and
 |      allows the user to edit the function comment.
 |  
 |  get_current_item(self, *args)
 |      Get current item. This function refreshes the 'cpos' , 'item' , 'tail'
 |      fields. 'cfunc_t::get_line_item()'
 |      
 |      get_current_item(self, idv) -> bool
 |          @param idv: keyboard or mouse (C++: input_device_t)
 |          @return: false if failed
 |  
 |  get_current_label(self, *args)
 |      Get current label. If there is a label under the cursor, return its
 |      number.
 |  
 |  get_number(self, *args)
 |      Get current number. If the current item is a number, return pointer to
 |      it.
 |  
 |  in_ctree(self, *args)
 |      Is the current item a statement?
 |  
 |  invert_bits(self, *args)
 |      Bitwise negate a number. This function inverts all bits of the current
 |      number.
 |  
 |  invert_sign(self, *args)
 |      Negate a number. This function negates the current number.
 |  
 |  jump_enter(self, *args)
 |      Process the Enter key. This function jumps to the definition of the
 |      item under the cursor. If the current item is a function, it will be
 |      decompiled. If the current item is a global data, its disassemly text
 |      will be displayed.
 |      
 |      jump_enter(self, idv, omflags) -> bool
 |          @param idv: what cursor must be used, the keyboard or the mouse (C++:
 |                      input_device_t)
 |          @param omflags: OM_NEWWIN: new pseudocode window will open, 0: reuse
 |                          the existing window (C++: int)
 |          @return: false if failed
 |  
 |  locked(self, *args)
 |      Does the pseudocode window contain valid code? We lock windows before
 |      modifying them, to avoid recursion due to the events generated by the
 |      IDA kernel.
 |  
 |  map_lvar(self, *args)
 |      Map a local variable to another. This function permanently maps one
 |      lvar to another. All occurrences of the mapped variable are replaced
 |      by the new variable
 |      
 |      map_lvar(self, frm, to) -> bool
 |          @param frm: the variable being mapped (C++: lvar_t  *)
 |          @param to: the variable to map to. if NULL, unmaps the variable (C++:
 |                     lvar_t  *)
 |          @return: false if failed
 |  
 |  refresh_cpos(self, *args)
 |      Refresh the current position. This function refreshes the 'cpos'
 |      field.
 |      
 |      refresh_cpos(self, idv) -> bool
 |          @param idv: keyboard or mouse (C++: input_device_t)
 |          @return: false if failed
 |  
 |  refresh_ctext(self, *args)
 |      Refresh pseudocode window. This function refreshes the pseudocode
 |      window by regenerating its text from 'cfunc_t' . Instead of this
 |      function use refresh_func_ctext(), which refreshes all pseudocode
 |      windows for the function. 'refresh_view()' , refresh_func_ctext()
 |      
 |      refresh_ctext(self, activate=True)
 |          @param activate (C++: bool)
 |  
 |  refresh_view(self, *args)
 |      Refresh pseudocode window. This is the highest level refresh function.
 |      It causes the most profound refresh possible and can lead to
 |      redecompilation of the current function. Please consider using
 |      'refresh_ctext()' if you need a more superficial refresh.
 |      'refresh_ctext()'
 |      
 |      refresh_view(self, redo_mba)
 |          @param redo_mba: true means to redecompile the current function
 |                           false means to rebuild ctree without regenerating
 |                           microcode (C++: bool)
 |  
 |  rename_global(self, *args)
 |      Rename global item. This function displays a dialog box and allows the
 |      user to rename a global item (data or function).
 |      
 |      rename_global(self, ea) -> bool
 |          @param ea: address of the global item (C++: ea_t)
 |          @return: false if failed or cancelled
 |  
 |  rename_label(self, *args)
 |      Rename a label. This function displays a dialog box and allows the
 |      user to rename a statement label.
 |      
 |      rename_label(self, label) -> bool
 |          @param label: label number (C++: int)
 |          @return: false if failed or cancelled
 |  
 |  rename_lvar(self, *args)
 |      Rename local variable. This function permanently renames a local
 |      variable.
 |      
 |      rename_lvar(self, v, name, is_user_name) -> bool
 |          @param v: pointer to local variable (C++: lvar_t  *)
 |          @param name: new variable name (C++: const char *)
 |          @param is_user_name: use true to save the new name into the database
 |                               (C++: bool)
 |          @return: false if failed
 |  
 |  rename_strmem(self, *args)
 |      Rename structure field. This function displays a dialog box and allows
 |      the user to rename a structure field.
 |      
 |      rename_strmem(self, sptr, mptr) -> bool
 |          @param sptr: pointer to structure (C++: struc_t  *)
 |          @param mptr: pointer to structure member (C++: member_t  *)
 |          @return: false if failed or cancelled
 |  
 |  set_global_type(self, *args)
 |      Set global item type. This function displays a dialog box and allows
 |      the user to change the type of a global item (data or function).
 |      
 |      set_global_type(self, ea) -> bool
 |          @param ea: address of the global item (C++: ea_t)
 |          @return: false if failed or cancelled
 |  
 |  set_locked(self, *args)
 |      set_locked(self, v) -> bool
 |          @param v (C++: bool)
 |  
 |  set_lvar_cmt(self, *args)
 |      Set local variable comment. This function permanently sets a variable
 |      comment.
 |      
 |      set_lvar_cmt(self, v, cmt) -> bool
 |          @param v: pointer to local variable (C++: lvar_t  *)
 |          @param cmt: new comment (C++: const char *)
 |          @return: false if failed
 |  
 |  set_lvar_type(self, *args)
 |      Set local variable type. This function permanently sets a local
 |      variable type and clears NOPTR flag if it was set before by function
 |      'set_noptr_lvar'
 |      
 |      set_lvar_type(self, v, type) -> bool
 |          @param v: pointer to local variable (C++: lvar_t  *)
 |          @param type: new variable type (C++: const  tinfo_t  &)
 |          @return: false if failed
 |  
 |  set_noptr_lvar(self, *args)
 |      Inform that local variable should have a non-pointer type This
 |      function permanently sets a corresponding variable flag (NOPTR) and
 |      removes type if it was set before by function 'set_lvar_type'
 |      
 |      set_noptr_lvar(self, v) -> bool
 |          @param v: pointer to local variable (C++: lvar_t  *)
 |          @return: false if failed
 |  
 |  set_num_enum(self, *args)
 |      Convert number to symbolic constant. This function displays a dialog
 |      box and allows the user to select a symbolic constant to represent the
 |      number.
 |  
 |  set_num_radix(self, *args)
 |      Change number base. This function changes the current number
 |      representation.
 |      
 |      set_num_radix(self, base) -> bool
 |          @param base: number radix (10 or 16)   0 means a character constant
 |                       (C++: int)
 |          @return: false if failed
 |  
 |  set_num_stroff(self, *args)
 |      Convert number to structure field offset. Currently not implemented.
 |  
 |  set_strmem_type(self, *args)
 |      Set structure field type. This function displays a dialog box and
 |      allows the user to change the type of a structure field.
 |      
 |      set_strmem_type(self, sptr, mptr) -> bool
 |          @param sptr: pointer to structure (C++: struc_t  *)
 |          @param mptr: pointer to structure member (C++: member_t  *)
 |          @return: false if failed or cancelled
 |  
 |  set_valid(self, *args)
 |      set_valid(self, v)
 |          @param v (C++: bool)
 |  
 |  set_visible(self, *args)
 |      set_visible(self, v)
 |          @param v (C++: bool)
 |  
 |  split_item(self, *args)
 |      Split/unsplit item. This function splits the current assignment
 |      expression.
 |      
 |      split_item(self, split) -> bool
 |          @param split (C++: bool)
 |          @return: false if failed.
 |  
 |  switch_to(self, *args)
 |      Display the specified pseudocode. This function replaces the
 |      pseudocode window contents with the specified 'cfunc_t' .
 |      
 |      switch_to(self, f, activate)
 |          @param f: pointer to the function to display. (C++: cfuncptr_t)
 |          @param activate: should the pseudocode window get focus? (C++: bool)
 |  
 |  ui_edit_lvar_cmt(self, *args)
 |      Set local variable comment. This function displays a dialog box and
 |      allows the user to edit the comment of a local variable.
 |      
 |      ui_edit_lvar_cmt(self, v) -> bool
 |          @param v: pointer to local variable (C++: lvar_t  *)
 |          @return: false if failed or cancelled
 |  
 |  ui_map_lvar(self, *args)
 |      Map a local variable to another. This function displays a variable
 |      list and allows the user to select mapping.
 |      
 |      ui_map_lvar(self, v) -> bool
 |          @param v: pointer to local variable (C++: lvar_t  *)
 |          @return: false if failed or cancelled
 |  
 |  ui_rename_lvar(self, *args)
 |      Rename local variable. This function displays a dialog box and allows
 |      the user to rename a local variable.
 |      
 |      ui_rename_lvar(self, v) -> bool
 |          @param v: pointer to local variable (C++: lvar_t  *)
 |          @return: false if failed or cancelled
 |  
 |  ui_set_call_type(self, *args)
 |      Set type of a function call This function displays a dialog box and
 |      allows the user to change the type of a function call
 |      
 |      ui_set_call_type(self, e) -> bool
 |          @param e: pointer to call expression (C++: const  cexpr_t  *)
 |          @return: false if failed or cancelled
 |  
 |  ui_set_lvar_type(self, *args)
 |      Set local variable type. This function displays a dialog box and
 |      allows the user to change the type of a local variable.
 |      
 |      ui_set_lvar_type(self, v) -> bool
 |          @param v: pointer to local variable (C++: lvar_t  *)
 |          @return: false if failed or cancelled
 |  
 |  ui_unmap_lvar(self, *args)
 |      Unmap a local variable. This function displays list of variables
 |      mapped to the specified variable and allows the user to select a
 |      variable to unmap.
 |      
 |      ui_unmap_lvar(self, v) -> bool
 |          @param v: pointer to local variable (C++: lvar_t  *)
 |          @return: false if failed or cancelled
 |  
 |  valid(self, *args)
 |      Does the pseudocode window contain valid code? It can become invalid
 |      if the function type gets changed in IDA.
 |  
 |  visible(self, *args)
 |      Is the pseudocode window visible? if not, it might be invisible or
 |      destroyed
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cfunc
 |      vdui_t_cfunc_get(self) -> cfuncptr_t
 |  
 |  cpos
 |      vdui_t_cpos_get(self) -> ctext_position_t
 |  
 |  ct
 |      vdui_t_ct_get(self) -> TWidget *
 |  
 |  flags
 |      vdui_t_flags_get(self) -> int
 |  
 |  head
 |      vdui_t_head_get(self) -> ctree_item_t
 |  
 |  item
 |      vdui_t_item_get(self) -> ctree_item_t
 |  
 |  last_code
 |      vdui_t_last_code_get(self) -> merror_t
 |  
 |  mba
 |      vdui_t_mba_get(self) -> mba_t
 |  
 |  tail
 |      vdui_t_tail_get(self) -> ctree_item_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  toplevel
 |      vdui_t_toplevel_get(self) -> TWidget *
 |  
 |  view_idx
 |      vdui_t_view_idx_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_vdui_t>
 |      delete_vdui_t(self)

Help on class vivl_t in module ida_hexrays:

class vivl_t(voff_t)
 |  Proxy of C++ vivl_t class.
 |  
 |  Method resolution order:
 |      vivl_t
 |      voff_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: vivl_t const &
 |      
 |      
 |      __eq__(self, mop) -> bool
 |          mop: mop_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: vivl_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: vivl_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _type=mop_z, _off=-1, _size=0) -> vivl_t
 |          _type: mopt_t
 |          _off: sval_t
 |          _size: int
 |      
 |      
 |      __init__(self, ch) -> vivl_t
 |          ch: chain_t const &
 |      
 |      
 |      __init__(self, op) -> vivl_t
 |          op: mop_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: vivl_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: vivl_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: vivl_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: vivl_t const &
 |  
 |  contains(self, *args)
 |      Does our value interval contain the specified value offset?
 |      
 |      contains(self, voff2) -> bool
 |          @param voff2 (C++: const  voff_t  &)
 |  
 |  dstr(self, *args)
 |      dstr(self) -> char const *
 |  
 |  extend_to_cover(self, *args)
 |      Extend a value interval using another value interval of the same type
 |      
 |      extend_to_cover(self, r) -> bool
 |          @param r (C++: const  vivl_t  &)
 |          @return: success
 |  
 |  includes(self, *args)
 |      Does our value interval include another?
 |      
 |      includes(self, r) -> bool
 |          @param r (C++: const  vivl_t  &)
 |  
 |  intersect(self, *args)
 |      Intersect value intervals the same type
 |      
 |      intersect(self, r) -> uval_t
 |          @param r (C++: const  vivl_t  &)
 |          @return: size of the resulting intersection
 |  
 |  overlap(self, *args)
 |      Do two value intervals overlap?
 |      
 |      overlap(self, r) -> bool
 |          @param r (C++: const  vivl_t  &)
 |  
 |  set(self, *args)
 |      set(self, _type, _off, _size=0)
 |          @param _type (C++: mopt_t)
 |          @param _off (C++: sval_t)
 |          @param _size (C++: int)
 |      
 |      
 |      set(self, voff, _size)
 |          voff: voff_t const &
 |          @param _size (C++: int)
 |  
 |  set_reg(self, *args)
 |      set_reg(self, mreg, sz=0)
 |          @param mreg (C++: mreg_t)
 |          @param sz (C++: int)
 |  
 |  set_stkoff(self, *args)
 |      set_stkoff(self, stkoff, sz=0)
 |          @param stkoff (C++: sval_t)
 |          @param sz (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  size
 |      vivl_t_size_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_vivl_t>
 |      delete_vivl_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from voff_t:
 |  
 |  add(self, *args)
 |      add(self, width) -> voff_t
 |          @param width (C++: int)
 |  
 |  defined(self, *args)
 |      defined(self) -> bool
 |  
 |  diff(self, *args)
 |      diff(self, r) -> sval_t
 |          @param r (C++: const  voff_t  &)
 |  
 |  get_reg(self, *args)
 |      get_reg(self) -> mreg_t
 |  
 |  get_stkoff(self, *args)
 |      get_stkoff(self) -> sval_t
 |  
 |  inc(self, *args)
 |      inc(self, delta)
 |          @param delta (C++: sval_t)
 |  
 |  is_reg(self, *args)
 |      is_reg(self) -> bool
 |  
 |  is_stkoff(self, *args)
 |      is_stkoff(self) -> bool
 |  
 |  undef(self, *args)
 |      undef(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from voff_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      voff_t_off_get(self) -> sval_t
 |  
 |  type
 |      voff_t_type_get(self) -> mopt_t

Help on class voff_t in module ida_hexrays:

class voff_t(__builtin__.object)
 |  Proxy of C++ voff_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: voff_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: voff_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: voff_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> voff_t
 |          _type: mopt_t
 |          _off: sval_t
 |      
 |      
 |      __init__(self, op) -> voff_t
 |          op: mop_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: voff_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: voff_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: voff_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  add(self, *args)
 |      add(self, width) -> voff_t
 |          @param width (C++: int)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: voff_t const &
 |  
 |  defined(self, *args)
 |      defined(self) -> bool
 |  
 |  diff(self, *args)
 |      diff(self, r) -> sval_t
 |          @param r (C++: const  voff_t  &)
 |  
 |  get_reg(self, *args)
 |      get_reg(self) -> mreg_t
 |  
 |  get_stkoff(self, *args)
 |      get_stkoff(self) -> sval_t
 |  
 |  inc(self, *args)
 |      inc(self, delta)
 |          @param delta (C++: sval_t)
 |  
 |  is_reg(self, *args)
 |      is_reg(self) -> bool
 |  
 |  is_stkoff(self, *args)
 |      is_stkoff(self) -> bool
 |  
 |  set(self, *args)
 |      set(self, _type, _off)
 |          @param _type (C++: mopt_t)
 |          @param _off (C++: sval_t)
 |  
 |  set_reg(self, *args)
 |      set_reg(self, mreg)
 |          @param mreg (C++: mreg_t)
 |  
 |  set_stkoff(self, *args)
 |      set_stkoff(self, stkoff)
 |          @param stkoff (C++: sval_t)
 |  
 |  undef(self, *args)
 |      undef(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      voff_t_off_get(self) -> sval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      voff_t_type_get(self) -> mopt_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_voff_t>
 |      delete_voff_t(self)

=== ida_hexrays EPYDOC INJECTIONS ===
ida_hexrays.ACFL_BLKOPT
"""
perform interblock transformations
"""

ida_hexrays.ACFL_GLBDEL
"""
perform dead code eliminition
"""

ida_hexrays.ACFL_GLBPROP
"""
perform global propagation
"""

ida_hexrays.ACFL_GUESS
"""
may guess calling conventions
"""

ida_hexrays.ACFL_LOCOPT
"""
perform local propagation (requires ACFL_BLKOPT)
"""

ida_hexrays.ANCHOR_BLKCMT
"""
block comment (for ctree items)
"""

ida_hexrays.ANCHOR_CITEM
"""
c-tree item
"""

ida_hexrays.ANCHOR_ITP
"""
item type preciser
"""

ida_hexrays.ANCHOR_LVAR
"""
declaration of local variable
"""

ida_hexrays.CFL_FINAL
"""
call type is final, should not be changed
"""

ida_hexrays.CFL_HELPER
"""
created from a decompiler helper function
"""

ida_hexrays.CFL_NORET
"""
call does not return
"""

ida_hexrays.CFS_BOUNDS
"""
'eamap' and 'boundaries' are ready
"""

ida_hexrays.CFS_LOCKED
"""
cfunc is temporarily locked
"""

ida_hexrays.CFS_LVARS_HIDDEN
"""
local variable definitions are collapsed
"""

ida_hexrays.CFS_TEXT
"""
'sv' is ready (and hdrlines)
"""

ida_hexrays.CHF_FAKE
"""
fake chain created by widen_chains()
"""

ida_hexrays.CHF_INITED
"""
is chain initialized? (valid only after lvar allocation)
"""

ida_hexrays.CHF_OVER
"""
overlapped chain
"""

ida_hexrays.CHF_PASSTHRU
"""
pass-thru chain, must use the input variable to the block
"""

ida_hexrays.CHF_REPLACED
"""
chain operands have been replaced?
"""

ida_hexrays.CHF_TERM
"""
terminating chain; the variable does not survive across the block
"""

ida_hexrays.CIT_COLLAPSED
"""
display element in collapsed form
"""

ida_hexrays.CPBLK_FAST
"""
do not update minbstkref and minbargref
"""

ida_hexrays.CPBLK_MINREF
"""
update minbstkref and minbargref
"""

ida_hexrays.CPBLK_OPTJMP
"""
if it becomes useless

del the jump insn at the end of the block
"""

ida_hexrays.CV_FAST
"""
do not maintain parent information
"""

ida_hexrays.CV_INSNS
"""
visit only statements, prune all expressions do not use before the
final ctree maturity because expressions may contain statements at
intermediate stages (see cot_insn). Otherwise you risk missing
statements embedded into expressions.
"""

ida_hexrays.CV_PARENTS
"""
maintain parent information
"""

ida_hexrays.CV_POST
"""
call the leave...() functions
"""

ida_hexrays.CV_PRUNE
"""
this bit is set by visit...() to prune the walk
"""

ida_hexrays.CV_RESTART
"""
restart enumeration at the top expr (apply_to_exprs)
"""

ida_hexrays.DECOMP_ALL_BLKS
"""
generate microcode for unreachable blocks
"""

ida_hexrays.DECOMP_NO_CACHE
"""
do not use decompilation cache
"""

ida_hexrays.DECOMP_NO_FRAME
"""
do not use function frame info (only snippet mode)
"""

ida_hexrays.DECOMP_NO_HIDE
"""
do not hide display waitbox. see close_hexrays_waitboxes()
"""

ida_hexrays.DECOMP_NO_WAIT
"""
do not display waitbox
"""

ida_hexrays.DECOMP_NO_XREFS
"""
do not update global xrefs cache
"""

ida_hexrays.DECOMP_WARNINGS
"""
display warnings in the output window
"""

ida_hexrays.EQ_CMPDEST
"""
compare instruction destinations
"""

ida_hexrays.EQ_IGNCODE
"""
ignore instruction opcodes
"""

ida_hexrays.EQ_IGNSIZE
"""
ignore source operand sizes
"""

ida_hexrays.EQ_OPTINSN
"""
optimize mop_d operands
"""

ida_hexrays.EXFL_ALL
"""
all currently defined bits
"""

ida_hexrays.EXFL_ALONE
"""
standalone helper
"""

ida_hexrays.EXFL_CPADONE
"""
pointer arithmetic correction done
"""

ida_hexrays.EXFL_CSTR
"""
string literal
"""

ida_hexrays.EXFL_FPOP
"""
floating point operation
"""

ida_hexrays.EXFL_JUMPOUT
"""
jump out-of-function
"""

ida_hexrays.EXFL_LVALUE
"""
expression is lvalue even if it doesn't look like it
"""

ida_hexrays.EXFL_PARTIAL
"""
type of the expression is considered partial
"""

ida_hexrays.EXFL_UNDEF
"""
expression uses undefined value
"""

ida_hexrays.EXFL_VFTABLE
"""
is ptr to vftable (used for cot_memptr, cot_memref)
"""

ida_hexrays.FCI_DEAD
"""
some return registers were determined dead
"""

ida_hexrays.FCI_FINAL
"""
call type is final, should not be changed
"""

ida_hexrays.FCI_HASCALL
"""
A function is an synthetic helper combined from several instructions
and at least one of them was a call to a real functions
"""

ida_hexrays.FCI_HASFMT
"""
printf- or scanf-style format string

A variadic function with recognized
"""

ida_hexrays.FCI_NORET
"""
call does not return
"""

ida_hexrays.FCI_NOSIDE
"""
call does not have side effects
"""

ida_hexrays.FCI_PROP
"""
call has been propagated
"""

ida_hexrays.FCI_PURE
"""
pure function
"""

ida_hexrays.FCI_SPLOK
"""
spoiled/visible_memory lists have been optimized. for some functions
we can reduce them as soon as information about the arguments becomes
available. in order not to try optimize them again we use this bit.
"""

ida_hexrays.FD_BACKWARD
"""
search direction
"""

ida_hexrays.FD_DEF
"""
look for definition
"""

ida_hexrays.FD_DIRTY
"""
by function calls and indirect memory access

ignore possible implicit definitions
"""

ida_hexrays.FD_FORWARD
"""
search direction
"""

ida_hexrays.FD_USE
"""
look for use
"""

ida_hexrays.GCA_ALLOC
"""
enumerate only allocated chains
"""

ida_hexrays.GCA_EMPTY
"""
include empty chains
"""

ida_hexrays.GCA_NALLOC
"""
enumerate only non-allocated chains
"""

ida_hexrays.GCA_OFIRST
"""
consider only chains of the first block
"""

ida_hexrays.GCA_OLAST
"""
consider only chains of the last block
"""

ida_hexrays.GCA_SPEC
"""
include chains for special registers
"""

ida_hexrays.GCO_DEF
"""
is destination operand?
"""

ida_hexrays.GCO_REG
"""
is register? otherwise a stack variable
"""

ida_hexrays.GCO_STK
"""
a stack variable
"""

ida_hexrays.GCO_USE
"""
is source operand?
"""

ida_hexrays.GLN_ALL
"""
get both
"""

ida_hexrays.GLN_CURRENT
"""
get label of the current item
"""

ida_hexrays.GLN_GOTO_TARGET
"""
get goto target
"""

ida_hexrays.IPROP_ASSERT
"""
assertion: usually mov #val, op. assertions are used to help the
optimizer. assertions are ignored when generating ctree
"""

ida_hexrays.IPROP_CLNPOP
"""
(e.g. "pop ecx" is often used for that)

the purpose of the instruction is to clean stack
"""

ida_hexrays.IPROP_COMBINED
"""
insn has been modified because of a partial reference
"""

ida_hexrays.IPROP_DONT_COMB
"""
may not combine this instruction with others
"""

ida_hexrays.IPROP_DONT_PROP
"""
may not propagate
"""

ida_hexrays.IPROP_EXTSTX
"""
this is m_ext propagated into m_stx
"""

ida_hexrays.IPROP_FARCALL
"""
call of a far function using push cs/call sequence
"""

ida_hexrays.IPROP_FPINSN
"""
floating point insn
"""

ida_hexrays.IPROP_IGNLOWSRC
"""
low part of the instruction source operand has been created
artificially (this bit is used only for 'and x, 80...')
"""

ida_hexrays.IPROP_INV_JX
"""
inverted conditional jump
"""

ida_hexrays.IPROP_MBARRIER
"""
(instructions accessing memory may not be reordered past it)

this instruction acts as a memory barrier
"""

ida_hexrays.IPROP_MULTI_MOV
"""
(example: STM on ARM may transfer multiple registers)

the minsn was generated as part of insn that moves multiple
registersbits that can be set by plugins:
"""

ida_hexrays.IPROP_OPTIONAL
"""
optional instruction
"""

ida_hexrays.IPROP_PERSIST
"""
persistent insn; they are not destroyed
"""

ida_hexrays.IPROP_SPLIT
"""
the instruction has been split:
"""

ida_hexrays.IPROP_SPLIT1
"""
into 1 byte
"""

ida_hexrays.IPROP_SPLIT2
"""
into 2 bytes
"""

ida_hexrays.IPROP_SPLIT4
"""
into 4 bytes
"""

ida_hexrays.IPROP_SPLIT8
"""
into 8 bytes
"""

ida_hexrays.IPROP_TAILCALL
"""
tail call
"""

ida_hexrays.IPROP_WAS_NORET
"""
was noret icall
"""

ida_hexrays.IPROP_WILDMATCH
"""
match multiple insns
"""

ida_hexrays.LOCOPT_ALL
"""
is not set, only dirty blocks will be optimized

redo optimization for all blocks. if this bit
"""

ida_hexrays.LOCOPT_REFINE
"""
refine return type, ok to fail
"""

ida_hexrays.LOCOPT_REFINE2
"""
refine return type, try harder
"""

ida_hexrays.LVINF_FORCE
"""
force allocation of a new variable. forces the decompiler to create a
new variable at ll.defea
"""

ida_hexrays.LVINF_KEEP
"""
preserve saved user settings regardless of vars for example, if a var
loses all its user-defined attributes or even gets destroyed, keep its
'lvar_saved_info_t' . this is used for ephemeral variables that get
destroyed by macro recognition.
"""

ida_hexrays.LVINF_NOMAP
"""
forbid automatic mapping of the variable
"""

ida_hexrays.LVINF_NOPTR
"""
variable type should not be a pointer
"""

ida_hexrays.MBA_ASRPROP
"""
assertion have been propagated
"""

ida_hexrays.MBA_ASRTOK
"""
assertions have been generated
"""

ida_hexrays.MBA_CALLS
"""
callinfo has been built
"""

ida_hexrays.MBA_CHVARS
"""
can verify chain varnums
"""

ida_hexrays.MBA_CMBBLK
"""
request to combine blocks
"""

ida_hexrays.MBA_CMNSTK
"""
stkvars+stkargs should be considered as one area
"""

ida_hexrays.MBA_COLGDL
"""
display graph after each reduction
"""

ida_hexrays.MBA_DELPAIRS
"""
pairs have been deleted once
"""

ida_hexrays.MBA_GLBOPT
"""
microcode has been optimized globally
"""

ida_hexrays.MBA_INSGDL
"""
display instruction in graphs
"""

ida_hexrays.MBA_LOADED
"""
loaded gdl, no instructions (debugging)
"""

ida_hexrays.MBA_LVARS0
"""
lvar pre-allocation has been performed
"""

ida_hexrays.MBA_LVARS1
"""
lvar real allocation has been performed
"""

ida_hexrays.MBA_NICE
"""
apply transformations to c code
"""

ida_hexrays.MBA_NOFUNC
"""
function is not present, addresses might be wrong
"""

ida_hexrays.MBA_NUMADDR
"""
display definition addresses for numbers
"""

ida_hexrays.MBA_PASSREGS
"""
has 'mcallinfo_t::pass_regs'
"""

ida_hexrays.MBA_PATTERN
"""
microcode pattern, callinfo is present
"""

ida_hexrays.MBA_PRCDEFS
"""
use precise defeas for chain-allocated lvars
"""

ida_hexrays.MBA_PREOPT
"""
preoptimization stage complete
"""

ida_hexrays.MBA_REFINE
"""
may refine return value size
"""

ida_hexrays.MBA_RETFP
"""
function returns floating point value
"""

ida_hexrays.MBA_RETREF
"""
return type has been refined
"""

ida_hexrays.MBA_SAVRST
"""
save-restore analysis has been performed
"""

ida_hexrays.MBA_SHORT
"""
use short display
"""

ida_hexrays.MBA_SPLINFO
"""
(final_type ? idb_spoiled : spoiled_regs) is valid
"""

ida_hexrays.MBA_THUNK
"""
thunk function
"""

ida_hexrays.MBA_VALNUM
"""
display value numbers
"""

ida_hexrays.MBA_WINGR32
"""
use wingraph32
"""

ida_hexrays.MBL_BACKPROP
"""
performed backprop_cc
"""

ida_hexrays.MBL_CALL
"""
call information has been built
"""

ida_hexrays.MBL_COMB
"""
needs "combine" pass
"""

ida_hexrays.MBL_DEAD
"""
needs "eliminate deads" pass
"""

ida_hexrays.MBL_DMT64
"""
needs "demote 64bits"
"""

ida_hexrays.MBL_DSLOT
"""
block for delay slot
"""

ida_hexrays.MBL_FAKE
"""
fake block (after a tail call)
"""

ida_hexrays.MBL_GOTO
"""
this block is a goto target
"""

ida_hexrays.MBL_INCONST
"""
inconsistent lists: we are building them
"""

ida_hexrays.MBL_LIST
"""
use/def lists are ready (not dirty)
"""

ida_hexrays.MBL_NONFAKE
"""
regular block
"""

ida_hexrays.MBL_NORET
"""
dead end block: doesn't return execution control
"""

ida_hexrays.MBL_PRIV
"""
the specified are accepted (used in patterns)

private block - no instructions except
"""

ida_hexrays.MBL_PROP
"""
needs 'propagation' pass
"""

ida_hexrays.MBL_PUSH
"""
needs "convert push/pop instructions"
"""

ida_hexrays.MBL_TCAL
"""
aritifical call block for tail calls
"""

ida_hexrays.MBL_VALRANGES
"""
should optimize using value ranges
"""

ida_hexrays.MLI_CLR_FLAGS
"""
clear LVINF_... bits
"""

ida_hexrays.MLI_CMT
"""
apply lvar comment
"""

ida_hexrays.MLI_NAME
"""
apply lvar name
"""

ida_hexrays.MLI_SET_FLAGS
"""
set LVINF_... bits
"""

ida_hexrays.MLI_TYPE
"""
apply lvar type
"""

ida_hexrays.NALT_VD
"""
this index is not used by ida
"""

ida_hexrays.NF_BINVDONE
"""
temporary internal bit: inverting bits is done
"""

ida_hexrays.NF_BITNOT
"""
The user asked to invert bits of the constant.
"""

ida_hexrays.NF_FIXED
"""
number format has been defined by the user
"""

ida_hexrays.NF_NEGATE
"""
The user asked to negate the constant.
"""

ida_hexrays.NF_NEGDONE
"""
temporary internal bit: negation has been performed
"""

ida_hexrays.NF_VALID
"""
internal bit: stroff or enum is valid for enums: this bit is set
immediately for stroffs: this bit is set at the end of decompilation
"""

ida_hexrays.OPF_NEW_WINDOW
"""
open new window
"""

ida_hexrays.OPF_NO_WAIT
"""
do not display waitbox if decompilation happens
"""

ida_hexrays.OPF_REUSE
"""
reuse existing window
"""

ida_hexrays.OPF_REUSE_ACTIVE
"""
currently active widget is a pseudocode view

reuse existing window, only if the
"""

ida_hexrays.OPROP_CCFLAGS
"""
condition codes register value
"""

ida_hexrays.OPROP_FLOAT
"""
possibly floating value
"""

ida_hexrays.OPROP_IMPDONE
"""
imported operand (a pointer) has been dereferenced
"""

ida_hexrays.OPROP_LOWADDR
"""
a low address offset
"""

ida_hexrays.OPROP_UDEFVAL
"""
uses undefined value
"""

ida_hexrays.OPROP_UDT
"""
a struct or union
"""

ida_hexrays.OPTI_ADDREXPRS
"""
optimize all address expressions (&x+N; &x-&y)
"""

ida_hexrays.OPTI_COMBINSNS
"""
may combine insns (only for optimize_insn)
"""

ida_hexrays.OPTI_MINSTKREF
"""
may update minstkref
"""

ida_hexrays.OPTI_NO_LDXOPT
"""
the function is called after the propagation attempt, we do not
optimize low/high(ldx) in this case
"""

ida_hexrays.SHINS_LDXEA
"""
display address of ldx expressions (not used)
"""

ida_hexrays.SHINS_NUMADDR
"""
display definition addresses for numbers
"""

ida_hexrays.SHINS_SHORT
"""
do not display use-def chains and other attrs
"""

ida_hexrays.SHINS_VALNUM
"""
display value numbers
"""

ida_hexrays.ULV_PRECISE_DEFEA
"""
Use precise defea's for lvar locations.
"""

ida_hexrays.VDRUN_APPEND
"""
Create a new file or append to existing file.
"""

ida_hexrays.VDRUN_CMDLINE
"""
Called from ida's command line.
"""

ida_hexrays.VDRUN_LUMINA
"""
Use lumina server.
"""

ida_hexrays.VDRUN_MAYSTOP
"""
The user can cancel decompilation.
"""

ida_hexrays.VDRUN_NEWFILE
"""
Create a new file or overwrite existing file.
"""

ida_hexrays.VDRUN_ONLYNEW
"""
Fail if output file already exists.
"""

ida_hexrays.VDRUN_SENDIDB
"""
Send problematic databases to hex-rays.com.
"""

ida_hexrays.VDRUN_SILENT
"""
Silent decompilation.
"""

ida_hexrays.VDRUN_STATS
"""
Print statistics into vd_stats.txt.
"""

ida_hexrays.VDUI_VALID
"""
is valid?
"""

ida_hexrays.VDUI_VISIBLE
"""
is visible?
"""

ida_hexrays.VR_AT_END
"""
get value ranges after the instruction or at the block end, just after
the last instruction (if M is NULL)
"""

ida_hexrays.VR_AT_START
"""
at the block start (if M is NULL)

get value ranges before the instruction or
"""

ida_hexrays.VR_EXACT
"""
valrng size will be >= vivl.size

find exact match. if not set, the returned
"""
=== ida_hexrays EPYDOC INJECTIONS END ===
Help on function __make_idainfo_accessors in module ida_ida:

__make_idainfo_accessors(attr, getter_name=None, setter_name=None)

Help on function __make_idainfo_bound in module ida_ida:

__make_idainfo_bound(func, attr)
    #<pycode(py_ida)>

Help on function __make_idainfo_getter in module ida_ida:

__make_idainfo_getter(name)

Help on function __wrap_hooks_callback in module ida_ida:

__wrap_hooks_callback(klass, new_name, old_name, do_call)

Help on function calc_default_idaplace_flags in module ida_ida:

calc_default_idaplace_flags(*args)
    Get default disassembly line options.

Help on class compiler_info_t in module ida_ida:

class compiler_info_t(__builtin__.object)
 |  Proxy of C++ compiler_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> compiler_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cm
 |      compiler_info_t_cm_get(self) -> cm_t
 |  
 |  defalign
 |      compiler_info_t_defalign_get(self) -> uchar
 |  
 |  id
 |      compiler_info_t_id_get(self) -> comp_t
 |  
 |  size_b
 |      compiler_info_t_size_b_get(self) -> uchar
 |  
 |  size_e
 |      compiler_info_t_size_e_get(self) -> uchar
 |  
 |  size_i
 |      compiler_info_t_size_i_get(self) -> uchar
 |  
 |  size_l
 |      compiler_info_t_size_l_get(self) -> uchar
 |  
 |  size_ldbl
 |      compiler_info_t_size_ldbl_get(self) -> uchar
 |  
 |  size_ll
 |      compiler_info_t_size_ll_get(self) -> uchar
 |  
 |  size_s
 |      compiler_info_t_size_s_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_compiler_info_t>
 |      delete_compiler_info_t(self)

Help on class idainfo in module ida_ida:

class idainfo(__builtin__.object)
 |  Proxy of C++ idainfo class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  big_arg_align = __func(self, *args)
 |  
 |  gen_lzero = __func(self, *args)
 |  
 |  gen_null = __func(self, *args)
 |  
 |  gen_tryblks = __func(self, *args)
 |  
 |  get_abiname(self, *args)
 |      get_abiname(self) -> qstring
 |  
 |  get_demname_form = __func(self, *args)
 |  
 |  get_maxEA(self, *args)
 |      get_maxEA(self) -> ea_t
 |  
 |  get_minEA(self, *args)
 |      get_minEA(self) -> ea_t
 |  
 |  get_pack_mode = __func(self, *args)
 |  
 |  get_procName(self, *args)
 |      get_procName(self) -> qstring
 |  
 |  is_32bit = __func(self, *args)
 |  
 |  is_64bit = __func(self, *args)
 |  
 |  is_auto_enabled = __func(self, *args)
 |  
 |  is_be = __func(self, *args)
 |  
 |  is_dll = __func(self, *args)
 |  
 |  is_flat_off32 = __func(self, *args)
 |  
 |  is_graph_view = __func(self, *args)
 |  
 |  is_hard_float = __func(self, *args)
 |  
 |  is_kernel_mode = __func(self, *args)
 |  
 |  is_mem_aligned4 = __func(self, *args)
 |  
 |  is_snapshot = __func(self, *args)
 |  
 |  is_wide_high_byte_first = __func(self, *args)
 |  
 |  like_binary = __func(self, *args)
 |  
 |  line_pref_with_seg = __func(self, *args)
 |  
 |  loading_idc = __func(self, *args)
 |  
 |  map_stkargs = __func(self, *args)
 |  
 |  pack_stkargs = __func(self, *args)
 |  
 |  readonly_idb = __func(self, *args)
 |  
 |  set_64bit = __func(self, *args)
 |  
 |  set_auto_enabled = __func(self, *args)
 |  
 |  set_be = __func(self, *args)
 |  
 |  set_gen_lzero = __func(self, *args)
 |  
 |  set_gen_null = __func(self, *args)
 |  
 |  set_gen_tryblks = __func(self, *args)
 |  
 |  set_graph_view = __func(self, *args)
 |  
 |  set_line_pref_with_seg = __func(self, *args)
 |  
 |  set_maxEA(self, *args)
 |      set_maxEA(self, ea)
 |          ea: ea_t
 |  
 |  set_minEA(self, *args)
 |      set_minEA(self, ea)
 |          ea: ea_t
 |  
 |  set_pack_mode = __func(self, *args)
 |  
 |  set_show_auto = __func(self, *args)
 |  
 |  set_show_line_pref = __func(self, *args)
 |  
 |  set_show_void = __func(self, *args)
 |  
 |  set_wide_high_byte_first = __func(self, *args)
 |  
 |  show_auto = __func(self, *args)
 |  
 |  show_line_pref = __func(self, *args)
 |  
 |  show_void = __func(self, *args)
 |  
 |  stack_ldbl = __func(self, *args)
 |  
 |  stack_varargs = __func(self, *args)
 |  
 |  use_allasm = __func(self, *args)
 |  
 |  use_gcc_layout = __func(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  abibits
 |      idainfo_abibits_get(self) -> uint32
 |  
 |  abiname
 |      get_abiname(self) -> qstring
 |  
 |  af
 |      idainfo_af_get(self) -> uint32
 |  
 |  af2
 |      idainfo_af2_get(self) -> uint32
 |  
 |  appcall_options
 |      idainfo_appcall_options_get(self) -> uint32
 |  
 |  apptype
 |      idainfo_apptype_get(self) -> ushort
 |  
 |  asmtype
 |      idainfo_asmtype_get(self) -> uchar
 |  
 |  baseaddr
 |      idainfo_baseaddr_get(self) -> uval_t
 |  
 |  bin_prefix_size
 |      idainfo_bin_prefix_size_get(self) -> short
 |  
 |  cc
 |      idainfo_cc_get(self) -> compiler_info_t
 |  
 |  comment
 |      idainfo_comment_get(self) -> uchar
 |  
 |  database_change_count
 |      idainfo_database_change_count_get(self) -> uint32
 |  
 |  datatypes
 |      idainfo_datatypes_get(self) -> uval_t
 |  
 |  demnames
 |      idainfo_demnames_get(self) -> uchar
 |  
 |  filetype
 |      idainfo_filetype_get(self) -> ushort
 |  
 |  highoff
 |      idainfo_highoff_get(self) -> ea_t
 |  
 |  indent
 |      idainfo_indent_get(self) -> uchar
 |  
 |  lenxref
 |      idainfo_lenxref_get(self) -> ushort
 |  
 |  lflags
 |      idainfo_lflags_get(self) -> uint32
 |  
 |  listnames
 |      idainfo_listnames_get(self) -> uchar
 |  
 |  long_demnames
 |      idainfo_long_demnames_get(self) -> uint32
 |  
 |  lowoff
 |      idainfo_lowoff_get(self) -> ea_t
 |  
 |  main
 |      idainfo_main_get(self) -> ea_t
 |  
 |  margin
 |      idainfo_margin_get(self) -> ushort
 |  
 |  maxEA
 |      get_maxEA(self) -> ea_t
 |  
 |  max_autoname_len
 |      idainfo_max_autoname_len_get(self) -> ushort
 |  
 |  max_ea
 |      idainfo_max_ea_get(self) -> ea_t
 |  
 |  maxref
 |      idainfo_maxref_get(self) -> uval_t
 |  
 |  minEA
 |      get_minEA(self) -> ea_t
 |  
 |  min_ea
 |      idainfo_min_ea_get(self) -> ea_t
 |  
 |  nametype
 |      idainfo_nametype_get(self) -> char
 |  
 |  omax_ea
 |      idainfo_omax_ea_get(self) -> ea_t
 |  
 |  omin_ea
 |      idainfo_omin_ea_get(self) -> ea_t
 |  
 |  ostype
 |      idainfo_ostype_get(self) -> ushort
 |  
 |  outflags
 |      idainfo_outflags_get(self) -> uint32
 |  
 |  procName
 |      get_procName(self) -> qstring
 |  
 |  procname
 |      idainfo_procname_get(self) -> char [16]
 |  
 |  refcmtnum
 |      idainfo_refcmtnum_get(self) -> uchar
 |  
 |  s_cmtflg
 |      idainfo_s_cmtflg_get(self) -> uchar
 |  
 |  s_genflags
 |      idainfo_s_genflags_get(self) -> ushort
 |  
 |  s_limiter
 |      idainfo_s_limiter_get(self) -> uchar
 |  
 |  s_prefflag
 |      idainfo_s_prefflag_get(self) -> uchar
 |  
 |  s_xrefflag
 |      idainfo_s_xrefflag_get(self) -> uchar
 |  
 |  short_demnames
 |      idainfo_short_demnames_get(self) -> uint32
 |  
 |  specsegs
 |      idainfo_specsegs_get(self) -> uchar
 |  
 |  start_cs
 |      idainfo_start_cs_get(self) -> sel_t
 |  
 |  start_ea
 |      idainfo_start_ea_get(self) -> ea_t
 |  
 |  start_ip
 |      idainfo_start_ip_get(self) -> ea_t
 |  
 |  start_sp
 |      idainfo_start_sp_get(self) -> ea_t
 |  
 |  start_ss
 |      idainfo_start_ss_get(self) -> sel_t
 |  
 |  strlit_break
 |      idainfo_strlit_break_get(self) -> uchar
 |  
 |  strlit_flags
 |      idainfo_strlit_flags_get(self) -> uchar
 |  
 |  strlit_pref
 |      idainfo_strlit_pref_get(self) -> char [16]
 |  
 |  strlit_sernum
 |      idainfo_strlit_sernum_get(self) -> uval_t
 |  
 |  strlit_zeroes
 |      idainfo_strlit_zeroes_get(self) -> char
 |  
 |  strtype
 |      idainfo_strtype_get(self) -> int32
 |  
 |  tag
 |      idainfo_tag_get(self) -> char [3]
 |  
 |  thisown
 |      The membership flag
 |  
 |  type_xrefnum
 |      idainfo_type_xrefnum_get(self) -> uchar
 |  
 |  version
 |      idainfo_version_get(self) -> ushort
 |  
 |  xrefnum
 |      idainfo_xrefnum_get(self) -> uchar

Help on function inf_big_arg_align in module ida_ida:

inf_big_arg_align(*args)
    inf_big_arg_align() -> bool

Help on function inf_gen_lzero in module ida_ida:

inf_gen_lzero(*args)
    inf_gen_lzero() -> bool

Help on function inf_gen_null in module ida_ida:

inf_gen_null(*args)
    inf_gen_null() -> bool

Help on function inf_gen_tryblks in module ida_ida:

inf_gen_tryblks(*args)
    inf_gen_tryblks() -> bool

Help on function inf_get_demname_form in module ida_ida:

inf_get_demname_form(*args)
    Get 'DEMNAM_MASK' bits of #demnames.

Help on function inf_get_pack_mode in module ida_ida:

inf_get_pack_mode(*args)
    inf_get_pack_mode() -> int

Help on function inf_is_32bit in module ida_ida:

inf_is_32bit(*args)
    inf_is_32bit() -> bool

Help on function inf_is_64bit in module ida_ida:

inf_is_64bit(*args)
    inf_is_64bit() -> bool

Help on function inf_is_auto_enabled in module ida_ida:

inf_is_auto_enabled(*args)
    inf_is_auto_enabled() -> bool

Help on function inf_is_be in module ida_ida:

inf_is_be(*args)
    inf_is_be() -> bool

Help on function inf_is_dll in module ida_ida:

inf_is_dll(*args)
    inf_is_dll() -> bool

Help on function inf_is_flat_off32 in module ida_ida:

inf_is_flat_off32(*args)
    inf_is_flat_off32() -> bool

Help on function inf_is_graph_view in module ida_ida:

inf_is_graph_view(*args)
    inf_is_graph_view() -> bool

Help on function inf_is_hard_float in module ida_ida:

inf_is_hard_float(*args)
    inf_is_hard_float() -> bool

Help on function inf_is_kernel_mode in module ida_ida:

inf_is_kernel_mode(*args)
    inf_is_kernel_mode() -> bool

Help on function inf_is_mem_aligned4 in module ida_ida:

inf_is_mem_aligned4(*args)
    inf_is_mem_aligned4() -> bool

Help on function inf_is_snapshot in module ida_ida:

inf_is_snapshot(*args)
    inf_is_snapshot() -> bool

Help on function inf_is_wide_high_byte_first in module ida_ida:

inf_is_wide_high_byte_first(*args)
    inf_is_wide_high_byte_first() -> bool

Help on function inf_like_binary in module ida_ida:

inf_like_binary(*args)
    inf_like_binary() -> bool

Help on function inf_line_pref_with_seg in module ida_ida:

inf_line_pref_with_seg(*args)
    inf_line_pref_with_seg() -> bool

Help on function inf_loading_idc in module ida_ida:

inf_loading_idc(*args)
    inf_loading_idc() -> bool

Help on function inf_map_stkargs in module ida_ida:

inf_map_stkargs(*args)
    inf_map_stkargs() -> bool

Help on function inf_pack_stkargs in module ida_ida:

inf_pack_stkargs(*args)
    inf_pack_stkargs() -> bool

Help on function inf_readonly_idb in module ida_ida:

inf_readonly_idb(*args)
    inf_readonly_idb() -> bool

Help on function inf_set_64bit in module ida_ida:

inf_set_64bit(*args)
    inf_set_64bit(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_auto_enabled in module ida_ida:

inf_set_auto_enabled(*args)
    inf_set_auto_enabled(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_be in module ida_ida:

inf_set_be(*args)
    inf_set_be(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_gen_lzero in module ida_ida:

inf_set_gen_lzero(*args)
    inf_set_gen_lzero(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_gen_null in module ida_ida:

inf_set_gen_null(*args)
    inf_set_gen_null(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_gen_tryblks in module ida_ida:

inf_set_gen_tryblks(*args)
    inf_set_gen_tryblks(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_graph_view in module ida_ida:

inf_set_graph_view(*args)
    inf_set_graph_view(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_line_pref_with_seg in module ida_ida:

inf_set_line_pref_with_seg(*args)
    inf_set_line_pref_with_seg(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_pack_mode in module ida_ida:

inf_set_pack_mode(*args)
    inf_set_pack_mode(pack_mode) -> int
        @param pack_mode (C++: int)

Help on function inf_set_show_auto in module ida_ida:

inf_set_show_auto(*args)
    inf_set_show_auto(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_line_pref in module ida_ida:

inf_set_show_line_pref(*args)
    inf_set_show_line_pref(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_void in module ida_ida:

inf_set_show_void(*args)
    inf_set_show_void(_v=True) -> bool
        @param _v (C++: bool)

Help on function <lambda> in module ida_ida:

<lambda> lambda *args

Help on function inf_set_wide_high_byte_first in module ida_ida:

inf_set_wide_high_byte_first(*args)
    inf_set_wide_high_byte_first(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_show_auto in module ida_ida:

inf_show_auto(*args)
    inf_show_auto() -> bool

Help on function inf_show_line_pref in module ida_ida:

inf_show_line_pref(*args)
    inf_show_line_pref() -> bool

Help on function inf_show_void in module ida_ida:

inf_show_void(*args)
    inf_show_void() -> bool

Help on function inf_stack_ldbl in module ida_ida:

inf_stack_ldbl(*args)
    inf_stack_ldbl() -> bool

Help on function inf_stack_varargs in module ida_ida:

inf_stack_varargs(*args)
    inf_stack_varargs() -> bool

Help on function inf_use_allasm in module ida_ida:

inf_use_allasm(*args)
    inf_use_allasm() -> bool

Help on function inf_use_gcc_layout in module ida_ida:

inf_use_gcc_layout(*args)
    inf_use_gcc_layout() -> bool

Help on function inf_abi_set_by_user in module ida_ida:

inf_abi_set_by_user(*args)
    inf_abi_set_by_user() -> bool

Help on function inf_allow_non_matched_ops in module ida_ida:

inf_allow_non_matched_ops(*args)
    inf_allow_non_matched_ops() -> bool

Help on function inf_allow_sigmulti in module ida_ida:

inf_allow_sigmulti(*args)
    inf_allow_sigmulti() -> bool

Help on function inf_append_sigcmt in module ida_ida:

inf_append_sigcmt(*args)
    inf_append_sigcmt() -> bool

Help on function inf_check_manual_ops in module ida_ida:

inf_check_manual_ops(*args)
    inf_check_manual_ops() -> bool

Help on function inf_check_unicode_strlits in module ida_ida:

inf_check_unicode_strlits(*args)
    inf_check_unicode_strlits() -> bool

Help on function inf_coagulate_code in module ida_ida:

inf_coagulate_code(*args)
    inf_coagulate_code() -> bool

Help on function inf_coagulate_data in module ida_ida:

inf_coagulate_data(*args)
    inf_coagulate_data() -> bool

Help on function inf_compress_idb in module ida_ida:

inf_compress_idb(*args)
    inf_compress_idb() -> bool

Help on function inf_create_all_xrefs in module ida_ida:

inf_create_all_xrefs(*args)
    inf_create_all_xrefs() -> bool

Help on function inf_create_func_from_call in module ida_ida:

inf_create_func_from_call(*args)
    inf_create_func_from_call() -> bool

Help on function inf_create_func_from_ptr in module ida_ida:

inf_create_func_from_ptr(*args)
    inf_create_func_from_ptr() -> bool

Help on function inf_create_func_tails in module ida_ida:

inf_create_func_tails(*args)
    inf_create_func_tails() -> bool

Help on function inf_create_jump_tables in module ida_ida:

inf_create_jump_tables(*args)
    inf_create_jump_tables() -> bool

Help on function inf_create_off_on_dref in module ida_ida:

inf_create_off_on_dref(*args)
    inf_create_off_on_dref() -> bool

Help on function inf_create_off_using_fixup in module ida_ida:

inf_create_off_using_fixup(*args)
    inf_create_off_using_fixup() -> bool

Help on function inf_create_strlit_on_xref in module ida_ida:

inf_create_strlit_on_xref(*args)
    inf_create_strlit_on_xref() -> bool

Help on function inf_data_offset in module ida_ida:

inf_data_offset(*args)
    inf_data_offset() -> bool

Help on function inf_dbg_no_store_path in module ida_ida:

inf_dbg_no_store_path(*args)
    inf_dbg_no_store_path() -> bool

Help on function inf_decode_fpp in module ida_ida:

inf_decode_fpp(*args)
    inf_decode_fpp() -> bool

Help on function inf_del_no_xref_insns in module ida_ida:

inf_del_no_xref_insns(*args)
    inf_del_no_xref_insns() -> bool

Help on function inf_final_pass in module ida_ida:

inf_final_pass(*args)
    inf_final_pass() -> bool

Help on function inf_full_sp_ana in module ida_ida:

inf_full_sp_ana(*args)
    inf_full_sp_ana() -> bool

Help on function inf_gen_assume in module ida_ida:

inf_gen_assume(*args)
    inf_gen_assume() -> bool

Help on function inf_gen_org in module ida_ida:

inf_gen_org(*args)
    inf_gen_org() -> bool

Help on function inf_get_abibits in module ida_ida:

inf_get_abibits(*args)
    inf_get_abibits() -> uint32

Help on function inf_get_af in module ida_ida:

inf_get_af(*args)
    inf_get_af() -> uint32

Help on function inf_get_af2 in module ida_ida:

inf_get_af2(*args)
    inf_get_af2() -> uint32

Help on function inf_get_af2_low in module ida_ida:

inf_get_af2_low(*args)
    Get/set low 16bit half of inf.af2.

Help on function inf_get_af_high in module ida_ida:

inf_get_af_high(*args)
    inf_get_af_high() -> ushort

Help on function inf_get_af_low in module ida_ida:

inf_get_af_low(*args)
    Get/set low/high 16bit halves of inf.af.

Help on function inf_get_appcall_options in module ida_ida:

inf_get_appcall_options(*args)
    inf_get_appcall_options() -> uint32

Help on function inf_get_apptype in module ida_ida:

inf_get_apptype(*args)
    inf_get_apptype() -> ushort

Help on function inf_get_asmtype in module ida_ida:

inf_get_asmtype(*args)
    inf_get_asmtype() -> uchar

Help on function inf_get_baseaddr in module ida_ida:

inf_get_baseaddr(*args)
    inf_get_baseaddr() -> uval_t

Help on function inf_get_bin_prefix_size in module ida_ida:

inf_get_bin_prefix_size(*args)
    inf_get_bin_prefix_size() -> short

Help on function inf_get_cc in module ida_ida:

inf_get_cc(*args)
    inf_get_cc(out) -> bool
        @param out (C++: compiler_info_t  *)

Help on function inf_get_cc_cm in module ida_ida:

inf_get_cc_cm(*args)
    inf_get_cc_cm() -> cm_t

Help on function inf_get_cc_defalign in module ida_ida:

inf_get_cc_defalign(*args)
    inf_get_cc_defalign() -> uchar

Help on function inf_get_cc_id in module ida_ida:

inf_get_cc_id(*args)
    inf_get_cc_id() -> comp_t

Help on function inf_get_cc_size_b in module ida_ida:

inf_get_cc_size_b(*args)
    inf_get_cc_size_b() -> uchar

Help on function inf_get_cc_size_e in module ida_ida:

inf_get_cc_size_e(*args)
    inf_get_cc_size_e() -> uchar

Help on function inf_get_cc_size_i in module ida_ida:

inf_get_cc_size_i(*args)
    inf_get_cc_size_i() -> uchar

Help on function inf_get_cc_size_l in module ida_ida:

inf_get_cc_size_l(*args)
    inf_get_cc_size_l() -> uchar

Help on function inf_get_cc_size_ldbl in module ida_ida:

inf_get_cc_size_ldbl(*args)
    inf_get_cc_size_ldbl() -> uchar

Help on function inf_get_cc_size_ll in module ida_ida:

inf_get_cc_size_ll(*args)
    inf_get_cc_size_ll() -> uchar

Help on function inf_get_cc_size_s in module ida_ida:

inf_get_cc_size_s(*args)
    inf_get_cc_size_s() -> uchar

Help on function inf_get_cmtflg in module ida_ida:

inf_get_cmtflg(*args)
    inf_get_cmtflg() -> uchar

Help on function inf_get_comment in module ida_ida:

inf_get_comment(*args)
    inf_get_comment() -> uchar

Help on function inf_get_database_change_count in module ida_ida:

inf_get_database_change_count(*args)
    inf_get_database_change_count() -> uint32

Help on function inf_get_datatypes in module ida_ida:

inf_get_datatypes(*args)
    inf_get_datatypes() -> uval_t

Help on function inf_get_demnames in module ida_ida:

inf_get_demnames(*args)
    inf_get_demnames() -> uchar

Help on function inf_get_filetype in module ida_ida:

inf_get_filetype(*args)
    inf_get_filetype() -> filetype_t

Help on function inf_get_genflags in module ida_ida:

inf_get_genflags(*args)
    inf_get_genflags() -> ushort

Help on function inf_get_highoff in module ida_ida:

inf_get_highoff(*args)
    inf_get_highoff() -> ea_t

Help on function inf_get_indent in module ida_ida:

inf_get_indent(*args)
    inf_get_indent() -> uchar

Help on function inf_get_lenxref in module ida_ida:

inf_get_lenxref(*args)
    inf_get_lenxref() -> ushort

Help on function inf_get_lflags in module ida_ida:

inf_get_lflags(*args)
    inf_get_lflags() -> uint32

Help on function inf_get_limiter in module ida_ida:

inf_get_limiter(*args)
    inf_get_limiter() -> uchar

Help on function inf_get_listnames in module ida_ida:

inf_get_listnames(*args)
    inf_get_listnames() -> uchar

Help on function inf_get_long_demnames in module ida_ida:

inf_get_long_demnames(*args)
    inf_get_long_demnames() -> uint32

Help on function inf_get_lowoff in module ida_ida:

inf_get_lowoff(*args)
    inf_get_lowoff() -> ea_t

Help on function inf_get_main in module ida_ida:

inf_get_main(*args)
    inf_get_main() -> ea_t

Help on function inf_get_margin in module ida_ida:

inf_get_margin(*args)
    inf_get_margin() -> ushort

Help on function inf_get_max_autoname_len in module ida_ida:

inf_get_max_autoname_len(*args)
    inf_get_max_autoname_len() -> ushort

Help on function inf_get_max_ea in module ida_ida:

inf_get_max_ea(*args)
    inf_get_max_ea() -> ea_t

Help on function inf_get_maxref in module ida_ida:

inf_get_maxref(*args)
    inf_get_maxref() -> uval_t

Help on function inf_get_min_ea in module ida_ida:

inf_get_min_ea(*args)
    inf_get_min_ea() -> ea_t

Help on function inf_get_nametype in module ida_ida:

inf_get_nametype(*args)
    inf_get_nametype() -> char

Help on function inf_get_netdelta in module ida_ida:

inf_get_netdelta(*args)
    inf_get_netdelta() -> sval_t

Help on function inf_get_omax_ea in module ida_ida:

inf_get_omax_ea(*args)
    inf_get_omax_ea() -> ea_t

Help on function inf_get_omin_ea in module ida_ida:

inf_get_omin_ea(*args)
    inf_get_omin_ea() -> ea_t

Help on function inf_get_ostype in module ida_ida:

inf_get_ostype(*args)
    inf_get_ostype() -> ushort

Help on function inf_get_outflags in module ida_ida:

inf_get_outflags(*args)
    inf_get_outflags() -> uint32

Help on function inf_get_prefflag in module ida_ida:

inf_get_prefflag(*args)
    inf_get_prefflag() -> uchar

Help on function inf_get_privrange in module ida_ida:

inf_get_privrange(*args)
    inf_get_privrange(out) -> bool
        @param out (C++: range_t  *)

Help on function inf_get_privrange_end_ea in module ida_ida:

inf_get_privrange_end_ea(*args)
    inf_get_privrange_end_ea() -> ea_t

Help on function inf_get_privrange_start_ea in module ida_ida:

inf_get_privrange_start_ea(*args)
    inf_get_privrange_start_ea() -> ea_t

Help on function inf_get_procname in module ida_ida:

inf_get_procname(*args)
    inf_get_procname() -> str

Help on function inf_get_refcmtnum in module ida_ida:

inf_get_refcmtnum(*args)
    inf_get_refcmtnum() -> uchar

Help on function inf_get_short_demnames in module ida_ida:

inf_get_short_demnames(*args)
    inf_get_short_demnames() -> uint32

Help on function inf_get_specsegs in module ida_ida:

inf_get_specsegs(*args)
    inf_get_specsegs() -> uchar

Help on function inf_get_start_cs in module ida_ida:

inf_get_start_cs(*args)
    inf_get_start_cs() -> sel_t

Help on function inf_get_start_ea in module ida_ida:

inf_get_start_ea(*args)
    inf_get_start_ea() -> ea_t

Help on function inf_get_start_ip in module ida_ida:

inf_get_start_ip(*args)
    inf_get_start_ip() -> ea_t

Help on function inf_get_start_sp in module ida_ida:

inf_get_start_sp(*args)
    inf_get_start_sp() -> ea_t

Help on function inf_get_start_ss in module ida_ida:

inf_get_start_ss(*args)
    inf_get_start_ss() -> sel_t

Help on function inf_get_strlit_break in module ida_ida:

inf_get_strlit_break(*args)
    inf_get_strlit_break() -> uchar

Help on function inf_get_strlit_flags in module ida_ida:

inf_get_strlit_flags(*args)
    inf_get_strlit_flags() -> uchar

Help on function inf_get_strlit_pref in module ida_ida:

inf_get_strlit_pref(*args)
    inf_get_strlit_pref() -> str

Help on function inf_get_strlit_sernum in module ida_ida:

inf_get_strlit_sernum(*args)
    inf_get_strlit_sernum() -> uval_t

Help on function inf_get_strlit_zeroes in module ida_ida:

inf_get_strlit_zeroes(*args)
    inf_get_strlit_zeroes() -> char

Help on function inf_get_strtype in module ida_ida:

inf_get_strtype(*args)
    inf_get_strtype() -> int32

Help on function inf_get_type_xrefnum in module ida_ida:

inf_get_type_xrefnum(*args)
    inf_get_type_xrefnum() -> uchar

Help on function inf_get_version in module ida_ida:

inf_get_version(*args)
    inf_get_version() -> ushort

Help on function inf_get_xrefflag in module ida_ida:

inf_get_xrefflag(*args)
    inf_get_xrefflag() -> uchar

Help on function inf_get_xrefnum in module ida_ida:

inf_get_xrefnum(*args)
    inf_get_xrefnum() -> uchar

Help on function inf_guess_func_type in module ida_ida:

inf_guess_func_type(*args)
    inf_guess_func_type() -> bool

Help on function inf_handle_eh in module ida_ida:

inf_handle_eh(*args)
    inf_handle_eh() -> bool

Help on function inf_handle_rtti in module ida_ida:

inf_handle_rtti(*args)
    inf_handle_rtti() -> bool

Help on function inf_hide_comments in module ida_ida:

inf_hide_comments(*args)
    inf_hide_comments() -> bool

Help on function inf_hide_libfuncs in module ida_ida:

inf_hide_libfuncs(*args)
    inf_hide_libfuncs() -> bool

Help on function inf_huge_arg_align in module ida_ida:

inf_huge_arg_align(*args)
    inf_huge_arg_align() -> bool

Help on function inf_inc_database_change_count in module ida_ida:

inf_inc_database_change_count(*args)
    inf_inc_database_change_count(cnt=1)
        @param cnt (C++: int)

Help on function inf_is_limiter_empty in module ida_ida:

inf_is_limiter_empty(*args)
    inf_is_limiter_empty() -> bool

Help on function inf_is_limiter_thick in module ida_ida:

inf_is_limiter_thick(*args)
    inf_is_limiter_thick() -> bool

Help on function inf_is_limiter_thin in module ida_ida:

inf_is_limiter_thin(*args)
    inf_is_limiter_thin() -> bool

Help on function inf_macros_enabled in module ida_ida:

inf_macros_enabled(*args)
    inf_macros_enabled() -> bool

Help on function inf_mark_code in module ida_ida:

inf_mark_code(*args)
    inf_mark_code() -> bool

Help on function inf_no_store_user_info in module ida_ida:

inf_no_store_user_info(*args)
    inf_no_store_user_info() -> bool

Help on function inf_noflow_to_data in module ida_ida:

inf_noflow_to_data(*args)
    inf_noflow_to_data() -> bool

Help on function inf_noret_ana in module ida_ida:

inf_noret_ana(*args)
    inf_noret_ana() -> bool

Help on function inf_op_offset in module ida_ida:

inf_op_offset(*args)
    inf_op_offset() -> bool

Help on function inf_pack_idb in module ida_ida:

inf_pack_idb(*args)
    inf_pack_idb() -> bool

Help on function inf_postinc_strlit_sernum in module ida_ida:

inf_postinc_strlit_sernum(*args)
    inf_postinc_strlit_sernum(cnt=1) -> uval_t
        @param cnt (C++: uval_t)

Help on function inf_prefix_show_funcoff in module ida_ida:

inf_prefix_show_funcoff(*args)
    inf_prefix_show_funcoff() -> bool

Help on function inf_prefix_show_segaddr in module ida_ida:

inf_prefix_show_segaddr(*args)
    inf_prefix_show_segaddr() -> bool

Help on function inf_prefix_show_stack in module ida_ida:

inf_prefix_show_stack(*args)
    inf_prefix_show_stack() -> bool

Help on function inf_prefix_truncate_opcode_bytes in module ida_ida:

inf_prefix_truncate_opcode_bytes(*args)
    inf_prefix_truncate_opcode_bytes() -> bool

Help on function inf_propagate_regargs in module ida_ida:

inf_propagate_regargs(*args)
    inf_propagate_regargs() -> bool

Help on function inf_propagate_stkargs in module ida_ida:

inf_propagate_stkargs(*args)
    inf_propagate_stkargs() -> bool

Help on function inf_rename_jumpfunc in module ida_ida:

inf_rename_jumpfunc(*args)
    inf_rename_jumpfunc() -> bool

Help on function inf_rename_nullsub in module ida_ida:

inf_rename_nullsub(*args)
    inf_rename_nullsub() -> bool

Help on function inf_set_32bit in module ida_ida:

inf_set_32bit(*args)
    inf_set_32bit(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_abi_set_by_user in module ida_ida:

inf_set_abi_set_by_user(*args)
    inf_set_abi_set_by_user(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_abibits in module ida_ida:

inf_set_abibits(*args)
    inf_set_abibits(_v) -> bool
        @param _v (C++: uint32)

Help on function inf_set_af in module ida_ida:

inf_set_af(*args)
    inf_set_af(_v) -> bool
        @param _v (C++: uint32)

Help on function inf_set_af2 in module ida_ida:

inf_set_af2(*args)
    inf_set_af2(_v) -> bool
        @param _v (C++: uint32)

Help on function inf_set_af2_low in module ida_ida:

inf_set_af2_low(*args)
    inf_set_af2_low(saf)
        @param saf (C++: ushort)

Help on function inf_set_af_high in module ida_ida:

inf_set_af_high(*args)
    inf_set_af_high(saf2)
        @param saf2 (C++: ushort)

Help on function inf_set_af_low in module ida_ida:

inf_set_af_low(*args)
    inf_set_af_low(saf)
        @param saf (C++: ushort)

Help on function inf_set_allow_non_matched_ops in module ida_ida:

inf_set_allow_non_matched_ops(*args)
    inf_set_allow_non_matched_ops(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_allow_sigmulti in module ida_ida:

inf_set_allow_sigmulti(*args)
    inf_set_allow_sigmulti(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_appcall_options in module ida_ida:

inf_set_appcall_options(*args)
    inf_set_appcall_options(_v) -> bool
        @param _v (C++: uint32)

Help on function inf_set_append_sigcmt in module ida_ida:

inf_set_append_sigcmt(*args)
    inf_set_append_sigcmt(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_apptype in module ida_ida:

inf_set_apptype(*args)
    inf_set_apptype(_v) -> bool
        @param _v (C++: ushort)

Help on function inf_set_asmtype in module ida_ida:

inf_set_asmtype(*args)
    inf_set_asmtype(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_baseaddr in module ida_ida:

inf_set_baseaddr(*args)
    inf_set_baseaddr(_v) -> bool
        @param _v (C++: uval_t)

Help on function inf_set_big_arg_align in module ida_ida:

inf_set_big_arg_align(*args)
    inf_set_big_arg_align(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_bin_prefix_size in module ida_ida:

inf_set_bin_prefix_size(*args)
    inf_set_bin_prefix_size(_v) -> bool
        @param _v (C++: short)

Help on function inf_set_cc in module ida_ida:

inf_set_cc(*args)
    inf_set_cc(_v) -> bool
        @param _v (C++: const  compiler_info_t  &)

Help on function inf_set_cc_cm in module ida_ida:

inf_set_cc_cm(*args)
    inf_set_cc_cm(_v) -> bool
        @param _v (C++: cm_t)

Help on function inf_set_cc_defalign in module ida_ida:

inf_set_cc_defalign(*args)
    inf_set_cc_defalign(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_cc_id in module ida_ida:

inf_set_cc_id(*args)
    inf_set_cc_id(_v) -> bool
        @param _v (C++: comp_t)

Help on function inf_set_cc_size_b in module ida_ida:

inf_set_cc_size_b(*args)
    inf_set_cc_size_b(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_cc_size_e in module ida_ida:

inf_set_cc_size_e(*args)
    inf_set_cc_size_e(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_cc_size_i in module ida_ida:

inf_set_cc_size_i(*args)
    inf_set_cc_size_i(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_cc_size_l in module ida_ida:

inf_set_cc_size_l(*args)
    inf_set_cc_size_l(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_cc_size_ldbl in module ida_ida:

inf_set_cc_size_ldbl(*args)
    inf_set_cc_size_ldbl(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_cc_size_ll in module ida_ida:

inf_set_cc_size_ll(*args)
    inf_set_cc_size_ll(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_cc_size_s in module ida_ida:

inf_set_cc_size_s(*args)
    inf_set_cc_size_s(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_check_manual_ops in module ida_ida:

inf_set_check_manual_ops(*args)
    inf_set_check_manual_ops(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_check_unicode_strlits in module ida_ida:

inf_set_check_unicode_strlits(*args)
    inf_set_check_unicode_strlits(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_cmtflg in module ida_ida:

inf_set_cmtflg(*args)
    inf_set_cmtflg(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_coagulate_code in module ida_ida:

inf_set_coagulate_code(*args)
    inf_set_coagulate_code(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_coagulate_data in module ida_ida:

inf_set_coagulate_data(*args)
    inf_set_coagulate_data(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_comment in module ida_ida:

inf_set_comment(*args)
    inf_set_comment(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_compress_idb in module ida_ida:

inf_set_compress_idb(*args)
    inf_set_compress_idb(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_create_all_xrefs in module ida_ida:

inf_set_create_all_xrefs(*args)
    inf_set_create_all_xrefs(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_create_func_from_call in module ida_ida:

inf_set_create_func_from_call(*args)
    inf_set_create_func_from_call(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_create_func_from_ptr in module ida_ida:

inf_set_create_func_from_ptr(*args)
    inf_set_create_func_from_ptr(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_create_func_tails in module ida_ida:

inf_set_create_func_tails(*args)
    inf_set_create_func_tails(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_create_jump_tables in module ida_ida:

inf_set_create_jump_tables(*args)
    inf_set_create_jump_tables(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_create_off_on_dref in module ida_ida:

inf_set_create_off_on_dref(*args)
    inf_set_create_off_on_dref(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_create_off_using_fixup in module ida_ida:

inf_set_create_off_using_fixup(*args)
    inf_set_create_off_using_fixup(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_create_strlit_on_xref in module ida_ida:

inf_set_create_strlit_on_xref(*args)
    inf_set_create_strlit_on_xref(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_data_offset in module ida_ida:

inf_set_data_offset(*args)
    inf_set_data_offset(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_database_change_count in module ida_ida:

inf_set_database_change_count(*args)
    inf_set_database_change_count(_v) -> bool
        @param _v (C++: uint32)

Help on function inf_set_datatypes in module ida_ida:

inf_set_datatypes(*args)
    inf_set_datatypes(_v) -> bool
        @param _v (C++: uval_t)

Help on function inf_set_dbg_no_store_path in module ida_ida:

inf_set_dbg_no_store_path(*args)
    inf_set_dbg_no_store_path(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_decode_fpp in module ida_ida:

inf_set_decode_fpp(*args)
    inf_set_decode_fpp(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_del_no_xref_insns in module ida_ida:

inf_set_del_no_xref_insns(*args)
    inf_set_del_no_xref_insns(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_demnames in module ida_ida:

inf_set_demnames(*args)
    inf_set_demnames(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_dll in module ida_ida:

inf_set_dll(*args)
    inf_set_dll(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_filetype in module ida_ida:

inf_set_filetype(*args)
    inf_set_filetype(_v) -> bool
        @param _v (C++: filetype_t)

Help on function inf_set_final_pass in module ida_ida:

inf_set_final_pass(*args)
    inf_set_final_pass(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_flat_off32 in module ida_ida:

inf_set_flat_off32(*args)
    inf_set_flat_off32(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_full_sp_ana in module ida_ida:

inf_set_full_sp_ana(*args)
    inf_set_full_sp_ana(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_gen_assume in module ida_ida:

inf_set_gen_assume(*args)
    inf_set_gen_assume(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_gen_org in module ida_ida:

inf_set_gen_org(*args)
    inf_set_gen_org(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_genflags in module ida_ida:

inf_set_genflags(*args)
    inf_set_genflags(_v) -> bool
        @param _v (C++: ushort)

Help on function inf_set_guess_func_type in module ida_ida:

inf_set_guess_func_type(*args)
    inf_set_guess_func_type(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_handle_eh in module ida_ida:

inf_set_handle_eh(*args)
    inf_set_handle_eh(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_handle_rtti in module ida_ida:

inf_set_handle_rtti(*args)
    inf_set_handle_rtti(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_hard_float in module ida_ida:

inf_set_hard_float(*args)
    inf_set_hard_float(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_hide_comments in module ida_ida:

inf_set_hide_comments(*args)
    inf_set_hide_comments(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_hide_libfuncs in module ida_ida:

inf_set_hide_libfuncs(*args)
    inf_set_hide_libfuncs(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_highoff in module ida_ida:

inf_set_highoff(*args)
    inf_set_highoff(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_huge_arg_align in module ida_ida:

inf_set_huge_arg_align(*args)
    inf_set_huge_arg_align(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_indent in module ida_ida:

inf_set_indent(*args)
    inf_set_indent(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_kernel_mode in module ida_ida:

inf_set_kernel_mode(*args)
    inf_set_kernel_mode(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_lenxref in module ida_ida:

inf_set_lenxref(*args)
    inf_set_lenxref(_v) -> bool
        @param _v (C++: ushort)

Help on function inf_set_lflags in module ida_ida:

inf_set_lflags(*args)
    inf_set_lflags(_v) -> bool
        @param _v (C++: uint32)

Help on function inf_set_limiter in module ida_ida:

inf_set_limiter(*args)
    inf_set_limiter(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_limiter_empty in module ida_ida:

inf_set_limiter_empty(*args)
    inf_set_limiter_empty(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_limiter_thick in module ida_ida:

inf_set_limiter_thick(*args)
    inf_set_limiter_thick(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_limiter_thin in module ida_ida:

inf_set_limiter_thin(*args)
    inf_set_limiter_thin(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_listnames in module ida_ida:

inf_set_listnames(*args)
    inf_set_listnames(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_loading_idc in module ida_ida:

inf_set_loading_idc(*args)
    inf_set_loading_idc(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_long_demnames in module ida_ida:

inf_set_long_demnames(*args)
    inf_set_long_demnames(_v) -> bool
        @param _v (C++: uint32)

Help on function inf_set_lowoff in module ida_ida:

inf_set_lowoff(*args)
    inf_set_lowoff(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_macros_enabled in module ida_ida:

inf_set_macros_enabled(*args)
    inf_set_macros_enabled(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_main in module ida_ida:

inf_set_main(*args)
    inf_set_main(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_map_stkargs in module ida_ida:

inf_set_map_stkargs(*args)
    inf_set_map_stkargs(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_margin in module ida_ida:

inf_set_margin(*args)
    inf_set_margin(_v) -> bool
        @param _v (C++: ushort)

Help on function inf_set_mark_code in module ida_ida:

inf_set_mark_code(*args)
    inf_set_mark_code(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_max_autoname_len in module ida_ida:

inf_set_max_autoname_len(*args)
    inf_set_max_autoname_len(_v) -> bool
        @param _v (C++: ushort)

Help on function inf_set_max_ea in module ida_ida:

inf_set_max_ea(*args)
    inf_set_max_ea(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_maxref in module ida_ida:

inf_set_maxref(*args)
    inf_set_maxref(_v) -> bool
        @param _v (C++: uval_t)

Help on function inf_set_mem_aligned4 in module ida_ida:

inf_set_mem_aligned4(*args)
    inf_set_mem_aligned4(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_min_ea in module ida_ida:

inf_set_min_ea(*args)
    inf_set_min_ea(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_nametype in module ida_ida:

inf_set_nametype(*args)
    inf_set_nametype(_v) -> bool
        @param _v (C++: char)

Help on function inf_set_netdelta in module ida_ida:

inf_set_netdelta(*args)
    inf_set_netdelta(_v) -> bool
        @param _v (C++: sval_t)

Help on function inf_set_no_store_user_info in module ida_ida:

inf_set_no_store_user_info(*args)
    inf_set_no_store_user_info(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_noflow_to_data in module ida_ida:

inf_set_noflow_to_data(*args)
    inf_set_noflow_to_data(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_noret_ana in module ida_ida:

inf_set_noret_ana(*args)
    inf_set_noret_ana(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_omax_ea in module ida_ida:

inf_set_omax_ea(*args)
    inf_set_omax_ea(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_omin_ea in module ida_ida:

inf_set_omin_ea(*args)
    inf_set_omin_ea(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_op_offset in module ida_ida:

inf_set_op_offset(*args)
    inf_set_op_offset(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_ostype in module ida_ida:

inf_set_ostype(*args)
    inf_set_ostype(_v) -> bool
        @param _v (C++: ushort)

Help on function inf_set_outflags in module ida_ida:

inf_set_outflags(*args)
    inf_set_outflags(_v) -> bool
        @param _v (C++: uint32)

Help on function inf_set_pack_idb in module ida_ida:

inf_set_pack_idb(*args)
    inf_set_pack_idb(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_pack_stkargs in module ida_ida:

inf_set_pack_stkargs(*args)
    inf_set_pack_stkargs(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_prefflag in module ida_ida:

inf_set_prefflag(*args)
    inf_set_prefflag(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_prefix_show_funcoff in module ida_ida:

inf_set_prefix_show_funcoff(*args)
    inf_set_prefix_show_funcoff(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_prefix_show_segaddr in module ida_ida:

inf_set_prefix_show_segaddr(*args)
    inf_set_prefix_show_segaddr(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_prefix_show_stack in module ida_ida:

inf_set_prefix_show_stack(*args)
    inf_set_prefix_show_stack(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_prefix_truncate_opcode_bytes in module ida_ida:

inf_set_prefix_truncate_opcode_bytes(*args)
    inf_set_prefix_truncate_opcode_bytes(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_privrange in module ida_ida:

inf_set_privrange(*args)
    inf_set_privrange(_v) -> bool
        @param _v (C++: const  range_t  &)

Help on function inf_set_privrange_end_ea in module ida_ida:

inf_set_privrange_end_ea(*args)
    inf_set_privrange_end_ea(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_privrange_start_ea in module ida_ida:

inf_set_privrange_start_ea(*args)
    inf_set_privrange_start_ea(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_procname in module ida_ida:

inf_set_procname(*args)
    inf_set_procname(_v, len=size_t(-1)) -> bool
        @param _v (C++: const char *)
        @param len (C++: size_t)

Help on function inf_set_propagate_regargs in module ida_ida:

inf_set_propagate_regargs(*args)
    inf_set_propagate_regargs(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_propagate_stkargs in module ida_ida:

inf_set_propagate_stkargs(*args)
    inf_set_propagate_stkargs(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_readonly_idb in module ida_ida:

inf_set_readonly_idb(*args)
    inf_set_readonly_idb(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_refcmtnum in module ida_ida:

inf_set_refcmtnum(*args)
    inf_set_refcmtnum(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_rename_jumpfunc in module ida_ida:

inf_set_rename_jumpfunc(*args)
    inf_set_rename_jumpfunc(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_rename_nullsub in module ida_ida:

inf_set_rename_nullsub(*args)
    inf_set_rename_nullsub(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_short_demnames in module ida_ida:

inf_set_short_demnames(*args)
    inf_set_short_demnames(_v) -> bool
        @param _v (C++: uint32)

Help on function inf_set_should_create_stkvars in module ida_ida:

inf_set_should_create_stkvars(*args)
    inf_set_should_create_stkvars(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_should_trace_sp in module ida_ida:

inf_set_should_trace_sp(*args)
    inf_set_should_trace_sp(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_all_comments in module ida_ida:

inf_set_show_all_comments(*args)
    inf_set_show_all_comments(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_hidden_funcs in module ida_ida:

inf_set_show_hidden_funcs(*args)
    inf_set_show_hidden_funcs(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_hidden_insns in module ida_ida:

inf_set_show_hidden_insns(*args)
    inf_set_show_hidden_insns(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_hidden_segms in module ida_ida:

inf_set_show_hidden_segms(*args)
    inf_set_show_hidden_segms(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_repeatables in module ida_ida:

inf_set_show_repeatables(*args)
    inf_set_show_repeatables(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_src_linnum in module ida_ida:

inf_set_show_src_linnum(*args)
    inf_set_show_src_linnum(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_xref_fncoff in module ida_ida:

inf_set_show_xref_fncoff(*args)
    inf_set_show_xref_fncoff(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_xref_seg in module ida_ida:

inf_set_show_xref_seg(*args)
    inf_set_show_xref_seg(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_xref_tmarks in module ida_ida:

inf_set_show_xref_tmarks(*args)
    inf_set_show_xref_tmarks(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_show_xref_val in module ida_ida:

inf_set_show_xref_val(*args)
    inf_set_show_xref_val(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_snapshot in module ida_ida:

inf_set_snapshot(*args)
    inf_set_snapshot(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_specsegs in module ida_ida:

inf_set_specsegs(*args)
    inf_set_specsegs(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_stack_ldbl in module ida_ida:

inf_set_stack_ldbl(*args)
    inf_set_stack_ldbl(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_stack_varargs in module ida_ida:

inf_set_stack_varargs(*args)
    inf_set_stack_varargs(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_start_cs in module ida_ida:

inf_set_start_cs(*args)
    inf_set_start_cs(_v) -> bool
        @param _v (C++: sel_t)

Help on function inf_set_start_ea in module ida_ida:

inf_set_start_ea(*args)
    inf_set_start_ea(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_start_ip in module ida_ida:

inf_set_start_ip(*args)
    inf_set_start_ip(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_start_sp in module ida_ida:

inf_set_start_sp(*args)
    inf_set_start_sp(_v) -> bool
        @param _v (C++: ea_t)

Help on function inf_set_start_ss in module ida_ida:

inf_set_start_ss(*args)
    inf_set_start_ss(_v) -> bool
        @param _v (C++: sel_t)

Help on function inf_set_strlit_autocmt in module ida_ida:

inf_set_strlit_autocmt(*args)
    inf_set_strlit_autocmt(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_strlit_break in module ida_ida:

inf_set_strlit_break(*args)
    inf_set_strlit_break(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_strlit_flags in module ida_ida:

inf_set_strlit_flags(*args)
    inf_set_strlit_flags(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_strlit_name_bit in module ida_ida:

inf_set_strlit_name_bit(*args)
    inf_set_strlit_name_bit(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_strlit_names in module ida_ida:

inf_set_strlit_names(*args)
    inf_set_strlit_names(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_strlit_pref in module ida_ida:

inf_set_strlit_pref(*args)
    inf_set_strlit_pref(_v, len=size_t(-1)) -> bool
        @param _v (C++: const char *)
        @param len (C++: size_t)

Help on function inf_set_strlit_savecase in module ida_ida:

inf_set_strlit_savecase(*args)
    inf_set_strlit_savecase(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_strlit_serial_names in module ida_ida:

inf_set_strlit_serial_names(*args)
    inf_set_strlit_serial_names(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_strlit_sernum in module ida_ida:

inf_set_strlit_sernum(*args)
    inf_set_strlit_sernum(_v) -> bool
        @param _v (C++: uval_t)

Help on function inf_set_strlit_zeroes in module ida_ida:

inf_set_strlit_zeroes(*args)
    inf_set_strlit_zeroes(_v) -> bool
        @param _v (C++: char)

Help on function inf_set_strtype in module ida_ida:

inf_set_strtype(*args)
    inf_set_strtype(_v) -> bool
        @param _v (C++: int32)

Help on function inf_set_trace_flow in module ida_ida:

inf_set_trace_flow(*args)
    inf_set_trace_flow(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_truncate_on_del in module ida_ida:

inf_set_truncate_on_del(*args)
    inf_set_truncate_on_del(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_type_xrefnum in module ida_ida:

inf_set_type_xrefnum(*args)
    inf_set_type_xrefnum(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_unicode_strlits in module ida_ida:

inf_set_unicode_strlits(*args)
    inf_set_unicode_strlits(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_use_allasm in module ida_ida:

inf_set_use_allasm(*args)
    inf_set_use_allasm(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_use_flirt in module ida_ida:

inf_set_use_flirt(*args)
    inf_set_use_flirt(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_use_gcc_layout in module ida_ida:

inf_set_use_gcc_layout(*args)
    inf_set_use_gcc_layout(_v=True) -> bool
        @param _v (C++: bool)

Help on function inf_set_version in module ida_ida:

inf_set_version(*args)
    inf_set_version(_v) -> bool
        @param _v (C++: ushort)

Help on function inf_set_xrefflag in module ida_ida:

inf_set_xrefflag(*args)
    inf_set_xrefflag(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_set_xrefnum in module ida_ida:

inf_set_xrefnum(*args)
    inf_set_xrefnum(_v) -> bool
        @param _v (C++: uchar)

Help on function inf_should_create_stkvars in module ida_ida:

inf_should_create_stkvars(*args)
    inf_should_create_stkvars() -> bool

Help on function inf_should_trace_sp in module ida_ida:

inf_should_trace_sp(*args)
    inf_should_trace_sp() -> bool

Help on function inf_show_all_comments in module ida_ida:

inf_show_all_comments(*args)
    inf_show_all_comments() -> bool

Help on function inf_show_hidden_funcs in module ida_ida:

inf_show_hidden_funcs(*args)
    inf_show_hidden_funcs() -> bool

Help on function inf_show_hidden_insns in module ida_ida:

inf_show_hidden_insns(*args)
    inf_show_hidden_insns() -> bool

Help on function inf_show_hidden_segms in module ida_ida:

inf_show_hidden_segms(*args)
    inf_show_hidden_segms() -> bool

Help on function inf_show_repeatables in module ida_ida:

inf_show_repeatables(*args)
    inf_show_repeatables() -> bool

Help on function inf_show_src_linnum in module ida_ida:

inf_show_src_linnum(*args)
    inf_show_src_linnum() -> bool

Help on function inf_show_xref_fncoff in module ida_ida:

inf_show_xref_fncoff(*args)
    inf_show_xref_fncoff() -> bool

Help on function inf_show_xref_seg in module ida_ida:

inf_show_xref_seg(*args)
    inf_show_xref_seg() -> bool

Help on function inf_show_xref_tmarks in module ida_ida:

inf_show_xref_tmarks(*args)
    inf_show_xref_tmarks() -> bool

Help on function inf_show_xref_val in module ida_ida:

inf_show_xref_val(*args)
    inf_show_xref_val() -> bool

Help on function inf_strlit_autocmt in module ida_ida:

inf_strlit_autocmt(*args)
    inf_strlit_autocmt() -> bool

Help on function inf_strlit_name_bit in module ida_ida:

inf_strlit_name_bit(*args)
    inf_strlit_name_bit() -> bool

Help on function inf_strlit_names in module ida_ida:

inf_strlit_names(*args)
    inf_strlit_names() -> bool

Help on function inf_strlit_savecase in module ida_ida:

inf_strlit_savecase(*args)
    inf_strlit_savecase() -> bool

Help on function inf_strlit_serial_names in module ida_ida:

inf_strlit_serial_names(*args)
    inf_strlit_serial_names() -> bool

Help on function inf_test_mode in module ida_ida:

inf_test_mode(*args)
    inf_test_mode() -> bool

Help on function inf_trace_flow in module ida_ida:

inf_trace_flow(*args)
    inf_trace_flow() -> bool

Help on function inf_truncate_on_del in module ida_ida:

inf_truncate_on_del(*args)
    inf_truncate_on_del() -> bool

Help on function inf_unicode_strlits in module ida_ida:

inf_unicode_strlits(*args)
    inf_unicode_strlits() -> bool

Help on function inf_use_flirt in module ida_ida:

inf_use_flirt(*args)
    inf_use_flirt() -> bool

Help on function is_filetype_like_binary in module ida_ida:

is_filetype_like_binary(*args)
    Is unstructured input file?
    
    is_filetype_like_binary(ft) -> bool
        @param ft (C++: filetype_t)

Help on function <lambda> in module ida_ida:

<lambda> lambda *args

Help on function to_ea in module ida_ida:

to_ea(*args)
    Convert (sel,off) value to a linear address.
    
    to_ea(reg_cs, reg_ip) -> ea_t
        @param reg_cs (C++: sel_t)
        @param reg_ip (C++: uval_t)

=== ida_ida EPYDOC INJECTIONS ===
ida_ida.ABI_8ALIGN4
"""
4 byte alignment for 8byte scalars (__int64/double) inside structures?
"""

ida_ida.ABI_BIGARG_ALIGN
"""
(e.g. __int64 argument should be 8byte aligned on some 32bit
platforms)

use natural type alignment for argument if the alignment exceeds
native word size
"""

ida_ida.ABI_GCC_LAYOUT
"""
use gcc layout for udts (used for mingw)
"""

ida_ida.ABI_HARD_FLOAT
"""
use the floating-point register set
"""

ida_ida.ABI_HUGEARG_ALIGN
"""
use natural type alignment for an argument even if its alignment
exceeds double native word size (the default is to use double word
max). e.g. if this bit is set, __int128 has 16-byte alignment
"""

ida_ida.ABI_MAP_STKARGS
"""
register arguments are mapped to stack area (and consume stack slots)
"""

ida_ida.ABI_PACK_STKARGS
"""
do not align stack arguments to stack slots
"""

ida_ida.ABI_SET_BY_USER
"""
compiler/abi were set by user flag and require SETCOMP_BY_USER flag to
be changed
"""

ida_ida.ABI_STACK_LDBL
"""
long double arguments are passed on stack
"""

ida_ida.ABI_STACK_VARARGS
"""
varargs are always passed on stack (even when there are free
registers)
"""

ida_ida.AF2_DOEH
"""
Handle EH information.
"""

ida_ida.AF2_DORTTI
"""
Handle RTTI information.
"""

ida_ida.AF2_MACRO
"""
Try to combine several instructions into a macro instruction
"""

ida_ida.AF_ANORET
"""
Perform 'no-return' analysis.
"""

ida_ida.AF_CHKUNI
"""
Check for unicode strings.
"""

ida_ida.AF_CODE
"""
Trace execution flow.
"""

ida_ida.AF_DATOFF
"""
Automatically convert data to offsets.
"""

ida_ida.AF_DOCODE
"""
Coagulate code segs at the final pass.
"""

ida_ida.AF_DODATA
"""
Coagulate data segs at the final pass.
"""

ida_ida.AF_DREFOFF
"""
Create offset if data xref to seg32 exists.
"""

ida_ida.AF_FINAL
"""
Final pass of analysis.
"""

ida_ida.AF_FIXUP
"""
Create offsets and segments using fixup info.
"""

ida_ida.AF_FLIRT
"""
Use flirt signatures.
"""

ida_ida.AF_FTAIL
"""
Create function tails.
"""

ida_ida.AF_HFLIRT
"""
Automatically hide library functions.
"""

ida_ida.AF_IMMOFF
"""
Convert 32bit instruction operand to offset.
"""

ida_ida.AF_JFUNC
"""
Rename jump functions as j_...
"""

ida_ida.AF_JUMPTBL
"""
Locate and create jump tables.
"""

ida_ida.AF_LVAR
"""
Create stack variables.
"""

ida_ida.AF_MARKCODE
"""
Mark typical code sequences as code.
"""

ida_ida.AF_MEMFUNC
"""
Try to guess member function types.
"""

ida_ida.AF_NULLSUB
"""
Rename empty functions as nullsub_...
"""

ida_ida.AF_PROC
"""
Create functions if call is present.
"""

ida_ida.AF_PROCPTR
"""
Create function if data xref data->code32 exists.
"""

ida_ida.AF_PURDAT
"""
Control flow to data segment is ignored.
"""

ida_ida.AF_REGARG
"""
Propagate register argument information.
"""

ida_ida.AF_SIGCMT
"""
Append a signature name comment for recognized anonymous library
functions.
"""

ida_ida.AF_SIGMLT
"""
Allow recognition of several copies of the same function.
"""

ida_ida.AF_STKARG
"""
Propagate stack argument information.
"""

ida_ida.AF_STRLIT
"""
Create string literal if data xref exists.
"""

ida_ida.AF_TRACE
"""
Trace stack pointer.
"""

ida_ida.AF_TRFUNC
"""
Truncate functions upon code deletion.
"""

ida_ida.AF_UNK
"""
Delete instructions with no xrefs.
"""

ida_ida.AF_USED
"""
Analyze and create all xrefs.
"""

ida_ida.AF_VERSP
"""
Perform full SP-analysis. (\\ph{verify_sp})
"""

ida_ida.DEMNAM_CMNT
"""
display demangled names as comments
"""

ida_ida.DEMNAM_FIRST
"""
override type info
"""

ida_ida.DEMNAM_GCC3
"""
assume gcc3 names (valid for gnu compiler)
"""

ida_ida.DEMNAM_MASK
"""
mask for name form
"""

ida_ida.DEMNAM_NAME
"""
display demangled names as regular names
"""

ida_ida.DEMNAM_NONE
"""
don't display demangled names
"""

ida_ida.IDAINFO_TAG_SIZE
"""
The database parameters. This structure is kept in the ida database.
It contains the essential parameters for the current program
"""

ida_ida.IDB_COMPRESSED
"""
compress & pack database components
"""

ida_ida.IDB_PACKED
"""
pack database components into .idb
"""

ida_ida.IDB_UNPACKED
"""
leave database components unpacked
"""

ida_ida.INFFL_ALLASM
"""
the target assembler

may use constructs not supported by
"""

ida_ida.INFFL_AUTO
"""
Autoanalysis is enabled?
"""

ida_ida.INFFL_CHKOPS
"""
check manual operands? (unused)
"""

ida_ida.INFFL_GRAPH_VIEW
"""
currently using graph options (\\dto{graph})
"""

ida_ida.INFFL_LOADIDC
"""
loading an idc file that contains database info
"""

ida_ida.INFFL_NMOPS
"""
allow non-matched operands? (unused)
"""

ida_ida.INFFL_NOUSER
"""
do not store user info in the database
"""

ida_ida.INFFL_READONLY
"""
(internal) temporary interdiction to modify the database
"""

ida_ida.LFLG_64BIT
"""
64-bit program?
"""

ida_ida.LFLG_COMPRESS
"""
compress the database?
"""

ida_ida.LFLG_DBG_NOPATH
"""
do not store input full path in debugger process options
"""

ida_ida.LFLG_FLAT_OFF32
"""
treat 'REF_OFF32' as 32-bit offset for 16bit segments (otherwise try
SEG16:OFF16)
"""

ida_ida.LFLG_IS_DLL
"""
Is dynamic library?
"""

ida_ida.LFLG_KERNMODE
"""
is kernel mode binary?
"""

ida_ida.LFLG_MSF
"""
Byte order: is MSB first?
"""

ida_ida.LFLG_PACK
"""
pack the database?
"""

ida_ida.LFLG_PC_FLAT
"""
32-bit program?
"""

ida_ida.LFLG_PC_FPP
"""
decode floating point processor instructions?
"""

ida_ida.LFLG_SNAPSHOT
"""
memory snapshot was taken?
"""

ida_ida.LFLG_WIDE_HBF
"""
(wide bytes: \\ph{dnbits} > 8)

Bit order of wide bytes: high byte first?
"""

ida_ida.LMT_EMPTY
"""
empty lines at the end of basic blocks
"""

ida_ida.LMT_THICK
"""
thick borders
"""

ida_ida.LMT_THIN
"""
thin borders
"""

ida_ida.LN_AUTO
"""
include autogenerated names
"""

ida_ida.LN_NORMAL
"""
include normal names
"""

ida_ida.LN_PUBLIC
"""
include public names
"""

ida_ida.LN_WEAK
"""
include weak names
"""

ida_ida.OFLG_GEN_ASSUME
"""
Generate 'assume' directives?
"""

ida_ida.OFLG_GEN_NULL
"""
Generate empty lines?
"""

ida_ida.OFLG_GEN_ORG
"""
Generate 'org' directives?
"""

ida_ida.OFLG_GEN_TRYBLKS
"""
Generate try/catch directives?
"""

ida_ida.OFLG_LZERO
"""
generate leading zeroes in numbers
"""

ida_ida.OFLG_PREF_SEG
"""
line prefixes with segment name?
"""

ida_ida.OFLG_SHOW_AUTO
"""
Display autoanalysis indicator?
"""

ida_ida.OFLG_SHOW_PREF
"""
Show line prefixes?
"""

ida_ida.OFLG_SHOW_VOID
"""
Display void marks?
"""

ida_ida.PREF_FNCOFF
"""
show function offsets?
"""

ida_ida.PREF_PFXTRUNC
"""
truncate instruction bytes if they would need more than 1 line
"""

ida_ida.PREF_SEGADR
"""
show segment addresses?
"""

ida_ida.PREF_STACK
"""
show stack pointer?
"""

ida_ida.SCF_ALLCMT
"""
comment all lines?
"""

ida_ida.SCF_LINNUM
"""
show source line numbers
"""

ida_ida.SCF_NOCMT
"""
no comments at all
"""

ida_ida.SCF_RPTCMT
"""
show repeatable comments?
"""

ida_ida.SCF_SHHID_FUNC
"""
show hidden functions
"""

ida_ida.SCF_SHHID_ITEM
"""
show hidden instructions
"""

ida_ida.SCF_SHHID_SEGM
"""
show hidden segments
"""

ida_ida.SCF_TESTMODE
"""
testida.idc is running
"""

ida_ida.STRF_AUTO
"""
names have 'autogenerated' bit?
"""

ida_ida.STRF_COMMENT
"""
generate auto comment for string references?
"""

ida_ida.STRF_GEN
"""
generate names?
"""

ida_ida.STRF_SAVECASE
"""
preserve case of strings for identifiers
"""

ida_ida.STRF_SERIAL
"""
generate serial names?
"""

ida_ida.STRF_UNICODE
"""
unicode strings are present?
"""

ida_ida.SW_SEGXRF
"""
show segments in xrefs?
"""

ida_ida.SW_XRFFNC
"""
show function offsets?
"""

ida_ida.SW_XRFMRK
"""
show xref type marks?
"""

ida_ida.SW_XRFVAL
"""
show xref values? (otherwise-"...")
"""

ida_ida.UA_MAXOP
"""
max number of operands allowed for an instruction
"""
=== ida_ida EPYDOC INJECTIONS END ===
Help on class CustomIDAMemo in module ida_kernwin:

class CustomIDAMemo(View_Hooks)
 |  #<pycode(py_kernwin_viewhooks)>
 |  # -----------------------------------------------------------------------
 |  #                           CustomIDAMemo
 |  # -----------------------------------------------------------------------
 |  
 |  Method resolution order:
 |      CustomIDAMemo
 |      View_Hooks
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  __init__(self)
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |  
 |  view_click(self, view, ve)
 |  
 |  view_close(self, view, *args)
 |  
 |  view_curpos(self, view, *args)
 |  
 |  view_dblclick(self, view, ve)
 |  
 |  view_deactivated(self, view)
 |  
 |  view_keydown(self, view, key, state)
 |  
 |  view_loc_changed(self, view, now, was)
 |  
 |  view_mouse_moved(self, view, ve)
 |  
 |  view_mouse_over(self, view, ve)
 |  
 |  view_switched(self, view, rt)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args)
 |      A view is being created.
 |      
 |      view_created(self, view)
 |          @param view (C++: TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from View_Hooks:
 |  
 |  __swig_destroy__ = <built-in function delete_View_Hooks>
 |      delete_View_Hooks(self)

Help on __IDAPython_Completion_Util in module ida_idaapi object:

class __IDAPython_Completion_Util(__builtin__.object)
 |  Internal utility class for auto-completion support
 |  
 |  Methods defined here:
 |  
 |  __call__(self, line, x)
 |  
 |  __init__(self)
 |  
 |  debug(self, *args)
 |  
 |  dir_namespace(self, m, prefix)
 |  
 |  get_candidates(self, qname, line, match_syntax_char)
 |  
 |  maybe_extend_syntactically(self, ns, name, line, syntax_char)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  QNAME_PAT = <_sre.SRE_Pattern object>

Help on function IDAPython_ExecScript in module ida_idaapi:

IDAPython_ExecScript(script, g, print_error=True)
    Run the specified script.

Help on function IDAPython_ExecSystem in module ida_idaapi:

IDAPython_ExecSystem(cmd)
    Executes a command with popen().

Help on function IDAPython_FormatExc in module ida_idaapi:

IDAPython_FormatExc(etype, value=None, tb=None, limit=None)
    This function is used to format an exception given the
    values returned by a PyErr_Fetch()

Help on function IDAPython_LoadProcMod in module ida_idaapi:

IDAPython_LoadProcMod(script, g, print_error=True)
    Load processor module.

Help on function IDAPython_UnLoadProcMod in module ida_idaapi:

IDAPython_UnLoadProcMod(script, g, print_error=True)
    Unload processor module.

Help on class IDAPython_displayhook in module ida_idaapi:

class IDAPython_displayhook
 |  # ------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |  
 |  _print_hex(self, x)
 |  
 |  displayhook(self, item)
 |  
 |  format_item(self, num_printer, storage, item)
 |  
 |  format_seq(self, num_printer, storage, item, opn, cls)

Help on class PyIdc_cvt_int64__ in module ida_idaapi:

class PyIdc_cvt_int64__(pyidc_cvt_helper__)
 |  Helper class for explicitly representing VT_INT64 values
 |  
 |  Method resolution order:
 |      PyIdc_cvt_int64__
 |      pyidc_cvt_helper__
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  _PyIdc_cvt_int64____op = __op(self, op_n, other, rev=False)
 |  
 |  __add__(self, other)
 |  
 |  __div__(self, other)
 |  
 |  __init__(self, v)
 |  
 |  __mul__(self, other)
 |  
 |  __radd__(self, other)
 |  
 |  __rdiv__(self, other)
 |  
 |  __rmul__(self, other)
 |  
 |  __rsub__(self, other)
 |  
 |  __sub__(self, other)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  _PyIdc_cvt_int64____op_table = {0: <function <lambda>>, 1: <function <...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from pyidc_cvt_helper__:
 |  
 |  _pyidc_cvt_helper____get_value = __get_value(self)
 |  
 |  _pyidc_cvt_helper____set_value = __set_value(self, v)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pyidc_cvt_helper__:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  value

Help on class PyIdc_cvt_refclass__ in module ida_idaapi:

class PyIdc_cvt_refclass__(pyidc_cvt_helper__)
 |  Helper class for representing references to immutable objects
 |  
 |  Method resolution order:
 |      PyIdc_cvt_refclass__
 |      pyidc_cvt_helper__
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, v)
 |  
 |  cstr(self)
 |      Returns the string as a C string (up to the zero termination)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from pyidc_cvt_helper__:
 |  
 |  _pyidc_cvt_helper____get_value = __get_value(self)
 |  
 |  _pyidc_cvt_helper____set_value = __set_value(self, v)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pyidc_cvt_helper__:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  value

Help on instance of __BC695 in module ida_idaapi:

class __BC695
 |  # ----------------------------------- helpers for bw-compat w/ 6.95 API
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |  
 |  dummy(self, *args)
 |  
 |  false_p(self, *args)
 |  
 |  identity(self, arg)
 |  
 |  replace_fun(self, new)

Help on instance of IDAPython_displayhook in module ida_idaapi:

class IDAPython_displayhook
 |  # ------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |  
 |  _print_hex(self, x)
 |  
 |  displayhook(self, item)
 |  
 |  format_item(self, num_printer, storage, item)
 |  
 |  format_seq(self, num_printer, storage, item, opn, cls)

Help on class __BC695 in module ida_idaapi:

class __BC695
 |  # ----------------------------------- helpers for bw-compat w/ 6.95 API
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |  
 |  dummy(self, *args)
 |  
 |  false_p(self, *args)
 |  
 |  identity(self, arg)
 |  
 |  replace_fun(self, new)

Help on class __IDAPython_Completion_Util in module ida_idaapi:

class __IDAPython_Completion_Util(__builtin__.object)
 |  Internal utility class for auto-completion support
 |  
 |  Methods defined here:
 |  
 |  __call__(self, line, x)
 |  
 |  __init__(self)
 |  
 |  debug(self, *args)
 |  
 |  dir_namespace(self, m, prefix)
 |  
 |  get_candidates(self, qname, line, match_syntax_char)
 |  
 |  maybe_extend_syntactically(self, ns, name, line, syntax_char)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  QNAME_PAT = <_sre.SRE_Pattern object>

Help on function __install_excepthook in module ida_idaapi:

__install_excepthook()
    # Since version 5.5, PyQt5 doesn't simply print the PyQt exceptions by default
    # anymore: https://github.com/baoboa/pyqt5/commit/1e1d8a3ba677ef3e47b916b8a5b9c281d0f8e4b5#diff-848704a82f6a6e3a13112145ce32ac69L63
    # The default behavior now is that qFatal() is called, causing the application
    # to abort().
    # We do not want that to happen in IDA, and simply having a sys.excepthook
    # that is different from sys.__excepthook__ is enough for PyQt5 to return
    # to the previous behavior

Help on function _bounded_getitem_iterator in module ida_idaapi:

_bounded_getitem_iterator(self)
    Helper function, to be set as __iter__ method for qvector-, or array-based classes.

Help on function _listify_types in module ida_idaapi:

_listify_types(*classes)

Help on function _qvector_back in module ida_idaapi:

_qvector_back(self)
    # -----------------------------------------------------------------------

Help on function _qvector_front in module ida_idaapi:

_qvector_front(self)
    # -----------------------------------------------------------------------

Help on function _replace_module_function in module ida_idaapi:

_replace_module_function(replacement)

Help on function _utf8_native in module ida_idaapi:

_utf8_native(utf8)

Help on function as_UTF16 in module ida_idaapi:

as_UTF16(s)
    Convenience function to convert a string into appropriate unicode format

Help on function as_cstr in module ida_idaapi:

as_cstr(val)
    Returns a C str from the passed value. The passed value can be of type refclass (returned by a call to buffer() or byref())
    It scans for the first   and returns the string value up to that point.

Help on function as_int32 in module ida_idaapi:

as_int32(v)
    Returns a number as a signed int32 number

Help on function as_signed in module ida_idaapi:

as_signed(v, nbits=32)
    Returns a number as signed. The number of bits are specified by the user.
    The MSB holds the sign.

Help on function as_uint32 in module ida_idaapi:

as_uint32(v)
    Returns a number as an unsigned int32 number

Help on function copy_bits in module ida_idaapi:

copy_bits(v, s, e=-1)
    Copy bits from a value
    @param v: the value
    @param s: starting bit (0-based)
    @param e: ending bit

Help on function disable_script_timeout in module ida_idaapi:

disable_script_timeout(*args)
    disable_script_timeout()
    Disables the script timeout and hides the script wait box.
    Calling L{set_script_timeout} will not have any effects until the script is compiled and executed again
    
    @return: None

Help on function enable_extlang_python in module ida_idaapi:

enable_extlang_python(*args)
    enable_extlang_python(enable)
    Enables or disables Python extlang.
    When enabled, all expressions will be evaluated by Python.
    @param enable: Set to True to enable, False otherwise

Help on function enable_python_cli in module ida_idaapi:

enable_python_cli(*args)
    enable_python_cli(enable)
        enable: bool

Help on function format_basestring in module ida_idaapi:

format_basestring(*args)
    format_basestring(_in) -> PyObject *
        _in: PyObject *

Help on function get_inf_structure in module ida_idaapi:

get_inf_structure(*args)
    get_inf_structure() -> idainfo
    Returns the global variable 'inf' (an instance of idainfo structure, see ida.hpp)

Help on class loader_input_t in module ida_idaapi:

class loader_input_t(__builtin__.object)
 |  Proxy of C++ loader_input_t class.
 |  
 |  
 |  A helper class to work with linput_t related functions.
 |  This class is also used by file loaders scripts.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, pycapsule=None) -> loader_input_t
 |      Closes the file
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  close(self, *args)
 |      close(self)
 |  
 |  file2base(self, *args)
 |      file2base(self, pos, ea1, ea2, patchable) -> int
 |      Load portion of file into the database
 |      This function will include (ea1..ea2) into the addressing space of the
 |      program (make it enabled)
 |      @param li: pointer ot input source
 |      @param pos: position in the file
 |      @param (ea1..ea2): range of destination linear addresses
 |      @param patchable: should the kernel remember correspondance of
 |                        file offsets to linear addresses.
 |      @return: 1-ok,0-read error, a warning is displayed
 |  
 |  filename(self, *args)
 |      filename(self) -> PyObject *
 |  
 |  get_char(self, *args)
 |      get_char(self) -> PyObject *
 |  
 |  get_linput(self, *args)
 |      get_linput(self) -> linput_t *
 |  
 |  gets(self, *args)
 |      gets(self, len) -> PyObject *
 |      Reads a line from the input file. Returns the read line or None
 |  
 |  getz(self, *args)
 |      getz(self, sz, fpos=-1) -> PyObject *
 |      Returns a zero terminated string at the given position
 |      @param sz: maximum size of the string
 |      @param fpos: if != -1 then seek will be performed before reading
 |      @return: The string or None on failure.
 |  
 |  open(self, *args)
 |      open(self, filename, remote=False) -> bool
 |      Opens a file (or a remote file)
 |      @return: Boolean
 |  
 |  open_memory(self, *args)
 |      open_memory(self, start, size=0) -> bool
 |      Create a linput for process memory (By internally calling idaapi.create_memory_linput())
 |      This linput will use dbg->read_memory() to read data
 |      @param start: starting address of the input
 |      @param size: size of the memory range to represent as linput
 |                  if unknown, may be passed as 0
 |  
 |  opened(self, *args)
 |      opened(self) -> bool
 |      Checks if the file is opened or not
 |  
 |  read(self, *args)
 |      read(self, size) -> PyObject *
 |      Reads from the file. Returns the buffer or None
 |  
 |  readbytes(self, *args)
 |      readbytes(self, size, big_endian) -> PyObject *
 |      Similar to read() but it respect the endianness
 |  
 |  seek(self, *args)
 |      seek(self, pos, whence=SEEK_SET) -> int64
 |      Set input source position
 |      @return: the new position (not 0 as fseek!)
 |  
 |  set_linput(self, *args)
 |      set_linput(self, linput)
 |      Links the current loader_input_t instance to a linput_t instance
 |  
 |  size(self, *args)
 |      size(self) -> int64
 |  
 |  tell(self, *args)
 |      tell(self) -> int64
 |      Returns the current position
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  from_capsule(*args)
 |      from_capsule(pycapsule) -> loader_input_t
 |          pycapsule: PyObject *
 |  
 |  from_fp(*args)
 |      from_fp(fp) -> loader_input_t
 |      A static method to construct an instance from a FILE*
 |  
 |  from_linput(*args)
 |      from_linput(linput) -> loader_input_t
 |          linput: linput_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __idc_cvt_id__
 |      loader_input_t___idc_cvt_id___get(self) -> int
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_loader_input_t>
 |      delete_loader_input_t(self)

Help on function loader_input_t_from_capsule in module ida_idaapi:

loader_input_t_from_capsule(*args)
    loader_input_t_from_capsule(pycapsule) -> loader_input_t
        pycapsule: PyObject *

Help on function loader_input_t_from_fp in module ida_idaapi:

loader_input_t_from_fp(*args)
    loader_input_t_from_fp(fp) -> loader_input_t
        fp: FILE *

Help on function loader_input_t_from_linput in module ida_idaapi:

loader_input_t_from_linput(*args)
    loader_input_t_from_linput(linput) -> loader_input_t
        linput: linput_t *

Help on function notify_when in module ida_idaapi:

notify_when(when, callback)
    Register a callback that will be called when an event happens.
    @param when: one of NW_XXXX constants
    @param callback: This callback prototype varies depending on the 'when' parameter:
                     The general callback format:
                         def notify_when_callback(nw_code)
                     In the case of NW_OPENIDB:
                         def notify_when_callback(nw_code, is_old_database)
    @return: Boolean

Help on class object_t in module ida_idaapi:

class object_t(__builtin__.object)
 |  Helper class used to initialize empty objects
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, idx)
 |      Allow access to object attributes by index (like dictionaries)
 |  
 |  __init__(self, **kwds)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function parse_command_line3 in module ida_idaapi:

parse_command_line3(*args)
    parse_command_line3(cmdline) -> PyObject *
        cmdline: char const *

Help on class plugin_t in module ida_idaapi:

class plugin_t(pyidc_opaque_object_t)
 |  Base class for all scripted plugins.
 |  
 |  Method resolution order:
 |      plugin_t
 |      pyidc_opaque_object_t
 |      __builtin__.object
 |  
 |  Data descriptors inherited from pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on class plugmod_t in module ida_idaapi:

class plugmod_t(pyidc_opaque_object_t)
 |  Base class for all scripted multi-plugins.
 |  
 |  Method resolution order:
 |      plugmod_t
 |      pyidc_opaque_object_t
 |      __builtin__.object
 |  
 |  Data descriptors inherited from pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on class py_clinked_object_t in module ida_idaapi:

class py_clinked_object_t(pyidc_opaque_object_t)
 |  This is a utility and base class for C linked objects
 |  
 |  Method resolution order:
 |      py_clinked_object_t
 |      pyidc_opaque_object_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __del__(self)
 |      Delete the link upon object destruction (only if not static)
 |  
 |  __init__(self, lnk=None)
 |  
 |  _create_clink(self)
 |      Overwrite me.
 |      Creates a new clink
 |      @return: PyCapsule representing the C link
 |  
 |  _del_clink(self, lnk)
 |      Overwrite me.
 |      This method deletes the link
 |  
 |  _free(self)
 |      Explicitly delete the link (only if not static)
 |  
 |  _get_clink_ptr(self)
 |      Overwrite me.
 |      Returns the C link pointer as a 64bit number
 |  
 |  assign(self, other)
 |      Overwrite me.
 |      This method allows you to assign an instance contents to anothers
 |      @return: Boolean
 |  
 |  copy(self)
 |      Returns a new copy of this class
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  clink
 |  
 |  clink_ptr
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on function pycim_get_widget in module ida_idaapi:

pycim_get_widget(*args)
    pycim_get_widget(_self) -> TWidget *
        self: PyObject *

Help on function pycim_view_close in module ida_idaapi:

pycim_view_close(*args)
    pycim_view_close(_self)
        self: PyObject *

Help on function pygc_create_groups in module ida_idaapi:

pygc_create_groups(*args)
    pygc_create_groups(_self, groups_infos) -> PyObject *
        self: PyObject *
        groups_infos: PyObject *

Help on function pygc_delete_groups in module ida_idaapi:

pygc_delete_groups(*args)
    pygc_delete_groups(_self, groups, new_current) -> PyObject *
        self: PyObject *
        groups: PyObject *
        new_current: PyObject *

Help on function pygc_refresh in module ida_idaapi:

pygc_refresh(*args)
    pygc_refresh(_self)
        self: PyObject *

Help on function pygc_set_groups_visibility in module ida_idaapi:

pygc_set_groups_visibility(*args)
    pygc_set_groups_visibility(_self, groups, expand, new_current) -> PyObject *
        self: PyObject *
        groups: PyObject *
        expand: PyObject *
        new_current: PyObject *

Help on class pyidc_cvt_helper__ in module ida_idaapi:

class pyidc_cvt_helper__(__builtin__.object)
 |  This is a special helper object that helps detect which kind
 |  of object is this python object wrapping and how to convert it
 |  back and from IDC.
 |  This object is characterized by its special attribute and its value
 |  
 |  Methods defined here:
 |  
 |  __init__(self, cvt_id, value)
 |  
 |  _pyidc_cvt_helper____get_value = __get_value(self)
 |  
 |  _pyidc_cvt_helper____set_value = __set_value(self, v)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  value

Help on class pyidc_opaque_object_t in module ida_idaapi:

class pyidc_opaque_object_t(__builtin__.object)
 |  This is the base class for all Python<->IDC opaque objects
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __idc_cvt_id__ = 2

Help on function replfun in module ida_idaapi:

replfun(func)

Help on function require in module ida_idaapi:

require(modulename, package=None)
    Load, or reload a module.
    
    When under heavy development, a user's tool might consist of multiple
    modules. If those are imported using the standard 'import' mechanism,
    there is no guarantee that the Python implementation will re-read
    and re-evaluate the module's Python code. In fact, it usually doesn't.
    What should be done instead is 'reload()'-ing that module.
    
    This is a simple helper function that will do just that: In case the
    module doesn't exist, it 'import's it, and if it does exist,
    'reload()'s it.
    
    The importing module (i.e., the module calling require()) will have
    the loaded module bound to its globals(), under the name 'modulename'.
    (If require() is called from the command line, the importing module
    will be '__main__'.)
    
    For more information, see: <http://www.hexblog.com/?p=749>.

Help on function set_script_timeout in module ida_idaapi:

set_script_timeout(*args)
    set_script_timeout(timeout) -> int
    Changes the script timeout value. The script wait box dialog will be hidden and shown again when the timeout elapses.
    See also L{disable_script_timeout}.
    
    @param timeout: This value is in seconds.
                    If this value is set to zero then the script will never timeout.
    @return: Returns the old timeout value

Help on function struct_unpack in module ida_idaapi:

struct_unpack(buffer, signed=False, offs=0)
    Unpack a buffer given its length and offset using struct.unpack_from().
    This function will know how to unpack the given buffer by using the lookup table '__struct_unpack_table'
    If the buffer is of unknown length then None is returned. Otherwise the unpacked value is returned.

Help on function get_mark_comment in module ida_idc:

get_mark_comment(*args)
    get_mark_comment(slot) -> PyObject *
        slot: int32

Help on function get_marked_pos in module ida_idc:

get_marked_pos(*args)
    get_marked_pos(slot) -> ea_t
        slot: int32

Help on function mark_position in module ida_idc:

mark_position(*args)
    mark_position(ea, lnnum, x, y, slot, comment)
        ea: ea_t
        lnnum: int
        x: short
        y: short
        slot: int32
        comment: char const *

Help on Appcall__ in module ida_idd object:

class Appcall__(__builtin__.object)
 |  # -----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  _Appcall____get_consts = __get_consts(self)
 |  
 |  __getattr__(self, name_or_ea)
 |      Allows you to call functions as if they were member functions (by returning a callable object)
 |  
 |  __getitem__(self, idx)
 |      Use self[func_name] syntax if the function name contains invalid characters for an attribute name
 |      See __getattr___
 |  
 |  __init__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  UTF16(s)
 |  
 |  _Appcall____name_or_ea = __name_or_ea(name_or_ea)
 |      Function that accepts a name or an ea and checks if the address is enabled.
 |      If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
 |      @return:
 |          - Returns the resolved EA or
 |          - Raises an exception if the address is not enabled
 |  
 |  _Appcall____typedecl_or_tinfo = __typedecl_or_tinfo(typedecl_or_tinfo, flags=None)
 |      Function that accepts a tinfo_t object or type declaration as a string
 |      If a type declaration is passed then ida_typeinf.parse_decl() is applied to prepare tinfo_t object
 |      @return:
 |          - Returns the tinfo_t object
 |          - Raises an exception if the declaration cannot be parsed
 |  
 |  array(type_name)
 |      Defines an array type. Later you need to pack() / unpack()
 |  
 |  buffer(str=None, size=0, fill='\x00')
 |      Creates a string buffer. The returned value (r) will be a byref object.
 |      Use r.value to get the contents and r.size to get the buffer's size
 |  
 |  byref(val)
 |      Method to create references to immutable objects
 |      Currently we support references to int/strings
 |      Objects need not be passed by reference (this will be done automatically)
 |  
 |  cleanup_appcall(tid=0)
 |      Equivalent to IDC's CleanupAppcall()
 |  
 |  cstr(val)
 |  
 |  get_appcall_options()
 |      Return the global Appcall options
 |  
 |  int64(v)
 |      Whenever a 64bit number is needed use this method to construct an object
 |  
 |  obj(**kwds)
 |      Returns an empty object or objects with attributes as passed via its keywords arguments
 |  
 |  proto(name_or_ea, proto_or_tinfo, flags=None)
 |      Allows you to instantiate an appcall (callable object) with the desired prototype
 |      @param name_or_ea: The name of the function (will be resolved with LocByName())
 |      @param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
 |      @return:
 |          - On failure it raises an exception if the prototype could not be parsed
 |            or the address is not resolvable
 |          - Returns a callbable Appcall instance with the given prototypes and flags
 |  
 |  set_appcall_options(opt)
 |      Method to change the Appcall options globally (not per Appcall)
 |  
 |  typedobj(typedecl_or_tinfo, ea=None)
 |      Returns an appcall object for a type (can be given as tinfo_t object or
 |      as a string declaration)
 |      One can then use retrieve() member method
 |      @param ea: Optional parameter that later can be used to retrieve the type
 |      @return: Appcall object or raises ValueError exception
 |  
 |  unicode = UTF16(s)
 |  
 |  valueof(name, default=0)
 |      Returns the numeric value of a given name string.
 |      If the name could not be resolved then the default value will be returned
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  Consts
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  APPCALL_DEBEV = 2
 |  
 |  APPCALL_MANUAL = 1
 |  
 |  APPCALL_TIMEOUT = 4
 |  
 |  __name__ = 'Appcall__'

Help on class Appcall__ in module ida_idd:

class Appcall__(__builtin__.object)
 |  # -----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  _Appcall____get_consts = __get_consts(self)
 |  
 |  __getattr__(self, name_or_ea)
 |      Allows you to call functions as if they were member functions (by returning a callable object)
 |  
 |  __getitem__(self, idx)
 |      Use self[func_name] syntax if the function name contains invalid characters for an attribute name
 |      See __getattr___
 |  
 |  __init__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  UTF16(s)
 |  
 |  _Appcall____name_or_ea = __name_or_ea(name_or_ea)
 |      Function that accepts a name or an ea and checks if the address is enabled.
 |      If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
 |      @return:
 |          - Returns the resolved EA or
 |          - Raises an exception if the address is not enabled
 |  
 |  _Appcall____typedecl_or_tinfo = __typedecl_or_tinfo(typedecl_or_tinfo, flags=None)
 |      Function that accepts a tinfo_t object or type declaration as a string
 |      If a type declaration is passed then ida_typeinf.parse_decl() is applied to prepare tinfo_t object
 |      @return:
 |          - Returns the tinfo_t object
 |          - Raises an exception if the declaration cannot be parsed
 |  
 |  array(type_name)
 |      Defines an array type. Later you need to pack() / unpack()
 |  
 |  buffer(str=None, size=0, fill='\x00')
 |      Creates a string buffer. The returned value (r) will be a byref object.
 |      Use r.value to get the contents and r.size to get the buffer's size
 |  
 |  byref(val)
 |      Method to create references to immutable objects
 |      Currently we support references to int/strings
 |      Objects need not be passed by reference (this will be done automatically)
 |  
 |  cleanup_appcall(tid=0)
 |      Equivalent to IDC's CleanupAppcall()
 |  
 |  cstr(val)
 |  
 |  get_appcall_options()
 |      Return the global Appcall options
 |  
 |  int64(v)
 |      Whenever a 64bit number is needed use this method to construct an object
 |  
 |  obj(**kwds)
 |      Returns an empty object or objects with attributes as passed via its keywords arguments
 |  
 |  proto(name_or_ea, proto_or_tinfo, flags=None)
 |      Allows you to instantiate an appcall (callable object) with the desired prototype
 |      @param name_or_ea: The name of the function (will be resolved with LocByName())
 |      @param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
 |      @return:
 |          - On failure it raises an exception if the prototype could not be parsed
 |            or the address is not resolvable
 |          - Returns a callbable Appcall instance with the given prototypes and flags
 |  
 |  set_appcall_options(opt)
 |      Method to change the Appcall options globally (not per Appcall)
 |  
 |  typedobj(typedecl_or_tinfo, ea=None)
 |      Returns an appcall object for a type (can be given as tinfo_t object or
 |      as a string declaration)
 |      One can then use retrieve() member method
 |      @param ea: Optional parameter that later can be used to retrieve the type
 |      @return: Appcall object or raises ValueError exception
 |  
 |  unicode = UTF16(s)
 |  
 |  valueof(name, default=0)
 |      Returns the numeric value of a given name string.
 |      If the name could not be resolved then the default value will be returned
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  Consts
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  APPCALL_DEBEV = 2
 |  
 |  APPCALL_MANUAL = 1
 |  
 |  APPCALL_TIMEOUT = 4
 |  
 |  __name__ = 'Appcall__'

Help on class Appcall_array__ in module ida_idd:

class Appcall_array__(__builtin__.object)
 |  This class is used with Appcall.array() method
 |  
 |  Methods defined here:
 |  
 |  __init__(self, tp)
 |  
 |  pack(self, L)
 |      Packs a list or tuple into a byref buffer
 |  
 |  try_to_convert_to_list(self, obj)
 |      Is this object a list? We check for the existance of attribute zero and attribute self.size-1
 |  
 |  unpack(self, buf, as_list=True)
 |      Unpacks an array back into a list or an object
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class Appcall_callable__ in module ida_idd:

class Appcall_callable__(__builtin__.object)
 |  Helper class to issue appcalls using a natural syntax:
 |    appcall.FunctionNameInTheDatabase(arguments, ....)
 |  or
 |    appcall["Function@8"](arguments, ...)
 |  or
 |    f8 = appcall["Function@8"]
 |    f8(arg1, arg2, ...)
 |  or
 |    o = appcall.obj()
 |    i = byref(5)
 |    appcall.funcname(arg1, i, "hello", o)
 |  
 |  Methods defined here:
 |  
 |  _Appcall_callable____get_ea = __get_ea(self)
 |  
 |  _Appcall_callable____get_fields = __get_fields(self)
 |  
 |  _Appcall_callable____get_options = __get_options(self)
 |  
 |  _Appcall_callable____get_size = __get_size(self)
 |  
 |  _Appcall_callable____get_tif = __get_tif(self)
 |  
 |  _Appcall_callable____get_timeout = __get_timeout(self)
 |  
 |  _Appcall_callable____get_type = __get_type(self)
 |  
 |  _Appcall_callable____set_ea = __set_ea(self, val)
 |  
 |  _Appcall_callable____set_options = __set_options(self, v)
 |  
 |  _Appcall_callable____set_timeout = __set_timeout(self, v)
 |  
 |  __call__(self, *args)
 |      Make object callable. We redirect execution to idaapi.appcall()
 |  
 |  __init__(self, ea, tinfo_or_typestr=None, fields=None)
 |      Initializes an appcall with a given function ea
 |  
 |  retrieve(self, src=None, flags=0)
 |      Unpacks a typed object from the database if an ea is given or from a string if a string was passed
 |      @param src: the address of the object or a string
 |      @return: Returns a tuple of boolean and object or error number (Bool, Error | Object).
 |  
 |  store(self, obj, dest_ea=None, base_ea=0, flags=0)
 |      Packs an object into a given ea if provided or into a string if no address was passed.
 |      @param obj: The object to pack
 |      @param dest_ea: If packing to idb this will be the store location
 |      @param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers
 |      
 |      @return:
 |          - If packing to a string then a Tuple(Boolean, packed_string or error code)
 |          - If packing to the database then a return code is returned (0 is success)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |  
 |  fields
 |  
 |  options
 |  
 |  size
 |  
 |  tif
 |  
 |  timeout
 |  
 |  type

Help on class Appcall_consts__ in module ida_idd:

class Appcall_consts__(__builtin__.object)
 |  Helper class used by Appcall.Consts attribute
 |  It is used to retrieve constants via attribute access
 |  
 |  Methods defined here:
 |  
 |  __getattr__(self, attr)
 |  
 |  __init__(self, default=None)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function appcall in module ida_idd:

appcall(*args)
    appcall(func_ea, tid, _type_or_none, _fields, arg_list) -> PyObject *
        func_ea: ea_t
        tid: thid_t
        _type_or_none: bytevec_t const &
        _fields: bytevec_t const &
        arg_list: PyObject *

Help on class bptaddr_t in module ida_idd:

class bptaddr_t(__builtin__.object)
 |  Proxy of C++ bptaddr_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bptaddr_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hea
 |      bptaddr_t_hea_get(self) -> ea_t
 |  
 |  kea
 |      bptaddr_t_kea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_bptaddr_t>
 |      delete_bptaddr_t(self)

Help on class call_stack_info_t in module ida_idd:

class call_stack_info_t(__builtin__.object)
 |  Proxy of C++ call_stack_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: call_stack_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> call_stack_info_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: call_stack_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  callea
 |      call_stack_info_t_callea_get(self) -> ea_t
 |  
 |  fp
 |      call_stack_info_t_fp_get(self) -> ea_t
 |  
 |  funcea
 |      call_stack_info_t_funcea_get(self) -> ea_t
 |  
 |  funcok
 |      call_stack_info_t_funcok_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_call_stack_info_t>
 |      delete_call_stack_info_t(self)

Help on class call_stack_t in module ida_idd:

class call_stack_t(__builtin__.object)
 |  Proxy of C++ qvector< call_stack_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< call_stack_info_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> call_stack_info_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> call_stack_t
 |          x: qvector< call_stack_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< call_stack_info_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: call_stack_info_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: call_stack_info_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: call_stack_info_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> call_stack_info_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> call_stack_info_t
 |      begin(self) -> call_stack_info_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> call_stack_info_t
 |      end(self) -> call_stack_info_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> call_stack_info_t
 |          it: qvector< call_stack_info_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> call_stack_info_t
 |          first: qvector< call_stack_info_t >::iterator
 |          last: qvector< call_stack_info_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> call_stack_info_t
 |  
 |  find(self, *args)
 |      find(self, x) -> call_stack_info_t
 |          x: call_stack_info_t const &
 |      
 |      
 |      find(self, x) -> call_stack_info_t
 |          x: call_stack_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=call_stack_info_t())
 |          x: call_stack_info_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: call_stack_info_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: call_stack_info_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> call_stack_info_t
 |          it: qvector< call_stack_info_t >::iterator
 |          x: call_stack_info_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: call_stack_info_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: call_stack_info_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< call_stack_info_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_call_stack_t>
 |      delete_call_stack_t(self)

Help on function can_exc_continue in module ida_idd:

can_exc_continue(*args)
    can_exc_continue(ev) -> bool
        ev: debug_event_t const *

Help on function cleanup_appcall in module ida_idd:

cleanup_appcall(*args)
    Cleanup after manual appcall.
    
    cleanup_appcall(tid) -> error_t
        @param tid: thread to use.  NO_THREAD  means to use the current thread
                    The application state is restored as it was before calling
                    the last appcall(). Nested appcalls are supported. (C++:
                    thid_t)
        @return: eOk  if successful, otherwise an error code

Help on function dbg_appcall in module ida_idd:

dbg_appcall(*args)
    Call a function from the debugged application.
    
    dbg_appcall(retval, func_ea, tid, ptif, argv, argnum) -> error_t
        @param retval (C++: idc_value_t  *)
        @param func_ea: address to call (C++: ea_t)
        @param tid: thread to use.  NO_THREAD  means to use the current thread
                    (C++: thid_t)
        @param ptif: pointer to type of the function to call (C++: const
                     tinfo_t  *)
        @param argv: array of arguments (C++: idc_value_t  *)
        @param argnum: number of actual arguments (C++: size_t)
        @return: eOk  if successful, otherwise an error code

Help on built-in function dbg_can_query in module _ida_dbg:

dbg_can_query(...)
    dbg_can_query() -> bool

Help on function dbg_get_memory_info in module ida_idd:

dbg_get_memory_info(*args)
    dbg_get_memory_info() -> PyObject *
    This function returns the memory configuration of a debugged process.
    @return:
        None if no debugger is active
        tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm)

Help on function dbg_get_name in module ida_idd:

dbg_get_name(*args)
    dbg_get_name() -> PyObject *
    This function returns the current debugger's name.
    @return: Debugger name or None if no debugger is active

Help on function dbg_get_registers in module ida_idd:

dbg_get_registers(*args)
    dbg_get_registers() -> PyObject *
    This function returns the register definition from the currently loaded debugger.
    Basically, it returns an array of structure similar to to idd.hpp / register_info_t
    @return:
        None if no debugger is loaded
        tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
        The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)

Help on function dbg_get_thread_sreg_base in module ida_idd:

dbg_get_thread_sreg_base(*args)
    dbg_get_thread_sreg_base(tid, sreg_value) -> PyObject *
    Returns the segment register base value
    @param tid: thread id
    @param sreg_value: segment register (selector) value
    @return:
        - The base as an 'ea'
        - Or None on failure

Help on function dbg_read_memory in module ida_idd:

dbg_read_memory(*args)
    dbg_read_memory(ea, sz) -> PyObject *
    Reads from the debugee's memory at the specified ea
    @return:
        - The read buffer (as a string)
        - Or None on failure

Help on function dbg_write_memory in module ida_idd:

dbg_write_memory(*args)
    dbg_write_memory(ea, buf) -> PyObject *
    Writes a buffer to the debugee's memory
    @return: Boolean

Help on class debapp_attrs_t in module ida_idd:

class debapp_attrs_t(__builtin__.object)
 |  Proxy of C++ debapp_attrs_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> debapp_attrs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  addrsize
 |      debapp_attrs_t_addrsize_get(self) -> int
 |  
 |  cbsize
 |      debapp_attrs_t_cbsize_get(self) -> int32
 |  
 |  is_be
 |      debapp_attrs_t_is_be_get(self) -> int
 |  
 |  platform
 |      debapp_attrs_t_platform_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_debapp_attrs_t>
 |      delete_debapp_attrs_t(self)

Help on class debug_event_t in module ida_idd:

class debug_event_t(__builtin__.object)
 |  Proxy of C++ debug_event_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> debug_event_t
 |          r: debug_event_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  bpt(self, *args)
 |      'EXCEPTION'
 |  
 |  bpt_ea(self, *args)
 |      On some systems with special memory mappings the triggered ea might be
 |      different from the actual ea. Calculate the address to use.
 |  
 |  clear(self, *args)
 |      clear the dependent information (see below), set event code to
 |      NO_EVENT
 |  
 |  clear_all(self, *args)
 |      clear_all(self)
 |  
 |  copy(self, *args)
 |      copy(self, r) -> debug_event_t
 |          @param r (C++: const  debug_event_t  &)
 |  
 |  eid(self, *args)
 |      Event code.
 |  
 |  exc(self, *args)
 |      exc(self) -> excinfo_t
 |      exc(self) -> excinfo_t
 |  
 |  exit_code(self, *args)
 |      'THREAD_STARTED' (thread name) 'LIB_UNLOADED' (unloaded library name)
 |      'INFORMATION' (will be displayed in the output window if not empty)
 |  
 |  info(self, *args)
 |      'BREAKPOINT'
 |  
 |  modinfo(self, *args)
 |      Information that depends on the event code:
 |      
 |      < 'PROCESS_STARTED' , 'PROCESS_ATTACHED' , 'LIB_LOADED'
 |      'PROCESS_EXITED' , 'THREAD_EXITED'
 |  
 |  set_bpt(self, *args)
 |      set_bpt(self) -> bptaddr_t
 |  
 |  set_eid(self, *args)
 |      Set event code. If the new event code is compatible with the old one
 |      then the dependent information (see below) will be preserved.
 |      Otherwise the event will be cleared and the new event code will be
 |      set.
 |      
 |      set_eid(self, id)
 |          @param id (C++: event_id_t)
 |  
 |  set_exception(self, *args)
 |      set_exception(self) -> excinfo_t
 |  
 |  set_exit_code(self, *args)
 |      set_exit_code(self, id, code)
 |          @param id (C++: event_id_t)
 |          @param code (C++: int)
 |  
 |  set_info(self, *args)
 |      set_info(self, id) -> qstring &
 |          @param id (C++: event_id_t)
 |  
 |  set_modinfo(self, *args)
 |      set_modinfo(self, id) -> modinfo_t
 |          @param id (C++: event_id_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      debug_event_t_ea_get(self) -> ea_t
 |  
 |  handled
 |      debug_event_t_handled_get(self) -> bool
 |  
 |  pid
 |      debug_event_t_pid_get(self) -> pid_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      debug_event_t_tid_get(self) -> thid_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_debug_event_t>
 |      delete_debug_event_t(self)

Help on class exception_info_t in module ida_idd:

class exception_info_t(__builtin__.object)
 |  Proxy of C++ exception_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> exception_info_t
 |          _code: uint
 |          _flags: uint32
 |          _name: char const *
 |          _desc: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  break_on(self, *args)
 |      Should we break on the exception?
 |  
 |  handle(self, *args)
 |      Should we handle the exception?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  code
 |      exception_info_t_code_get(self) -> uint
 |  
 |  desc
 |      exception_info_t_desc_get(self) -> qstring *
 |  
 |  flags
 |      exception_info_t_flags_get(self) -> uint32
 |  
 |  name
 |      exception_info_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_exception_info_t>
 |      delete_exception_info_t(self)

Help on class excinfo_t in module ida_idd:

class excinfo_t(__builtin__.object)
 |  Proxy of C++ excinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> excinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  can_cont
 |      excinfo_t_can_cont_get(self) -> bool
 |  
 |  code
 |      excinfo_t_code_get(self) -> uint32
 |  
 |  ea
 |      excinfo_t_ea_get(self) -> ea_t
 |  
 |  info
 |      excinfo_t_info_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_excinfo_t>
 |      delete_excinfo_t(self)

Help on class excvec_t in module ida_idd:

class excvec_t(__builtin__.object)
 |  Proxy of C++ qvector< exception_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> exception_info_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> excvec_t
 |          x: qvector< exception_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: exception_info_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> exception_info_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> exception_info_t
 |      begin(self) -> exception_info_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> exception_info_t
 |      end(self) -> exception_info_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> exception_info_t
 |          it: qvector< exception_info_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> exception_info_t
 |          first: qvector< exception_info_t >::iterator
 |          last: qvector< exception_info_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> exception_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=exception_info_t())
 |          x: exception_info_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: exception_info_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> exception_info_t
 |          it: qvector< exception_info_t >::iterator
 |          x: exception_info_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: exception_info_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: exception_info_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< exception_info_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_excvec_t>
 |      delete_excvec_t(self)

Help on function get_event_bpt_hea in module ida_idd:

get_event_bpt_hea(*args)
    get_event_bpt_hea(ev) -> ea_t
        ev: debug_event_t const *

Help on function get_event_exc_code in module ida_idd:

get_event_exc_code(*args)
    get_event_exc_code(ev) -> uint
        ev: debug_event_t const *

Help on function get_event_exc_ea in module ida_idd:

get_event_exc_ea(*args)
    get_event_exc_ea(ev) -> ea_t
        ev: debug_event_t const *

Help on function get_event_exc_info in module ida_idd:

get_event_exc_info(*args)
    get_event_exc_info(ev) -> str
        ev: debug_event_t const *

Help on function get_event_info in module ida_idd:

get_event_info(*args)
    get_event_info(ev) -> str
        ev: debug_event_t const *

Help on function get_event_module_base in module ida_idd:

get_event_module_base(*args)
    get_event_module_base(ev) -> ea_t
        ev: debug_event_t const *

Help on function get_event_module_name in module ida_idd:

get_event_module_name(*args)
    get_event_module_name(ev) -> str
        ev: debug_event_t const *

Help on function get_event_module_size in module ida_idd:

get_event_module_size(*args)
    get_event_module_size(ev) -> asize_t
        ev: debug_event_t const *

Help on class meminfo_vec_t in module ida_idd:

class meminfo_vec_t(__builtin__.object)
 |  Proxy of C++ qvector< memory_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< memory_info_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> memory_info_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> meminfo_vec_t
 |          x: qvector< memory_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< memory_info_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: memory_info_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: memory_info_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: memory_info_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> memory_info_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> memory_info_t
 |      begin(self) -> memory_info_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> memory_info_t
 |      end(self) -> memory_info_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> memory_info_t
 |          it: qvector< memory_info_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> memory_info_t
 |          first: qvector< memory_info_t >::iterator
 |          last: qvector< memory_info_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> memory_info_t
 |  
 |  find(self, *args)
 |      find(self, x) -> memory_info_t
 |          x: memory_info_t const &
 |      
 |      
 |      find(self, x) -> memory_info_t
 |          x: memory_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=memory_info_t())
 |          x: memory_info_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: memory_info_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: memory_info_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> memory_info_t
 |          it: qvector< memory_info_t >::iterator
 |          x: memory_info_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: memory_info_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: memory_info_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< memory_info_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_meminfo_vec_t>
 |      delete_meminfo_vec_t(self)

Help on class memory_info_t in module ida_idd:

class memory_info_t(ida_range.range_t)
 |  Proxy of C++ memory_info_t class.
 |  
 |  Method resolution order:
 |      memory_info_t
 |      ida_range.range_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: memory_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> memory_info_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: memory_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bitness
 |      memory_info_t_bitness_get(self) -> uchar
 |  
 |  name
 |      memory_info_t_name_get(self) -> qstring *
 |  
 |  perm
 |      memory_info_t_perm_get(self) -> uchar
 |  
 |  sbase
 |      memory_info_t_sbase_get(self) -> ea_t
 |  
 |  sclass
 |      memory_info_t_sclass_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_memory_info_t>
 |      delete_memory_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  _print(self, *args)
 |      _print(self) -> size_t
 |  
 |  clear(self, *args)
 |      Set 'start_ea' , 'end_ea' to 0.
 |  
 |  compare(self, *args)
 |      Compare two 'range_t' instances, based on the start_ea.
 |      
 |      compare(self, r) -> int
 |          @param r (C++: const  range_t  &)
 |  
 |  contains(self, *args)
 |      Is 'ea' in the address range?
 |      
 |      contains(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |      
 |      
 |      contains(self, r) -> bool
 |          r: range_t const &
 |  
 |  empty(self, *args)
 |      Is the size of the 'range_t' <= 0?
 |  
 |  extend(self, *args)
 |      Ensure that the 'range_t' includes 'ea'.
 |      
 |      extend(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  intersect(self, *args)
 |      Assign the 'range_t' to the intersection between the 'range_t' and
 |      'r'.
 |      
 |      intersect(self, r)
 |          @param r (C++: const  range_t  &)
 |  
 |  overlaps(self, *args)
 |      Is there an ea in 'r' that is also in this 'range_t' ?
 |      
 |      overlaps(self, r) -> bool
 |          @param r (C++: const  range_t  &)
 |  
 |  size(self, *args)
 |      Get 'end_ea' - 'start_ea' .
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t

Help on class modinfo_t in module ida_idd:

class modinfo_t(__builtin__.object)
 |  Proxy of C++ modinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> modinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  base
 |      modinfo_t_base_get(self) -> ea_t
 |  
 |  name
 |      modinfo_t_name_get(self) -> qstring *
 |  
 |  rebase_to
 |      modinfo_t_rebase_to_get(self) -> ea_t
 |  
 |  size
 |      modinfo_t_size_get(self) -> asize_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_modinfo_t>
 |      delete_modinfo_t(self)

Help on class process_info_t in module ida_idd:

class process_info_t(__builtin__.object)
 |  Proxy of C++ process_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> process_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      process_info_t_name_get(self) -> qstring *
 |  
 |  pid
 |      process_info_t_pid_get(self) -> pid_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_process_info_t>
 |      delete_process_info_t(self)

Help on class procinfo_vec_t in module ida_idd:

class procinfo_vec_t(__builtin__.object)
 |  Proxy of C++ qvector< process_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> process_info_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> procinfo_vec_t
 |          x: qvector< process_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: process_info_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> process_info_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> process_info_t
 |      begin(self) -> process_info_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> process_info_t
 |      end(self) -> process_info_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> process_info_t
 |          it: qvector< process_info_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> process_info_t
 |          first: qvector< process_info_t >::iterator
 |          last: qvector< process_info_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> process_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=process_info_t())
 |          x: process_info_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: process_info_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> process_info_t
 |          it: qvector< process_info_t >::iterator
 |          x: process_info_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: process_info_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: process_info_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< process_info_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_procinfo_vec_t>
 |      delete_procinfo_vec_t(self)

Help on class register_info_t in module ida_idd:

class register_info_t(__builtin__.object)
 |  Proxy of C++ register_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> register_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bit_strings
 |      register_info_t_bit_strings_get(self) -> char const *const *
 |  
 |  default_bit_strings_mask
 |      register_info_t_default_bit_strings_mask_get(self) -> uval_t
 |  
 |  dtype
 |      register_info_t_dtype_get(self) -> op_dtype_t
 |  
 |  flags
 |      register_info_t_flags_get(self) -> uint32
 |  
 |  name
 |      register_info_t_name_get(self) -> char const *
 |  
 |  register_class
 |      register_info_t_register_class_get(self) -> register_class_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_register_info_t>
 |      delete_register_info_t(self)

Help on class regval_t in module ida_idd:

class regval_t(__builtin__.object)
 |  Proxy of C++ regval_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: regval_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regval_t
 |          r: regval_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: regval_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  bytes(self, *args)
 |      bytes(self) -> bytevec_t
 |      bytes(self) -> bytevec_t const &
 |  
 |  clear(self, *args)
 |      Clear register value.
 |  
 |  get_data(self, *args)
 |      get_data(self)
 |      get_data(self) -> void const *
 |  
 |  get_data_size(self, *args)
 |      get_data_size(self) -> size_t
 |  
 |  set_bytes(self, *args)
 |      set_bytes(self, data, size)
 |          data: uchar const *
 |          size: size_t
 |      
 |      
 |      set_bytes(self, v)
 |          v: bytevec_t const &
 |  
 |  set_float(self, *args)
 |      set_float(self, x)
 |          x: ushort const *
 |  
 |  set_int(self, *args)
 |      set_int(self, x)
 |          x: uint64
 |  
 |  set_unavailable(self, *args)
 |      set_unavailable(self)
 |  
 |  swap(self, *args)
 |      Set this = r and r = this.
 |      
 |      swap(self, r)
 |          @param r (C++: regval_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fval
 |      regval_t_fval_get(self) -> uint16 [6]
 |  
 |  ival
 |      regval_t_ival_get(self) -> uint64
 |  
 |  rvtype
 |      regval_t_rvtype_get(self) -> int32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_regval_t>
 |      delete_regval_t(self)

Help on class scattered_segm_t in module ida_idd:

class scattered_segm_t(ida_range.range_t)
 |  Proxy of C++ scattered_segm_t class.
 |  
 |  Method resolution order:
 |      scattered_segm_t
 |      ida_range.range_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> scattered_segm_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  name
 |      scattered_segm_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_scattered_segm_t>
 |      delete_scattered_segm_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: range_t const &
 |  
 |  _print(self, *args)
 |      _print(self) -> size_t
 |  
 |  clear(self, *args)
 |      Set 'start_ea' , 'end_ea' to 0.
 |  
 |  compare(self, *args)
 |      Compare two 'range_t' instances, based on the start_ea.
 |      
 |      compare(self, r) -> int
 |          @param r (C++: const  range_t  &)
 |  
 |  contains(self, *args)
 |      Is 'ea' in the address range?
 |      
 |      contains(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |      
 |      
 |      contains(self, r) -> bool
 |          r: range_t const &
 |  
 |  empty(self, *args)
 |      Is the size of the 'range_t' <= 0?
 |  
 |  extend(self, *args)
 |      Ensure that the 'range_t' includes 'ea'.
 |      
 |      extend(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  intersect(self, *args)
 |      Assign the 'range_t' to the intersection between the 'range_t' and
 |      'r'.
 |      
 |      intersect(self, r)
 |          @param r (C++: const  range_t  &)
 |  
 |  overlaps(self, *args)
 |      Is there an ea in 'r' that is also in this 'range_t' ?
 |      
 |      overlaps(self, r) -> bool
 |          @param r (C++: const  range_t  &)
 |  
 |  size(self, *args)
 |      Get 'end_ea' - 'start_ea' .
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t

Help on function set_debug_event_code in module ida_idd:

set_debug_event_code(*args)
    set_debug_event_code(ev, id)
        @param ev (C++: debug_event_t  *)
        @param id (C++: event_id_t)

Help on class thread_name_t in module ida_idd:

class thread_name_t(__builtin__.object)
 |  Proxy of C++ thread_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> thread_name_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      thread_name_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      thread_name_t_tid_get(self) -> thid_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_thread_name_t>
 |      delete_thread_name_t(self)

=== ida_idd EPYDOC INJECTIONS ===
ida_idd.EXC_BREAK
"""
break on the exception
"""

ida_idd.EXC_HANDLE
"""
should be handled by the debugger?
"""

ida_idd.EXC_MSG
"""
instead of a warning, log the exception to the output window
"""

ida_idd.EXC_SILENT
"""
do not warn or log to the output window
"""

ida_idd.IDD_INTERFACE_VERSION
"""
The IDD interface version number.
"""

ida_idd.NO_PROCESS
"""
No process.
"""

ida_idd.NO_THREAD
"""
No thread. in 'PROCESS_STARTED' this value can be used to specify that
the main thread has not been created. It will be initialized later by
a 'THREAD_STARTED' event.
"""

ida_idd.REGISTER_ADDRESS
"""
may contain an address
"""

ida_idd.REGISTER_CS
"""
code segment
"""

ida_idd.REGISTER_CUSTFMT
"""
register should be displayed using a custom data format. the format
name is in bit_strings[0] the corresponding 'regval_t' will use
'bytevec_t'
"""

ida_idd.REGISTER_FP
"""
frame pointer
"""

ida_idd.REGISTER_IP
"""
instruction pointer
"""

ida_idd.REGISTER_NOLF
"""
allowing the next register to be displayed to its right (on the same
line)

displays this register without returning to the next line
"""

ida_idd.REGISTER_READONLY
"""
the user can't modify the current value of this register
"""

ida_idd.REGISTER_SP
"""
stack pointer
"""

ida_idd.REGISTER_SS
"""
stack segment
"""

ida_idd.RVT_FLOAT
"""
floating point
"""

ida_idd.RVT_INT
"""
integer
"""

ida_idd.RVT_UNAVAILABLE
"""
other values mean custom data type

unavailable
"""
=== ida_idd EPYDOC INJECTIONS END ===
Help on function AssembleLine in module ida_idp:

AssembleLine(*args)
    AssembleLine(ea, cs, ip, use32, nonnul_line) -> PyObject *
    Assemble an instruction to a string (display a warning if an error is found)
    
    @param ea: linear address of instruction
    @param cs:  cs of instruction
    @param ip:  ip of instruction
    @param use32: is 32bit segment
    @param line: line to assemble
    @return:
        - None on failure
        - or a string containing the assembled instruction

Help on class IDB_Hooks in module ida_idp:

class IDB_Hooks(__builtin__.object)
 |  Proxy of C++ IDB_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> IDB_Hooks
 |          _flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  adding_segm(self, *args)
 |      A segment is being created.
 |      
 |      adding_segm(self, s)
 |          @param s (C++: segment_t *)
 |  
 |  allsegs_moved(self, *args)
 |      Program rebasing is complete. This event is generated after series of
 |      segm_moved events
 |      
 |      allsegs_moved(self, info)
 |          @param info (C++: segm_move_infos_t *)
 |  
 |  auto_empty(self, *args)
 |      Info: all analysis queues are empty. This callback is called once when
 |      the initial analysis is finished. If the queue is not empty upon the
 |      return from this callback, it will be called later again.
 |  
 |  auto_empty_finally(self, *args)
 |      Info: all analysis queues are empty definitively. This callback is
 |      called only once.
 |  
 |  bookmark_changed(self, *args)
 |      Boomarked position changed.
 |      
 |      bookmark_changed(self, index, pos, desc)
 |          @param index (C++: uint32)
 |          @param pos (C++: const lochist_entry_t *)
 |          @param desc: if desc==NULL, then the bookmark was deleted.  (C++:
 |                       const char *)
 |  
 |  byte_patched(self, *args)
 |      A byte has been patched.
 |      
 |      byte_patched(self, ea, old_value)
 |          @param ea (C++: ea_t)
 |          @param old_value (C++: uint32)
 |  
 |  callee_addr_changed(self, *args)
 |      Callee address has been updated by the user.
 |      
 |      callee_addr_changed(self, ea, callee)
 |          @param ea (C++: ea_t)
 |          @param callee (C++: ea_t)
 |  
 |  changing_cmt(self, *args)
 |      An item comment is to be changed.
 |      
 |      changing_cmt(self, ea, repeatable_cmt, newcmt)
 |          @param ea (C++: ea_t)
 |          @param repeatable_cmt (C++: bool)
 |          @param newcmt (C++: const char *)
 |  
 |  changing_enum_bf(self, *args)
 |      An enum type 'bitfield' attribute is to be changed.
 |      
 |      changing_enum_bf(self, id, new_bf)
 |          @param id (C++: enum_t)
 |          @param new_bf (C++: bool)
 |  
 |  changing_enum_cmt(self, *args)
 |      An enum or member type comment is to be changed.
 |      
 |      changing_enum_cmt(self, id, repeatable, newcmt)
 |          @param id (C++: tid_t)
 |          @param repeatable (C++: bool)
 |          @param newcmt (C++: const char *)
 |  
 |  changing_op_ti(self, *args)
 |      An operand typestring (c/c++ prototype) is to be changed.
 |      
 |      changing_op_ti(self, ea, n, new_type, new_fnames)
 |          @param ea (C++: ea_t)
 |          @param n (C++: int)
 |          @param new_type (C++: const type_t *)
 |          @param new_fnames (C++: const p_list *)
 |  
 |  changing_op_type(self, *args)
 |      An operand type (offset, hex, etc...) is to be changed.
 |      
 |      changing_op_type(self, ea, n, opinfo)
 |          @param ea (C++: ea_t)
 |          @param n: eventually or'ed with OPND_OUTER or OPND_ALL  (C++: int)
 |          @param opinfo: additional operand info  (C++: const opinfo_t *)
 |  
 |  changing_range_cmt(self, *args)
 |      Range comment is to be changed.
 |      
 |      changing_range_cmt(self, kind, a, cmt, repeatable)
 |          @param kind (C++: range_kind_t)
 |          @param a (C++: const range_t *)
 |          @param cmt (C++: const char *)
 |          @param repeatable (C++: bool)
 |  
 |  changing_segm_class(self, *args)
 |      Segment class is being changed.
 |      
 |      changing_segm_class(self, s)
 |          @param s (C++: segment_t *)
 |  
 |  changing_segm_end(self, *args)
 |      Segment end address is to be changed.
 |      
 |      changing_segm_end(self, s, new_end, segmod_flags)
 |          @param s (C++: segment_t *)
 |          @param new_end (C++: ea_t)
 |          @param segmod_flags (C++: int)
 |  
 |  changing_segm_name(self, *args)
 |      Segment name is being changed.
 |      
 |      changing_segm_name(self, s, oldname)
 |          @param s (C++: segment_t *)
 |          @param oldname (C++: const char *)
 |  
 |  changing_segm_start(self, *args)
 |      Segment start address is to be changed.
 |      
 |      changing_segm_start(self, s, new_start, segmod_flags)
 |          @param s (C++: segment_t *)
 |          @param new_start (C++: ea_t)
 |          @param segmod_flags (C++: int)
 |  
 |  changing_struc_align(self, *args)
 |      A structure type is being changed (the struct alignment).
 |      
 |      changing_struc_align(self, sptr)
 |          @param sptr (C++: struc_t *)
 |  
 |  changing_struc_cmt(self, *args)
 |      A structure type comment is to be changed.
 |      
 |      changing_struc_cmt(self, struc_id, repeatable, newcmt)
 |          @param struc_id (C++: tid_t)
 |          @param repeatable (C++: bool)
 |          @param newcmt (C++: const char *)
 |  
 |  changing_struc_member(self, *args)
 |      A structure member is to be changed.
 |      
 |      changing_struc_member(self, sptr, mptr, flag, ti, nbytes)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |          @param flag (C++: flags_t)
 |          @param ti (C++: const opinfo_t *)
 |          @param nbytes (C++: asize_t)
 |  
 |  changing_ti(self, *args)
 |      An item typestring (c/c++ prototype) is to be changed.
 |      
 |      changing_ti(self, ea, new_type, new_fnames)
 |          @param ea (C++: ea_t)
 |          @param new_type (C++: const type_t *)
 |          @param new_fnames (C++: const p_list *)
 |  
 |  closebase(self, *args)
 |      The database will be closed now.
 |  
 |  cmt_changed(self, *args)
 |      An item comment has been changed.
 |      
 |      cmt_changed(self, ea, repeatable_cmt)
 |          @param ea (C++: ea_t)
 |          @param repeatable_cmt (C++: bool)
 |  
 |  compiler_changed(self, *args)
 |      The kernel has changed the compiler information. (\inf{cc} structure;
 |      'get_abi_name' )
 |  
 |  deleting_enum(self, *args)
 |      An enum type is to be deleted.
 |      
 |      deleting_enum(self, id)
 |          @param id (C++: enum_t)
 |  
 |  deleting_enum_member(self, *args)
 |      An enum member is to be deleted.
 |      
 |      deleting_enum_member(self, id, cid)
 |          @param id (C++: enum_t)
 |          @param cid (C++: const_t)
 |  
 |  deleting_func(self, *args)
 |      The kernel is about to delete a function.
 |      
 |      deleting_func(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  deleting_func_tail(self, *args)
 |      A function tail chunk is to be removed.
 |      
 |      deleting_func_tail(self, pfn, tail)
 |          @param pfn (C++: func_t *)
 |          @param tail (C++: const range_t *)
 |  
 |  deleting_segm(self, *args)
 |      A segment is to be deleted.
 |      
 |      deleting_segm(self, start_ea)
 |          @param start_ea (C++: ea_t)
 |  
 |  deleting_struc(self, *args)
 |      A structure type is to be deleted.
 |      
 |      deleting_struc(self, sptr)
 |          @param sptr (C++: struc_t *)
 |  
 |  deleting_struc_member(self, *args)
 |      A structure member is to be deleted.
 |      
 |      deleting_struc_member(self, sptr, mptr)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |  
 |  deleting_tryblks(self, *args)
 |      About to delete tryblk information in given range
 |      
 |      deleting_tryblks(self, range)
 |          @param range (C++: const range_t *)
 |  
 |  destroyed_items(self, *args)
 |      Instructions/data have been destroyed in [ea1,ea2).
 |      
 |      destroyed_items(self, ea1, ea2, will_disable_range)
 |          @param ea1 (C++: ea_t)
 |          @param ea2 (C++: ea_t)
 |          @param will_disable_range (C++: bool)
 |  
 |  determined_main(self, *args)
 |      The main() function has been determined.
 |      
 |      determined_main(self, main)
 |          @param main: address of the main() function  (C++: ea_t)
 |  
 |  dirtree_link(self, *args)
 |      Dirtree: an item has been linked/unlinked.
 |      
 |      dirtree_link(self, dt, path, link)
 |          @param dt (C++: dirtree_t *)
 |          @param path (C++: const char *)
 |          @param link (C++: bool)
 |  
 |  dirtree_mkdir(self, *args)
 |      Dirtree: a directory has been created.
 |      
 |      dirtree_mkdir(self, dt, path)
 |          @param dt (C++: dirtree_t *)
 |          @param path (C++: const char *)
 |  
 |  dirtree_move(self, *args)
 |      Dirtree: a directory or item has been moved.
 |      
 |      dirtree_move(self, dt, _from, to)
 |          @param dt (C++: dirtree_t *)
 |          @param _from (C++: const char *)
 |          @param to (C++: const char *)
 |  
 |  dirtree_rank(self, *args)
 |      Dirtree: a directory or item rank has been changed.
 |      
 |      dirtree_rank(self, dt, path, rank)
 |          @param dt (C++: dirtree_t *)
 |          @param path (C++: const char *)
 |          @param rank (C++: size_t)
 |  
 |  dirtree_rmdir(self, *args)
 |      Dirtree: a directory has been deleted.
 |      
 |      dirtree_rmdir(self, dt, path)
 |          @param dt (C++: dirtree_t *)
 |          @param path (C++: const char *)
 |  
 |  dirtree_rminode(self, *args)
 |      Dirtree: an inode became unavailable.
 |      
 |      dirtree_rminode(self, dt, inode)
 |          @param dt (C++: dirtree_t *)
 |          @param inode (C++: inode_t)
 |  
 |  enum_bf_changed(self, *args)
 |      An enum type 'bitfield' attribute has been changed.
 |      
 |      enum_bf_changed(self, id)
 |          @param id (C++: enum_t)
 |  
 |  enum_cmt_changed(self, *args)
 |      An enum or member type comment has been changed.
 |      
 |      enum_cmt_changed(self, id, repeatable)
 |          @param id (C++: tid_t)
 |          @param repeatable (C++: bool)
 |  
 |  enum_created(self, *args)
 |      An enum type has been created.
 |      
 |      enum_created(self, id)
 |          @param id (C++: enum_t)
 |  
 |  enum_deleted(self, *args)
 |      An enum type has been deleted.
 |      
 |      enum_deleted(self, id)
 |          @param id (C++: enum_t)
 |  
 |  enum_member_created(self, *args)
 |      An enum member has been created.
 |      
 |      enum_member_created(self, id, cid)
 |          @param id (C++: enum_t)
 |          @param cid (C++: const_t)
 |  
 |  enum_member_deleted(self, *args)
 |      An enum member has been deleted.
 |      
 |      enum_member_deleted(self, id, cid)
 |          @param id (C++: enum_t)
 |          @param cid (C++: const_t)
 |  
 |  enum_renamed(self, *args)
 |      An enum or member has been renamed.
 |      
 |      enum_renamed(self, id)
 |          @param id (C++: tid_t)
 |  
 |  expanding_struc(self, *args)
 |      A structure type is to be expanded/shrunk.
 |      
 |      expanding_struc(self, sptr, offset, delta)
 |          @param sptr (C++: struc_t *)
 |          @param offset (C++: ea_t)
 |          @param delta (C++: adiff_t)
 |  
 |  extlang_changed(self, *args)
 |      The list of extlangs or the default extlang was changed.
 |      
 |      extlang_changed(self, kind, el, idx)
 |          @param kind: 0: extlang installed 1: extlang removed 2: default
 |                       extlang changed  (C++: int)
 |          @param el: pointer to the extlang affected  (C++: extlang_t *)
 |          @param idx: extlang index  (C++: int)
 |  
 |  extra_cmt_changed(self, *args)
 |      An extra comment has been changed.
 |      
 |      extra_cmt_changed(self, ea, line_idx, cmt)
 |          @param ea (C++: ea_t)
 |          @param line_idx (C++: int)
 |          @param cmt (C++: const char *)
 |  
 |  flow_chart_created(self, *args)
 |      Gui has retrieved a function flow chart. Plugins may modify the flow
 |      chart in this callback.
 |      
 |      flow_chart_created(self, fc)
 |          @param fc (C++: qflow_chart_t *)
 |  
 |  frame_deleted(self, *args)
 |      The kernel has deleted a function frame.
 |      
 |      frame_deleted(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  func_added(self, *args)
 |      The kernel has added a function.
 |      
 |      func_added(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  func_deleted(self, *args)
 |      A function has been deleted.
 |      
 |      func_deleted(self, func_ea)
 |          @param func_ea (C++: ea_t)
 |  
 |  func_noret_changed(self, *args)
 |      'FUNC_NORET' bit has been changed.
 |      
 |      func_noret_changed(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  func_tail_appended(self, *args)
 |      A function tail chunk has been appended.
 |      
 |      func_tail_appended(self, pfn, tail)
 |          @param pfn (C++: func_t *)
 |          @param tail (C++: func_t *)
 |  
 |  func_tail_deleted(self, *args)
 |      A function tail chunk has been removed.
 |      
 |      func_tail_deleted(self, pfn, tail_ea)
 |          @param pfn (C++: func_t *)
 |          @param tail_ea (C++: ea_t)
 |  
 |  func_updated(self, *args)
 |      The kernel has updated a function.
 |      
 |      func_updated(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  idasgn_loaded(self, *args)
 |      FLIRT signature has been loaded for normal processing (not for
 |      recognition of startup sequences).
 |      
 |      idasgn_loaded(self, short_sig_name)
 |          @param short_sig_name (C++: const char *)
 |  
 |  item_color_changed(self, *args)
 |      An item color has been changed.
 |      
 |      item_color_changed(self, ea, color)
 |          @param ea (C++: ea_t)
 |          @param color: if color==DEFCOLOR, the the color is deleted.  (C++:
 |                        bgcolor_t)
 |  
 |  kernel_config_loaded(self, *args)
 |      This event is issued when ida.cfg is parsed.
 |      
 |      kernel_config_loaded(self, pass_number)
 |          @param pass_number (C++: int)
 |  
 |  loader_finished(self, *args)
 |      External file loader finished its work. Use this event to augment the
 |      existing loader functionality.
 |      
 |      loader_finished(self, li, neflags, filetypename)
 |          @param li (C++: linput_t *)
 |          @param neflags: Load file flags  (C++: uint16)
 |          @param filetypename (C++: const char *)
 |  
 |  local_types_changed(self, *args)
 |      Local types have been changed.
 |  
 |  make_code(self, *args)
 |      An instruction is being created.
 |      
 |      make_code(self, insn)
 |          @param insn (C++: const insn_t*)
 |  
 |  make_data(self, *args)
 |      A data item is being created.
 |      
 |      make_data(self, ea, flags, tid, len)
 |          @param ea (C++: ea_t)
 |          @param flags (C++: flags_t)
 |          @param tid (C++: tid_t)
 |          @param len (C++: asize_t)
 |  
 |  op_ti_changed(self, *args)
 |      An operand typestring (c/c++ prototype) has been changed.
 |      
 |      op_ti_changed(self, ea, n, type, fnames)
 |          @param ea (C++: ea_t)
 |          @param n (C++: int)
 |          @param type (C++: const type_t *)
 |          @param fnames (C++: const p_list *)
 |  
 |  op_type_changed(self, *args)
 |      An operand type (offset, hex, etc...) has been set or deleted.
 |      
 |      op_type_changed(self, ea, n)
 |          @param ea (C++: ea_t)
 |          @param n: eventually or'ed with OPND_OUTER or OPND_ALL  (C++: int)
 |  
 |  range_cmt_changed(self, *args)
 |      Range comment has been changed.
 |      
 |      range_cmt_changed(self, kind, a, cmt, repeatable)
 |          @param kind (C++: range_kind_t)
 |          @param a (C++: const range_t *)
 |          @param cmt (C++: const char *)
 |          @param repeatable (C++: bool)
 |  
 |  renamed(self, *args)
 |      The kernel has renamed a byte. See also the \idpcode{rename} event
 |      
 |      renamed(self, ea, new_name, local_name)
 |          @param ea (C++: ea_t)
 |          @param new_name (C++: const char *)
 |          @param local_name (C++: bool)
 |  
 |  renaming_enum(self, *args)
 |      An enum or enum member is to be renamed.
 |      
 |      renaming_enum(self, id, is_enum, newname)
 |          @param id (C++: tid_t)
 |          @param is_enum (C++: bool)
 |          @param newname (C++: const char *)
 |  
 |  renaming_struc(self, *args)
 |      A structure type is to be renamed.
 |      
 |      renaming_struc(self, id, oldname, newname)
 |          @param id (C++: tid_t)
 |          @param oldname (C++: const char *)
 |          @param newname (C++: const char *)
 |  
 |  renaming_struc_member(self, *args)
 |      A structure member is to be renamed.
 |      
 |      renaming_struc_member(self, sptr, mptr, newname)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |          @param newname (C++: const char *)
 |  
 |  savebase(self, *args)
 |      The database is being saved.
 |  
 |  segm_added(self, *args)
 |      A new segment has been created.
 |      
 |      segm_added(self, s)
 |          @param s: See also adding_segm  (C++: segment_t *)
 |  
 |  segm_attrs_updated(self, *args)
 |      Segment attributes has been changed.
 |      
 |      segm_attrs_updated(self, s)
 |          @param s: This event is generated for secondary segment attributes
 |                    (examples: color, permissions, etc)  (C++: segment_t *)
 |  
 |  segm_class_changed(self, *args)
 |      Segment class has been changed.
 |      
 |      segm_class_changed(self, s, sclass)
 |          @param s (C++: segment_t *)
 |          @param sclass (C++: const char *)
 |  
 |  segm_deleted(self, *args)
 |      A segment has been deleted.
 |      
 |      segm_deleted(self, start_ea, end_ea)
 |          @param start_ea (C++: ea_t)
 |          @param end_ea (C++: ea_t)
 |  
 |  segm_end_changed(self, *args)
 |      Segment end address has been changed.
 |      
 |      segm_end_changed(self, s, oldend)
 |          @param s (C++: segment_t *)
 |          @param oldend (C++: ea_t)
 |  
 |  segm_moved(self, *args)
 |      Segment has been moved.
 |      
 |      segm_moved(self, _from, to, size, changed_netmap)
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @param size (C++: asize_t)
 |          @param changed_netmap: See also idb_event::allsegs_moved  (C++: bool)
 |  
 |  segm_name_changed(self, *args)
 |      Segment name has been changed.
 |      
 |      segm_name_changed(self, s, name)
 |          @param s (C++: segment_t *)
 |          @param name (C++: const char *)
 |  
 |  segm_start_changed(self, *args)
 |      Segment start address has been changed.
 |      
 |      segm_start_changed(self, s, oldstart)
 |          @param s (C++: segment_t *)
 |          @param oldstart (C++: ea_t)
 |  
 |  set_func_end(self, *args)
 |      Function chunk end address will be changed.
 |      
 |      set_func_end(self, pfn, new_end)
 |          @param pfn (C++: func_t *)
 |          @param new_end (C++: ea_t)
 |  
 |  set_func_start(self, *args)
 |      Function chunk start address will be changed.
 |      
 |      set_func_start(self, pfn, new_start)
 |          @param pfn (C++: func_t *)
 |          @param new_start (C++: ea_t)
 |  
 |  sgr_changed(self, *args)
 |      The kernel has changed a segment register value.
 |      
 |      sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag)
 |          @param start_ea (C++: ea_t)
 |          @param end_ea (C++: ea_t)
 |          @param regnum (C++: int)
 |          @param value (C++: sel_t)
 |          @param old_value (C++: sel_t)
 |          @param tag: Segment register range tags  (C++: uchar)
 |  
 |  sgr_deleted(self, *args)
 |      The kernel has deleted a segment register value.
 |      
 |      sgr_deleted(self, start_ea, end_ea, regnum)
 |          @param start_ea (C++: ea_t)
 |          @param end_ea (C++: ea_t)
 |          @param regnum (C++: int)
 |  
 |  stkpnts_changed(self, *args)
 |      Stack change points have been modified.
 |      
 |      stkpnts_changed(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  struc_align_changed(self, *args)
 |      A structure type has been changed (the struct alignment).
 |      
 |      struc_align_changed(self, sptr)
 |          @param sptr (C++: struc_t *)
 |  
 |  struc_cmt_changed(self, *args)
 |      A structure type comment has been changed.
 |      
 |      struc_cmt_changed(self, struc_id, repeatable_cmt)
 |          @param struc_id (C++: tid_t)
 |          @param repeatable_cmt (C++: bool)
 |  
 |  struc_created(self, *args)
 |      A new structure type has been created.
 |      
 |      struc_created(self, struc_id)
 |          @param struc_id (C++: tid_t)
 |  
 |  struc_deleted(self, *args)
 |      A structure type has been deleted.
 |      
 |      struc_deleted(self, struc_id)
 |          @param struc_id (C++: tid_t)
 |  
 |  struc_expanded(self, *args)
 |      A structure type has been expanded/shrank.
 |      
 |      struc_expanded(self, sptr)
 |          @param sptr (C++: struc_t *)
 |  
 |  struc_member_changed(self, *args)
 |      A structure member has been changed.
 |      
 |      struc_member_changed(self, sptr, mptr)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |  
 |  struc_member_created(self, *args)
 |      A structure member has been created.
 |      
 |      struc_member_created(self, sptr, mptr)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |  
 |  struc_member_deleted(self, *args)
 |      A structure member has been deleted.
 |      
 |      struc_member_deleted(self, sptr, member_id, offset)
 |          @param sptr (C++: struc_t *)
 |          @param member_id (C++: tid_t)
 |          @param offset (C++: ea_t)
 |  
 |  struc_member_renamed(self, *args)
 |      A structure member has been renamed.
 |      
 |      struc_member_renamed(self, sptr, mptr)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |  
 |  struc_renamed(self, *args)
 |      A structure type has been renamed.
 |      
 |      struc_renamed(self, sptr)
 |          @param sptr (C++: struc_t *)
 |  
 |  tail_owner_changed(self, *args)
 |      A tail chunk owner has been changed.
 |      
 |      tail_owner_changed(self, tail, owner_func, old_owner)
 |          @param tail (C++: func_t *)
 |          @param owner_func (C++: ea_t)
 |          @param old_owner (C++: ea_t)
 |  
 |  thunk_func_created(self, *args)
 |      A thunk bit has been set for a function.
 |      
 |      thunk_func_created(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  ti_changed(self, *args)
 |      An item typestring (c/c++ prototype) has been changed.
 |      
 |      ti_changed(self, ea, type, fnames)
 |          @param ea (C++: ea_t)
 |          @param type (C++: const type_t *)
 |          @param fnames (C++: const p_list *)
 |  
 |  tryblks_updated(self, *args)
 |      Updated tryblk information
 |      
 |      tryblks_updated(self, tbv)
 |          @param tbv (C++: const tryblks_t *)
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  updating_tryblks(self, *args)
 |      About to update tryblk information
 |      
 |      updating_tryblks(self, tbv)
 |          @param tbv (C++: const tryblks_t *)
 |  
 |  upgraded(self, *args)
 |      The database has been upgraded and the receiver can upgrade its info
 |      as well
 |      
 |      upgraded(self, _from)
 |          @param _from: - old IDB version  (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_IDB_Hooks>
 |      delete_IDB_Hooks(self)

Help on class IDP_Hooks in module ida_idp:

class IDP_Hooks(__builtin__.object)
 |  Proxy of C++ IDP_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> IDP_Hooks
 |          _flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ev_add_cref(self, *args)
 |      A code reference is being created.
 |      
 |      ev_add_cref(self, _from, to, type) -> int
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @param type (C++: cref_t)
 |          @retval: <0 - cancel cref creation
 |          @retval: 0 - not implemented or continue
 |  
 |  ev_add_dref(self, *args)
 |      A data reference is being created.
 |      
 |      ev_add_dref(self, _from, to, type) -> int
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @param type (C++: dref_t)
 |          @retval: <0 - cancel dref creation
 |          @retval: 0 - not implemented or continue
 |  
 |  ev_adjust_argloc(self, *args)
 |      Adjust argloc according to its type/size and platform endianess
 |      
 |      ev_adjust_argloc(self, argloc, optional_type, size) -> int
 |          @param argloc: , inout  (C++: argloc_t *)
 |          optional_type: tinfo_t const *
 |          @param size: 'size' makes no sense if type != NULL (type->get_size()
 |                       should be used instead)  (C++: int)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |          @retval: -1 - error
 |  
 |  ev_adjust_libfunc_ea(self, *args)
 |      Called when a signature module has been matched against bytes in the
 |      database. This is used to compute the offset at which a particular
 |      module's libfunc should be applied.'ea' initially contains the ea_t of
 |      the start of the pattern match
 |      
 |      ev_adjust_libfunc_ea(self, sig, libfun, ea) -> int
 |          @param sig (C++: const idasgn_t *)
 |          @param libfun (C++: const libfunc_t *)
 |          @param ea (C++: ea_t *)
 |          @retval: 1 - the ea_t pointed to by the third argument was modified.
 |          @retval: <=0 - not modified. use default algorithm.
 |  
 |  ev_adjust_refinfo(self, *args)
 |      Called from apply_fixup before converting operand to reference. Can be
 |      used for changing the reference info. (e.g. the PPC module adds
 |      REFINFO_NOBASE for some references)
 |      
 |      ev_adjust_refinfo(self, ri, ea, n, fd) -> int
 |          @param ri (C++: refinfo_t *)
 |          @param ea: instruction address  (C++: ea_t)
 |          @param n: operand number  (C++: int)
 |          @param fd (C++: const fixup_data_t *)
 |          @retval: <0 - do not create an offset
 |          @retval: 0 - not implemented or refinfo adjusted
 |  
 |  ev_ana_insn(self, *args)
 |      Analyze one instruction and fill 'out' structure. This function
 |      shouldn't change the database, flags or anything else. All these
 |      actions should be performed only by emu_insn() function. \insn_t{ea}
 |      contains address of instruction to analyze.
 |      
 |      ev_ana_insn(self, out) -> bool
 |          @param out (C++: insn_t *)
 |          @retval: 0 - if instruction can't be decoded.
 |  
 |  ev_analyze_prolog(self, *args)
 |      Analyzes function prolog, epilog, and updates purge, and function
 |      attributes
 |      
 |      ev_analyze_prolog(self, ea) -> int
 |          @param ea: start of function  (C++: ea_t)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_arch_changed(self, *args)
 |      The loader is done parsing arch-related information, which the
 |      processor module might want to use to finish its initialization.
 |  
 |  ev_arg_addrs_ready(self, *args)
 |      Argument address info is ready.
 |      
 |      ev_arg_addrs_ready(self, caller, n, tif, addrs) -> int
 |          @param caller (C++: ea_t)
 |          @param n: number of formal arguments  (C++: int)
 |          @param tif: call prototype  (C++: tinfo_t *)
 |          @param addrs: argument intilization addresses  (C++: ea_t *)
 |          @retval: <0 - do not save into idb; other values mean "ok to save"
 |  
 |  ev_asm_installed(self, *args)
 |      After setting a new assembler
 |      
 |      ev_asm_installed(self, asmnum) -> int
 |          @param asmnum: See also ev_newasm  (C++: int)
 |  
 |  ev_assemble(self, *args)
 |      Assemble an instruction. (display a warning if an error is found).
 |      
 |      ev_assemble(self, ea, cs, ip, use32, line) -> PyObject *
 |          @param ea: linear address of instruction  (C++: ea_t)
 |          @param cs: cs of instruction  (C++: ea_t)
 |          @param ip: ip of instruction  (C++: ea_t)
 |          @param use32: is 32bit segment?  (C++: bool)
 |          @param line: line to assemble  (C++: const char *)
 |  
 |  ev_auto_queue_empty(self, *args)
 |      One analysis queue is empty.
 |      
 |      ev_auto_queue_empty(self, type) -> int
 |          @param type (C++: atype_t)
 |          @retval: void - see also  idb_event::auto_empty_finally
 |  
 |  ev_calc_arglocs(self, *args)
 |      Calculate function argument locations. This callback should fill
 |      retloc, all arglocs, and stkargs. This callback is never called for
 |      'CM_CC_SPECIAL' functions.
 |      
 |      ev_calc_arglocs(self, fti) -> int
 |          @param fti: points to the func type info  (C++: func_type_data_t *)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |          @retval: -1 - error
 |  
 |  ev_calc_cdecl_purged_bytes(self, *args)
 |      Calculate number of purged bytes after call.
 |      
 |      ev_calc_cdecl_purged_bytes(self, ea) -> int
 |          @param ea: address of the call instruction  (C++: ea_t)
 |          @return: number of purged bytes (usually add sp, N)
 |  
 |  ev_calc_next_eas(self, *args)
 |      Calculate list of addresses the instruction in 'insn' may pass control
 |      to. This callback is required for source level debugging.
 |      
 |      ev_calc_next_eas(self, res, insn, over) -> int
 |          @param res: , out: array for the results.  (C++: eavec_t *)
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @param over: calculate for step over (ignore call targets)  (C++:
 |                       bool)
 |          @retval: <0 - incalculable (indirect jumps, for example)
 |          @retval: >=0 - number of addresses of called functions in the array.
 |                         They must be put at the beginning of the array (0 if
 |                         over=true)
 |  
 |  ev_calc_purged_bytes(self, *args)
 |      Calculate number of purged bytes by the given function type.
 |      
 |      ev_calc_purged_bytes(self, p_purged_bytes, fti) -> int
 |          @param p_purged_bytes: ptr to output  (C++: int *)
 |          @param fti: func type details  (C++: const func_type_data_t *)
 |          @retval: 1 -
 |          @retval: 0 - not implemented
 |  
 |  ev_calc_retloc(self, *args)
 |      Calculate return value location.
 |      
 |      ev_calc_retloc(self, retloc, rettype, cc) -> int
 |          @param retloc (C++: argloc_t *)
 |          @param rettype (C++: const tinfo_t *)
 |          @param cc (C++: cm_t)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok,
 |          @retval: -1 - error
 |  
 |  ev_calc_spdelta(self, *args)
 |      Calculate amount of change to sp for the given insn. This event is
 |      required to decompile code snippets.
 |      
 |      ev_calc_spdelta(self, spdelta, insn) -> int
 |          @param spdelta (C++: sval_t *)
 |          @param insn (C++: const insn_t *)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_calc_step_over(self, *args)
 |      Calculate the address of the instruction which will be executed after
 |      "step over". The kernel will put a breakpoint there. If the step over
 |      is equal to step into or we cannot calculate the address, return
 |      'BADADDR' .
 |      
 |      ev_calc_step_over(self, target, ip) -> int
 |          @param target: pointer to the answer  (C++: ea_t *)
 |          @param ip: instruction address  (C++: ea_t)
 |          @retval: 0 - unimplemented
 |          @retval: 1 - implemented
 |  
 |  ev_calc_switch_cases(self, *args)
 |      Calculate case values and targets for a custom jump table.
 |      
 |      ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -> int
 |          @param casevec: vector of case values (may be NULL)  (C++: casevec_t
 |                          *)
 |          @param targets: corresponding target addresses (my be NULL)  (C++:
 |                          eavec_t *)
 |          @param insn_ea: address of the 'indirect jump' instruction  (C++:
 |                          ea_t)
 |          @param si: switch information  (C++: switch_info_t *)
 |          @retval: 1 - ok
 |          @retval: <=0 - failed
 |  
 |  ev_calc_varglocs(self, *args)
 |      Calculate locations of the arguments that correspond to '...'.
 |      
 |      ev_calc_varglocs(self, ftd, aux_regs, aux_stkargs, nfixed) -> int
 |          @param ftd: , inout: info about all arguments (including varargs)
 |                      (C++: func_type_data_t *)
 |          @param aux_regs: buffer for hidden register arguments, may be NULL
 |                           (C++: regobjs_t *)
 |          @param aux_stkargs: buffer for hidden stack arguments, may be NULL
 |                              (C++: relobj_t *)
 |          @param nfixed: number of fixed arguments  (C++: int)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |          @retval: -1 - error On some platforms variadic calls require passing
 |                        additional information: for example, number of floating
 |                        variadic arguments must be passed in rax on gcc-x64. The
 |                        locations and values that constitute this additional
 |                        information are returned in the buffers pointed by
 |                        aux_regs and aux_stkargs
 |  
 |  ev_calcrel(self, *args)
 |      Reserved.
 |  
 |  ev_can_have_type(self, *args)
 |      Can the operand have a type as offset, segment, decimal, etc? (for
 |      example, a register AX can't have a type, meaning that the user can't
 |      change its representation. see 'bytes.hpp' for information about types
 |      and flags)
 |      
 |      ev_can_have_type(self, op) -> int
 |          @param op (C++: const op_t *)
 |          @retval: 0 - unknown
 |          @retval: <0 - no
 |          @retval: 1 - yes
 |  
 |  ev_clean_tbit(self, *args)
 |      Clear the TF bit after an insn like pushf stored it in memory.
 |      
 |      ev_clean_tbit(self, ea, getreg, regvalues) -> int
 |          @param ea: instruction address  (C++: ea_t)
 |          @param getreg: function to get register values  (C++:
 |                         processor_t::regval_getter_t *)
 |          @param regvalues: register values array  (C++: const regval_t *)
 |          @retval: 1 - ok
 |          @retval: 0 - failed
 |  
 |  ev_cmp_operands(self, *args)
 |      Compare instruction operands
 |      
 |      ev_cmp_operands(self, op1, op2) -> int
 |          @param op1 (C++: const op_t*)
 |          @param op2 (C++: const op_t*)
 |          @retval: 1 - equal
 |          @retval: -1 - not equal
 |          @retval: 0 - not implemented
 |  
 |  ev_coagulate(self, *args)
 |      Try to define some unexplored bytes. This notification will be called
 |      if the kernel tried all possibilities and could not find anything more
 |      useful than to convert to array of bytes. The module can help the
 |      kernel and convert the bytes into something more useful.
 |      
 |      ev_coagulate(self, start_ea) -> int
 |          @param start_ea (C++: ea_t)
 |          @return: number of converted bytes
 |  
 |  ev_coagulate_dref(self, *args)
 |      Data reference is being analyzed. plugin may correct 'code_ea' (e.g.
 |      for thumb mode refs, we clear the last bit)
 |      
 |      ev_coagulate_dref(self, _from, to, may_define, code_ea) -> int
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @param may_define (C++: bool)
 |          @param code_ea (C++: ea_t *)
 |          @retval: <0 - cancel dref analysis
 |          @retval: 0 - not implemented or continue
 |  
 |  ev_create_flat_group(self, *args)
 |      Create special segment representing the flat group.
 |      
 |      ev_create_flat_group(self, image_base, bitness, dataseg_sel) -> int
 |          @param image_base (C++: ea_t)
 |          @param bitness (C++: int)
 |          @param dataseg_sel: return value is ignored  (C++: sel_t)
 |  
 |  ev_create_func_frame(self, *args)
 |      Create a function frame for a newly created function Set up frame
 |      size, its attributes etc
 |      
 |      ev_create_func_frame(self, pfn) -> int
 |          @param pfn (C++: func_t *)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_create_switch_xrefs(self, *args)
 |      Create xrefs for a custom jump table.
 |      
 |      ev_create_switch_xrefs(self, jumpea, si) -> int
 |          @param jumpea: address of the jump insn  (C++: ea_t)
 |          @param si: switch information  (C++: const switch_info_t *)
 |          @return: must return 1 Must be implemented if module uses custom jump
 |                   tables,
 |  
 |  ev_creating_segm(self, *args)
 |      A new segment is about to be created.
 |      
 |      ev_creating_segm(self, seg) -> int
 |          @param seg (C++: segment_t *)
 |          @retval: 1 - ok
 |          @retval: <0 - segment should not be created
 |  
 |  ev_decorate_name(self, *args)
 |      Decorate/undecorate a C symbol name.
 |      
 |      ev_decorate_name(self, name, mangle, cc, optional_type) -> PyObject *
 |          @param name: name of symbol  (C++: const char *)
 |          @param mangle: true-mangle, false-unmangle  (C++: bool)
 |          @param cc: calling convention  (C++: cm_t)
 |          optional_type: tinfo_t const *
 |          @retval: 1 - if success
 |          @retval: 0 - not implemented or failed
 |  
 |  ev_del_cref(self, *args)
 |      A code reference is being deleted.
 |      
 |      ev_del_cref(self, _from, to, expand) -> int
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @param expand (C++: bool)
 |          @retval: <0 - cancel cref deletion
 |          @retval: 0 - not implemented or continue
 |  
 |  ev_del_dref(self, *args)
 |      A data reference is being deleted.
 |      
 |      ev_del_dref(self, _from, to) -> int
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @retval: <0 - cancel dref deletion
 |          @retval: 0 - not implemented or continue
 |  
 |  ev_delay_slot_insn(self, *args)
 |      Get delay slot instructionInput EA may point to the instruction with a
 |      delay slot or to the delay slot instruction itself.
 |      
 |      ev_delay_slot_insn(self, ea, bexec, fexec) -> PyObject *
 |          @param ea: in: instruction address in question, out: (if the answer is
 |                     positive) if the delay slot contains valid insn: the
 |                     address of the delay slot insn else: BADADDR (invalid insn,
 |                     e.g. a branch)  (C++: ea_t *)
 |          @param bexec: execute slot if jumping, initially set to 'true'  (C++:
 |                        bool *)
 |          @param fexec: execute slot if not jumping, initally set to 'true'
 |                        (C++: bool *)
 |          @retval: 1 - positive answer
 |          @retval: <=0 - ordinary insn
 |  
 |  ev_demangle_name(self, *args)
 |      Demangle a C++ (or another language) name into a user-readable string.
 |      This event is called by 'demangle_name()' if you call
 |      'demangle_name()' from the handler, protect against recursion!
 |      
 |      ev_demangle_name(self, name, disable_mask, demreq) -> PyObject *
 |          @param name: mangled name  (C++: const char *)
 |          @param disable_mask: flags to inhibit parts of output or compiler
 |                               info/other (see MNG_)  (C++: uint32)
 |          @param demreq: operation to perform  (C++: demreq_type_t)
 |          @retval: 1 - if success
 |          @retval: 0 - not implemented
 |  
 |  ev_emu_insn(self, *args)
 |      Emulate instruction, create cross-references, plan to analyze
 |      subsequent instructions, modify flags etc. Upon entrance to this
 |      function, all information about the instruction is in 'insn'
 |      structure.
 |      
 |      ev_emu_insn(self, insn) -> bool
 |          @param insn (C++: const insn_t *)
 |          @retval: 1 - ok
 |          @retval: -1 - the kernel will delete the instruction
 |  
 |  ev_endbinary(self, *args)
 |      IDA has loaded a binary file.
 |      
 |      ev_endbinary(self, ok) -> int
 |          @param ok: file loaded successfully?  (C++: bool)
 |  
 |  ev_ending_undo(self, *args)
 |      Ended undoing/redoing an action
 |      
 |      ev_ending_undo(self, action_name, is_undo) -> int
 |          @param action_name: action that we finished undoing/redoing. is not
 |                              NULL.  (C++: const char *)
 |          @param is_undo: true if performing undo, false if performing redo
 |                          (C++: bool)
 |  
 |  ev_equal_reglocs(self, *args)
 |      Are 2 register arglocs the same?. We need this callback for the pc
 |      module.
 |      
 |      ev_equal_reglocs(self, a1, a2) -> int
 |          @param a1 (C++: argloc_t *)
 |          @param a2 (C++: argloc_t *)
 |          @retval: 1 - yes
 |          @retval: -1 - no
 |          @retval: 0 - not implemented
 |  
 |  ev_extract_address(self, *args)
 |      Extract address from a string.
 |      
 |      ev_extract_address(self, out_ea, screen_ea, string, position) -> int
 |          @param out_ea: , out  (C++: ea_t *)
 |          @param screen_ea (C++: ea_t)
 |          @param string (C++: const char *)
 |          @param position (C++: size_t)
 |          @retval: 1 - ok
 |          @retval: 0 - kernel should use the standard algorithm
 |          @retval: -1 - error
 |  
 |  ev_find_op_value(self, *args)
 |      Find operand value via a register tracker. The returned value in 'out'
 |      is valid before executing the instruction.
 |      
 |      ev_find_op_value(self, pinsn, opn) -> PyObject *
 |          @param pinsn: instruction  (C++: const insn_t *)
 |          @param opn: operand index  (C++: int)
 |          @retval: 1 - if implemented, and value was found
 |          @retval: 0 - not implemented, -1 decoding failed, or no value found
 |  
 |  ev_find_reg_value(self, *args)
 |      Find register value via a register tracker. The returned value in
 |      'out' is valid before executing the instruction.
 |      
 |      ev_find_reg_value(self, pinsn, reg) -> PyObject *
 |          @param pinsn: instruction  (C++: const insn_t *)
 |          @param reg: register index  (C++: int)
 |          @retval: 1 - if implemented, and value was found
 |          @retval: 0 - not implemented, -1 decoding failed, or no value found
 |  
 |  ev_func_bounds(self, *args)
 |      'find_func_bounds()' finished its work. The module may fine tune the
 |      function bounds
 |      
 |      ev_func_bounds(self, possible_return_code, pfn, max_func_end_ea) -> int
 |          @param possible_return_code: , in/out  (C++: int *)
 |          @param pfn (C++: func_t *)
 |          @param max_func_end_ea: (from the kernel's point of view)  (C++: ea_t)
 |          @retval: void -
 |  
 |  ev_gen_asm_or_lst(self, *args)
 |      Callback: generating asm or lst file. The kernel calls this callback
 |      twice, at the beginning and at the end of listing generation. The
 |      processor module can intercept this event and adjust its output
 |      
 |      ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline) -> int
 |          @param starting: beginning listing generation  (C++: bool)
 |          @param fp: output file  (C++: FILE *)
 |          @param is_asm: true:assembler, false:listing  (C++: bool)
 |          @param flags: flags passed to gen_file()  (C++: int)
 |          @param outline: ptr to ptr to outline callback. if this callback is
 |                          defined for this code, it will be used by the kernel
 |                          to output the generated lines  (C++: html_line_cb_t
 |                          **)
 |          @retval: void -
 |  
 |  ev_gen_map_file(self, *args)
 |      Generate map file. If not implemented the kernel itself will create
 |      the map file.
 |      
 |      ev_gen_map_file(self, nlines, fp) -> int
 |          @param nlines: number of lines in map file (-1 means write error)
 |                         (C++: int *)
 |          @param fp: output file  (C++: FILE *)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |          @retval: -1 - write error
 |  
 |  ev_gen_regvar_def(self, *args)
 |      Generate register variable definition line.
 |      
 |      ev_gen_regvar_def(self, outctx, v) -> int
 |          @param outctx (C++: outctx_t *)
 |          @param v (C++: regvar_t *)
 |          @retval: >0 - ok, generated the definition text
 |          @retval: 0 - not implemented
 |  
 |  ev_gen_src_file_lnnum(self, *args)
 |      Callback: generate analog of:
 |      
 |      < #line "file.c" 123
 |      <
 |      
 |      directive.
 |      
 |      ev_gen_src_file_lnnum(self, outctx, file, lnnum) -> int
 |          @param outctx: output context  (C++: outctx_t *)
 |          @param file: source file (may be NULL)  (C++: const char *)
 |          @param lnnum: line number  (C++: size_t)
 |          @retval: 1 - directive has been generated
 |          @retval: 0 - not implemented
 |  
 |  ev_gen_stkvar_def(self, *args)
 |      Generate stack variable definition line Default line is varname = type
 |      ptr value, where 'type' is one of byte,word,dword,qword,tbyte
 |      
 |      ev_gen_stkvar_def(self, outctx, mptr, v) -> int
 |          @param outctx (C++: outctx_t *)
 |          @param mptr (C++: const member_t *)
 |          @param v (C++: sval_t)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_get_abi_info(self, *args)
 |      Get all possible ABI names and optional extensions for given compiler
 |      abiname/option is a string entirely consisting of letters, digits and
 |      underscore
 |      
 |      ev_get_abi_info(self, abi_names, abi_opts, comp) -> int
 |          @param abi_names: - all possible ABis each in form abiname-
 |                            opt1-opt2-...  (C++: qstrvec_t *)
 |          @param abi_opts: - array of all possible options in form
 |                           "opt:description" or opt:hint-line#description  (C++:
 |                           qstrvec_t *)
 |          @param comp: - compiler ID  (C++: comp_t)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |  
 |  ev_get_autocmt(self, *args)
 |      Callback: get dynamic auto comment. Will be called if the autocomments
 |      are enabled and the comment retrieved from ida.int starts with '$!'.
 |      'insn' contains valid info.
 |      
 |      ev_get_autocmt(self, insn) -> PyObject *
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @retval: 1 - new comment has been generated
 |          @retval: 0 - callback has not been handled. the buffer must not be
 |                       changed in this case
 |  
 |  ev_get_bg_color(self, *args)
 |      Get item background color. Plugins can hook this callback to color
 |      disassembly lines dynamically
 |      
 |      ev_get_bg_color(self, ea) -> int or None
 |          @param color: , out  (C++: bgcolor_t *)
 |          @param ea (C++: ea_t)
 |          @retval: 0 - not implemented
 |          @retval: 1 - color set
 |  
 |  ev_get_cc_regs(self, *args)
 |      Get register allocation convention for given calling convention
 |      
 |      ev_get_cc_regs(self, regs, cc) -> int
 |          @param regs: , out  (C++: callregs_t *)
 |          @param cc (C++: cm_t)
 |          @retval: 1 -
 |          @retval: 0 - not implemented
 |  
 |  ev_get_code16_mode(self, *args)
 |      Get ISA 16-bit mode
 |      
 |      ev_get_code16_mode(self, ea) -> int
 |          @param ea: address to get the ISA mode  (C++: ea_t)
 |          @retval: 1 - 16-bit mode
 |          @retval: 0 - not implemented or 32-bit mode
 |  
 |  ev_get_dbr_opnum(self, *args)
 |      Get the number of the operand to be displayed in the debugger
 |      reference view (text mode).
 |      
 |      ev_get_dbr_opnum(self, opnum, insn) -> int
 |          @param opnum: operand number (out, -1 means no such operand)  (C++:
 |                        int *)
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @retval: 0 - unimplemented
 |          @retval: 1 - implemented
 |  
 |  ev_get_default_enum_size(self, *args)
 |      Get default enum size. Not generated anymore. inf_get_cc_size_e() is
 |      used instead
 |  
 |  ev_get_frame_retsize(self, *args)
 |      Get size of function return address in bytes If this event is not
 |      implemented, the kernel will assume8 bytes for 64-bit function4 bytes
 |      for 32-bit function2 bytes otherwise
 |      
 |      ev_get_frame_retsize(self, frsize, pfn) -> int
 |          @param frsize: frame size (out)  (C++: int *)
 |          @param pfn: , can't be NULL  (C++: const func_t *)
 |  
 |  ev_get_macro_insn_head(self, *args)
 |      Calculate the start of a macro instruction. This notification is
 |      called if IP points to the middle of an instruction
 |      
 |      ev_get_macro_insn_head(self, head, ip) -> int
 |          @param head: , out: answer, BADADDR means normal instruction  (C++:
 |                       ea_t *)
 |          @param ip: instruction address  (C++: ea_t)
 |          @retval: 0 - unimplemented
 |          @retval: 1 - implemented
 |  
 |  ev_get_operand_string(self, *args)
 |      Request text string for operand (cli, java, ...).
 |      
 |      ev_get_operand_string(self, insn, opnum) -> PyObject *
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @param opnum: operand number, -1 means any string operand  (C++: int)
 |          @retval: 0 - no string (or empty string)
 |          @retval: >0 - original string length without terminating zero
 |  
 |  ev_get_procmod(self, *args)
 |      Get pointer to the processor module object. All processor modules must
 |      implement this. The pointer is returned as size_t.
 |  
 |  ev_get_reg_accesses(self, *args)
 |      Get info about the registers that are used/changed by an instruction.
 |      
 |      ev_get_reg_accesses(self, accvec, insn, flags) -> int
 |          @param accvec: out: info about accessed registers  (C++:
 |                         reg_accesses_t*)
 |          @param insn: instruction in question  (C++: const insn_t *)
 |          @param flags: reserved, must be 0  (C++: int)
 |          @retval: -1 - if accvec is nullptr
 |          @retval: 1 - found the requested access (and filled accvec)
 |          @retval: 0 - not implemented
 |  
 |  ev_get_reg_info(self, *args)
 |      Get register information by its name. example: "ah"
 |      returns:main_regname="eax" 'bitrange_t' = { offset==8, nbits==8 }This
 |      callback may be unimplemented if the register names are all present in
 |      \ph{reg_names} and they all have the same size
 |      
 |      ev_get_reg_info(self, main_regname, bitrange, regname) -> int
 |          @param main_regname: , out  (C++: const char **)
 |          @param bitrange: , out: position and size of the value within
 |                           'main_regname' (empty bitrange == whole register)
 |                           (C++: bitrange_t *)
 |          @param regname (C++: const char *)
 |          @retval: 1 - ok
 |          @retval: -1 - failed (not found)
 |          @retval: 0 - unimplemented
 |  
 |  ev_get_reg_name(self, *args)
 |      Generate text representation of a register. Most processor modules do
 |      not need to implement this callback. It is useful only if
 |      \ph{reg_names}[reg] does not provide the correct register name.
 |      
 |      ev_get_reg_name(self, reg, width, reghi) -> PyObject *
 |          @param reg: internal register number as defined in the processor
 |                      module  (C++: int)
 |          @param width: register width in bytes  (C++: size_t)
 |          @param reghi: if not -1 then this function will return the register
 |                        pair  (C++: int)
 |          @retval: -1 - if error
 |          @retval: strlen(buf) - if success
 |  
 |  ev_get_simd_types(self, *args)
 |      Get SIMD-related types according to given attributes ant/or argument
 |      location
 |      
 |      ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -> int
 |          @param out (C++: simd_info_vec_t *)
 |          @param simd_attrs: , may be NULL  (C++: const simd_info_t *)
 |          @param argloc: , may be NULL  (C++: const argloc_t *)
 |          @param create_tifs: return valid tinfo_t objects, create if neccessary
 |                              (C++: bool)
 |          @retval: number - of found types
 |          @retval: -1 - error If name==NULL, initialize all SIMD types
 |  
 |  ev_get_stkarg_offset(self, *args)
 |      Get offset from SP to the first stack argument. For example: pc: 0,
 |      hppa: -0x34, ppc: 0x38
 |  
 |  ev_get_stkvar_scale_factor(self, *args)
 |      Should stack variable references be multiplied by a coefficient before
 |      being used in the stack frame?. Currently used by TMS320C55 because
 |      the references into the stack should be multiplied by 2
 |      'PR_SCALE_STKVARS' should be set to use this callback
 |  
 |  ev_getreg(self, *args)
 |      IBM PC only internal request, should never be used for other purpose
 |      Get register value by internal index
 |      
 |      ev_getreg(self, regval, regnum) -> int
 |          @param regval: , out  (C++: uval_t *)
 |          @param regnum (C++: int)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |          @retval: -1 - failed (undefined value or bad regnum)
 |  
 |  ev_init(self, *args)
 |      The IDP module is just loaded.
 |      
 |      ev_init(self, idp_modname) -> int
 |          @param idp_modname: processor module name  (C++: const char *)
 |          @retval: <0 - on failure
 |  
 |  ev_insn_reads_tbit(self, *args)
 |      Check if insn will read the TF bit.
 |      
 |      ev_insn_reads_tbit(self, insn, getreg, regvalues) -> int
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @param getreg: function to get register values  (C++:
 |                         processor_t::regval_getter_t *)
 |          @param regvalues: register values array  (C++: const regval_t *)
 |          @retval: 2 - yes, will generate 'step' exception
 |          @retval: 1 - yes, will store the TF bit in memory
 |          @retval: 0 - no
 |  
 |  ev_is_align_insn(self, *args)
 |      Is the instruction created only for alignment purposes?. Do not
 |      directly call this function, use 'is_align_insn()'
 |      
 |      ev_is_align_insn(self, ea) -> int
 |          @param ea: - instruction address  (C++: ea_t)
 |          @retval: number - of bytes in the instruction
 |  
 |  ev_is_alloca_probe(self, *args)
 |      Does the function at 'ea' behave as __alloca_probe?
 |      
 |      ev_is_alloca_probe(self, ea) -> int
 |          @param ea (C++: ea_t)
 |          @retval: 1 - yes
 |          @retval: 0 - no
 |  
 |  ev_is_basic_block_end(self, *args)
 |      Is the current instruction end of a basic block?. This function should
 |      be defined for processors with delayed jump slots.
 |      
 |      ev_is_basic_block_end(self, insn, call_insn_stops_block) -> int
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @param call_insn_stops_block (C++: bool)
 |          @retval: 0 - unknown
 |          @retval: <0 - no
 |          @retval: 1 - yes
 |  
 |  ev_is_call_insn(self, *args)
 |      Is the instruction a "call"?
 |      
 |      ev_is_call_insn(self, insn) -> int
 |          @param insn: instruction  (C++: const insn_t *)
 |          @retval: 0 - unknown
 |          @retval: <0 - no
 |          @retval: 1 - yes
 |  
 |  ev_is_cond_insn(self, *args)
 |      Is conditional instruction?
 |      
 |      ev_is_cond_insn(self, insn) -> int
 |          @param insn: instruction address  (C++: const insn_t *)
 |          @retval: 1 - yes
 |          @retval: -1 - no
 |          @retval: 0 - not implemented or not instruction
 |  
 |  ev_is_far_jump(self, *args)
 |      is indirect far jump or call instruction? meaningful only if the
 |      processor has 'near' and 'far' reference types
 |      
 |      ev_is_far_jump(self, icode) -> int
 |          @param icode (C++: int)
 |          @retval: 0 - not implemented
 |          @retval: 1 - yes
 |          @retval: -1 - no
 |  
 |  ev_is_indirect_jump(self, *args)
 |      Determine if instruction is an indirect jump. If 'CF_JUMP' bit cannot
 |      describe all jump types jumps, please define this callback.
 |      
 |      ev_is_indirect_jump(self, insn) -> int
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @retval: 0 - use  CF_JUMP
 |          @retval: 1 - no
 |          @retval: 2 - yes
 |  
 |  ev_is_insn_table_jump(self, *args)
 |      Determine if instruction is a table jump or call. If 'CF_JUMP' bit
 |      cannot describe all kinds of table jumps, please define this callback.
 |      It will be called for insns with 'CF_JUMP' bit set.
 |      
 |      ev_is_insn_table_jump(self, insn) -> int
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @retval: 0 - yes
 |          @retval: <0 - no
 |  
 |  ev_is_jump_func(self, *args)
 |      Is the function a trivial "jump" function?.
 |      
 |      ev_is_jump_func(self, pfn, jump_target, func_pointer) -> int
 |          @param pfn (C++: func_t *)
 |          @param jump_target (C++: ea_t *)
 |          @param func_pointer (C++: ea_t *)
 |          @retval: <0 - no
 |          @retval: 0 - don't know
 |          @retval: 1 - yes, see 'jump_target' and 'func_pointer'
 |  
 |  ev_is_ret_insn(self, *args)
 |      Is the instruction a "return"?
 |      
 |      ev_is_ret_insn(self, insn, strict) -> int
 |          @param insn: instruction  (C++: const insn_t *)
 |          @param strict: 1: report only ret instructions 0: include instructions
 |                         like "leave" which begins the function epilog  (C++:
 |                         bool)
 |          @retval: 0 - unknown
 |          @retval: <0 - no
 |          @retval: 1 - yes
 |  
 |  ev_is_sane_insn(self, *args)
 |      Is the instruction sane for the current file type?.
 |      
 |      ev_is_sane_insn(self, insn, no_crefs) -> int
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @param no_crefs: 1: the instruction has no code refs to it. ida just
 |                           tries to convert unexplored bytes to an instruction
 |                           (but there is no other reason to convert them into an
 |                           instruction) 0: the instruction is created because of
 |                           some coderef, user request or another weighty reason.
 |                           (C++: int)
 |          @retval: >=0 - ok
 |          @retval: <0 - no, the instruction isn't likely to appear in the
 |                        program
 |  
 |  ev_is_sp_based(self, *args)
 |      Check whether the operand is relative to stack pointer or frame
 |      pointer This event is used to determine how to output a stack variable
 |      If not implemented, then all operands are sp based by default.
 |      Implement this event only if some stack references use frame pointer
 |      instead of stack pointer.
 |      
 |      ev_is_sp_based(self, mode, insn, op) -> int
 |          @param mode: out, combination of SP/FP operand flags  (C++: int *)
 |          @param insn (C++: const insn_t *)
 |          @param op (C++: const op_t *)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |  
 |  ev_is_switch(self, *args)
 |      Find 'switch' idiom. It will be called for instructions marked with
 |      'CF_JUMP' .
 |      
 |      ev_is_switch(self, si, insn) -> int
 |          @param si: , out  (C++: switch_info_t *)
 |          @param insn: instruction possibly belonging to a switch  (C++: const
 |                       insn_t *)
 |          @retval: 1 - switch is found, 'si' is filled
 |          @retval: 0 - no switch found or not implemented
 |  
 |  ev_last_cb_before_loader(self, *args)
 |      ev_last_cb_before_loader(self) -> int
 |  
 |  ev_loader(self, *args)
 |      This code and higher ones are reserved for the loaders. The arguments
 |      and the return values are defined by the loaders
 |  
 |  ev_lower_func_type(self, *args)
 |      Get function arguments which should be converted to pointers when
 |      lowering function prototype. The processor module can also modify
 |      'fti' in order to make non-standard conversion of some arguments.
 |      
 |      ev_lower_func_type(self, argnums, fti) -> int
 |          @param argnums: , out - numbers of arguments to be converted to
 |                          pointers in acsending order  (C++: intvec_t *)
 |          @param fti: , inout func type details (special values -1/-2 for return
 |                      value - position of hidden 'retstr' argument: -1 - at the
 |                      beginning, -2 - at the end)  (C++: func_type_data_t *)
 |          @retval: 0 - not implemented
 |          @retval: 1 - argnums was filled
 |          @retval: 2 - argnums was filled and made substantial changes to fti
 |  
 |  ev_max_ptr_size(self, *args)
 |      Get maximal size of a pointer in bytes.
 |  
 |  ev_may_be_func(self, *args)
 |      Can a function start here?
 |      
 |      ev_may_be_func(self, insn, state) -> int
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @param state: autoanalysis phase 0: creating functions 1: creating
 |                        chunks  (C++: int)
 |          @return: probability 1..100
 |  
 |  ev_may_show_sreg(self, *args)
 |      The kernel wants to display the segment registers in the messages
 |      window.
 |      
 |      ev_may_show_sreg(self, current_ea) -> int
 |          @param current_ea (C++: ea_t)
 |          @retval: <0 - if the kernel should not show the segment registers.
 |                        (assuming that the module has done it)
 |          @retval: 0 - not implemented
 |  
 |  ev_moving_segm(self, *args)
 |      May the kernel move the segment?
 |      
 |      ev_moving_segm(self, seg, to, flags) -> int
 |          @param seg: segment to move  (C++: segment_t *)
 |          @param to: new segment start address  (C++: ea_t)
 |          @param flags: combination of Move segment flags  (C++: int)
 |          @retval: 0 - yes
 |          @retval: <0 - the kernel should stop
 |  
 |  ev_newasm(self, *args)
 |      Before setting a new assembler.
 |      
 |      ev_newasm(self, asmnum) -> int
 |          @param asmnum: See also ev_asm_installed  (C++: int)
 |  
 |  ev_newbinary(self, *args)
 |      IDA is about to load a binary file.
 |      
 |      ev_newbinary(self, filename, fileoff, basepara, binoff, nbytes) -> int
 |          @param filename: binary file name  (C++: char *)
 |          @param fileoff: offset in the file  (C++: qoff64_t)
 |          @param basepara: base loading paragraph  (C++: ea_t)
 |          @param binoff: loader offset  (C++: ea_t)
 |          @param nbytes: number of bytes to load  (C++: uint64)
 |  
 |  ev_newfile(self, *args)
 |      A new file has been loaded.
 |      
 |      ev_newfile(self, fname) -> int
 |          @param fname: input file name  (C++: char *)
 |  
 |  ev_newprc(self, *args)
 |      Before changing processor type.
 |      
 |      ev_newprc(self, pnum, keep_cfg) -> int
 |          @param pnum: processor number in the array of processor names  (C++:
 |                       int)
 |          @param keep_cfg: true: do not modify kernel configuration  (C++: bool)
 |          @retval: 1 - ok
 |          @retval: <0 - prohibit
 |  
 |  ev_next_exec_insn(self, *args)
 |      Get next address to be executed This function must return the next
 |      address to be executed. If the instruction following the current one
 |      is executed, then it must return 'BADADDR' Usually the instructions to
 |      consider are: jumps, branches, calls, returns. This function is
 |      essential if the 'single step' is not supported in hardware.
 |      
 |      ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -> int
 |          @param target: , out: pointer to the answer  (C++: ea_t *)
 |          @param ea: instruction address  (C++: ea_t)
 |          @param tid: current therad id  (C++: int)
 |          @param getreg: function to get register values  (C++:
 |                         processor_t::regval_getter_t *)
 |          @param regvalues: register values array  (C++: const regval_t *)
 |          @retval: 0 - unimplemented
 |          @retval: 1 - implemented
 |  
 |  ev_oldfile(self, *args)
 |      An old file has been loaded.
 |      
 |      ev_oldfile(self, fname) -> int
 |          @param fname: input file name  (C++: char *)
 |  
 |  ev_out_assumes(self, *args)
 |      Function to produce assume directives when segment register value
 |      changes.
 |      
 |      ev_out_assumes(self, outctx) -> int
 |          @param outctx (C++: outctx_t *)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_out_data(self, *args)
 |      Generate text representation of data items This function may change
 |      the database and create cross-references if analyze_only is set
 |      
 |      ev_out_data(self, outctx, analyze_only) -> int
 |          @param outctx (C++: outctx_t *)
 |          @param analyze_only (C++: bool)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_out_footer(self, *args)
 |      Function to produce end of disassembled text
 |      
 |      ev_out_footer(self, outctx) -> int
 |          @param outctx (C++: outctx_t *)
 |          @retval: void -
 |  
 |  ev_out_header(self, *args)
 |      Function to produce start of disassembled text
 |      
 |      ev_out_header(self, outctx) -> int
 |          @param outctx (C++: outctx_t *)
 |          @retval: void -
 |  
 |  ev_out_insn(self, *args)
 |      Generate text representation of an instruction in 'ctx.insn'
 |      'outctx_t' provides functions to output the generated text. This
 |      function shouldn't change the database, flags or anything else. All
 |      these actions should be performed only by emu_insn() function.
 |      
 |      ev_out_insn(self, outctx) -> bool
 |          @param outctx (C++: outctx_t *)
 |          @retval: void -
 |  
 |  ev_out_label(self, *args)
 |      The kernel is going to generate an instruction label line or a
 |      function header.
 |      
 |      ev_out_label(self, outctx, colored_name) -> int
 |          @param outctx (C++: outctx_t *)
 |          @param colored_name (C++: const char *)
 |          @retval: <0 - if the kernel should not generate the label
 |          @retval: 0 - not implemented or continue
 |  
 |  ev_out_mnem(self, *args)
 |      Generate instruction mnemonics. This callback should append the
 |      colored mnemonics to ctx.outbuf Optional notification, if absent,
 |      out_mnem will be called.
 |      
 |      ev_out_mnem(self, outctx) -> int
 |          @param outctx (C++: outctx_t *)
 |          @retval: 1 - if appended the mnemonics
 |          @retval: 0 - not implemented
 |  
 |  ev_out_operand(self, *args)
 |      Generate text representation of an instruction operand 'outctx_t'
 |      provides functions to output the generated text. All these actions
 |      should be performed only by emu_insn() function.
 |      
 |      ev_out_operand(self, outctx, op) -> bool
 |          @param outctx (C++: outctx_t *)
 |          @param op (C++: const op_t *)
 |          @retval: 1 - ok
 |          @retval: -1 - operand is hidden
 |  
 |  ev_out_segend(self, *args)
 |      Function to produce end of segment
 |      
 |      ev_out_segend(self, outctx, seg) -> int
 |          @param outctx (C++: outctx_t *)
 |          @param seg (C++: segment_t *)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_out_segstart(self, *args)
 |      Function to produce start of segment
 |      
 |      ev_out_segstart(self, outctx, seg) -> int
 |          @param outctx (C++: outctx_t *)
 |          @param seg (C++: segment_t *)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_out_special_item(self, *args)
 |      Generate text representation of an item in a special segment i.e.
 |      absolute symbols, externs, communal definitions etc
 |      
 |      ev_out_special_item(self, outctx, segtype) -> int
 |          @param outctx (C++: outctx_t *)
 |          @param segtype (C++: uchar)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |          @retval: -1 - overflow
 |  
 |  ev_realcvt(self, *args)
 |      Floating point -> IEEE conversion
 |      
 |      ev_realcvt(self, m, e, swt) -> int
 |          @param m: pointer to data  (C++: void *)
 |          @param e: internal IEEE format data  (C++: uint16 *)
 |          @param swt: operation (see realcvt() in ieee.h)  (C++: uint16)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |  
 |  ev_rename(self, *args)
 |      The kernel is going to rename a byte.
 |      
 |      ev_rename(self, ea, new_name) -> int
 |          @param ea (C++: ea_t)
 |          @param new_name (C++: const char *)
 |          @retval: <0 - if the kernel should not rename it.
 |          @retval: 2 - to inhibit the notification. I.e., the kernel should not
 |                       rename, but ' set_name() ' should return 'true'. also see
 |                       \idpcode{renamed} the return value is ignored when kernel
 |                       is going to delete name
 |  
 |  ev_replaying_undo(self, *args)
 |      Replaying an undo/redo buffer
 |      
 |      ev_replaying_undo(self, action_name, vec, is_undo) -> int
 |          @param action_name: action that we perform undo/redo for. may be NULL
 |                              for intermediary buffers.  (C++: const char *)
 |          @param vec (C++: const undo_records_t *)
 |          @param is_undo: true if performing undo, false if performing redo This
 |                          event may be generated multiple times per undo/redo
 |                          (C++: bool)
 |  
 |  ev_set_code16_mode(self, *args)
 |      Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE,
 |      MIPS16 Set ISA 16-bit mode
 |      
 |      ev_set_code16_mode(self, ea, code16) -> int
 |          @param ea: address to set new ISA mode  (C++: ea_t)
 |          @param code16: true for 16-bit mode, false for 32-bit mode  (C++:
 |                         bool)
 |  
 |  ev_set_idp_options(self, *args)
 |      Set IDP-specific configuration option Also see set_options_t in
 |      'config.hpp'
 |      
 |      ev_set_idp_options(self, keyword, value_type, value, idb_loaded) -> int
 |          @param keyword (C++: const char *)
 |          @param value_type (C++: int)
 |          @param value (C++: const void *)
 |          @param idb_loaded: true if the ev_oldfile/ev_newfile events have been
 |                             generated  (C++: bool)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |          @retval: -1 - error (and message in errbuf)
 |  
 |  ev_set_proc_options(self, *args)
 |      Called if the user specified an option string in the command line:
 |      -p<processor name>:<options>. Can be used for setting a processor
 |      subtype. Also called if option string is passed to
 |      'set_processor_type()' and IDC's SetProcessorType().
 |      
 |      ev_set_proc_options(self, options, confidence) -> int
 |          @param options (C++: const char *)
 |          @param confidence: 0: loader's suggestion 1: user's decision  (C++:
 |                             int)
 |          @retval: <0 - if bad option string
 |  
 |  ev_setup_til(self, *args)
 |      Setup default type libraries. (called after loading a new file into
 |      the database). The processor module may load tils, setup memory model
 |      and perform other actions required to set up the type system. This is
 |      an optional callback.
 |  
 |  ev_shadow_args_size(self, *args)
 |      Get size of shadow args in bytes.
 |      
 |      ev_shadow_args_size(self, shadow_args_size, pfn) -> int
 |          @param shadow_args_size (C++: int *)
 |          @param pfn: (may be NULL)  (C++: func_t *)
 |          @retval: 1 - if filled *shadow_args_size
 |          @retval: 0 - not implemented
 |  
 |  ev_str2reg(self, *args)
 |      Convert a register name to a register number. The register number is
 |      the register index in the \ph{reg_names} array Most processor modules
 |      do not need to implement this callback It is useful only if
 |      \ph{reg_names}[reg] does not provide the correct register names
 |      
 |      ev_str2reg(self, regname) -> int
 |          @param regname (C++: const char *)
 |          @retval: register - number + 1
 |          @retval: 0 - not implemented or could not be decoded
 |  
 |  ev_term(self, *args)
 |      The IDP module is being unloaded.
 |  
 |  ev_treat_hindering_item(self, *args)
 |      An item hinders creation of another item.
 |      
 |      ev_treat_hindering_item(self, hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> int
 |          @param hindering_item_ea (C++: ea_t)
 |          @param new_item_flags: (0 for code)  (C++: flags_t)
 |          @param new_item_ea (C++: ea_t)
 |          @param new_item_length (C++: asize_t)
 |          @retval: 0 - no reaction
 |          @retval: !=0 - the kernel may delete the hindering item
 |  
 |  ev_undefine(self, *args)
 |      An item in the database (insn or data) is being deleted.
 |      
 |      ev_undefine(self, ea) -> int
 |          @param ea (C++: ea_t)
 |          @retval: 1 - do not delete srranges at the item end
 |          @retval: 0 - srranges can be deleted
 |  
 |  ev_use_arg_types(self, *args)
 |      Use information about callee arguments.
 |      
 |      ev_use_arg_types(self, ea, fti, rargs) -> int
 |          @param ea: address of the call instruction  (C++: ea_t)
 |          @param fti: info about function type  (C++: func_type_data_t *)
 |          @param rargs: array of register arguments  (C++: funcargvec_t *)
 |          @retval: 1 - (and removes handled arguments from fti and rargs)
 |          @retval: 0 - not implemented
 |  
 |  ev_use_regarg_type(self, *args)
 |      Use information about register argument.
 |      
 |      ev_use_regarg_type(self, ea, rargs) -> PyObject *
 |          @param ea: address of the instruction  (C++: ea_t)
 |          @param rargs: vector of register arguments (including regs extracted
 |                        from scattered arguments)  (C++: const funcargvec_t *)
 |          @retval: 1 -
 |          @retval: 0 - not implemented
 |  
 |  ev_use_stkarg_type(self, *args)
 |      Use information about a stack argument.
 |      
 |      ev_use_stkarg_type(self, ea, arg) -> int
 |          @param ea: address of the push instruction which pushes the function
 |                     argument into the stack  (C++: ea_t)
 |          @param arg: argument info  (C++: const funcarg_t *)
 |          @retval: 1 - ok
 |          @retval: <=0 - failed, the kernel will create a comment with the
 |                         argument name or type for the instruction
 |  
 |  ev_validate_flirt_func(self, *args)
 |      Flirt has recognized a library function. This callback can be used by
 |      a plugin or proc module to intercept it and validate such a function.
 |      
 |      ev_validate_flirt_func(self, start_ea, funcname) -> int
 |          @param start_ea (C++: ea_t)
 |          @param funcname (C++: const char *)
 |          @retval: -1 - do not create a function,
 |          @retval: 0 - function is validated
 |  
 |  ev_verify_noreturn(self, *args)
 |      The kernel wants to set 'noreturn' flags for a function.
 |      
 |      ev_verify_noreturn(self, pfn) -> int
 |          @param pfn (C++: func_t *)
 |          @retval: 0 - ok. any other value: do not set 'noreturn' flag
 |  
 |  ev_verify_sp(self, *args)
 |      All function instructions have been analyzed. Now the processor module
 |      can analyze the stack pointer for the whole function
 |      
 |      ev_verify_sp(self, pfn) -> int
 |          @param pfn (C++: func_t *)
 |          @retval: 0 - ok
 |          @retval: <0 - bad stack pointer
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_IDP_Hooks>
 |      delete_IDP_Hooks(self)

Help on class __ph in module ida_idp:

class __ph(__builtin__.object)
 |  # ----------------------------------------------------------------------
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cnbits
 |  
 |  dnbits
 |  
 |  flag
 |  
 |  icode_return
 |  
 |  id
 |  
 |  instruc
 |  
 |  instruc_end
 |  
 |  instruc_start
 |  
 |  reg_code_sreg
 |  
 |  reg_data_sreg
 |  
 |  reg_first_sreg
 |  
 |  reg_last_sreg
 |  
 |  regnames
 |  
 |  segreg_size
 |  
 |  tbyte_size
 |  
 |  version

Help on class _idp_cvar_t in module ida_idp:

class _idp_cvar_t
 |  Data descriptors defined here:
 |  
 |  ash

Help on class _notify_when_dispatcher_t in module ida_idp:

class _notify_when_dispatcher_t
 |  Methods defined here:
 |  
 |  __init__(self)
 |  
 |  _find(self, fun)
 |  
 |  dispatch(self, slot, *args)
 |  
 |  notify_when(self, when, fun)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  _IDB_Hooks = <class 'ida_idp._IDB_Hooks'>
 |  
 |  
 |  _IDP_Hooks = <class 'ida_idp._IDP_Hooks'>
 |  
 |  
 |  _callback_t = <class ida_idp._callback_t>

Help on class _processor_t_Trampoline_IDB_Hooks in module ida_idp:

class _processor_t_Trampoline_IDB_Hooks(IDB_Hooks)
 |  Method resolution order:
 |      _processor_t_Trampoline_IDB_Hooks
 |      IDB_Hooks
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, proc)
 |  
 |  _processor_t_Trampoline_IDB_Hooks__dummy = __dummy(self, *args)
 |  
 |  _processor_t_Trampoline_IDB_Hooks__make_parent_caller = __make_parent_caller(self, key)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from IDB_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  adding_segm(self, *args)
 |      A segment is being created.
 |      
 |      adding_segm(self, s)
 |          @param s (C++: segment_t *)
 |  
 |  allsegs_moved(self, *args)
 |      Program rebasing is complete. This event is generated after series of
 |      segm_moved events
 |      
 |      allsegs_moved(self, info)
 |          @param info (C++: segm_move_infos_t *)
 |  
 |  auto_empty(self, *args)
 |      Info: all analysis queues are empty. This callback is called once when
 |      the initial analysis is finished. If the queue is not empty upon the
 |      return from this callback, it will be called later again.
 |  
 |  auto_empty_finally(self, *args)
 |      Info: all analysis queues are empty definitively. This callback is
 |      called only once.
 |  
 |  bookmark_changed(self, *args)
 |      Boomarked position changed.
 |      
 |      bookmark_changed(self, index, pos, desc)
 |          @param index (C++: uint32)
 |          @param pos (C++: const lochist_entry_t *)
 |          @param desc: if desc==NULL, then the bookmark was deleted.  (C++:
 |                       const char *)
 |  
 |  byte_patched(self, *args)
 |      A byte has been patched.
 |      
 |      byte_patched(self, ea, old_value)
 |          @param ea (C++: ea_t)
 |          @param old_value (C++: uint32)
 |  
 |  callee_addr_changed(self, *args)
 |      Callee address has been updated by the user.
 |      
 |      callee_addr_changed(self, ea, callee)
 |          @param ea (C++: ea_t)
 |          @param callee (C++: ea_t)
 |  
 |  changing_cmt(self, *args)
 |      An item comment is to be changed.
 |      
 |      changing_cmt(self, ea, repeatable_cmt, newcmt)
 |          @param ea (C++: ea_t)
 |          @param repeatable_cmt (C++: bool)
 |          @param newcmt (C++: const char *)
 |  
 |  changing_enum_bf(self, *args)
 |      An enum type 'bitfield' attribute is to be changed.
 |      
 |      changing_enum_bf(self, id, new_bf)
 |          @param id (C++: enum_t)
 |          @param new_bf (C++: bool)
 |  
 |  changing_enum_cmt(self, *args)
 |      An enum or member type comment is to be changed.
 |      
 |      changing_enum_cmt(self, id, repeatable, newcmt)
 |          @param id (C++: tid_t)
 |          @param repeatable (C++: bool)
 |          @param newcmt (C++: const char *)
 |  
 |  changing_op_ti(self, *args)
 |      An operand typestring (c/c++ prototype) is to be changed.
 |      
 |      changing_op_ti(self, ea, n, new_type, new_fnames)
 |          @param ea (C++: ea_t)
 |          @param n (C++: int)
 |          @param new_type (C++: const type_t *)
 |          @param new_fnames (C++: const p_list *)
 |  
 |  changing_op_type(self, *args)
 |      An operand type (offset, hex, etc...) is to be changed.
 |      
 |      changing_op_type(self, ea, n, opinfo)
 |          @param ea (C++: ea_t)
 |          @param n: eventually or'ed with OPND_OUTER or OPND_ALL  (C++: int)
 |          @param opinfo: additional operand info  (C++: const opinfo_t *)
 |  
 |  changing_range_cmt(self, *args)
 |      Range comment is to be changed.
 |      
 |      changing_range_cmt(self, kind, a, cmt, repeatable)
 |          @param kind (C++: range_kind_t)
 |          @param a (C++: const range_t *)
 |          @param cmt (C++: const char *)
 |          @param repeatable (C++: bool)
 |  
 |  changing_segm_class(self, *args)
 |      Segment class is being changed.
 |      
 |      changing_segm_class(self, s)
 |          @param s (C++: segment_t *)
 |  
 |  changing_segm_end(self, *args)
 |      Segment end address is to be changed.
 |      
 |      changing_segm_end(self, s, new_end, segmod_flags)
 |          @param s (C++: segment_t *)
 |          @param new_end (C++: ea_t)
 |          @param segmod_flags (C++: int)
 |  
 |  changing_segm_name(self, *args)
 |      Segment name is being changed.
 |      
 |      changing_segm_name(self, s, oldname)
 |          @param s (C++: segment_t *)
 |          @param oldname (C++: const char *)
 |  
 |  changing_segm_start(self, *args)
 |      Segment start address is to be changed.
 |      
 |      changing_segm_start(self, s, new_start, segmod_flags)
 |          @param s (C++: segment_t *)
 |          @param new_start (C++: ea_t)
 |          @param segmod_flags (C++: int)
 |  
 |  changing_struc_align(self, *args)
 |      A structure type is being changed (the struct alignment).
 |      
 |      changing_struc_align(self, sptr)
 |          @param sptr (C++: struc_t *)
 |  
 |  changing_struc_cmt(self, *args)
 |      A structure type comment is to be changed.
 |      
 |      changing_struc_cmt(self, struc_id, repeatable, newcmt)
 |          @param struc_id (C++: tid_t)
 |          @param repeatable (C++: bool)
 |          @param newcmt (C++: const char *)
 |  
 |  changing_struc_member(self, *args)
 |      A structure member is to be changed.
 |      
 |      changing_struc_member(self, sptr, mptr, flag, ti, nbytes)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |          @param flag (C++: flags_t)
 |          @param ti (C++: const opinfo_t *)
 |          @param nbytes (C++: asize_t)
 |  
 |  changing_ti(self, *args)
 |      An item typestring (c/c++ prototype) is to be changed.
 |      
 |      changing_ti(self, ea, new_type, new_fnames)
 |          @param ea (C++: ea_t)
 |          @param new_type (C++: const type_t *)
 |          @param new_fnames (C++: const p_list *)
 |  
 |  closebase(self, *args)
 |      The database will be closed now.
 |  
 |  cmt_changed(self, *args)
 |      An item comment has been changed.
 |      
 |      cmt_changed(self, ea, repeatable_cmt)
 |          @param ea (C++: ea_t)
 |          @param repeatable_cmt (C++: bool)
 |  
 |  compiler_changed(self, *args)
 |      The kernel has changed the compiler information. (\inf{cc} structure;
 |      'get_abi_name' )
 |  
 |  deleting_enum(self, *args)
 |      An enum type is to be deleted.
 |      
 |      deleting_enum(self, id)
 |          @param id (C++: enum_t)
 |  
 |  deleting_enum_member(self, *args)
 |      An enum member is to be deleted.
 |      
 |      deleting_enum_member(self, id, cid)
 |          @param id (C++: enum_t)
 |          @param cid (C++: const_t)
 |  
 |  deleting_func(self, *args)
 |      The kernel is about to delete a function.
 |      
 |      deleting_func(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  deleting_func_tail(self, *args)
 |      A function tail chunk is to be removed.
 |      
 |      deleting_func_tail(self, pfn, tail)
 |          @param pfn (C++: func_t *)
 |          @param tail (C++: const range_t *)
 |  
 |  deleting_segm(self, *args)
 |      A segment is to be deleted.
 |      
 |      deleting_segm(self, start_ea)
 |          @param start_ea (C++: ea_t)
 |  
 |  deleting_struc(self, *args)
 |      A structure type is to be deleted.
 |      
 |      deleting_struc(self, sptr)
 |          @param sptr (C++: struc_t *)
 |  
 |  deleting_struc_member(self, *args)
 |      A structure member is to be deleted.
 |      
 |      deleting_struc_member(self, sptr, mptr)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |  
 |  deleting_tryblks(self, *args)
 |      About to delete tryblk information in given range
 |      
 |      deleting_tryblks(self, range)
 |          @param range (C++: const range_t *)
 |  
 |  destroyed_items(self, *args)
 |      Instructions/data have been destroyed in [ea1,ea2).
 |      
 |      destroyed_items(self, ea1, ea2, will_disable_range)
 |          @param ea1 (C++: ea_t)
 |          @param ea2 (C++: ea_t)
 |          @param will_disable_range (C++: bool)
 |  
 |  determined_main(self, *args)
 |      The main() function has been determined.
 |      
 |      determined_main(self, main)
 |          @param main: address of the main() function  (C++: ea_t)
 |  
 |  dirtree_link(self, *args)
 |      Dirtree: an item has been linked/unlinked.
 |      
 |      dirtree_link(self, dt, path, link)
 |          @param dt (C++: dirtree_t *)
 |          @param path (C++: const char *)
 |          @param link (C++: bool)
 |  
 |  dirtree_mkdir(self, *args)
 |      Dirtree: a directory has been created.
 |      
 |      dirtree_mkdir(self, dt, path)
 |          @param dt (C++: dirtree_t *)
 |          @param path (C++: const char *)
 |  
 |  dirtree_move(self, *args)
 |      Dirtree: a directory or item has been moved.
 |      
 |      dirtree_move(self, dt, _from, to)
 |          @param dt (C++: dirtree_t *)
 |          @param _from (C++: const char *)
 |          @param to (C++: const char *)
 |  
 |  dirtree_rank(self, *args)
 |      Dirtree: a directory or item rank has been changed.
 |      
 |      dirtree_rank(self, dt, path, rank)
 |          @param dt (C++: dirtree_t *)
 |          @param path (C++: const char *)
 |          @param rank (C++: size_t)
 |  
 |  dirtree_rmdir(self, *args)
 |      Dirtree: a directory has been deleted.
 |      
 |      dirtree_rmdir(self, dt, path)
 |          @param dt (C++: dirtree_t *)
 |          @param path (C++: const char *)
 |  
 |  dirtree_rminode(self, *args)
 |      Dirtree: an inode became unavailable.
 |      
 |      dirtree_rminode(self, dt, inode)
 |          @param dt (C++: dirtree_t *)
 |          @param inode (C++: inode_t)
 |  
 |  enum_bf_changed(self, *args)
 |      An enum type 'bitfield' attribute has been changed.
 |      
 |      enum_bf_changed(self, id)
 |          @param id (C++: enum_t)
 |  
 |  enum_cmt_changed(self, *args)
 |      An enum or member type comment has been changed.
 |      
 |      enum_cmt_changed(self, id, repeatable)
 |          @param id (C++: tid_t)
 |          @param repeatable (C++: bool)
 |  
 |  enum_created(self, *args)
 |      An enum type has been created.
 |      
 |      enum_created(self, id)
 |          @param id (C++: enum_t)
 |  
 |  enum_deleted(self, *args)
 |      An enum type has been deleted.
 |      
 |      enum_deleted(self, id)
 |          @param id (C++: enum_t)
 |  
 |  enum_member_created(self, *args)
 |      An enum member has been created.
 |      
 |      enum_member_created(self, id, cid)
 |          @param id (C++: enum_t)
 |          @param cid (C++: const_t)
 |  
 |  enum_member_deleted(self, *args)
 |      An enum member has been deleted.
 |      
 |      enum_member_deleted(self, id, cid)
 |          @param id (C++: enum_t)
 |          @param cid (C++: const_t)
 |  
 |  enum_renamed(self, *args)
 |      An enum or member has been renamed.
 |      
 |      enum_renamed(self, id)
 |          @param id (C++: tid_t)
 |  
 |  expanding_struc(self, *args)
 |      A structure type is to be expanded/shrunk.
 |      
 |      expanding_struc(self, sptr, offset, delta)
 |          @param sptr (C++: struc_t *)
 |          @param offset (C++: ea_t)
 |          @param delta (C++: adiff_t)
 |  
 |  extlang_changed(self, *args)
 |      The list of extlangs or the default extlang was changed.
 |      
 |      extlang_changed(self, kind, el, idx)
 |          @param kind: 0: extlang installed 1: extlang removed 2: default
 |                       extlang changed  (C++: int)
 |          @param el: pointer to the extlang affected  (C++: extlang_t *)
 |          @param idx: extlang index  (C++: int)
 |  
 |  extra_cmt_changed(self, *args)
 |      An extra comment has been changed.
 |      
 |      extra_cmt_changed(self, ea, line_idx, cmt)
 |          @param ea (C++: ea_t)
 |          @param line_idx (C++: int)
 |          @param cmt (C++: const char *)
 |  
 |  flow_chart_created(self, *args)
 |      Gui has retrieved a function flow chart. Plugins may modify the flow
 |      chart in this callback.
 |      
 |      flow_chart_created(self, fc)
 |          @param fc (C++: qflow_chart_t *)
 |  
 |  frame_deleted(self, *args)
 |      The kernel has deleted a function frame.
 |      
 |      frame_deleted(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  func_added(self, *args)
 |      The kernel has added a function.
 |      
 |      func_added(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  func_deleted(self, *args)
 |      A function has been deleted.
 |      
 |      func_deleted(self, func_ea)
 |          @param func_ea (C++: ea_t)
 |  
 |  func_noret_changed(self, *args)
 |      'FUNC_NORET' bit has been changed.
 |      
 |      func_noret_changed(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  func_tail_appended(self, *args)
 |      A function tail chunk has been appended.
 |      
 |      func_tail_appended(self, pfn, tail)
 |          @param pfn (C++: func_t *)
 |          @param tail (C++: func_t *)
 |  
 |  func_tail_deleted(self, *args)
 |      A function tail chunk has been removed.
 |      
 |      func_tail_deleted(self, pfn, tail_ea)
 |          @param pfn (C++: func_t *)
 |          @param tail_ea (C++: ea_t)
 |  
 |  func_updated(self, *args)
 |      The kernel has updated a function.
 |      
 |      func_updated(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  idasgn_loaded(self, *args)
 |      FLIRT signature has been loaded for normal processing (not for
 |      recognition of startup sequences).
 |      
 |      idasgn_loaded(self, short_sig_name)
 |          @param short_sig_name (C++: const char *)
 |  
 |  item_color_changed(self, *args)
 |      An item color has been changed.
 |      
 |      item_color_changed(self, ea, color)
 |          @param ea (C++: ea_t)
 |          @param color: if color==DEFCOLOR, the the color is deleted.  (C++:
 |                        bgcolor_t)
 |  
 |  kernel_config_loaded(self, *args)
 |      This event is issued when ida.cfg is parsed.
 |      
 |      kernel_config_loaded(self, pass_number)
 |          @param pass_number (C++: int)
 |  
 |  loader_finished(self, *args)
 |      External file loader finished its work. Use this event to augment the
 |      existing loader functionality.
 |      
 |      loader_finished(self, li, neflags, filetypename)
 |          @param li (C++: linput_t *)
 |          @param neflags: Load file flags  (C++: uint16)
 |          @param filetypename (C++: const char *)
 |  
 |  local_types_changed(self, *args)
 |      Local types have been changed.
 |  
 |  make_code(self, *args)
 |      An instruction is being created.
 |      
 |      make_code(self, insn)
 |          @param insn (C++: const insn_t*)
 |  
 |  make_data(self, *args)
 |      A data item is being created.
 |      
 |      make_data(self, ea, flags, tid, len)
 |          @param ea (C++: ea_t)
 |          @param flags (C++: flags_t)
 |          @param tid (C++: tid_t)
 |          @param len (C++: asize_t)
 |  
 |  op_ti_changed(self, *args)
 |      An operand typestring (c/c++ prototype) has been changed.
 |      
 |      op_ti_changed(self, ea, n, type, fnames)
 |          @param ea (C++: ea_t)
 |          @param n (C++: int)
 |          @param type (C++: const type_t *)
 |          @param fnames (C++: const p_list *)
 |  
 |  op_type_changed(self, *args)
 |      An operand type (offset, hex, etc...) has been set or deleted.
 |      
 |      op_type_changed(self, ea, n)
 |          @param ea (C++: ea_t)
 |          @param n: eventually or'ed with OPND_OUTER or OPND_ALL  (C++: int)
 |  
 |  range_cmt_changed(self, *args)
 |      Range comment has been changed.
 |      
 |      range_cmt_changed(self, kind, a, cmt, repeatable)
 |          @param kind (C++: range_kind_t)
 |          @param a (C++: const range_t *)
 |          @param cmt (C++: const char *)
 |          @param repeatable (C++: bool)
 |  
 |  renamed(self, *args)
 |      The kernel has renamed a byte. See also the \idpcode{rename} event
 |      
 |      renamed(self, ea, new_name, local_name)
 |          @param ea (C++: ea_t)
 |          @param new_name (C++: const char *)
 |          @param local_name (C++: bool)
 |  
 |  renaming_enum(self, *args)
 |      An enum or enum member is to be renamed.
 |      
 |      renaming_enum(self, id, is_enum, newname)
 |          @param id (C++: tid_t)
 |          @param is_enum (C++: bool)
 |          @param newname (C++: const char *)
 |  
 |  renaming_struc(self, *args)
 |      A structure type is to be renamed.
 |      
 |      renaming_struc(self, id, oldname, newname)
 |          @param id (C++: tid_t)
 |          @param oldname (C++: const char *)
 |          @param newname (C++: const char *)
 |  
 |  renaming_struc_member(self, *args)
 |      A structure member is to be renamed.
 |      
 |      renaming_struc_member(self, sptr, mptr, newname)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |          @param newname (C++: const char *)
 |  
 |  savebase(self, *args)
 |      The database is being saved.
 |  
 |  segm_added(self, *args)
 |      A new segment has been created.
 |      
 |      segm_added(self, s)
 |          @param s: See also adding_segm  (C++: segment_t *)
 |  
 |  segm_attrs_updated(self, *args)
 |      Segment attributes has been changed.
 |      
 |      segm_attrs_updated(self, s)
 |          @param s: This event is generated for secondary segment attributes
 |                    (examples: color, permissions, etc)  (C++: segment_t *)
 |  
 |  segm_class_changed(self, *args)
 |      Segment class has been changed.
 |      
 |      segm_class_changed(self, s, sclass)
 |          @param s (C++: segment_t *)
 |          @param sclass (C++: const char *)
 |  
 |  segm_deleted(self, *args)
 |      A segment has been deleted.
 |      
 |      segm_deleted(self, start_ea, end_ea)
 |          @param start_ea (C++: ea_t)
 |          @param end_ea (C++: ea_t)
 |  
 |  segm_end_changed(self, *args)
 |      Segment end address has been changed.
 |      
 |      segm_end_changed(self, s, oldend)
 |          @param s (C++: segment_t *)
 |          @param oldend (C++: ea_t)
 |  
 |  segm_moved(self, *args)
 |      Segment has been moved.
 |      
 |      segm_moved(self, _from, to, size, changed_netmap)
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @param size (C++: asize_t)
 |          @param changed_netmap: See also idb_event::allsegs_moved  (C++: bool)
 |  
 |  segm_name_changed(self, *args)
 |      Segment name has been changed.
 |      
 |      segm_name_changed(self, s, name)
 |          @param s (C++: segment_t *)
 |          @param name (C++: const char *)
 |  
 |  segm_start_changed(self, *args)
 |      Segment start address has been changed.
 |      
 |      segm_start_changed(self, s, oldstart)
 |          @param s (C++: segment_t *)
 |          @param oldstart (C++: ea_t)
 |  
 |  set_func_end(self, *args)
 |      Function chunk end address will be changed.
 |      
 |      set_func_end(self, pfn, new_end)
 |          @param pfn (C++: func_t *)
 |          @param new_end (C++: ea_t)
 |  
 |  set_func_start(self, *args)
 |      Function chunk start address will be changed.
 |      
 |      set_func_start(self, pfn, new_start)
 |          @param pfn (C++: func_t *)
 |          @param new_start (C++: ea_t)
 |  
 |  sgr_changed(self, *args)
 |      The kernel has changed a segment register value.
 |      
 |      sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag)
 |          @param start_ea (C++: ea_t)
 |          @param end_ea (C++: ea_t)
 |          @param regnum (C++: int)
 |          @param value (C++: sel_t)
 |          @param old_value (C++: sel_t)
 |          @param tag: Segment register range tags  (C++: uchar)
 |  
 |  sgr_deleted(self, *args)
 |      The kernel has deleted a segment register value.
 |      
 |      sgr_deleted(self, start_ea, end_ea, regnum)
 |          @param start_ea (C++: ea_t)
 |          @param end_ea (C++: ea_t)
 |          @param regnum (C++: int)
 |  
 |  stkpnts_changed(self, *args)
 |      Stack change points have been modified.
 |      
 |      stkpnts_changed(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  struc_align_changed(self, *args)
 |      A structure type has been changed (the struct alignment).
 |      
 |      struc_align_changed(self, sptr)
 |          @param sptr (C++: struc_t *)
 |  
 |  struc_cmt_changed(self, *args)
 |      A structure type comment has been changed.
 |      
 |      struc_cmt_changed(self, struc_id, repeatable_cmt)
 |          @param struc_id (C++: tid_t)
 |          @param repeatable_cmt (C++: bool)
 |  
 |  struc_created(self, *args)
 |      A new structure type has been created.
 |      
 |      struc_created(self, struc_id)
 |          @param struc_id (C++: tid_t)
 |  
 |  struc_deleted(self, *args)
 |      A structure type has been deleted.
 |      
 |      struc_deleted(self, struc_id)
 |          @param struc_id (C++: tid_t)
 |  
 |  struc_expanded(self, *args)
 |      A structure type has been expanded/shrank.
 |      
 |      struc_expanded(self, sptr)
 |          @param sptr (C++: struc_t *)
 |  
 |  struc_member_changed(self, *args)
 |      A structure member has been changed.
 |      
 |      struc_member_changed(self, sptr, mptr)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |  
 |  struc_member_created(self, *args)
 |      A structure member has been created.
 |      
 |      struc_member_created(self, sptr, mptr)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |  
 |  struc_member_deleted(self, *args)
 |      A structure member has been deleted.
 |      
 |      struc_member_deleted(self, sptr, member_id, offset)
 |          @param sptr (C++: struc_t *)
 |          @param member_id (C++: tid_t)
 |          @param offset (C++: ea_t)
 |  
 |  struc_member_renamed(self, *args)
 |      A structure member has been renamed.
 |      
 |      struc_member_renamed(self, sptr, mptr)
 |          @param sptr (C++: struc_t *)
 |          @param mptr (C++: member_t *)
 |  
 |  struc_renamed(self, *args)
 |      A structure type has been renamed.
 |      
 |      struc_renamed(self, sptr)
 |          @param sptr (C++: struc_t *)
 |  
 |  tail_owner_changed(self, *args)
 |      A tail chunk owner has been changed.
 |      
 |      tail_owner_changed(self, tail, owner_func, old_owner)
 |          @param tail (C++: func_t *)
 |          @param owner_func (C++: ea_t)
 |          @param old_owner (C++: ea_t)
 |  
 |  thunk_func_created(self, *args)
 |      A thunk bit has been set for a function.
 |      
 |      thunk_func_created(self, pfn)
 |          @param pfn (C++: func_t *)
 |  
 |  ti_changed(self, *args)
 |      An item typestring (c/c++ prototype) has been changed.
 |      
 |      ti_changed(self, ea, type, fnames)
 |          @param ea (C++: ea_t)
 |          @param type (C++: const type_t *)
 |          @param fnames (C++: const p_list *)
 |  
 |  tryblks_updated(self, *args)
 |      Updated tryblk information
 |      
 |      tryblks_updated(self, tbv)
 |          @param tbv (C++: const tryblks_t *)
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  updating_tryblks(self, *args)
 |      About to update tryblk information
 |      
 |      updating_tryblks(self, tbv)
 |          @param tbv (C++: const tryblks_t *)
 |  
 |  upgraded(self, *args)
 |      The database has been upgraded and the receiver can upgrade its info
 |      as well
 |      
 |      upgraded(self, _from)
 |          @param _from: - old IDB version  (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from IDB_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from IDB_Hooks:
 |  
 |  __swig_destroy__ = <built-in function delete_IDB_Hooks>
 |      delete_IDB_Hooks(self)

Help on class asm_t in module ida_idp:

class asm_t(__builtin__.object)
 |  Proxy of C++ asm_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> asm_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a_align
 |      asm_t_a_align_get(self) -> char const *
 |  
 |  a_ascii
 |      asm_t_a_ascii_get(self) -> char const *
 |  
 |  a_band
 |      asm_t_a_band_get(self) -> char const *
 |  
 |  a_bnot
 |      asm_t_a_bnot_get(self) -> char const *
 |  
 |  a_bor
 |      asm_t_a_bor_get(self) -> char const *
 |  
 |  a_bss
 |      asm_t_a_bss_get(self) -> char const *
 |  
 |  a_byte
 |      asm_t_a_byte_get(self) -> char const *
 |  
 |  a_comdef
 |      asm_t_a_comdef_get(self) -> char const *
 |  
 |  a_curip
 |      asm_t_a_curip_get(self) -> char const *
 |  
 |  a_double
 |      asm_t_a_double_get(self) -> char const *
 |  
 |  a_dups
 |      asm_t_a_dups_get(self) -> char const *
 |  
 |  a_dword
 |      asm_t_a_dword_get(self) -> char const *
 |  
 |  a_equ
 |      asm_t_a_equ_get(self) -> char const *
 |  
 |  a_extrn
 |      asm_t_a_extrn_get(self) -> char const *
 |  
 |  a_float
 |      asm_t_a_float_get(self) -> char const *
 |  
 |  a_include_fmt
 |      asm_t_a_include_fmt_get(self) -> char const *
 |  
 |  a_mod
 |      asm_t_a_mod_get(self) -> char const *
 |  
 |  a_oword
 |      asm_t_a_oword_get(self) -> char const *
 |  
 |  a_packreal
 |      asm_t_a_packreal_get(self) -> char const *
 |  
 |  a_public
 |      asm_t_a_public_get(self) -> char const *
 |  
 |  a_qword
 |      asm_t_a_qword_get(self) -> char const *
 |  
 |  a_rva
 |      asm_t_a_rva_get(self) -> char const *
 |  
 |  a_seg
 |      asm_t_a_seg_get(self) -> char const *
 |  
 |  a_shl
 |      asm_t_a_shl_get(self) -> char const *
 |  
 |  a_shr
 |      asm_t_a_shr_get(self) -> char const *
 |  
 |  a_sizeof_fmt
 |      asm_t_a_sizeof_fmt_get(self) -> char const *
 |  
 |  a_tbyte
 |      asm_t_a_tbyte_get(self) -> char const *
 |  
 |  a_vstruc_fmt
 |      asm_t_a_vstruc_fmt_get(self) -> char const *
 |  
 |  a_weak
 |      asm_t_a_weak_get(self) -> char const *
 |  
 |  a_word
 |      asm_t_a_word_get(self) -> char const *
 |  
 |  a_xor
 |      asm_t_a_xor_get(self) -> char const *
 |  
 |  a_yword
 |      asm_t_a_yword_get(self) -> char const *
 |  
 |  accsep
 |      asm_t_accsep_get(self) -> char
 |  
 |  ascsep
 |      asm_t_ascsep_get(self) -> char
 |  
 |  cmnt
 |      asm_t_cmnt_get(self) -> char const *
 |  
 |  cmnt2
 |      asm_t_cmnt2_get(self) -> char const *
 |  
 |  end
 |      asm_t_end_get(self) -> char const *
 |  
 |  esccodes
 |      asm_t_esccodes_get(self) -> char const *
 |  
 |  flag
 |      asm_t_flag_get(self) -> uint32
 |  
 |  flag2
 |      asm_t_flag2_get(self) -> uint32
 |  
 |  header
 |      asm_t_header_get(self) -> char const *const *
 |  
 |  help
 |      asm_t_help_get(self) -> help_t
 |  
 |  high16
 |      asm_t_high16_get(self) -> char const *
 |  
 |  high8
 |      asm_t_high8_get(self) -> char const *
 |  
 |  lbrace
 |      asm_t_lbrace_get(self) -> char
 |  
 |  low16
 |      asm_t_low16_get(self) -> char const *
 |  
 |  low8
 |      asm_t_low8_get(self) -> char const *
 |  
 |  name
 |      asm_t_name_get(self) -> char const *
 |  
 |  origin
 |      asm_t_origin_get(self) -> char const *
 |  
 |  rbrace
 |      asm_t_rbrace_get(self) -> char
 |  
 |  thisown
 |      The membership flag
 |  
 |  uflag
 |      asm_t_uflag_get(self) -> uint16
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_asm_t>
 |      delete_asm_t(self)

Help on function assemble in module ida_idp:

assemble(*args)
    assemble(ea, cs, ip, use32, line) -> bool
    Assemble an instruction into the database (display a warning if an error is found)
    @param ea: linear address of instruction
    @param cs: cs of instruction
    @param ip: ip of instruction
    @param use32: is 32bit segment?
    @param line: line to assemble
    
    @return: Boolean. True on success.

Help on function cfg_get_cc_header_path in module ida_idp:

cfg_get_cc_header_path(*args)
    cfg_get_cc_header_path(compid) -> char const *
        compid: comp_t

Help on function cfg_get_cc_parm in module ida_idp:

cfg_get_cc_parm(*args)
    cfg_get_cc_parm(compid, name) -> char const *
        compid: comp_t
        name: char const *

Help on function cfg_get_cc_predefined_macros in module ida_idp:

cfg_get_cc_predefined_macros(*args)
    cfg_get_cc_predefined_macros(compid) -> char const *
        compid: comp_t

Help on function clr_module_data in module ida_idp:

clr_module_data(*args)
    Unregister pointer to database specific module data.
    
    clr_module_data(data_id) -> void *
        @param data_id: an data_id that was assigned by  set_module_data()
                        (C++: int)
        @return: previously registered pointer for the current database. it
                 can be deallocated now. Multiple calls to this function with
                 the same id are forbidden.

Help on function delay_slot_insn in module ida_idp:

delay_slot_insn(*args)
    delay_slot_insn(ea, bexec, fexec) -> bool
        ea: ea_t *
        bexec: bool *
        fexec: bool *

Help on function gen_idb_event in module ida_idp:

gen_idb_event(*args)
    the kernel will use this function to generate idb_events
    
    gen_idb_event(code)
        @param code (C++: idb_event::event_code_t)

Help on function get_ash in module ida_idp:

get_ash(*args)
    get_ash() -> asm_t

Help on function get_idb_notifier_addr in module ida_idp:

get_idb_notifier_addr(*args)
    get_idb_notifier_addr(arg1) -> PyObject *
        arg1: PyObject *

Help on function get_idb_notifier_ud_addr in module ida_idp:

get_idb_notifier_ud_addr(*args)
    get_idb_notifier_ud_addr(hooks) -> PyObject *
        hooks: IDB_Hooks *

Help on function get_idp_name in module ida_idp:

get_idp_name(*args)
    Get name of the current processor module. The name is derived from the
    file name. For example, for IBM PC the module is named "pc.w32"
    (windows version), then the module name is "PC" (uppercase). If no
    processor module is loaded, this function will return NULL

Help on function get_idp_notifier_addr in module ida_idp:

get_idp_notifier_addr(*args)
    get_idp_notifier_addr(arg1) -> PyObject *
        arg1: PyObject *

Help on function get_idp_notifier_ud_addr in module ida_idp:

get_idp_notifier_ud_addr(*args)
    get_idp_notifier_ud_addr(hooks) -> PyObject *
        hooks: IDP_Hooks *

Help on function get_module_data in module ida_idp:

get_module_data(*args)
    Get pointer to the database specific module data.
    
    get_module_data(data_id) -> void *
        @param data_id: data id that was initialized by  set_module_data()
                        (C++: int)
        @return: previously registered pointer for the current database

Help on function get_ph in module ida_idp:

get_ph(*args)
    get_ph() -> processor_t *

Help on function get_reg_info in module ida_idp:

get_reg_info(*args)
    get_reg_info(regname, bitrange) -> char const *
        regname: char const *
        bitrange: bitrange_t *

Help on function get_reg_name in module ida_idp:

get_reg_name(*args)
    Get text representation of a register. For most processors this
    function will just return \ph{reg_names}[reg]. If the processor module
    has implemented processor_t::get_reg_name, it will be used instead
    
    get_reg_name(reg, width, reghi=-1) -> str
        @param reg: internal register number as defined in the processor
                    module (C++: int)
        @param width: register width in bytes (C++: size_t)
        @param reghi: if specified, then this function will return the
                      register pair (C++: int)
        @return: length of register name in bytes or -1 if failure

Help on function has_cf_chg in module ida_idp:

has_cf_chg(*args)
    Does an instruction with the specified feature modify the i-th
    operand?
    
    has_cf_chg(feature, opnum) -> bool
        @param feature (C++: uint32)
        @param opnum (C++: uint)

Help on function has_cf_use in module ida_idp:

has_cf_use(*args)
    Does an instruction with the specified feature use a value of the i-th
    operand?
    
    has_cf_use(feature, opnum) -> bool
        @param feature (C++: uint32)
        @param opnum (C++: uint)

Help on function has_insn_feature in module ida_idp:

has_insn_feature(*args)
    Does the specified instruction have the specified feature?
    
    has_insn_feature(icode, bit) -> bool
        @param icode (C++: int)
        @param bit (C++: uint32)

Help on function is_align_insn in module ida_idp:

is_align_insn(*args)
    If the instruction at 'ea' looks like an alignment instruction, return
    its length in bytes. Otherwise return 0.
    
    is_align_insn(ea) -> int
        @param ea (C++: ea_t)

Help on function is_basic_block_end in module ida_idp:

is_basic_block_end(*args)
    Is the instruction the end of a basic block?
    
    is_basic_block_end(insn, call_insn_stops_block) -> bool
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param call_insn_stops_block (C++: bool)

Help on function is_call_insn in module ida_idp:

is_call_insn(*args)
    Is the instruction a "call"?
    
    is_call_insn(insn) -> bool
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)

Help on function is_indirect_jump_insn in module ida_idp:

is_indirect_jump_insn(*args)
    Is the instruction an indirect jump?
    
    is_indirect_jump_insn(insn) -> bool
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)

Help on function is_ret_insn in module ida_idp:

is_ret_insn(*args)
    Is the instruction a "return"?
    
    is_ret_insn(insn, strict=True) -> bool
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param strict (C++: bool)

Help on function parse_reg_name in module ida_idp:

parse_reg_name(*args)
    Get register info by name.
    
    parse_reg_name(ri, regname) -> bool
        @param ri: result (C++: reg_info_t  *)
        @param regname: name of register (C++: const char *)
        @return: success

Help on __ph in module ida_idp object:

class __ph(__builtin__.object)
 |  # ----------------------------------------------------------------------
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cnbits
 |  
 |  dnbits
 |  
 |  flag
 |  
 |  icode_return
 |  
 |  id
 |  
 |  instruc
 |  
 |  instruc_end
 |  
 |  instruc_start
 |  
 |  reg_code_sreg
 |  
 |  reg_data_sreg
 |  
 |  reg_first_sreg
 |  
 |  reg_last_sreg
 |  
 |  regnames
 |  
 |  segreg_size
 |  
 |  tbyte_size
 |  
 |  version

Help on function ph_calcrel in module ida_idp:

ph_calcrel(*args)
    ph_calcrel(ea)
        ea: ea_t

Help on function ph_find_op_value in module ida_idp:

ph_find_op_value(*args)
    ph_find_op_value(insn, op) -> ssize_t
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        op: int

Help on function ph_find_reg_value in module ida_idp:

ph_find_reg_value(*args)
    ph_find_reg_value(insn, reg) -> ssize_t
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        reg: int

Help on function ph_get_cnbits in module ida_idp:

ph_get_cnbits(*args)
    ph_get_cnbits() -> size_t
    Returns the 'ph.cnbits'

Help on function ph_get_dnbits in module ida_idp:

ph_get_dnbits(*args)
    ph_get_dnbits() -> size_t
    Returns the 'ph.dnbits'

Help on function ph_get_flag in module ida_idp:

ph_get_flag(*args)
    ph_get_flag() -> size_t
    Returns the 'ph.flag'

Help on function ph_get_icode_return in module ida_idp:

ph_get_icode_return(*args)
    ph_get_icode_return() -> size_t
    Returns the 'ph.icode_return'

Help on function ph_get_id in module ida_idp:

ph_get_id(*args)
    ph_get_id() -> size_t
    Returns the 'ph.id' field

Help on function ph_get_instruc in module ida_idp:

ph_get_instruc(*args)
    ph_get_instruc() -> PyObject *
    Returns a list of tuples (instruction_name, instruction_feature) containing the
    instructions list as defined in he processor module

Help on function ph_get_instruc_end in module ida_idp:

ph_get_instruc_end(*args)
    ph_get_instruc_end() -> size_t
    Returns the 'ph.instruc_end'

Help on function ph_get_instruc_start in module ida_idp:

ph_get_instruc_start(*args)
    ph_get_instruc_start() -> size_t
    Returns the 'ph.instruc_start'

Help on function ph_get_operand_info in module ida_idp:

ph_get_operand_info(*args)
    ph_get_operand_info(ea, n) -> PyObject *
    Returns the operand information given an ea and operand number.
    
    @param ea: address
    @param n: operand number
    
    @return: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).
             Please refer to idd_opinfo_t structure in the SDK.

Help on function ph_get_reg_accesses in module ida_idp:

ph_get_reg_accesses(*args)
    ph_get_reg_accesses(accvec, insn, flags) -> ssize_t
        accvec: reg_accesses_t *
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        flags: int

Help on function ph_get_reg_code_sreg in module ida_idp:

ph_get_reg_code_sreg(*args)
    ph_get_reg_code_sreg() -> size_t
    Returns the 'ph.reg_code_sreg'

Help on function ph_get_reg_data_sreg in module ida_idp:

ph_get_reg_data_sreg(*args)
    ph_get_reg_data_sreg() -> size_t
    Returns the 'ph.reg_data_sreg'

Help on function ph_get_reg_first_sreg in module ida_idp:

ph_get_reg_first_sreg(*args)
    ph_get_reg_first_sreg() -> size_t
    Returns the 'ph.reg_first_sreg'

Help on function ph_get_reg_last_sreg in module ida_idp:

ph_get_reg_last_sreg(*args)
    ph_get_reg_last_sreg() -> size_t
    Returns the 'ph.reg_last_sreg'

Help on function ph_get_regnames in module ida_idp:

ph_get_regnames(*args)
    ph_get_regnames() -> PyObject *
    Returns the list of register names as defined in the processor module

Help on function ph_get_segreg_size in module ida_idp:

ph_get_segreg_size(*args)
    ph_get_segreg_size() -> size_t
    Returns the 'ph.segreg_size'

Help on function ph_get_tbyte_size in module ida_idp:

ph_get_tbyte_size(*args)
    ph_get_tbyte_size() -> size_t
    Returns the 'ph.tbyte_size' field as defined in he processor module

Help on function ph_get_version in module ida_idp:

ph_get_version(*args)
    ph_get_version() -> size_t
    Returns the 'ph.version'

Help on function process_config_directive in module ida_idp:

process_config_directive(*args)
    process_config_directive(directive, priority=2)
        directive: char const *
        priority: int

Help on class processor_t in module ida_idp:

class processor_t(IDP_Hooks)
 |  Method resolution order:
 |      processor_t
 |      IDP_Hooks
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |  
 |  _get_idb_notifier_addr(self)
 |  
 |  _get_idb_notifier_ud_addr(self)
 |  
 |  _get_idp_notifier_addr(self)
 |  
 |  _get_idp_notifier_ud_addr(self)
 |  
 |  _get_notify(self, what, unimp_val=0, imp_forced_val=None, add_prefix=True, mandatory_impl=None)
 |      This helper is used to implement backward-compatibility
 |      of pre IDA 7.3 processor_t interfaces.
 |  
 |  _make_forced_value_wrapper(self, val, meth=None)
 |  
 |  _make_int_returning_wrapper(self, meth, intval=0)
 |  
 |  auto_empty(self, *args)
 |  
 |  auto_empty_finally(self, *args)
 |  
 |  closebase(self, *args)
 |  
 |  compiler_changed(self, *args)
 |  
 |  deleting_func(self, pfn)
 |  
 |  determined_main(self, *args)
 |  
 |  ev_ana_insn(self, *args)
 |  
 |  ev_assemble(self, *args)
 |  
 |  ev_auto_queue_empty(self, *args)
 |  
 |  ev_calc_step_over(self, target, ip)
 |  
 |  ev_can_have_type(self, *args)
 |  
 |  ev_cmp_operands(self, *args)
 |  
 |  ev_coagulate(self, *args)
 |  
 |  ev_coagulate_dref(self, from_ea, to_ea, may_define, _code_ea)
 |  
 |  ev_create_func_frame(self, pfn)
 |  
 |  ev_create_switch_xrefs(self, *args)
 |  
 |  ev_creating_segm(self, s)
 |  
 |  ev_emu_insn(self, *args)
 |  
 |  ev_endbinary(self, *args)
 |  
 |  ev_func_bounds(self, _possible_return_code, pfn, max_func_end_ea)
 |  
 |  ev_gen_map_file(self, nlines, fp)
 |  
 |  ev_gen_regvar_def(self, ctx, v)
 |  
 |  ev_gen_src_file_lnnum(self, *args)
 |  
 |  ev_get_autocmt(self, *args)
 |  
 |  ev_get_frame_retsize(self, frsize, pfn)
 |  
 |  ev_get_operand_string(self, buf, insn, opnum)
 |  
 |  ev_is_align_insn(self, *args)
 |  
 |  ev_is_alloca_probe(self, *args)
 |  
 |  ev_is_basic_block_end(self, *args)
 |  
 |  ev_is_call_insn(self, *args)
 |  
 |  ev_is_far_jump(self, *args)
 |  
 |  ev_is_indirect_jump(self, *args)
 |  
 |  ev_is_insn_table_jump(self, *args)
 |  
 |  ev_is_ret_insn(self, *args)
 |  
 |  ev_is_sane_insn(self, *args)
 |  
 |  ev_is_sp_based(self, mode, insn, op)
 |  
 |  ev_is_switch(self, *args)
 |  
 |  ev_may_be_func(self, *args)
 |  
 |  ev_may_show_sreg(self, *args)
 |  
 |  ev_moving_segm(self, s, to_ea, flags)
 |  
 |  ev_newbinary(self, *args)
 |  
 |  ev_newfile(self, *args)
 |  
 |  ev_newprc(self, *args)
 |  
 |  ev_oldfile(self, *args)
 |  
 |  ev_out_assumes(self, *args)
 |  
 |  ev_out_data(self, *args)
 |  
 |  ev_out_footer(self, *args)
 |  
 |  ev_out_header(self, *args)
 |  
 |  ev_out_insn(self, *args)
 |  
 |  ev_out_label(self, *args)
 |  
 |  ev_out_mnem(self, *args)
 |  
 |  ev_out_operand(self, *args)
 |  
 |  ev_out_segend(self, ctx, s)
 |  
 |  ev_out_segstart(self, ctx, s)
 |  
 |  ev_out_special_item(self, *args)
 |  
 |  ev_rename(self, *args)
 |  
 |  ev_set_idp_options(self, keyword, value_type, value, idb_loaded)
 |  
 |  ev_set_proc_options(self, *args)
 |  
 |  ev_str2reg(self, *args)
 |  
 |  ev_treat_hindering_item(self, *args)
 |  
 |  ev_undefine(self, *args)
 |  
 |  ev_validate_flirt_func(self, *args)
 |  
 |  ev_verify_noreturn(self, pfn)
 |  
 |  ev_verify_sp(self, pfn)
 |  
 |  func_added(self, pfn)
 |  
 |  get_auxpref(self, insn)
 |      This function returns insn.auxpref value
 |  
 |  get_idpdesc(self)
 |      This function must be present and should return the list of
 |      short processor names similar to the one in ph.psnames.
 |      This method can be overridden to return to the kernel a different IDP description.
 |  
 |  get_uFlag(self)
 |      Use this utility function to retrieve the 'uFlag' global variable
 |  
 |  idasgn_loaded(self, *args)
 |  
 |  kernel_config_loaded(self, *args)
 |  
 |  make_code(self, *args)
 |  
 |  make_data(self, *args)
 |  
 |  renamed(self, *args)
 |  
 |  savebase(self, *args)
 |  
 |  segm_moved(self, from_ea, to_ea, size, changed_netmap)
 |  
 |  set_func_end(self, *args)
 |  
 |  set_func_start(self, *args)
 |  
 |  sgr_changed(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __idc_cvt_id__ = 2
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from IDP_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ev_add_cref(self, *args)
 |      A code reference is being created.
 |      
 |      ev_add_cref(self, _from, to, type) -> int
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @param type (C++: cref_t)
 |          @retval: <0 - cancel cref creation
 |          @retval: 0 - not implemented or continue
 |  
 |  ev_add_dref(self, *args)
 |      A data reference is being created.
 |      
 |      ev_add_dref(self, _from, to, type) -> int
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @param type (C++: dref_t)
 |          @retval: <0 - cancel dref creation
 |          @retval: 0 - not implemented or continue
 |  
 |  ev_adjust_argloc(self, *args)
 |      Adjust argloc according to its type/size and platform endianess
 |      
 |      ev_adjust_argloc(self, argloc, optional_type, size) -> int
 |          @param argloc: , inout  (C++: argloc_t *)
 |          optional_type: tinfo_t const *
 |          @param size: 'size' makes no sense if type != NULL (type->get_size()
 |                       should be used instead)  (C++: int)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |          @retval: -1 - error
 |  
 |  ev_adjust_libfunc_ea(self, *args)
 |      Called when a signature module has been matched against bytes in the
 |      database. This is used to compute the offset at which a particular
 |      module's libfunc should be applied.'ea' initially contains the ea_t of
 |      the start of the pattern match
 |      
 |      ev_adjust_libfunc_ea(self, sig, libfun, ea) -> int
 |          @param sig (C++: const idasgn_t *)
 |          @param libfun (C++: const libfunc_t *)
 |          @param ea (C++: ea_t *)
 |          @retval: 1 - the ea_t pointed to by the third argument was modified.
 |          @retval: <=0 - not modified. use default algorithm.
 |  
 |  ev_adjust_refinfo(self, *args)
 |      Called from apply_fixup before converting operand to reference. Can be
 |      used for changing the reference info. (e.g. the PPC module adds
 |      REFINFO_NOBASE for some references)
 |      
 |      ev_adjust_refinfo(self, ri, ea, n, fd) -> int
 |          @param ri (C++: refinfo_t *)
 |          @param ea: instruction address  (C++: ea_t)
 |          @param n: operand number  (C++: int)
 |          @param fd (C++: const fixup_data_t *)
 |          @retval: <0 - do not create an offset
 |          @retval: 0 - not implemented or refinfo adjusted
 |  
 |  ev_analyze_prolog(self, *args)
 |      Analyzes function prolog, epilog, and updates purge, and function
 |      attributes
 |      
 |      ev_analyze_prolog(self, ea) -> int
 |          @param ea: start of function  (C++: ea_t)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_arch_changed(self, *args)
 |      The loader is done parsing arch-related information, which the
 |      processor module might want to use to finish its initialization.
 |  
 |  ev_arg_addrs_ready(self, *args)
 |      Argument address info is ready.
 |      
 |      ev_arg_addrs_ready(self, caller, n, tif, addrs) -> int
 |          @param caller (C++: ea_t)
 |          @param n: number of formal arguments  (C++: int)
 |          @param tif: call prototype  (C++: tinfo_t *)
 |          @param addrs: argument intilization addresses  (C++: ea_t *)
 |          @retval: <0 - do not save into idb; other values mean "ok to save"
 |  
 |  ev_asm_installed(self, *args)
 |      After setting a new assembler
 |      
 |      ev_asm_installed(self, asmnum) -> int
 |          @param asmnum: See also ev_newasm  (C++: int)
 |  
 |  ev_calc_arglocs(self, *args)
 |      Calculate function argument locations. This callback should fill
 |      retloc, all arglocs, and stkargs. This callback is never called for
 |      'CM_CC_SPECIAL' functions.
 |      
 |      ev_calc_arglocs(self, fti) -> int
 |          @param fti: points to the func type info  (C++: func_type_data_t *)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |          @retval: -1 - error
 |  
 |  ev_calc_cdecl_purged_bytes(self, *args)
 |      Calculate number of purged bytes after call.
 |      
 |      ev_calc_cdecl_purged_bytes(self, ea) -> int
 |          @param ea: address of the call instruction  (C++: ea_t)
 |          @return: number of purged bytes (usually add sp, N)
 |  
 |  ev_calc_next_eas(self, *args)
 |      Calculate list of addresses the instruction in 'insn' may pass control
 |      to. This callback is required for source level debugging.
 |      
 |      ev_calc_next_eas(self, res, insn, over) -> int
 |          @param res: , out: array for the results.  (C++: eavec_t *)
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @param over: calculate for step over (ignore call targets)  (C++:
 |                       bool)
 |          @retval: <0 - incalculable (indirect jumps, for example)
 |          @retval: >=0 - number of addresses of called functions in the array.
 |                         They must be put at the beginning of the array (0 if
 |                         over=true)
 |  
 |  ev_calc_purged_bytes(self, *args)
 |      Calculate number of purged bytes by the given function type.
 |      
 |      ev_calc_purged_bytes(self, p_purged_bytes, fti) -> int
 |          @param p_purged_bytes: ptr to output  (C++: int *)
 |          @param fti: func type details  (C++: const func_type_data_t *)
 |          @retval: 1 -
 |          @retval: 0 - not implemented
 |  
 |  ev_calc_retloc(self, *args)
 |      Calculate return value location.
 |      
 |      ev_calc_retloc(self, retloc, rettype, cc) -> int
 |          @param retloc (C++: argloc_t *)
 |          @param rettype (C++: const tinfo_t *)
 |          @param cc (C++: cm_t)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok,
 |          @retval: -1 - error
 |  
 |  ev_calc_spdelta(self, *args)
 |      Calculate amount of change to sp for the given insn. This event is
 |      required to decompile code snippets.
 |      
 |      ev_calc_spdelta(self, spdelta, insn) -> int
 |          @param spdelta (C++: sval_t *)
 |          @param insn (C++: const insn_t *)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_calc_switch_cases(self, *args)
 |      Calculate case values and targets for a custom jump table.
 |      
 |      ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -> int
 |          @param casevec: vector of case values (may be NULL)  (C++: casevec_t
 |                          *)
 |          @param targets: corresponding target addresses (my be NULL)  (C++:
 |                          eavec_t *)
 |          @param insn_ea: address of the 'indirect jump' instruction  (C++:
 |                          ea_t)
 |          @param si: switch information  (C++: switch_info_t *)
 |          @retval: 1 - ok
 |          @retval: <=0 - failed
 |  
 |  ev_calc_varglocs(self, *args)
 |      Calculate locations of the arguments that correspond to '...'.
 |      
 |      ev_calc_varglocs(self, ftd, aux_regs, aux_stkargs, nfixed) -> int
 |          @param ftd: , inout: info about all arguments (including varargs)
 |                      (C++: func_type_data_t *)
 |          @param aux_regs: buffer for hidden register arguments, may be NULL
 |                           (C++: regobjs_t *)
 |          @param aux_stkargs: buffer for hidden stack arguments, may be NULL
 |                              (C++: relobj_t *)
 |          @param nfixed: number of fixed arguments  (C++: int)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |          @retval: -1 - error On some platforms variadic calls require passing
 |                        additional information: for example, number of floating
 |                        variadic arguments must be passed in rax on gcc-x64. The
 |                        locations and values that constitute this additional
 |                        information are returned in the buffers pointed by
 |                        aux_regs and aux_stkargs
 |  
 |  ev_calcrel(self, *args)
 |      Reserved.
 |  
 |  ev_clean_tbit(self, *args)
 |      Clear the TF bit after an insn like pushf stored it in memory.
 |      
 |      ev_clean_tbit(self, ea, getreg, regvalues) -> int
 |          @param ea: instruction address  (C++: ea_t)
 |          @param getreg: function to get register values  (C++:
 |                         processor_t::regval_getter_t *)
 |          @param regvalues: register values array  (C++: const regval_t *)
 |          @retval: 1 - ok
 |          @retval: 0 - failed
 |  
 |  ev_create_flat_group(self, *args)
 |      Create special segment representing the flat group.
 |      
 |      ev_create_flat_group(self, image_base, bitness, dataseg_sel) -> int
 |          @param image_base (C++: ea_t)
 |          @param bitness (C++: int)
 |          @param dataseg_sel: return value is ignored  (C++: sel_t)
 |  
 |  ev_decorate_name(self, *args)
 |      Decorate/undecorate a C symbol name.
 |      
 |      ev_decorate_name(self, name, mangle, cc, optional_type) -> PyObject *
 |          @param name: name of symbol  (C++: const char *)
 |          @param mangle: true-mangle, false-unmangle  (C++: bool)
 |          @param cc: calling convention  (C++: cm_t)
 |          optional_type: tinfo_t const *
 |          @retval: 1 - if success
 |          @retval: 0 - not implemented or failed
 |  
 |  ev_del_cref(self, *args)
 |      A code reference is being deleted.
 |      
 |      ev_del_cref(self, _from, to, expand) -> int
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @param expand (C++: bool)
 |          @retval: <0 - cancel cref deletion
 |          @retval: 0 - not implemented or continue
 |  
 |  ev_del_dref(self, *args)
 |      A data reference is being deleted.
 |      
 |      ev_del_dref(self, _from, to) -> int
 |          @param _from (C++: ea_t)
 |          @param to (C++: ea_t)
 |          @retval: <0 - cancel dref deletion
 |          @retval: 0 - not implemented or continue
 |  
 |  ev_delay_slot_insn(self, *args)
 |      Get delay slot instructionInput EA may point to the instruction with a
 |      delay slot or to the delay slot instruction itself.
 |      
 |      ev_delay_slot_insn(self, ea, bexec, fexec) -> PyObject *
 |          @param ea: in: instruction address in question, out: (if the answer is
 |                     positive) if the delay slot contains valid insn: the
 |                     address of the delay slot insn else: BADADDR (invalid insn,
 |                     e.g. a branch)  (C++: ea_t *)
 |          @param bexec: execute slot if jumping, initially set to 'true'  (C++:
 |                        bool *)
 |          @param fexec: execute slot if not jumping, initally set to 'true'
 |                        (C++: bool *)
 |          @retval: 1 - positive answer
 |          @retval: <=0 - ordinary insn
 |  
 |  ev_demangle_name(self, *args)
 |      Demangle a C++ (or another language) name into a user-readable string.
 |      This event is called by 'demangle_name()' if you call
 |      'demangle_name()' from the handler, protect against recursion!
 |      
 |      ev_demangle_name(self, name, disable_mask, demreq) -> PyObject *
 |          @param name: mangled name  (C++: const char *)
 |          @param disable_mask: flags to inhibit parts of output or compiler
 |                               info/other (see MNG_)  (C++: uint32)
 |          @param demreq: operation to perform  (C++: demreq_type_t)
 |          @retval: 1 - if success
 |          @retval: 0 - not implemented
 |  
 |  ev_ending_undo(self, *args)
 |      Ended undoing/redoing an action
 |      
 |      ev_ending_undo(self, action_name, is_undo) -> int
 |          @param action_name: action that we finished undoing/redoing. is not
 |                              NULL.  (C++: const char *)
 |          @param is_undo: true if performing undo, false if performing redo
 |                          (C++: bool)
 |  
 |  ev_equal_reglocs(self, *args)
 |      Are 2 register arglocs the same?. We need this callback for the pc
 |      module.
 |      
 |      ev_equal_reglocs(self, a1, a2) -> int
 |          @param a1 (C++: argloc_t *)
 |          @param a2 (C++: argloc_t *)
 |          @retval: 1 - yes
 |          @retval: -1 - no
 |          @retval: 0 - not implemented
 |  
 |  ev_extract_address(self, *args)
 |      Extract address from a string.
 |      
 |      ev_extract_address(self, out_ea, screen_ea, string, position) -> int
 |          @param out_ea: , out  (C++: ea_t *)
 |          @param screen_ea (C++: ea_t)
 |          @param string (C++: const char *)
 |          @param position (C++: size_t)
 |          @retval: 1 - ok
 |          @retval: 0 - kernel should use the standard algorithm
 |          @retval: -1 - error
 |  
 |  ev_find_op_value(self, *args)
 |      Find operand value via a register tracker. The returned value in 'out'
 |      is valid before executing the instruction.
 |      
 |      ev_find_op_value(self, pinsn, opn) -> PyObject *
 |          @param pinsn: instruction  (C++: const insn_t *)
 |          @param opn: operand index  (C++: int)
 |          @retval: 1 - if implemented, and value was found
 |          @retval: 0 - not implemented, -1 decoding failed, or no value found
 |  
 |  ev_find_reg_value(self, *args)
 |      Find register value via a register tracker. The returned value in
 |      'out' is valid before executing the instruction.
 |      
 |      ev_find_reg_value(self, pinsn, reg) -> PyObject *
 |          @param pinsn: instruction  (C++: const insn_t *)
 |          @param reg: register index  (C++: int)
 |          @retval: 1 - if implemented, and value was found
 |          @retval: 0 - not implemented, -1 decoding failed, or no value found
 |  
 |  ev_gen_asm_or_lst(self, *args)
 |      Callback: generating asm or lst file. The kernel calls this callback
 |      twice, at the beginning and at the end of listing generation. The
 |      processor module can intercept this event and adjust its output
 |      
 |      ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline) -> int
 |          @param starting: beginning listing generation  (C++: bool)
 |          @param fp: output file  (C++: FILE *)
 |          @param is_asm: true:assembler, false:listing  (C++: bool)
 |          @param flags: flags passed to gen_file()  (C++: int)
 |          @param outline: ptr to ptr to outline callback. if this callback is
 |                          defined for this code, it will be used by the kernel
 |                          to output the generated lines  (C++: html_line_cb_t
 |                          **)
 |          @retval: void -
 |  
 |  ev_gen_stkvar_def(self, *args)
 |      Generate stack variable definition line Default line is varname = type
 |      ptr value, where 'type' is one of byte,word,dword,qword,tbyte
 |      
 |      ev_gen_stkvar_def(self, outctx, mptr, v) -> int
 |          @param outctx (C++: outctx_t *)
 |          @param mptr (C++: const member_t *)
 |          @param v (C++: sval_t)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |  
 |  ev_get_abi_info(self, *args)
 |      Get all possible ABI names and optional extensions for given compiler
 |      abiname/option is a string entirely consisting of letters, digits and
 |      underscore
 |      
 |      ev_get_abi_info(self, abi_names, abi_opts, comp) -> int
 |          @param abi_names: - all possible ABis each in form abiname-
 |                            opt1-opt2-...  (C++: qstrvec_t *)
 |          @param abi_opts: - array of all possible options in form
 |                           "opt:description" or opt:hint-line#description  (C++:
 |                           qstrvec_t *)
 |          @param comp: - compiler ID  (C++: comp_t)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |  
 |  ev_get_bg_color(self, *args)
 |      Get item background color. Plugins can hook this callback to color
 |      disassembly lines dynamically
 |      
 |      ev_get_bg_color(self, ea) -> int or None
 |          @param color: , out  (C++: bgcolor_t *)
 |          @param ea (C++: ea_t)
 |          @retval: 0 - not implemented
 |          @retval: 1 - color set
 |  
 |  ev_get_cc_regs(self, *args)
 |      Get register allocation convention for given calling convention
 |      
 |      ev_get_cc_regs(self, regs, cc) -> int
 |          @param regs: , out  (C++: callregs_t *)
 |          @param cc (C++: cm_t)
 |          @retval: 1 -
 |          @retval: 0 - not implemented
 |  
 |  ev_get_code16_mode(self, *args)
 |      Get ISA 16-bit mode
 |      
 |      ev_get_code16_mode(self, ea) -> int
 |          @param ea: address to get the ISA mode  (C++: ea_t)
 |          @retval: 1 - 16-bit mode
 |          @retval: 0 - not implemented or 32-bit mode
 |  
 |  ev_get_dbr_opnum(self, *args)
 |      Get the number of the operand to be displayed in the debugger
 |      reference view (text mode).
 |      
 |      ev_get_dbr_opnum(self, opnum, insn) -> int
 |          @param opnum: operand number (out, -1 means no such operand)  (C++:
 |                        int *)
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @retval: 0 - unimplemented
 |          @retval: 1 - implemented
 |  
 |  ev_get_default_enum_size(self, *args)
 |      Get default enum size. Not generated anymore. inf_get_cc_size_e() is
 |      used instead
 |  
 |  ev_get_macro_insn_head(self, *args)
 |      Calculate the start of a macro instruction. This notification is
 |      called if IP points to the middle of an instruction
 |      
 |      ev_get_macro_insn_head(self, head, ip) -> int
 |          @param head: , out: answer, BADADDR means normal instruction  (C++:
 |                       ea_t *)
 |          @param ip: instruction address  (C++: ea_t)
 |          @retval: 0 - unimplemented
 |          @retval: 1 - implemented
 |  
 |  ev_get_procmod(self, *args)
 |      Get pointer to the processor module object. All processor modules must
 |      implement this. The pointer is returned as size_t.
 |  
 |  ev_get_reg_accesses(self, *args)
 |      Get info about the registers that are used/changed by an instruction.
 |      
 |      ev_get_reg_accesses(self, accvec, insn, flags) -> int
 |          @param accvec: out: info about accessed registers  (C++:
 |                         reg_accesses_t*)
 |          @param insn: instruction in question  (C++: const insn_t *)
 |          @param flags: reserved, must be 0  (C++: int)
 |          @retval: -1 - if accvec is nullptr
 |          @retval: 1 - found the requested access (and filled accvec)
 |          @retval: 0 - not implemented
 |  
 |  ev_get_reg_info(self, *args)
 |      Get register information by its name. example: "ah"
 |      returns:main_regname="eax" 'bitrange_t' = { offset==8, nbits==8 }This
 |      callback may be unimplemented if the register names are all present in
 |      \ph{reg_names} and they all have the same size
 |      
 |      ev_get_reg_info(self, main_regname, bitrange, regname) -> int
 |          @param main_regname: , out  (C++: const char **)
 |          @param bitrange: , out: position and size of the value within
 |                           'main_regname' (empty bitrange == whole register)
 |                           (C++: bitrange_t *)
 |          @param regname (C++: const char *)
 |          @retval: 1 - ok
 |          @retval: -1 - failed (not found)
 |          @retval: 0 - unimplemented
 |  
 |  ev_get_reg_name(self, *args)
 |      Generate text representation of a register. Most processor modules do
 |      not need to implement this callback. It is useful only if
 |      \ph{reg_names}[reg] does not provide the correct register name.
 |      
 |      ev_get_reg_name(self, reg, width, reghi) -> PyObject *
 |          @param reg: internal register number as defined in the processor
 |                      module  (C++: int)
 |          @param width: register width in bytes  (C++: size_t)
 |          @param reghi: if not -1 then this function will return the register
 |                        pair  (C++: int)
 |          @retval: -1 - if error
 |          @retval: strlen(buf) - if success
 |  
 |  ev_get_simd_types(self, *args)
 |      Get SIMD-related types according to given attributes ant/or argument
 |      location
 |      
 |      ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -> int
 |          @param out (C++: simd_info_vec_t *)
 |          @param simd_attrs: , may be NULL  (C++: const simd_info_t *)
 |          @param argloc: , may be NULL  (C++: const argloc_t *)
 |          @param create_tifs: return valid tinfo_t objects, create if neccessary
 |                              (C++: bool)
 |          @retval: number - of found types
 |          @retval: -1 - error If name==NULL, initialize all SIMD types
 |  
 |  ev_get_stkarg_offset(self, *args)
 |      Get offset from SP to the first stack argument. For example: pc: 0,
 |      hppa: -0x34, ppc: 0x38
 |  
 |  ev_get_stkvar_scale_factor(self, *args)
 |      Should stack variable references be multiplied by a coefficient before
 |      being used in the stack frame?. Currently used by TMS320C55 because
 |      the references into the stack should be multiplied by 2
 |      'PR_SCALE_STKVARS' should be set to use this callback
 |  
 |  ev_getreg(self, *args)
 |      IBM PC only internal request, should never be used for other purpose
 |      Get register value by internal index
 |      
 |      ev_getreg(self, regval, regnum) -> int
 |          @param regval: , out  (C++: uval_t *)
 |          @param regnum (C++: int)
 |          @retval: 1 - ok
 |          @retval: 0 - not implemented
 |          @retval: -1 - failed (undefined value or bad regnum)
 |  
 |  ev_init(self, *args)
 |      The IDP module is just loaded.
 |      
 |      ev_init(self, idp_modname) -> int
 |          @param idp_modname: processor module name  (C++: const char *)
 |          @retval: <0 - on failure
 |  
 |  ev_insn_reads_tbit(self, *args)
 |      Check if insn will read the TF bit.
 |      
 |      ev_insn_reads_tbit(self, insn, getreg, regvalues) -> int
 |          @param insn: the instruction  (C++: const insn_t*)
 |          @param getreg: function to get register values  (C++:
 |                         processor_t::regval_getter_t *)
 |          @param regvalues: register values array  (C++: const regval_t *)
 |          @retval: 2 - yes, will generate 'step' exception
 |          @retval: 1 - yes, will store the TF bit in memory
 |          @retval: 0 - no
 |  
 |  ev_is_cond_insn(self, *args)
 |      Is conditional instruction?
 |      
 |      ev_is_cond_insn(self, insn) -> int
 |          @param insn: instruction address  (C++: const insn_t *)
 |          @retval: 1 - yes
 |          @retval: -1 - no
 |          @retval: 0 - not implemented or not instruction
 |  
 |  ev_is_jump_func(self, *args)
 |      Is the function a trivial "jump" function?.
 |      
 |      ev_is_jump_func(self, pfn, jump_target, func_pointer) -> int
 |          @param pfn (C++: func_t *)
 |          @param jump_target (C++: ea_t *)
 |          @param func_pointer (C++: ea_t *)
 |          @retval: <0 - no
 |          @retval: 0 - don't know
 |          @retval: 1 - yes, see 'jump_target' and 'func_pointer'
 |  
 |  ev_last_cb_before_loader(self, *args)
 |      ev_last_cb_before_loader(self) -> int
 |  
 |  ev_loader(self, *args)
 |      This code and higher ones are reserved for the loaders. The arguments
 |      and the return values are defined by the loaders
 |  
 |  ev_lower_func_type(self, *args)
 |      Get function arguments which should be converted to pointers when
 |      lowering function prototype. The processor module can also modify
 |      'fti' in order to make non-standard conversion of some arguments.
 |      
 |      ev_lower_func_type(self, argnums, fti) -> int
 |          @param argnums: , out - numbers of arguments to be converted to
 |                          pointers in acsending order  (C++: intvec_t *)
 |          @param fti: , inout func type details (special values -1/-2 for return
 |                      value - position of hidden 'retstr' argument: -1 - at the
 |                      beginning, -2 - at the end)  (C++: func_type_data_t *)
 |          @retval: 0 - not implemented
 |          @retval: 1 - argnums was filled
 |          @retval: 2 - argnums was filled and made substantial changes to fti
 |  
 |  ev_max_ptr_size(self, *args)
 |      Get maximal size of a pointer in bytes.
 |  
 |  ev_newasm(self, *args)
 |      Before setting a new assembler.
 |      
 |      ev_newasm(self, asmnum) -> int
 |          @param asmnum: See also ev_asm_installed  (C++: int)
 |  
 |  ev_next_exec_insn(self, *args)
 |      Get next address to be executed This function must return the next
 |      address to be executed. If the instruction following the current one
 |      is executed, then it must return 'BADADDR' Usually the instructions to
 |      consider are: jumps, branches, calls, returns. This function is
 |      essential if the 'single step' is not supported in hardware.
 |      
 |      ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -> int
 |          @param target: , out: pointer to the answer  (C++: ea_t *)
 |          @param ea: instruction address  (C++: ea_t)
 |          @param tid: current therad id  (C++: int)
 |          @param getreg: function to get register values  (C++:
 |                         processor_t::regval_getter_t *)
 |          @param regvalues: register values array  (C++: const regval_t *)
 |          @retval: 0 - unimplemented
 |          @retval: 1 - implemented
 |  
 |  ev_realcvt(self, *args)
 |      Floating point -> IEEE conversion
 |      
 |      ev_realcvt(self, m, e, swt) -> int
 |          @param m: pointer to data  (C++: void *)
 |          @param e: internal IEEE format data  (C++: uint16 *)
 |          @param swt: operation (see realcvt() in ieee.h)  (C++: uint16)
 |          @retval: 0 - not implemented
 |          @retval: 1 - ok
 |  
 |  ev_replaying_undo(self, *args)
 |      Replaying an undo/redo buffer
 |      
 |      ev_replaying_undo(self, action_name, vec, is_undo) -> int
 |          @param action_name: action that we perform undo/redo for. may be NULL
 |                              for intermediary buffers.  (C++: const char *)
 |          @param vec (C++: const undo_records_t *)
 |          @param is_undo: true if performing undo, false if performing redo This
 |                          event may be generated multiple times per undo/redo
 |                          (C++: bool)
 |  
 |  ev_set_code16_mode(self, *args)
 |      Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE,
 |      MIPS16 Set ISA 16-bit mode
 |      
 |      ev_set_code16_mode(self, ea, code16) -> int
 |          @param ea: address to set new ISA mode  (C++: ea_t)
 |          @param code16: true for 16-bit mode, false for 32-bit mode  (C++:
 |                         bool)
 |  
 |  ev_setup_til(self, *args)
 |      Setup default type libraries. (called after loading a new file into
 |      the database). The processor module may load tils, setup memory model
 |      and perform other actions required to set up the type system. This is
 |      an optional callback.
 |  
 |  ev_shadow_args_size(self, *args)
 |      Get size of shadow args in bytes.
 |      
 |      ev_shadow_args_size(self, shadow_args_size, pfn) -> int
 |          @param shadow_args_size (C++: int *)
 |          @param pfn: (may be NULL)  (C++: func_t *)
 |          @retval: 1 - if filled *shadow_args_size
 |          @retval: 0 - not implemented
 |  
 |  ev_term(self, *args)
 |      The IDP module is being unloaded.
 |  
 |  ev_use_arg_types(self, *args)
 |      Use information about callee arguments.
 |      
 |      ev_use_arg_types(self, ea, fti, rargs) -> int
 |          @param ea: address of the call instruction  (C++: ea_t)
 |          @param fti: info about function type  (C++: func_type_data_t *)
 |          @param rargs: array of register arguments  (C++: funcargvec_t *)
 |          @retval: 1 - (and removes handled arguments from fti and rargs)
 |          @retval: 0 - not implemented
 |  
 |  ev_use_regarg_type(self, *args)
 |      Use information about register argument.
 |      
 |      ev_use_regarg_type(self, ea, rargs) -> PyObject *
 |          @param ea: address of the instruction  (C++: ea_t)
 |          @param rargs: vector of register arguments (including regs extracted
 |                        from scattered arguments)  (C++: const funcargvec_t *)
 |          @retval: 1 -
 |          @retval: 0 - not implemented
 |  
 |  ev_use_stkarg_type(self, *args)
 |      Use information about a stack argument.
 |      
 |      ev_use_stkarg_type(self, ea, arg) -> int
 |          @param ea: address of the push instruction which pushes the function
 |                     argument into the stack  (C++: ea_t)
 |          @param arg: argument info  (C++: const funcarg_t *)
 |          @retval: 1 - ok
 |          @retval: <=0 - failed, the kernel will create a comment with the
 |                         argument name or type for the instruction
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from IDP_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from IDP_Hooks:
 |  
 |  __swig_destroy__ = <built-in function delete_IDP_Hooks>
 |      delete_IDP_Hooks(self)

Help on class reg_access_t in module ida_idp:

class reg_access_t(__builtin__.object)
 |  Proxy of C++ reg_access_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: reg_access_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reg_access_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: reg_access_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  have_common_bits(self, *args)
 |      have_common_bits(self, r) -> bool
 |          @param r (C++: const  reg_access_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  access_type
 |      reg_access_t_access_type_get(self) -> access_type_t
 |  
 |  opnum
 |      reg_access_t_opnum_get(self) -> uchar
 |  
 |  range
 |      reg_access_t_range_get(self) -> bitrange_t
 |  
 |  regnum
 |      reg_access_t_regnum_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_reg_access_t>
 |      delete_reg_access_t(self)

Help on class reg_access_vec_t in module ida_idp:

class reg_access_vec_t(__builtin__.object)
 |  Proxy of C++ qvector< reg_access_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< reg_access_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> reg_access_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reg_access_vec_t
 |          x: qvector< reg_access_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< reg_access_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: reg_access_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: reg_access_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: reg_access_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> reg_access_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> reg_access_t
 |      begin(self) -> reg_access_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> reg_access_t
 |      end(self) -> reg_access_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> reg_access_t
 |          it: qvector< reg_access_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> reg_access_t
 |          first: qvector< reg_access_t >::iterator
 |          last: qvector< reg_access_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> reg_access_t
 |  
 |  find(self, *args)
 |      find(self, x) -> reg_access_t
 |          x: reg_access_t const &
 |      
 |      
 |      find(self, x) -> reg_access_t
 |          x: reg_access_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=reg_access_t())
 |          x: reg_access_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: reg_access_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: reg_access_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> reg_access_t
 |          it: qvector< reg_access_t >::iterator
 |          x: reg_access_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: reg_access_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: reg_access_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< reg_access_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_reg_access_vec_t>
 |      delete_reg_access_vec_t(self)

Help on class reg_accesses_t in module ida_idp:

class reg_accesses_t(reg_access_vec_t)
 |  Proxy of C++ reg_accesses_t class.
 |  
 |  Method resolution order:
 |      reg_accesses_t
 |      reg_access_vec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reg_accesses_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_reg_accesses_t>
 |      delete_reg_accesses_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from reg_access_vec_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< reg_access_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> reg_access_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< reg_access_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: reg_access_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: reg_access_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: reg_access_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> reg_access_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> reg_access_t
 |      begin(self) -> reg_access_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> reg_access_t
 |      end(self) -> reg_access_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> reg_access_t
 |          it: qvector< reg_access_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> reg_access_t
 |          first: qvector< reg_access_t >::iterator
 |          last: qvector< reg_access_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> reg_access_t
 |  
 |  find(self, *args)
 |      find(self, x) -> reg_access_t
 |          x: reg_access_t const &
 |      
 |      
 |      find(self, x) -> reg_access_t
 |          x: reg_access_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=reg_access_t())
 |          x: reg_access_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: reg_access_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: reg_access_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> reg_access_t
 |          it: qvector< reg_access_t >::iterator
 |          x: reg_access_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: reg_access_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: reg_access_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< reg_access_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from reg_access_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class reg_info_t in module ida_idp:

class reg_info_t(__builtin__.object)
 |  Proxy of C++ reg_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: reg_info_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: reg_info_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: reg_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reg_info_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: reg_info_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: reg_info_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: reg_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: reg_info_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  reg
 |      reg_info_t_reg_get(self) -> int
 |  
 |  size
 |      reg_info_t_size_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_reg_info_t>
 |      delete_reg_info_t(self)

Help on function register_cfgopts in module ida_idp:

register_cfgopts(*args)
    register_cfgopts(opts, nopts, cb=None, obj=None) -> bool
        opts: cfgopt_t const []
        nopts: size_t
        cb: config_changed_cb_t *
        obj: void *

Help on function set_module_data in module ida_idp:

set_module_data(*args)
    Starting from IDA v7.5 all modules should use the following 3
    functions to handle idb specific static data because now the kernel
    supports opening and working with multiple idbs files simultaneously.
    See the source code of the processor modules in the SDK for the usage
    examples. Register pointer to database specific module data.
    
    set_module_data(data_id, data_ptr) -> void *
        @param data_id: initially the pointed-to value must be 0, the kernel
                        will fill it with a unique id. once assigned, the
                        data_id does not change. (C++: int *)
        @param data_ptr: pointer to the data to register (C++: void *)
        @return: data_ptr. The registered pointer can later be retrieved using
                 get_module_data()

Help on function set_processor_type in module ida_idp:

set_processor_type(*args)
    Set target processor type. Once a processor module is loaded, it
    cannot be replaced until we close the idb.
    
    set_processor_type(procname, level) -> bool
        @param procname: name of processor type (one of names present in
                         \ph{psnames}) (C++: const char *)
        @param level: SETPROC_ (C++: setproc_level_t)
        @return: success

Help on function set_target_assembler in module ida_idp:

set_target_assembler(*args)
    Set target assembler.
    
    set_target_assembler(asmnum) -> bool
        @param asmnum: number of assembler in the current processor module
                       (C++: int)
        @return: success

Help on function sizeof_ldbl in module ida_idp:

sizeof_ldbl(*args)
    sizeof_ldbl() -> size_t

Help on function str2reg in module ida_idp:

str2reg(*args)
    Get any reg number (-1 on error)
    
    str2reg(p) -> int
        @param p (C++: const char *)

=== ida_idp EPYDOC INJECTIONS ===
ida_idp.AS2_BRACE
"""
Use braces for all expressions.
"""

ida_idp.AS2_BYTE1CHAR
"""
Meaningful only for wide byte processors.

One symbol per processor byte
"""

ida_idp.AS2_COLONSUF
"""
addresses may have ":xx" suffix this suffix must be ignored when
extracting the address under the cursor
"""

ida_idp.AS2_IDEALDSCR
"""
Description of struc/union is in the 'reverse' form (keyword before
name) the same as in borland tasm ideal
"""

ida_idp.AS2_STRINV
"""
(For processors with bytes bigger than 8 bits)

Invert meaning of \\inf{wide_high_byte_first} for text strings
"""

ida_idp.AS2_TERSESTR
"""
NAME<fld,fld,...> is supported.

'terse' structure initialization form
"""

ida_idp.AS2_YWORD
"""
a_yword field is present and valid
"""

ida_idp.ASB_BINF0
"""
010101b
"""

ida_idp.ASB_BINF1
"""
^B010101
"""

ida_idp.ASB_BINF2
"""
%010101
"""

ida_idp.ASB_BINF3
"""
0b1010101
"""

ida_idp.ASB_BINF4
"""
b'1010101
"""

ida_idp.ASB_BINF5
"""
b'1010101'
"""

ida_idp.ASD_DECF0
"""
34
"""

ida_idp.ASD_DECF1
"""
#34
"""

ida_idp.ASD_DECF3
"""
.34
"""

ida_idp.ASH_HEXF0
"""
34h
"""

ida_idp.ASH_HEXF1
"""
h'34
"""

ida_idp.ASH_HEXF2
"""
34
"""

ida_idp.ASH_HEXF3
"""
0x34
"""

ida_idp.ASH_HEXF4
"""
$34
"""

ida_idp.ASH_HEXF5
"""
<^R > (radix)
"""

ida_idp.ASO_OCTF0
"""
123o
"""

ida_idp.ASO_OCTF1
"""
0123
"""

ida_idp.ASO_OCTF2
"""
123
"""

ida_idp.ASO_OCTF3
"""
@123
"""

ida_idp.ASO_OCTF4
"""
o'123
"""

ida_idp.ASO_OCTF5
"""
123q
"""

ida_idp.ASO_OCTF6
"""
~123
"""

ida_idp.ASO_OCTF7
"""
q'123
"""

ida_idp.AS_1TEXT
"""
1 text per line, no bytes
"""

ida_idp.AS_2CHRE
"""
double char constants are: "xy
"""

ida_idp.AS_ALIGN2
"""
(.align 5 means to align at 32byte boundary)

.align directive expects an exponent rather than a power of 2
"""

ida_idp.AS_ASCIIC
"""
(\\n,\\x01 and similar)

ascii directive accepts C-like escape sequences
"""

ida_idp.AS_ASCIIZ
"""
ascii directive inserts implicit zero byte at the end
"""

ida_idp.AS_BINFM
"""
mask - binary number format
"""

ida_idp.AS_COLON
"""
create colons after data names ?
"""

ida_idp.AS_DECFM
"""
mask - decimal number format
"""

ida_idp.AS_HEXFM
"""
mask - hex number format
"""

ida_idp.AS_LALIGN
"""
Labels at "align" keyword are supported.
"""

ida_idp.AS_N2CHR
"""
can't have 2 byte char consts
"""

ida_idp.AS_NCHRE
"""
char constants are: 'x
"""

ida_idp.AS_NCMAS
"""
no commas in ascii directives
"""

ida_idp.AS_NHIAS
"""
no characters with high bit
"""

ida_idp.AS_NOCODECLN
"""
don't create colons after code names
"""

ida_idp.AS_NOSPACE
"""
No spaces in expressions.
"""

ida_idp.AS_NOXRF
"""
Disable xrefs during the output file generation.
"""

ida_idp.AS_OCTFM
"""
mask - octal number format
"""

ida_idp.AS_OFFST
"""
offsets are 'offset xxx' ?
"""

ida_idp.AS_ONEDUP
"""
One array definition per line.
"""

ida_idp.AS_RELSUP
"""
Checkarg: 'and','or','xor' operations with addresses are possible.
"""

ida_idp.AS_UDATA
"""
can use '?' in data directives
"""

ida_idp.AS_UNEQU
"""
replace undefined data items with EQU (for ANTA's A80)
"""

ida_idp.AS_XTRNTYPE
"""
Assembler understands type of extern symbols as ":type" suffix.
"""

ida_idp.CF_CALL
"""
CALL instruction (should make a procedure here)
"""

ida_idp.CF_CHG1
"""
The instruction modifies the first operand.
"""

ida_idp.CF_CHG2
"""
The instruction modifies the second operand.
"""

ida_idp.CF_CHG3
"""
The instruction modifies the third operand.
"""

ida_idp.CF_CHG4
"""
The instruction modifies 4 operand.
"""

ida_idp.CF_CHG5
"""
The instruction modifies 5 operand.
"""

ida_idp.CF_CHG6
"""
The instruction modifies 6 operand.
"""

ida_idp.CF_HLL
"""
language function.

Instruction may be present in a high level
"""

ida_idp.CF_JUMP
"""
jump or call (thus needs additional analysis)

The instruction passes execution using indirect
"""

ida_idp.CF_SHFT
"""
Bit-shift instruction (shl,shr...)
"""

ida_idp.CF_STOP
"""
next instruction

Instruction doesn't pass execution to the
"""

ida_idp.CF_USE1
"""
The instruction uses value of the first operand.
"""

ida_idp.CF_USE2
"""
The instruction uses value of the second operand.
"""

ida_idp.CF_USE3
"""
The instruction uses value of the third operand.
"""

ida_idp.CF_USE4
"""
The instruction uses value of the 4 operand.
"""

ida_idp.CF_USE5
"""
The instruction uses value of the 5 operand.
"""

ida_idp.CF_USE6
"""
The instruction uses value of the 6 operand.
"""

ida_idp.CUSTOM_INSN_ITYPE
"""
Custom instruction codes defined by processor extension plugins must
be greater than or equal to this
"""

ida_idp.HKCB_AUTODEL
"""
automatically delete event listener object after uninstalling it
"""

ida_idp.HKCB_GLOBAL
"""
is global event listener? if true, the listener will survive database
closing and opening. it will stay in the memory until explicitly
unhooked. otherwise the kernel will delete it as soon as the owner is
unloaded. should be used only with PLUGIN_FIX plugins.
"""

ida_idp.IDP_INTERFACE_VERSION
"""
The interface version number.see also 'IDA_SDK_VERSION' from 'pro.h'
"""

ida_idp.OP_FP_BASED
"""
operand is FP based
"""

ida_idp.OP_SP_ADD
"""
operand value is added to the pointer
"""

ida_idp.OP_SP_BASED
"""
operand is SP based
"""

ida_idp.OP_SP_SUB
"""
operand value is subtracted from the pointer
"""

ida_idp.PLFM_386
"""
Intel 80x86.
"""

ida_idp.PLFM_6502
"""
6502
"""

ida_idp.PLFM_65C816
"""
65802/65816
"""

ida_idp.PLFM_6800
"""
Motorola 68xx.
"""

ida_idp.PLFM_68K
"""
Motorola 680x0.
"""

ida_idp.PLFM_80196
"""
Intel 80196.
"""

ida_idp.PLFM_8051
"""
8051
"""

ida_idp.PLFM_AD2106X
"""
Analog Devices ADSP 2106X.
"""

ida_idp.PLFM_AD218X
"""
Analog Devices ADSP 218X.
"""

ida_idp.PLFM_ALPHA
"""
DEC Alpha.
"""

ida_idp.PLFM_ARC
"""
Argonaut RISC Core.
"""

ida_idp.PLFM_ARM
"""
Advanced RISC Machines.
"""

ida_idp.PLFM_AVR
"""
Atmel 8-bit RISC processor(s)
"""

ida_idp.PLFM_C166
"""
Siemens C166 family.
"""

ida_idp.PLFM_C39
"""
Rockwell C39.
"""

ida_idp.PLFM_CR16
"""
NSC CR16.
"""

ida_idp.PLFM_DALVIK
"""
Android Dalvik Virtual Machine.
"""

ida_idp.PLFM_DSP56K
"""
Motorola DSP5600x.
"""

ida_idp.PLFM_DSP96K
"""
Motorola DSP96000.
"""

ida_idp.PLFM_EBC
"""
EFI Bytecode.
"""

ida_idp.PLFM_F2MC
"""
Fujistu F2MC-16.
"""

ida_idp.PLFM_FR
"""
Fujitsu FR Family.
"""

ida_idp.PLFM_H8
"""
Hitachi H8/300, H8/2000.
"""

ida_idp.PLFM_H8500
"""
Hitachi H8/500.
"""

ida_idp.PLFM_HPPA
"""
Hewlett-Packard PA-RISC.
"""

ida_idp.PLFM_I860
"""
Intel 860.
"""

ida_idp.PLFM_I960
"""
Intel 960.
"""

ida_idp.PLFM_IA64
"""
Intel Itanium IA64.
"""

ida_idp.PLFM_JAVA
"""
Java.
"""

ida_idp.PLFM_KR1878
"""
Angstrem KR1878.
"""

ida_idp.PLFM_M16C
"""
Renesas M16C.
"""

ida_idp.PLFM_M32R
"""
Mitsubishi 32bit RISC.
"""

ida_idp.PLFM_M740
"""
Mitsubishi 8bit.
"""

ida_idp.PLFM_M7700
"""
Mitsubishi 16bit.
"""

ida_idp.PLFM_M7900
"""
Mitsubishi 7900.
"""

ida_idp.PLFM_MC6812
"""
Motorola 68HC12.
"""

ida_idp.PLFM_MC6816
"""
Motorola 68HC16.
"""

ida_idp.PLFM_MIPS
"""
MIPS.
"""

ida_idp.PLFM_MN102L00
"""
Panasonic MN10200.
"""

ida_idp.PLFM_MSP430
"""
Texas Instruments MSP430.
"""

ida_idp.PLFM_NEC_78K0
"""
NEC 78K0.
"""

ida_idp.PLFM_NEC_78K0S
"""
NEC 78K0S.
"""

ida_idp.PLFM_NEC_V850X
"""
NEC V850 and V850ES/E1/E2.
"""

ida_idp.PLFM_NET
"""
Microsoft Visual Studio.Net.
"""

ida_idp.PLFM_OAKDSP
"""
Atmel OAK DSP.
"""

ida_idp.PLFM_PDP
"""
PDP11.
"""

ida_idp.PLFM_PIC
"""
Microchip's PIC.
"""

ida_idp.PLFM_PIC16
"""
Microchip's 16-bit PIC.
"""

ida_idp.PLFM_PPC
"""
PowerPC.
"""

ida_idp.PLFM_S390
"""
IBM's S390.
"""

ida_idp.PLFM_SCR_ADPT
"""
Processor module adapter for processor modules written in scripting
languages.
"""

ida_idp.PLFM_SH
"""
Renesas (formerly Hitachi) SuperH.
"""

ida_idp.PLFM_SPARC
"""
SPARC.
"""

ida_idp.PLFM_SPC700
"""
Sony SPC700.
"""

ida_idp.PLFM_SPU
"""
Cell Broadband Engine Synergistic Processor Unit.
"""

ida_idp.PLFM_ST20
"""
SGS-Thomson ST20.
"""

ida_idp.PLFM_ST7
"""
SGS-Thomson ST7.
"""

ida_idp.PLFM_ST9
"""
ST9+.
"""

ida_idp.PLFM_TLCS900
"""
Toshiba TLCS-900.
"""

ida_idp.PLFM_TMS
"""
Texas Instruments TMS320C5x.
"""

ida_idp.PLFM_TMS320C1X
"""
Texas Instruments TMS320C1x.
"""

ida_idp.PLFM_TMS320C28
"""
Texas Instruments TMS320C28x.
"""

ida_idp.PLFM_TMS320C3
"""
Texas Instruments TMS320C3.
"""

ida_idp.PLFM_TMS320C54
"""
Texas Instruments TMS320C54xx.
"""

ida_idp.PLFM_TMS320C55
"""
Texas Instruments TMS320C55xx.
"""

ida_idp.PLFM_TMSC6
"""
Texas Instruments TMS320C6x.
"""

ida_idp.PLFM_TRICORE
"""
Tasking Tricore.
"""

ida_idp.PLFM_TRIMEDIA
"""
Trimedia.
"""

ida_idp.PLFM_UNSP
"""
SunPlus unSP.
"""

ida_idp.PLFM_Z8
"""
Z8.
"""

ida_idp.PLFM_Z80
"""
8085, Z80
"""

ida_idp.PRN_BIN
"""
binary
"""

ida_idp.PRN_DEC
"""
decimal
"""

ida_idp.PRN_HEX
"""
hex
"""

ida_idp.PRN_OCT
"""
octal
"""

ida_idp.PR_ADJSEGS
"""
IDA may adjust segments' starting/ending addresses.
"""

ida_idp.PR_ALIGN
"""
All data items should be aligned properly.
"""

ida_idp.PR_ALIGN_INSN
"""
allow ida to create alignment instructions arbitrarily. Since these
instructions might lead to other wrong instructions and spoil the
listing, IDA does not create them by default anymore
"""

ida_idp.PR_ASSEMBLE
"""
Module has a built-in assembler and will react to ev_assemble.
"""

ida_idp.PR_BINMEM
"""
the processor module provides correct segmentation for binary files
(i.e. it creates additional segments) The kernel will not ask the user
to specify the RAM/ROM sizes
"""

ida_idp.PR_CHK_XREF
"""
don't allow near xrefs between segments with different bases
"""

ida_idp.PR_CNDINSNS
"""
has conditional instructions
"""

ida_idp.PR_DEFNUM
"""
mask - default number representation
"""

ida_idp.PR_DEFSEG32
"""
segments are 32-bit by default
"""

ida_idp.PR_DEFSEG64
"""
segments are 64-bit by default
"""

ida_idp.PR_DELAYED
"""
has delayed jumps and calls if this flag is set,
\\ph{is_basic_block_end}, \\ph{has_delay_slot} should be implemented
"""

ida_idp.PR_NOCHANGE
"""
(display only)

The user can't change segments and code/data attributes
"""

ida_idp.PR_NO_SEGMOVE
"""
(i.e. the user can't move segments)

the processor module doesn't support 'move_segm()'
"""

ida_idp.PR_PURGING
"""
there are calling conventions which may purge bytes from the stack
"""

ida_idp.PR_RNAMESOK
"""
allow user register names for location names
"""

ida_idp.PR_SCALE_STKVARS
"""
use \\ph{get_stkvar_scale} callback
"""

ida_idp.PR_SEGS
"""
has segment registers?
"""

ida_idp.PR_SEGTRANS
"""
the processor module supports the segment translation feature (meaning
it calculates the code addresses using the 'map_code_ea()' function)
"""

ida_idp.PR_SGROTHER
"""
the segment registers don't contain the segment selectors.
"""

ida_idp.PR_STACK_UP
"""
the stack grows up
"""

ida_idp.PR_TYPEINFO
"""
ALL OF THEM SHOULD BE IMPLEMENTED!

the processor module supports type information callbacks
"""

ida_idp.PR_USE32
"""
supports 32-bit addressing?
"""

ida_idp.PR_USE64
"""
supports 64-bit addressing?
"""

ida_idp.PR_USE_ARG_TYPES
"""
use \\ph{use_arg_types} callback
"""

ida_idp.PR_USE_TBYTE
"""
'BTMT_SPECFLT' means _TBYTE type
"""

ida_idp.PR_WORD_INS
"""
instruction codes are grouped 2bytes in binary line prefix
"""

ida_idp.REG_SPOIL
"""
processor_t::use_regarg_type uses this bit in the return value to
indicate that the register value has been spoiled
"""
=== ida_idp EPYDOC INJECTIONS END ===
Help on class Choose in module ida_kernwin:

class Choose(__builtin__.object)
 |  Chooser wrapper class.
 |  
 |  Some constants are defined in this class.
 |  Please refer to kernwin.hpp for more information.
 |  
 |  Methods defined here:
 |  
 |  Activate(self)
 |      Activates a visible chooser
 |  
 |  AddCommand(self, caption, flags=4, menu_index=-1, icon=-1, emb=None, shortcut=None)
 |  
 |  Close(self)
 |      Closes the chooser
 |  
 |  Embedded(self, create_chobj=False)
 |      Creates an embedded chooser (as opposed to Show())
 |      @return: Returns 0 on success or NO_ATTR
 |  
 |  GetEmbSelection(self)
 |      Deprecated. For embedded choosers, the selection is
 |      available through 'Form.EmbeddedChooserControl.selection'
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  OnPopup(self, widget, popup_handle)
 |  
 |  Refresh(self)
 |      Causes the refresh callback to trigger
 |  
 |  Show(self, modal=False)
 |      Activates or creates a chooser window
 |      @param modal: Display as modal dialog
 |      @return: For all choosers it will return NO_ATTR if some mandatory
 |               attribute is missing. The mandatory attributes are: flags,
 |               title, cols, OnGetSize(), OnGetLine();
 |               For modal choosers it will return the selected item index (0-based),
 |               or NO_SELECTION if no selection,
 |               or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
 |               For non-modal choosers it will return 0
 |               or ALREADY_EXISTS if the chooser was already open and is active now;
 |  
 |  __init__(self, title, cols, flags=0, popup_names=None, icon=-1, x1=-1, y1=-1, x2=-1, y2=-1, deflt=None, embedded=False, width=None, height=None, forbidden_cb=0)
 |      Constructs a chooser window.
 |      @param title: The chooser title
 |      @param cols: a list of colums; each list item is a list of two items
 |          example: [ ["Address", 10 | Choose.CHCOL_HEX],
 |                     ["Name",    30 | Choose.CHCOL_PLAIN] ]
 |      @param flags: One of CH_XXXX constants
 |      @param deflt: The index of the default item (0-based) for single
 |          selection choosers or the list of indexes for multi selection
 |          chooser
 |      @param popup_names: List of new captions to replace this list
 |          ["Insert", "Delete", "Edit", "Refresh"]
 |      @param icon: Icon index (the icon should exist in ida resources or
 |          an index to a custom loaded icon)
 |      @param x1, y1, x2, y2: The default location (for txt-version)
 |      @param embedded: Create as embedded chooser
 |      @param width: Embedded chooser width
 |      @param height: Embedded chooser height
 |      @param forbidden_cb: Explicitly forbidden callbacks
 |  
 |  adjust_last_item(self, n)
 |      Helper for OnDeleteLine() and OnRefresh() callbacks.
 |      They can be finished by the following line:
 |      return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
 |      @param: line number of the remaining select item
 |      @return: list of selected lines numbers (one element or empty)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  ALL_CHANGED = 1
 |  
 |  ALREADY_EXISTS = -3
 |  
 |  CHCOL_DEC = 196608
 |  
 |  CHCOL_DEFHIDDEN = 1048576
 |  
 |  CHCOL_DRAGHINT = 2097152
 |  
 |  CHCOL_EA = 262144
 |  
 |  CHCOL_FNAME = 327680
 |  
 |  CHCOL_FORMAT = 458752
 |  
 |  CHCOL_HEX = 131072
 |  
 |  CHCOL_INODENAME = 4194304
 |  
 |  CHCOL_PATH = 65536
 |  
 |  CHCOL_PLAIN = 0
 |  
 |  CHOOSE_HAVE_DEL = 16
 |  
 |  CHOOSE_HAVE_EDIT = 32
 |  
 |  CHOOSE_HAVE_ENTER = 64
 |  
 |  CHOOSE_HAVE_GETATTR = 4
 |  
 |  CHOOSE_HAVE_GETICON = 2
 |  
 |  CHOOSE_HAVE_INIT = 1
 |  
 |  CHOOSE_HAVE_INS = 8
 |  
 |  CHOOSE_HAVE_ONCLOSE = 512
 |  
 |  CHOOSE_HAVE_REFRESH = 128
 |  
 |  CHOOSE_HAVE_SELECT = 256
 |  
 |  CH_ATTRS = 32
 |  
 |  CH_BUILTIN_MASK = 33030144
 |  
 |  CH_BUILTIN_SHIFT = 19
 |  
 |  CH_CAN_DEL = 512
 |  
 |  CH_CAN_EDIT = 1024
 |  
 |  CH_CAN_INS = 256
 |  
 |  CH_CAN_REFRESH = 2048
 |  
 |  CH_FORCE_DEFAULT = 128
 |  
 |  CH_HAS_DIRTREE = 33554432
 |  
 |  CH_MODAL = 1
 |  
 |  CH_MULTI = 4
 |  
 |  CH_NOBTNS = 16
 |  
 |  CH_NOIDB = 64
 |  
 |  CH_NO_STATUS_BAR = 65536
 |  
 |  CH_QFLT = 4096
 |  
 |  CH_QFTYP_DEFAULT = 0
 |  
 |  CH_QFTYP_FUZZY = 32768
 |  
 |  CH_QFTYP_MASK = 57344
 |  
 |  CH_QFTYP_NORMAL = 8192
 |  
 |  CH_QFTYP_REGEX = 24576
 |  
 |  CH_QFTYP_SHIFT = 13
 |  
 |  CH_QFTYP_WHOLE_WORDS = 16384
 |  
 |  CH_RESTORE = 131072
 |  
 |  EMPTY_CHOOSER = -2
 |  
 |  NOTHING_CHANGED = 0
 |  
 |  NO_ATTR = -4
 |  
 |  NO_SELECTION = -1
 |  
 |  SELECTION_CHANGED = 2
 |  
 |  UI_Hooks_Trampoline = <class 'ida_kernwin.UI_Hooks_Trampoline'>

Help on class CustomIDAMemo in module ida_kernwin:

class CustomIDAMemo(View_Hooks)
 |  #<pycode(py_kernwin_viewhooks)>
 |  # -----------------------------------------------------------------------
 |  #                           CustomIDAMemo
 |  # -----------------------------------------------------------------------
 |  
 |  Method resolution order:
 |      CustomIDAMemo
 |      View_Hooks
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  __init__(self)
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |  
 |  view_click(self, view, ve)
 |  
 |  view_close(self, view, *args)
 |  
 |  view_curpos(self, view, *args)
 |  
 |  view_dblclick(self, view, ve)
 |  
 |  view_deactivated(self, view)
 |  
 |  view_keydown(self, view, key, state)
 |  
 |  view_loc_changed(self, view, now, was)
 |  
 |  view_mouse_moved(self, view, ve)
 |  
 |  view_mouse_over(self, view, ve)
 |  
 |  view_switched(self, view, rt)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args)
 |      A view is being created.
 |      
 |      view_created(self, view)
 |          @param view (C++: TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from View_Hooks:
 |  
 |  __swig_destroy__ = <built-in function delete_View_Hooks>
 |      delete_View_Hooks(self)

Help on class Form in module ida_kernwin:

class Form(__builtin__.object)
 |  # -----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  Add(self, name, ctrl, mkattr=True)
 |      Low level function. Prefer AddControls() to this function.
 |      This function adds one control to the form.
 |      
 |      @param name: Control name
 |      @param ctrl: Control object
 |      @param mkattr: Create control name / control object as a form attribute
 |  
 |  AddControls(self, controls, mkattr=True)
 |      Adds controls from a dictionary.
 |      The dictionary key is the control name and the value is a Form.Control object
 |      @param controls: The control dictionary
 |  
 |  Close(self, close_normally)
 |      Close the form
 |      @param close_normally:
 |                 1: form is closed normally as if the user pressed Enter
 |                 0: form is closed abnormally as if the user pressed Esc
 |      @return: None
 |  
 |  Compile(self)
 |      Compiles a form and returns the form object (self) and the argument list.
 |      The form object will contain object names corresponding to the form elements
 |      
 |      @return: It will raise an exception on failure. Otherwise the return value is ignored
 |  
 |  CompileEx(self, form)
 |      Low level function.
 |      Compiles (parses the form syntax and adds the control) the form string and
 |      returns the argument list to be passed the argument list to ask_form().
 |      
 |      The form controls are wrapped inside curly braces: {ControlName}.
 |      
 |      A special operator can be used to return the index of a given control by its name: {id:ControlName}.
 |      This is useful when you use the STARTITEM form keyword to set the initially focused control.
 |      (note that, technically, the index is not the same as the ID; that's because STARTITEM
 |      uses raw, 0-based indexes rather than control IDs to determine the focused widget.)
 |      
 |      @param form: Compiles the form and returns the arguments needed to be passed to ask_form()
 |  
 |  Compiled(self)
 |      Checks if the form has already been compiled
 |      
 |      @return: Boolean
 |  
 |  EnableField(self, ctrl, enable)
 |      Enable or disable an input field
 |      @return: False - no such control
 |  
 |  Execute(self)
 |      Displays a modal dialog containing the compiled form.
 |      @return: 1 - ok ; 0 - cancel
 |  
 |  FindControlById(self, id)
 |      Finds a control instance given its id
 |  
 |  Free(self)
 |      Frees all resources associated with a compiled form.
 |      Make sure you call this function when you finish using the form.
 |  
 |  GetControlValue(self, ctrl)
 |      Returns the control's value depending on its type
 |      @param ctrl: Form control instance
 |      @return:
 |          - color button, radio controls: integer
 |          - file/dir input, string input and string label: string
 |          - embedded chooser control (0-based indices of selected items): integer list
 |          - for multilinetext control: textctrl_info_t
 |          - dropdown list controls: string (when editable) or index (when readonly)
 |          - None: on failure
 |  
 |  GetFocusedField(self)
 |      Get currently focused input field.
 |      @return: None if no field is selected otherwise the control ID
 |  
 |  MoveField(self, ctrl, x, y, w, h)
 |      Move/resize an input field
 |      
 |      @return: False - no such fiel
 |  
 |  Open(self)
 |      Opens a widget containing the compiled form.
 |  
 |  RefreshField(self, ctrl)
 |      Refresh a field
 |      @return: False - no such control
 |  
 |  SetControlValue(self, ctrl, value)
 |      Set the control's value depending on its type
 |      @param ctrl: Form control instance
 |      @param value:
 |          - embedded chooser: a 0-base indices list to select embedded chooser items
 |          - multilinetext: a textctrl_info_t
 |          - dropdown list: an integer designating the selection index if readonly
 |                           a string designating the edit control value if not readonly
 |      @return: Boolean true on success
 |  
 |  SetFocusedField(self, ctrl)
 |      Set currently focused input field
 |      @return: False - no such control
 |  
 |  ShowField(self, ctrl, show)
 |      Show or hide an input field
 |      @return: False - no such control
 |  
 |  _AddGroup(self, Group, mkattr=True)
 |      Internal function.
 |      This function expands the group item names and creates individual group item controls
 |      
 |      @param Group: The group class (checkbox or radio group class)
 |  
 |  _ChkCompiled(self)
 |  
 |  __getitem__(self, name)
 |      Returns a control object by name
 |  
 |  __init__(self, form, controls)
 |      Contruct a Form class.
 |      This class wraps around ask_form() or open_form() and provides an easier / alternative syntax for describing forms.
 |      The form control names are wrapped inside the opening and closing curly braces and the control themselves are
 |      defined and instantiated via various form controls (subclasses of Form).
 |      
 |      @param form: The form string
 |      @param controls: A dictionary containing the control name as a _key_ and control object as _value_
 |  
 |  _reset(self)
 |      Resets the Form class state variables
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  ControlToFieldTypeIdAndSize(ctrl)
 |      Converts a control object to a tuple containing the field id
 |      and the associated buffer size
 |  
 |  _ParseFormTitle(form)
 |      Parses the form's title from the form text
 |  
 |  create_string_buffer(value, size=None)
 |  
 |  fieldtype_to_ctype(tp, i64=False)
 |      Factory method returning a ctype class corresponding to the field type string
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  ButtonInput = <class 'ida_kernwin.ButtonInput'>
 |      Button control.
 |      A handler along with a 'code' (numeric value) can be associated with the button.
 |      This way one handler can handle many buttons based on the button code (or in other terms id or tag)
 |  
 |  ChkGroupControl = <class 'ida_kernwin.ChkGroupControl'>
 |      Checkbox group control class.
 |      It holds a set of checkbox controls
 |  
 |  ChkGroupItemControl = <class 'ida_kernwin.ChkGroupItemControl'>
 |      Checkbox group item control
 |  
 |  ColorInput = <class 'ida_kernwin.ColorInput'>
 |      Color button input control
 |  
 |  Control = <class 'ida_kernwin.Control'>
 |  
 |  
 |  DirInput = <class 'ida_kernwin.DirInput'>
 |      Directory browsing control
 |  
 |  DropdownListControl = <class 'ida_kernwin.DropdownListControl'>
 |      Dropdown control
 |      This control allows manipulating a dropdown control
 |  
 |  EmbeddedChooserControl = <class 'ida_kernwin.EmbeddedChooserControl'>
 |      Embedded chooser control.
 |      This control links to a Chooser2 control created with the 'embedded=True'
 |  
 |  FT_ADDR = '$'
 |  
 |  FT_ASCII = 'A'
 |  
 |  FT_BIN = 'Y'
 |  
 |  FT_BUTTON = 'B'
 |  
 |  FT_CHAR = 'H'
 |  
 |  FT_CHKGRP = 'C'
 |  
 |  FT_CHKGRP2 = 'c'
 |  
 |  FT_COLOR = 'K'
 |  
 |  FT_DEC = 'D'
 |  
 |  FT_DIR = 'F'
 |  
 |  FT_DROPDOWN_LIST = 'b'
 |  
 |  FT_ECHOOSER = 'E'
 |  
 |  FT_FILE = 'f'
 |  
 |  FT_FORMCHG = '%/'
 |  
 |  FT_HEX = 'N'
 |  
 |  FT_HTML_LABEL = 'h'
 |  
 |  FT_IDENT = 'I'
 |  
 |  FT_INT64 = 'l'
 |  
 |  FT_MULTI_LINE_TEXT = 't'
 |  
 |  FT_OCT = 'O'
 |  
 |  FT_RADGRP = 'R'
 |  
 |  FT_RADGRP2 = 'r'
 |  
 |  FT_RAWHEX = 'M'
 |  
 |  FT_SEG = 'S'
 |  
 |  FT_SHEX = 'n'
 |  
 |  FT_TYPE = 'T'
 |  
 |  FT_UINT64 = 'L'
 |  
 |  FileInput = <class 'ida_kernwin.FileInput'>
 |      File Open/Save input control
 |  
 |  FormChangeCb = <class 'ida_kernwin.FormChangeCb'>
 |      Form change handler.
 |      This can be thought of like a dialog procedure.
 |      Everytime a form action occurs, this handler will be called along with the control id.
 |      The programmer can then call various form actions accordingly:
 |        - EnableField
 |        - ShowField
 |        - MoveField
 |        - GetFieldValue
 |        - etc...
 |      
 |      Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)
 |  
 |  GroupControl = <class 'ida_kernwin.GroupControl'>
 |      Base class for group controls
 |  
 |  GroupItemControl = <class 'ida_kernwin.GroupItemControl'>
 |      Base class for group control items
 |  
 |  InputControl = <class 'ida_kernwin.InputControl'>
 |      Generic form input control.
 |      It could be numeric control, string control, directory/file browsing, etc...
 |  
 |  LabelControl = <class 'ida_kernwin.LabelControl'>
 |      Base class for static label control
 |  
 |  MultiLineTextControl = <class 'ida_kernwin.MultiLineTextControl'>
 |      Multi line text control.
 |      This class inherits from textctrl_info_t. Thus the attributes are also inherited
 |      This control allows manipulating a multilinetext control
 |  
 |  NumericArgument = <class 'ida_kernwin.NumericArgument'>
 |      Argument representing various integer arguments (ushort, uint32, uint64, etc...)
 |      @param tp: One of Form.FT_XXX
 |  
 |  NumericInput = <class 'ida_kernwin.NumericInput'>
 |      A composite class serving as a base numeric input control class
 |  
 |  NumericLabel = <class 'ida_kernwin.NumericLabel'>
 |      Numeric label control
 |  
 |  RadGroupControl = <class 'ida_kernwin.RadGroupControl'>
 |      Radiobox group control class.
 |      It holds a set of radiobox controls
 |  
 |  RadGroupItemControl = <class 'ida_kernwin.RadGroupItemControl'>
 |      Radiobox group item control
 |  
 |  StringArgument = <class 'ida_kernwin.StringArgument'>
 |      Argument representing a character buffer
 |  
 |  StringInput = <class 'ida_kernwin.StringInput'>
 |      Base string input control class.
 |      This class also constructs a StringArgument
 |  
 |  StringLabel = <class 'ida_kernwin.StringLabel'>
 |      String label control
 |  
 |  _FT_USHORT = '_US'

Help on class IDAViewWrapper in module ida_kernwin:

class IDAViewWrapper(CustomIDAMemo)
 |  Deprecated. Use View_Hooks instead.
 |  
 |  Because the lifecycle of an IDAView is not trivial to track (e.g., a user
 |  might close, then re-open the same disassembly view), this wrapper doesn't
 |  bring anything superior to the View_Hooks: quite the contrary, as the
 |  latter is much more generic (and better maps IDA's internal model.)
 |  
 |  Method resolution order:
 |      IDAViewWrapper
 |      CustomIDAMemo
 |      View_Hooks
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  Bind(self)
 |  
 |  Unbind(self)
 |  
 |  __init__(self, title)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from CustomIDAMemo:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |  
 |  view_click(self, view, ve)
 |  
 |  view_close(self, view, *args)
 |  
 |  view_curpos(self, view, *args)
 |  
 |  view_dblclick(self, view, ve)
 |  
 |  view_deactivated(self, view)
 |  
 |  view_keydown(self, view, key, state)
 |  
 |  view_loc_changed(self, view, now, was)
 |  
 |  view_mouse_moved(self, view, ve)
 |  
 |  view_mouse_over(self, view, ve)
 |  
 |  view_switched(self, view, rt)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from CustomIDAMemo:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args)
 |      A view is being created.
 |      
 |      view_created(self, view)
 |          @param view (C++: TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from View_Hooks:
 |  
 |  __swig_destroy__ = <built-in function delete_View_Hooks>
 |      delete_View_Hooks(self)

Help on class PluginForm in module ida_kernwin:

class PluginForm(__builtin__.object)
 |  PluginForm class.
 |  
 |  This form can be used to host additional controls. Please check the PyQt example.
 |  
 |  Methods defined here:
 |  
 |  Close(self, options)
 |      Closes the form.
 |      
 |      @param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)
 |      
 |      @return: None
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  OnClose(self, form)
 |      Called when the plugin form is closed
 |      
 |      @return: None
 |  
 |  OnCreate(self, form)
 |      This event is called when the plugin form is created.
 |      The programmer should populate the form when this event is triggered.
 |      
 |      @return: None
 |  
 |  Show(self, caption, options=0)
 |      Creates the form if not was not created or brings to front if it was already created
 |      
 |      @param caption: The form caption
 |      @param options: One of PluginForm.WOPN_ constants
 |  
 |  __init__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  FormToPyQtWidget = TWidgetToPyQtWidget(tw, ctx=<module '__main__' from 'tools/dumpdoc.py'>)
 |      Convert a TWidget* to a QWidget to be used by PyQt
 |      
 |      @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
 |  
 |  FormToPySideWidget = TWidgetToPySideWidget(tw, ctx=<module '__main__' from 'tools/dumpdoc.py'>)
 |      Use this method to convert a TWidget* to a QWidget to be used by PySide
 |      
 |      @param ctx: Context. Reference to a module that already imported QtWidgets module
 |  
 |  QtWidgetToTWidget(w, ctx=<module '__main__' from 'tools/dumpdoc.py'>)
 |      Convert a QWidget to a TWidget* to be used by IDA
 |      
 |      @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
 |  
 |  TWidgetToPyQtWidget(tw, ctx=<module '__main__' from 'tools/dumpdoc.py'>)
 |      Convert a TWidget* to a QWidget to be used by PyQt
 |      
 |      @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
 |  
 |  TWidgetToPySideWidget(tw, ctx=<module '__main__' from 'tools/dumpdoc.py'>)
 |      Use this method to convert a TWidget* to a QWidget to be used by PySide
 |      
 |      @param ctx: Context. Reference to a module that already imported QtWidgets module
 |  
 |  _ensure_widget_deps(ctx)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  VALID_CAPSULE_NAME = '$valid$'
 |  
 |  WCLS_CLOSE_LATER = 8
 |  
 |  WCLS_DONT_SAVE_SIZE = 4
 |  
 |  WCLS_NO_CONTEXT = 2
 |  
 |  WCLS_SAVE = 1
 |  
 |  WOPN_CENTERED = 32
 |  
 |  WOPN_CREATE_ONLY = {}
 |  
 |  WOPN_DP_BEFORE = 2097152
 |  
 |  WOPN_DP_BOTTOM = 524288
 |  
 |  WOPN_DP_FLOATING = 8388608
 |  
 |  WOPN_DP_INSIDE = 1048576
 |  
 |  WOPN_DP_INSIDE_BEFORE = 3145728
 |  
 |  WOPN_DP_LEFT = 65536
 |  
 |  WOPN_DP_RIGHT = 262144
 |  
 |  WOPN_DP_TAB = 4194304
 |  
 |  WOPN_DP_TAB_BEFORE = 6291456
 |  
 |  WOPN_DP_TOP = 131072
 |  
 |  WOPN_MDI = 1
 |  
 |  WOPN_MENU = 16
 |  
 |  WOPN_ONTOP = 8
 |  
 |  WOPN_PERSIST = 64
 |  
 |  WOPN_RESTORE = 4
 |  
 |  WOPN_TAB = 2

Help on function TWidget__from_ptrval__ in module ida_kernwin:

TWidget__from_ptrval__(*args)
    TWidget__from_ptrval__(ptrval) -> TWidget *
        ptrval: size_t

Help on class UI_Hooks in module ida_kernwin:

class UI_Hooks(__builtin__.object)
 |  Proxy of C++ UI_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> UI_Hooks
 |          _flags: uint32
 |  
 |  __real_database_closed = database_closed(self, *args)
 |      The database has been closed. See also processor_t::closebase, it
 |      occurs earlier. See also ui_initing_database. This is not the same as
 |      IDA exiting. If you need to perform cleanup at the exiting time, use
 |      'qatexit()' .
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  create_desktop_widget(self, *args)
 |      create a widget, to be placed in the widget tree (at desktop-
 |      creation time.)
 |      
 |      create_desktop_widget(self, title, cfg) -> PyObject *
 |          @param title (C++: const char *)
 |          @param cfg (C++: const jobj_t *)
 |  
 |  current_widget_changed(self, *args)
 |      The currently-active TWidget changed.
 |      
 |      current_widget_changed(self, widget, prev_widget)
 |          @param widget (C++: TWidget *)
 |          @param prev_widget (C++: TWidget *)
 |  
 |  database_closed = __wrapper(self, *args)
 |      The database has been closed. See also processor_t::closebase, it
 |      occurs earlier. See also ui_initing_database. This is not the same as
 |      IDA exiting. If you need to perform cleanup at the exiting time, use
 |      'qatexit()' .
 |  
 |  database_inited(self, *args)
 |      database initialization has completed. the kernel is about to run
 |      idc scripts
 |      
 |      database_inited(self, is_new_database, idc_script)
 |          @param is_new_database (C++: int)
 |          @param idc_script: - may be NULL  (C++: const char *)
 |  
 |  debugger_menu_change(self, *args)
 |      debugger menu modification detected
 |      
 |      debugger_menu_change(self, enable)
 |          @param enable: true: debugger menu has been added, or a different
 |                         debugger has been selected false: debugger menu will be
 |                         removed (user switched to "No debugger")  (C++: bool)
 |  
 |  destroying_plugmod(self, *args)
 |      The plugin object is about to be destroyed
 |      
 |      destroying_plugmod(self, plugmod)
 |          @param plugmod (C++: const plugmod_t *)
 |  
 |  destroying_procmod(self, *args)
 |      The processor module is about to be destroyed
 |      
 |      destroying_procmod(self, procmod)
 |          @param procmod (C++: const procmod_t *)
 |  
 |  finish_populating_widget_popup(self, *args)
 |      IDA is about to be done populating the context menu for a widget.
 |      This is your chance to 'attach_action_to_popup()' .
 |      
 |      finish_populating_widget_popup(self, widget, popup_handle, ctx=None)
 |          @param widget (C++: TWidget *)
 |          @param popup_handle (C++: TPopupMenu *)
 |          @param ctx (C++: const action_activation_ctx_t *)
 |  
 |  get_chooser_item_attrs(self, *args)
 |      get item-specific attributes for a chooser. This callback is
 |      generated only after enable_chooser_attrs()
 |      
 |      get_chooser_item_attrs(self, chooser, n, attrs)
 |          @param chooser (C++: const chooser_base_t *)
 |          @param n (C++: size_t)
 |          @param attrs (C++: chooser_item_attrs_t *)
 |  
 |  get_custom_viewer_hint(self, *args)
 |      ui wants to display a hint for a viewer (idaview or custom). If
 |      the REG_HINTS_MARKER sequence is found in the returned hints string,
 |      it will be replaced with the contents of the "regular" hints. If the
 |      SRCDBG_HINTS_MARKER sequence is found in the returned hints string, it
 |      will be replaced with the contents of the source-level debugger-
 |      generated hints. The following keywords might appear at the beginning
 |      of the returned hints: HIGHLIGHT textwhere text will be highlighted
 |      CAPTION captioncaption for the hint widget
 |      
 |      get_custom_viewer_hint(self, viewer, place) -> PyObject *
 |          @param viewer: viewer  (C++: TWidget*)
 |          @param place: current position in the viewer  (C++: place_t *)
 |  
 |  get_ea_hint(self, *args)
 |      ui wants to display a simple hint for an address. Use this event
 |      to generate a custom hint See also more generic 'ui_get_item_hint'
 |      
 |      get_ea_hint(self, ea) -> PyObject *
 |          @param ea (C++: ea_t)
 |  
 |  get_item_hint(self, *args)
 |      ui wants to display multiline hint for an item. See also more
 |      generic 'ui_get_custom_viewer_hint'
 |      
 |      get_item_hint(self, ea, max_lines) -> PyObject *
 |          @param ea: or item id like a structure or enum member  (C++: ea_t)
 |          @param max_lines: maximal number of lines  (C++: int)
 |  
 |  get_lines_rendering_info(self, *args)
 |      get lines rendering information
 |      
 |      get_lines_rendering_info(self, out, widget, info)
 |          @param out (C++: lines_rendering_output_t *)
 |          @param widget (C++: const TWidget *)
 |          @param info (C++: const lines_rendering_input_t *)
 |  
 |  get_widget_config(self, *args)
 |      retrieve the widget configuration (it will be passed back at
 |      ui_create_desktop_widget-, and ui_set_widget_config-time)
 |      
 |      get_widget_config(self, widget, cfg) -> PyObject *
 |          @param widget (C++: const TWidget *)
 |          @param cfg (C++: jobj_t *)
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  idcstart(self, *args)
 |      Start of IDC engine work.
 |  
 |  idcstop(self, *args)
 |      Stop of IDC engine work.
 |  
 |  initing_database(self, *args)
 |      database initialization has started.
 |  
 |  plugin_loaded(self, *args)
 |      The plugin was loaded in memory.
 |      
 |      plugin_loaded(self, plugin_info)
 |          @param plugin_info (C++: const plugin_info_t *)
 |  
 |  plugin_unloading(self, *args)
 |      The plugin is about to be unloaded
 |      
 |      plugin_unloading(self, plugin_info)
 |          @param plugin_info (C++: const plugin_info_t *)
 |  
 |  populating_widget_popup(self, *args)
 |      IDA is populating the context menu for a widget. This is your
 |      chance to 'attach_action_to_popup()' .Have a look at
 |      ui_finish_populating_widget_popup, if you want to augment the context
 |      menu with your own actions after the menu has had a chance to be
 |      properly populated by the owning component or plugin (which typically
 |      does it on ui_populating_widget_popup.)
 |      
 |      populating_widget_popup(self, widget, popup_handle, ctx=None)
 |          @param widget (C++: TWidget *)
 |          @param popup_handle (C++: TPopupMenu *)
 |          @param ctx (C++: const action_activation_ctx_t *)
 |  
 |  postprocess_action(self, *args)
 |      an ida ui action has been handled
 |  
 |  preprocess_action(self, *args)
 |      ida ui is about to handle a user action.
 |      
 |      preprocess_action(self, name) -> int
 |          @param name: ui action name. these names can be looked up in
 |                       ida[tg]ui.cfg  (C++: const char *)
 |          @retval: 0 - ok
 |          @retval: nonzero - a plugin has handled the command
 |  
 |  range(self, *args)
 |      The disassembly range has been changed (\inf{min_ea} ...
 |      \inf{max_ea}). UI should redraw the scrollbars. See also:
 |      'ui_lock_range_refresh'
 |  
 |  ready_to_run(self, *args)
 |      all UI elements have been initialized. Automatic plugins may hook
 |      to this event to perform their tasks.
 |  
 |  resume(self, *args)
 |      Resume the suspended graphical interface. Only the text version.
 |      Interface should respond to it
 |  
 |  saved(self, *args)
 |      The kernel has saved the database. This callback just informs the
 |      interface.
 |  
 |  saving(self, *args)
 |      The kernel is flushing its buffers to the disk. The user interface
 |      should save its state. Parameters: none Returns: none
 |  
 |  screen_ea_changed(self, *args)
 |      The "current address" changed
 |      
 |      screen_ea_changed(self, ea, prev_ea)
 |          @param ea (C++: ea_t)
 |          @param prev_ea (C++: ea_t)
 |  
 |  set_widget_config(self, *args)
 |      set the widget configuration
 |      
 |      set_widget_config(self, widget, cfg)
 |          @param widget (C++: const TWidget *)
 |          @param cfg (C++: const jobj_t *)
 |  
 |  suspend(self, *args)
 |      Suspend graphical interface. Only the text version. Interface
 |      should respond to it.
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  updated_actions(self, *args)
 |      IDA is done updating actions.
 |  
 |  updating_actions(self, *args)
 |      IDA is about to update all actions. If your plugin needs to
 |      perform expensive operations more than once (e.g., once per action it
 |      registers), you should do them only once, right away.
 |      
 |      updating_actions(self, ctx)
 |          @param ctx (C++: action_update_ctx_t *)
 |  
 |  widget_closing(self, *args)
 |      TWidget is about to close. This event precedes ui_widget_invisible.
 |      Use this to perform some possible actions relevant to the lifecycle of
 |      this widget
 |      
 |      widget_closing(self, widget)
 |          @param widget (C++: TWidget *)
 |  
 |  widget_invisible(self, *args)
 |      TWidget is being closed. Use this event to destroy the window controls
 |      
 |      widget_invisible(self, widget)
 |          @param widget (C++: TWidget *)
 |  
 |  widget_visible(self, *args)
 |      TWidget is displayed on the screen. Use this event to populate the
 |      window with controls
 |      
 |      widget_visible(self, widget)
 |          @param widget (C++: TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_UI_Hooks>
 |      delete_UI_Hooks(self)

Help on class View_Hooks in module ida_kernwin:

class View_Hooks(__builtin__.object)
 |  Proxy of C++ View_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0) -> View_Hooks
 |          _flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  hook(self, *args)
 |      hook(self) -> bool
 |  
 |  unhook(self, *args)
 |      unhook(self) -> bool
 |  
 |  view_activated(self, *args)
 |      A view is activated
 |      
 |      view_activated(self, view)
 |          @param view (C++: TWidget *)
 |  
 |  view_click(self, *args)
 |      Click event
 |      
 |      view_click(self, view, event)
 |          @param view (C++: TWidget *)
 |          @param event (C++: const view_mouse_event_t *)
 |  
 |  view_close(self, *args)
 |      View closed
 |      
 |      view_close(self, view)
 |          @param view (C++: TWidget *)
 |  
 |  view_created(self, *args)
 |      A view is being created.
 |      
 |      view_created(self, view)
 |          @param view (C++: TWidget *)
 |  
 |  view_curpos(self, *args)
 |      Cursor position changed
 |      
 |      view_curpos(self, view)
 |          @param view (C++: TWidget *)
 |  
 |  view_dblclick(self, *args)
 |      Double click event
 |      
 |      view_dblclick(self, view, event)
 |          @param view (C++: TWidget *)
 |          @param event (C++: const view_mouse_event_t *)
 |  
 |  view_deactivated(self, *args)
 |      A view is deactivated
 |      
 |      view_deactivated(self, view)
 |          @param view (C++: TWidget *)
 |  
 |  view_keydown(self, *args)
 |      Key down event
 |      
 |      view_keydown(self, view, key, state)
 |          @param view (C++: TWidget *)
 |          @param key (C++: int)
 |          @param state (C++: view_event_state_t)
 |  
 |  view_loc_changed(self, *args)
 |      The location for the view has changed (can be either the 'place_t' ,
 |      the 'renderer_info_t' , or both.)
 |      
 |      view_loc_changed(self, view, now, was)
 |          @param view (C++: TWidget *)
 |          @param now (C++: const lochist_entry_t *)
 |          @param was (C++: const lochist_entry_t *)
 |  
 |  view_mouse_moved(self, *args)
 |      The mouse moved on the view
 |      
 |      view_mouse_moved(self, view, event)
 |          @param view (C++: TWidget *)
 |          @param event (C++: const view_mouse_event_t *)
 |  
 |  view_mouse_over(self, *args)
 |      The user moved the mouse over (or out of) a node or an edge. This is
 |      only relevant in a graph view.
 |      
 |      view_mouse_over(self, view, event)
 |          @param view (C++: TWidget *)
 |          @param event (C++: const view_mouse_event_t *)
 |  
 |  view_switched(self, *args)
 |      A view's renderer has changed.
 |      
 |      view_switched(self, view, rt)
 |          @param view (C++: TWidget *)
 |          @param rt (C++: tcc_renderer_type_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_View_Hooks>
 |      delete_View_Hooks(self)

Help on function __call_form_callable in module ida_kernwin:

__call_form_callable(call, *args)

Help on class __qtimer_t in module ida_kernwin:

class __qtimer_t(__builtin__.object)
 |  Proxy of C++ __qtimer_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qtimer_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete___qtimer_t>
 |      delete___qtimer_t(self)

Help on function _ask_addr in module ida_kernwin:

_ask_addr(*args)
    _ask_addr(addr, format) -> bool
        addr: ea_t *
        format: char const *

Help on function _ask_long in module ida_kernwin:

_ask_long(*args)
    _ask_long(value, format) -> bool
        value: sval_t *
        format: char const *

Help on function _ask_seg in module ida_kernwin:

_ask_seg(*args)
    _ask_seg(sel, format) -> bool
        sel: sel_t *
        format: char const *

Help on function _kludge_force_declare_dirspec_t in module ida_kernwin:

_kludge_force_declare_dirspec_t(*args)
    _kludge_force_declare_dirspec_t(arg1)
        arg1: dirspec_t const *

Help on function _kludge_force_declare_dirtree_t in module ida_kernwin:

_kludge_force_declare_dirtree_t(*args)
    _kludge_force_declare_dirtree_t(arg1)
        arg1: dirtree_t const *

Help on class action_ctx_base_t in module ida_kernwin:

class action_ctx_base_t(__builtin__.object)
 |  Proxy of C++ action_ctx_base_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> action_ctx_base_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _get_form(self, *args)
 |      _get_form(self) -> TWidget *
 |  
 |  _get_form_title(self, *args)
 |      _get_form_title(self) -> qstring
 |  
 |  _get_form_type(self, *args)
 |      _get_form_type(self) -> twidget_type_t
 |  
 |  has_flag(self, *args)
 |      Check if the given flag is set.
 |      
 |      has_flag(self, flag) -> bool
 |          @param flag (C++: uint32)
 |  
 |  reset(self, *args)
 |      Invalidate all context info.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  action
 |      action_ctx_base_t_action_get(self) -> char const *
 |  
 |  chooser_selection
 |      action_ctx_base_t_chooser_selection_get(self) -> sizevec_t *
 |  
 |  cur_ea
 |      action_ctx_base_t_cur_ea_get(self) -> ea_t
 |  
 |  cur_enum
 |      action_ctx_base_t_cur_enum_get(self) -> enum_t
 |  
 |  cur_enum_member
 |      action_ctx_base_t_cur_enum_member_get(self) -> const_t
 |  
 |  cur_extracted_ea
 |      action_ctx_base_t_cur_value_get(self) -> uval_t
 |  
 |  cur_fchunk
 |      action_ctx_base_t_cur_fchunk_get(self) -> func_t *
 |  
 |  cur_flags
 |      action_ctx_base_t_cur_flags_get(self) -> uint32
 |  
 |  cur_func
 |      action_ctx_base_t_cur_func_get(self) -> func_t *
 |  
 |  cur_seg
 |      action_ctx_base_t_cur_seg_get(self) -> segment_t *
 |  
 |  cur_strmem
 |      action_ctx_base_t_cur_strmem_get(self) -> member_t *
 |  
 |  cur_struc
 |      action_ctx_base_t_cur_struc_get(self) -> struc_t *
 |  
 |  cur_value
 |      action_ctx_base_t_cur_value_get(self) -> uval_t
 |  
 |  dirtree_selection
 |      action_ctx_base_t_dirtree_selection_get(self) -> dirtree_selection_t *
 |  
 |  focus
 |      action_ctx_base_t_focus_get(self) -> TWidget *
 |  
 |  form
 |      _get_form(self) -> TWidget *
 |  
 |  form_title
 |      _get_form_title(self) -> qstring
 |  
 |  form_type
 |      _get_form_type(self) -> twidget_type_t
 |  
 |  graph_selection
 |      action_ctx_base_t_graph_selection_get(self) -> screen_graph_selection_t *
 |  
 |  regname
 |      action_ctx_base_t_regname_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  widget
 |      action_ctx_base_t_widget_get(self) -> TWidget *
 |  
 |  widget_title
 |      action_ctx_base_t_widget_title_get(self) -> qstring *
 |  
 |  widget_type
 |      action_ctx_base_t_widget_type_get(self) -> twidget_type_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_action_ctx_base_t>
 |      delete_action_ctx_base_t(self)

Help on class action_desc_t in module ida_kernwin:

class action_desc_t(__builtin__.object)
 |  Proxy of C++ action_desc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, name, label, handler, shortcut=None, tooltip=None, icon=-1, flags=0) -> action_desc_t
 |          name: char const *
 |          label: char const *
 |          handler: PyObject *
 |          shortcut: char const *
 |          tooltip: char const *
 |          icon: int
 |          flags: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      action_desc_t_cb_get(self) -> int
 |  
 |  flags
 |      action_desc_t_flags_get(self) -> int
 |  
 |  icon
 |      action_desc_t_icon_get(self) -> int
 |  
 |  label
 |      action_desc_t_label_get(self) -> char const *
 |  
 |  name
 |      action_desc_t_name_get(self) -> char const *
 |  
 |  owner
 |      action_desc_t_owner_get(self) -> void const *
 |  
 |  shortcut
 |      action_desc_t_shortcut_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  tooltip
 |      action_desc_t_tooltip_get(self) -> char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_action_desc_t>
 |      delete_action_desc_t(self)

Help on class action_handler_t in module ida_kernwin:

class action_handler_t(__builtin__.object)
 |  # ----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |  
 |  activate(self, ctx)
 |  
 |  update(self, ctx)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function activate_widget in module ida_kernwin:

activate_widget(*args)
    Activate widget (only gui version) ( 'ui_activate_widget' ).
    
    activate_widget(widget, take_focus)
        @param widget: existing widget to display (C++: TWidget *)
        @param take_focus: give focus to given widget (C++: bool)

Help on function add_hotkey in module ida_kernwin:

add_hotkey(*args)
    add_hotkey(hotkey, pyfunc) -> PyObject *
    Associates a function call with a hotkey.
    Callable pyfunc will be called each time the hotkey is pressed
    
    @param hotkey: The hotkey
    @param pyfunc: Callable
    
    @return: Context object on success or None on failure.

Help on function add_idc_hotkey in module ida_kernwin:

add_idc_hotkey(*args)
    Add hotkey for IDC function ( 'ui_add_idckey' ).
    
    add_idc_hotkey(hotkey, idcfunc) -> int
        @param hotkey: hotkey name (C++: const char *)
        @param idcfunc: IDC function name (C++: const char *)
        @return: IDC hotkey error codes

Help on function add_spaces in module ida_kernwin:

add_spaces(*args)
    Add space characters to the colored string so that its length will be
    at least 'len' characters. Don't trim the string if it is longer than
    'len'.
    
    add_spaces(s, len) -> PyObject *
        s: char const *
        @param len: the desired length of the string (C++: ssize_t)
        @return: pointer to the end of input string

Help on function addon_count in module ida_kernwin:

addon_count(*args)
    Get number of installed addons.

Help on class addon_info_t in module ida_kernwin:

class addon_info_t(__builtin__.object)
 |  Proxy of C++ addon_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> addon_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      addon_info_t_cb_get(self) -> size_t
 |  
 |  custom_data
 |      addon_info_t_custom_data_get(self) -> void const *
 |  
 |  custom_size
 |      addon_info_t_custom_size_get(self) -> size_t
 |  
 |  freeform
 |      addon_info_t_freeform_get(self) -> char const *
 |  
 |  id
 |      addon_info_t_id_get(self) -> char const *
 |  
 |  name
 |      addon_info_t_name_get(self) -> char const *
 |  
 |  producer
 |      addon_info_t_producer_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  url
 |      addon_info_t_url_get(self) -> char const *
 |  
 |  version
 |      addon_info_t_version_get(self) -> char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_addon_info_t>
 |      delete_addon_info_t(self)

Help on function analyzer_options in module ida_kernwin:

analyzer_options(*args)
    Allow the user to set analyzer options. (show a dialog box) (
    'ui_analyzer_options' )

Help on function ask_addr in module ida_kernwin:

ask_addr(defval, format)
    # ----------------------------------------------------------------------

Help on function ask_buttons in module ida_kernwin:

ask_buttons(*args)
    Display a dialog box and get choice from maximum three possibilities (
    'ui_ask_buttons' ).for all buttons:use "" or NULL to take the default
    name for the button.use 'format' to hide the cancel button
    
    ask_buttons(Yes, No, Cancel, deflt, format) -> int
        @param Yes: text for the first button (C++: const char *)
        @param No: text for the second button (C++: const char *)
        @param Cancel: text for the third button (C++: const char *)
        @param deflt: default choice: one of  Button IDs (C++: int)
        @param format: printf-style format string for question. It may have
                       some prefixes, see below. (C++: const char *)
        @return: one of  Button IDs  specifying the selected button (Esc key
                 returns Cancel/3rd button value)

Help on function ask_file in module ida_kernwin:

ask_file(*args)
    ask_file(for_saving, defval, format) -> char *
        @param for_saving (C++: bool)
        @param defval (C++: const char *)
        @param format (C++: const char *)

Help on function ask_for_feedback in module ida_kernwin:

ask_for_feedback(*args)
    Show a message box asking to send the input file tosupport@hex-
    rays.com.
    
    ask_for_feedback(format)
        @param format: the reason why the input file is bad (C++: const char
                       *)

Help on function ask_form in module ida_kernwin:

ask_form(*args)

Help on function ask_ident in module ida_kernwin:

ask_ident(defval, format)
    # ----------------------------------------------------------------------

Help on function ask_long in module ida_kernwin:

ask_long(defval, format)
    # ----------------------------------------------------------------------

Help on function ask_seg in module ida_kernwin:

ask_seg(defval, format)
    # ----------------------------------------------------------------------

Help on function ask_str in module ida_kernwin:

ask_str(*args)
    ask_str(defval, hist, prompt) -> PyObject *
    Asks for a long text
    
    @param hist:   history id
    @param defval: The default value
    @param prompt: The prompt value
    @return: None or the entered string

Help on function ask_text in module ida_kernwin:

ask_text(*args)
    ask_text(max_size, defval, prompt) -> PyObject *
    Asks for a long text
    
    @param max_size: Maximum text length, 0 for unlimited
    @param defval: The default value
    @param prompt: The prompt value
    @return: None or the entered string

Help on function ask_yn in module ida_kernwin:

ask_yn(*args)
    Display a dialog box and get choice from "Yes", "No", "Cancel".
    
    ask_yn(deflt, format) -> int
        @param deflt: default choice: one of  Button IDs (C++: int)
        @param format: The question in printf() style format (C++: const char
                       *)
        @return: the selected button (one of  Button IDs ). Esc key returns
                 ASKBTN_CANCEL .

Help on function attach_action_to_menu in module ida_kernwin:

attach_action_to_menu(*args)
    Attach a previously-registered action to the menu (
    'ui_attach_action_to_menu' ).You should not change top level menu, or
    the Edit,Plugins submenus If you want to modify the debugger menu, do
    it at the ui_debugger_menu_change event (ida might destroy your menu
    item if you do it elsewhere).
    
    attach_action_to_menu(menupath, name, flags) -> bool
        @param menupath: path to the menu item after or before which the
                         insertion will take place.      Example:
                         Debug/StartProcess   Whitespace, punctuation are
                         ignored.   It is allowed to specify only the prefix
                         of the menu item.   Comparison is case insensitive.
                         menupath may start with the following prefixes:   [S]
                         - modify the main menu of the structure window   [E]
                         - modify the main menu of the enum window (C++: const
                         char *)
        @param name: the action name (C++: const char *)
        @param flags: a combination of  Set menu flags , to determine menu
                      item position (C++: int)
        @return: success

Help on function attach_action_to_popup in module ida_kernwin:

attach_action_to_popup(*args)
    Insert a previously-registered action into the widget's popup menu (
    'ui_attach_action_to_popup' ). This function has two "modes": 'single-
    shot', and 'permanent'.
    
    attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0) -> bool
        @param widget: target widget (C++: TWidget *)
        @param popup_handle: target popup menu   if non-NULL, the action is
                             added to this popup menu invocation (i.e.,
                             'single-shot')   if NULL, the action is added to
                             a list of actions that should always be present
                             in context menus for this widget (i.e.,
                             'permanent'.) (C++: TPopupMenu *)
        @param name: action name (C++: const char *)
        @param popuppath: can be NULL (C++: const char *)
        @param flags: a combination of SETMENU_ flags (see  Set menu flags )
                      (C++: int)
        @return: success

Help on function attach_action_to_toolbar in module ida_kernwin:

attach_action_to_toolbar(*args)
    Attach an action to an existing toolbar (
    'ui_attach_action_to_toolbar' ).
    
    attach_action_to_toolbar(toolbar_name, name) -> bool
        @param toolbar_name: the name of the toolbar (C++: const char *)
        @param name: the action name (C++: const char *)
        @return: success

Help on function attach_dynamic_action_to_popup in module ida_kernwin:

attach_dynamic_action_to_popup(*args)
    Create & insert an action into the widget's popup menu (
    'ui_attach_dynamic_action_to_popup' ). 'action_desc_t::handler' for
    'desc' must be instantiated using 'new', as it will be 'delete'd when
    the action is unregistered.
    
    attach_dynamic_action_to_popup(widget, popup_handle, desc, popuppath=None, flags=0) -> bool
        @param widget: target widget (C++: TWidget *)
        @param popup_handle: target popup (C++: TPopupMenu *)
        @param desc: created with  DYNACTION_DESC_LITERAL (C++: const
                     action_desc_t  &)
        @param popuppath: can be NULL (C++: const char *)
        @param flags: a combination of SETMENU_ constants (see  Set menu flags
                      ) (C++: int)
        @return: success

Help on function banner in module ida_kernwin:

banner(*args)
    Show a banner dialog box ( 'ui_banner' ).
    
    banner(wait) -> bool
        @param wait: time to wait before closing (C++: int)
        @retval: 1 - ok
        @retval: 0 - esc was pressed

Help on function beep in module ida_kernwin:

beep(*args)
    Issue a beeping sound ( 'ui_beep' ).
    
    beep(beep_type=beep_default)
        @param beep_type: beep_t (C++: beep_t)

Help on function call_nav_colorizer in module ida_kernwin:

call_nav_colorizer(*args)
    call_nav_colorizer(dict, ea, nbytes) -> uint32
    To be used with the IDA-provided colorizer, that is
    returned as result of the first call to set_nav_colorizer().

Help on function cancel_exec_request in module ida_kernwin:

cancel_exec_request(*args)
    Try to cancel an asynchronous exec request ( 'ui_cancel_exec_request'
    ).
    
    cancel_exec_request(req_id) -> bool
        @param req_id: request id (C++: int)
        @retval: true - successfully canceled
        @retval: false - request has already been processed.

Help on function cancel_thread_exec_requests in module ida_kernwin:

cancel_thread_exec_requests(*args)
    Try to cancel asynchronous exec requests created by the specified
    thread.
    
    cancel_thread_exec_requests(tid) -> int
        @param tid: thread id (C++: qthread_t)
        @return: number of the canceled requests.

Help on function choose_activate in module ida_kernwin:

choose_activate(*args)
    choose_activate(_self)
        self: PyObject *

Help on function choose_choose in module ida_kernwin:

choose_choose(*args)
    choose_choose(_self) -> PyObject *
        self: PyObject *

Help on function choose_close in module ida_kernwin:

choose_close(*args)
    choose_close(_self)
        self: PyObject *

Help on function choose_create_embedded_chobj in module ida_kernwin:

choose_create_embedded_chobj(*args)
    choose_create_embedded_chobj(_self) -> PyObject *
        self: PyObject *

Help on function choose_entry in module ida_kernwin:

choose_entry(*args)
    Choose an entry point ( 'ui_choose' , 'chtype_entry' ).
    
    choose_entry(title) -> ea_t
        @param title: chooser title (C++: const char *)
        @return: ea of selected entry point,  BADADDR  if none selected

Help on function choose_enum in module ida_kernwin:

choose_enum(*args)
    Choose an enum ( 'ui_choose' , 'chtype_enum' ).
    
    choose_enum(title, default_id) -> enum_t
        @param title: chooser title (C++: const char *)
        @param default_id: id of enum to select by default (C++: enum_t)
        @return: enum id of selected enum,  BADNODE  if none selected

Help on function choose_enum_by_value in module ida_kernwin:

choose_enum_by_value(*args)
    Choose an enum, restricted by value & size ( 'ui_choose' ,
    'chtype_enum_by_value_and_size' ). If the given value cannot be found
    initially, this function will ask if the user would like to import a
    standard enum.
    
    choose_enum_by_value(title, default_id, value, nbytes) -> enum_t
        @param title: chooser title (C++: const char *)
        @param default_id: id of enum to select by default (C++: enum_t)
        @param value: value to search for (C++: uint64)
        @param nbytes: size of value (C++: int)
        @return: enum id of selected (or imported) enum,  BADNODE  if none was
                 found

Help on function choose_find in module ida_kernwin:

choose_find(*args)
    choose_find(title) -> PyObject *
        title: char const *

Help on function choose_func in module ida_kernwin:

choose_func(*args)
    Choose a function ( 'ui_choose' , 'chtype_func' ).
    
    choose_func(title, default_ea) -> func_t *
        @param title: chooser title (C++: const char *)
        @param default_ea: ea of function to select by default (C++: ea_t)
        @return: pointer to function that was selected, NULL if none selected

Help on function choose_get_widget in module ida_kernwin:

choose_get_widget(*args)
    choose_get_widget(_self) -> TWidget *
        self: PyObject *

Help on function choose_idasgn in module ida_kernwin:

choose_idasgn(*args)
    choose_idasgn() -> PyObject *
    Opens the signature chooser
    
    @return: None or the selected signature name

Help on function choose_name in module ida_kernwin:

choose_name(*args)
    Choose a name ( 'ui_choose' , 'chtype_name' ).
    
    choose_name(title) -> ea_t
        @param title: chooser title (C++: const char *)
        @return: ea of selected name,  BADADDR  if none selected

Help on function choose_refresh in module ida_kernwin:

choose_refresh(*args)
    choose_refresh(_self)
        self: PyObject *

Help on function choose_segm in module ida_kernwin:

choose_segm(*args)
    Choose a segment ( 'ui_choose' , 'chtype_segm' ).
    
    choose_segm(title, default_ea) -> segment_t *
        @param title: chooser title (C++: const char *)
        @param default_ea: ea of segment to select by default (C++: ea_t)
        @return: pointer to segment that was selected, NULL if none selected

Help on function choose_srcp in module ida_kernwin:

choose_srcp(*args)
    Choose a segment register change point ( 'ui_choose' , 'chtype_srcp'
    ).
    
    choose_srcp(title) -> sreg_range_t *
        @param title: chooser title (C++: const char *)
        @return: pointer to segment register range of selected change point,
                 NULL if none selected

Help on function choose_stkvar_xref in module ida_kernwin:

choose_stkvar_xref(*args)
    Choose an xref to a stack variable ( 'ui_choose' , 'chtype_name' ).
    
    choose_stkvar_xref(pfn, mptr) -> ea_t
        @param pfn: function (C++: func_t  *)
        @param mptr: variable (C++: member_t  *)
        @return: ea of the selected xref, BADADDR if none selected

Help on function choose_struc in module ida_kernwin:

choose_struc(*args)
    Choose a structure ( 'ui_choose' , 'chtype_segm' ).
    
    choose_struc(title) -> struc_t *
        @param title: chooser title; (C++: const char *)
        @return: pointer to structure that was selected, NULL if none selected

Help on function choose_til in module ida_kernwin:

choose_til(*args)
    Choose a type library ( 'ui_choose' , 'chtype_idatil' ).

Help on function choose_xref in module ida_kernwin:

choose_xref(*args)
    Choose an xref to an address ( 'ui_choose' , 'chtype_xref' ).
    
    choose_xref(to) -> ea_t
        @param to: referenced address (C++: ea_t)
        @return: ea of selected xref, BADADDR if none selected

Help on class chooser_item_attrs_t in module ida_kernwin:

class chooser_item_attrs_t(__builtin__.object)
 |  Proxy of C++ chooser_item_attrs_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> chooser_item_attrs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  reset(self, *args)
 |      reset(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  color
 |      chooser_item_attrs_t_color_get(self) -> bgcolor_t
 |  
 |  flags
 |      chooser_item_attrs_t_flags_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_chooser_item_attrs_t>
 |      delete_chooser_item_attrs_t(self)

Help on function clear_refresh_request in module ida_kernwin:

clear_refresh_request(*args)
    clear_refresh_request(mask)
        @param mask (C++: uint64)

Help on class cli_t in module ida_kernwin:

class cli_t(ida_idaapi.pyidc_opaque_object_t)
 |  cli_t wrapper class.
 |  
 |  This class allows you to implement your own command line interface handlers.
 |  
 |  Method resolution order:
 |      cli_t
 |      ida_idaapi.pyidc_opaque_object_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  OnCompleteLine(self, prefix, n, line, prefix_start)
 |      The user pressed Tab. Find a completion number N for prefix PREFIX
 |      
 |      This callback is optional.
 |      
 |      @param prefix: Line prefix at prefix_start (string)
 |      @param n: completion number (int)
 |      @param line: the current line (string)
 |      @param prefix_start: the index where PREFIX starts in LINE (int)
 |      
 |      @return: None if no completion could be generated otherwise a String with the completion suggestion
 |  
 |  OnExecuteLine(self, line)
 |      The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.
 |      
 |      This callback is mandatory.
 |      
 |      @param line: typed line(s)
 |      @return Boolean: True-executed line, False-ask for more lines
 |  
 |  OnKeydown(self, line, x, sellen, vkey, shift)
 |      A keyboard key has been pressed
 |      This is a generic callback and the CLI is free to do whatever it wants.
 |      
 |      This callback is optional.
 |      
 |      @param line: current input line
 |      @param x: current x coordinate of the cursor
 |      @param sellen: current selection length (usually 0)
 |      @param vkey: virtual key code. if the key has been handled, it should be returned as zero
 |      @param shift: shift state
 |      
 |      @return:
 |          None - Nothing was changed
 |          tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
 |          It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)
 |  
 |  __del__(self)
 |  
 |  __init__(self)
 |  
 |  register(self, flags=0, sname=None, lname=None, hint=None)
 |      Registers the CLI.
 |      
 |      @param flags: Feature bits. No bits are defined yet, must be 0
 |      @param sname: Short name (displayed on the button)
 |      @param lname: Long name (displayed in the menu)
 |      @param hint:  Hint for the input line
 |      
 |      @return Boolean: True-Success, False-Failed
 |  
 |  unregister(self)
 |      Unregisters the CLI (if it was registered)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on function close_chooser in module ida_kernwin:

close_chooser(*args)
    Close a non-modal chooser ( 'ui_close_chooser' ).
    
    close_chooser(title) -> bool
        @param title: window title of chooser to close (C++: const char *)
        @return: success

Help on function close_widget in module ida_kernwin:

close_widget(*args)
    Close widget ( 'ui_close_widget' , only gui version).
    
    close_widget(widget, options)
        @param widget: pointer to the widget to close (C++: TWidget *)
        @param options: Form close flags (C++: int)

Help on function clr_cancelled in module ida_kernwin:

clr_cancelled(*args)
    Clear "Cancelled" flag ( 'ui_clr_cancelled' )

Help on function create_code_viewer in module ida_kernwin:

create_code_viewer(*args)
    Create a code viewer ( 'ui_create_code_viewer' ). A code viewer
    contains on the left side a widget representing the line numbers, and
    on the right side, the child widget passed as parameter. It will
    inherit its title from the child widget.
    
    create_code_viewer(custview, flags=0, parent=None) -> TWidget *
        @param custview: the custom view to be added (C++: TWidget *)
        @param flags: Code viewer flags (C++: int)
        @param parent: widget to contain the new code viewer (C++: TWidget *)

Help on function create_empty_widget in module ida_kernwin:

create_empty_widget(*args)
    Create an empty widget, serving as a container for custom user widgets
    
    create_empty_widget(title, icon=-1) -> TWidget *
        @param title (C++: const char *)
        @param icon (C++: int)

Help on function create_menu in module ida_kernwin:

create_menu(*args)
    Create a menu with the given name, label and optional position, either
    in the menubar, or as a submenu. If 'menupath' is non-NULL, it
    provides information about where the menu should be positioned. First,
    IDA will try and resolve the corresponding menu by its name. If such
    an existing menu is found and is present in the menubar, then the new
    menu will be inserted in the menubar before it. Otherwise, IDA will
    try to resolve 'menupath' as it would for 'attach_action_to_menu()'
    and, if found, add the new menu like so:
    
    // The new 'My menu' submenu will appear in the 'Comments' submenu
    // before the 'Enter comment..." command
    create_menu("(...)", "My menu", "Edit/Comments/Enter comment...");
    
    or
    
    // The new 'My menu' submenu will appear at the end of the
    // 'Comments' submenu.
    create_menu("(...)", "My menu", "Edit/Comments/");
    
    If the above fails, the new menu will be appended to the menubar.
    
    create_menu(name, label, menupath=None) -> bool
        @param name: name of menu (must be unique) (C++: const char *)
        @param label: label of menu (C++: const char *)
        @param menupath: where should the menu be inserted (C++: const char *)
        @return: success

Help on function create_toolbar in module ida_kernwin:

create_toolbar(*args)
    Create a toolbar with the given name, label and optional position
    
    create_toolbar(name, label, before=None, flags=0) -> bool
        @param name: name of toolbar (must be unique) (C++: const char *)
        @param label: label of toolbar (C++: const char *)
        @param before: if non-NULL, the toolbar before which the new toolbar
                       will be inserted (C++: const char *)
        @param flags: a combination of  create toolbar flags , to determine
                      toolbar position (C++: int)
        @return: success

Help on function custom_viewer_jump in module ida_kernwin:

custom_viewer_jump(*args)
    Append 'loc' to the viewer's history, and cause the viewer to display
    it.
    
    custom_viewer_jump(v, loc, flags=0) -> bool
        @param v: (TWidget *) (C++: TWidget *)
        @param loc: (const  lochist_entry_t  &) (C++: const  lochist_entry_t
                    &)
        @param flags: (uint32) or'ed combination of CVNF_* values (C++:
                      uint32)
        @return: success

Help on function del_hotkey in module ida_kernwin:

del_hotkey(*args)
    del_hotkey(pyctx) -> bool
    Deletes a previously registered function hotkey
    
    @param ctx: Hotkey context previously returned by add_hotkey()
    
    @return: Boolean.

Help on function del_idc_hotkey in module ida_kernwin:

del_idc_hotkey(*args)
    Delete IDC function hotkey ( 'ui_del_idckey' ).
    
    del_idc_hotkey(hotkey) -> bool
        @param hotkey: hotkey name (C++: const char *)
        @retval: 1 - ok
        @retval: 0 - failed

Help on function delete_menu in module ida_kernwin:

delete_menu(*args)
    Delete an existing menu
    
    delete_menu(name) -> bool
        @param name: name of menu (C++: const char *)
        @return: success

Help on function delete_toolbar in module ida_kernwin:

delete_toolbar(*args)
    Delete an existing toolbar
    
    delete_toolbar(name) -> bool
        @param name: name of toolbar (C++: const char *)
        @return: success

Help on function detach_action_from_menu in module ida_kernwin:

detach_action_from_menu(*args)
    Detach an action from the menu ( 'ui_detach_action_from_menu' ).
    
    detach_action_from_menu(menupath, name) -> bool
        @param menupath: path to the menu item (C++: const char *)
        @param name: the action name (C++: const char *)
        @return: success

Help on function detach_action_from_popup in module ida_kernwin:

detach_action_from_popup(*args)
    Remove a previously-registered action, from the list of 'permanent'
    context menu actions for this widget ( 'ui_detach_action_from_popup'
    ). This only makes sense if the action has been added to 'widget's
    list of permanent popup actions by calling attach_action_to_popup in
    'permanent' mode.
    
    detach_action_from_popup(widget, name) -> bool
        @param widget: target widget (C++: TWidget *)
        @param name: action name (C++: const char *)

Help on function detach_action_from_toolbar in module ida_kernwin:

detach_action_from_toolbar(*args)
    Detach an action from the toolbar ( 'ui_detach_action_from_toolbar' ).
    
    detach_action_from_toolbar(toolbar_name, name) -> bool
        @param toolbar_name: the name of the toolbar (C++: const char *)
        @param name: the action name (C++: const char *)
        @return: success

Help on class disabled_script_timeout_t in module ida_kernwin:

class disabled_script_timeout_t(__builtin__.object)
 |  Methods defined here:
 |  
 |  __enter__(self)
 |  
 |  __exit__(self, type, value, tb)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class disasm_line_t in module ida_kernwin:

class disasm_line_t(__builtin__.object)
 |  Proxy of C++ disasm_line_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> disasm_line_t
 |          other: disasm_line_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  at
 |      disasm_line_t_at_get(self) -> place_t
 |  
 |  bg_color
 |      disasm_line_t_bg_color_get(self) -> bgcolor_t
 |  
 |  is_default
 |      disasm_line_t_is_default_get(self) -> bool
 |  
 |  line
 |      disasm_line_t_line_get(self) -> qstring *
 |  
 |  prefix_color
 |      disasm_line_t_prefix_color_get(self) -> color_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_disasm_line_t>
 |      delete_disasm_line_t(self)

Help on class disasm_text_t in module ida_kernwin:

class disasm_text_t(__builtin__.object)
 |  Proxy of C++ qvector< disasm_line_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> disasm_line_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> disasm_text_t
 |          x: qvector< disasm_line_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: disasm_line_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> disasm_line_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> disasm_line_t
 |      begin(self) -> disasm_line_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> disasm_line_t
 |      end(self) -> disasm_line_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> disasm_line_t
 |          it: qvector< disasm_line_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> disasm_line_t
 |          first: qvector< disasm_line_t >::iterator
 |          last: qvector< disasm_line_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> disasm_line_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=disasm_line_t())
 |          x: disasm_line_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: disasm_line_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> disasm_line_t
 |          it: qvector< disasm_line_t >::iterator
 |          x: disasm_line_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: disasm_line_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: disasm_line_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< disasm_line_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_disasm_text_t>
 |      delete_disasm_text_t(self)

Help on function display_copyright_warning in module ida_kernwin:

display_copyright_warning(*args)
    Display copyright warning ( 'ui_copywarn' ).

Help on function display_widget in module ida_kernwin:

display_widget(*args)
    Display a widget, dock it if not done before
    
    display_widget(widget, options, dest_ctrl=None)
        @param widget: widget to display (C++: TWidget *)
        @param options: Widget open flags (C++: uint32)
        @param dest_ctrl: where to dock: if NULL or invalid then use the
                          active docker if there is not create a new tab
                          relative to current active tab (C++: const char *)

Help on function ea2str in module ida_kernwin:

ea2str(*args)
    Convert linear address to UTF-8 string.
    
    ea2str(ea) -> str
        @param ea (C++: ea_t)

Help on function ea_viewer_history_push_and_jump in module ida_kernwin:

ea_viewer_history_push_and_jump(*args)
    Push current location in the history and jump to the given location (
    'ui_ea_viewer_history_push_and_jump' ). This will jump in the given ea
    viewer and also in other synchronized views.
    
    ea_viewer_history_push_and_jump(v, ea, x, y, lnnum) -> bool
        @param v: ea viewer (C++: TWidget *)
        @param ea: jump destination (C++: ea_t)
        @param x: coords on screen (C++: int)
        @param y: coords on screen (C++: int)
        @param lnnum: desired line number of given address (C++: int)

Help on function enable_chooser_item_attrs in module ida_kernwin:

enable_chooser_item_attrs(*args)
    Enable item-specific attributes for chooser items (
    'ui_enable_chooser_item_attrs' ). For example: color list items
    differently depending on a criterium.If enabled, the chooser will
    generate ui_get_chooser_item_attrsevents that can be intercepted by a
    plugin to modify the item attributes.This event is generated only in
    the GUI version of IDA.Specifying 'CH_ATTRS' bit at the chooser
    creation time has the same effect.
    
    enable_chooser_item_attrs(chooser_caption, enable) -> bool
        @param chooser_caption (C++: const char *)
        @param enable (C++: bool)
        @return: success

Help on class enumplace_t in module ida_kernwin:

class enumplace_t(place_t)
 |  Proxy of C++ enumplace_t class.
 |  
 |  Method resolution order:
 |      enumplace_t
 |      place_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bmask
 |      enumplace_t_bmask_get(self) -> bmask_t
 |  
 |  idx
 |      enumplace_t_idx_get(self) -> size_t
 |  
 |  serial
 |      enumplace_t_serial_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      enumplace_t_value_get(self) -> uval_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_enumplace_t>
 |      delete_enumplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args)
 |      _print(self, out_buf, ud)
 |          out_buf: qstring *
 |          ud: void *
 |  
 |  adjust(self, *args)
 |      Adjust the current location to point to a displayable object. This
 |      function validates the location and makes sure that it points to an
 |      existing object. For example, if the location points to the middle of
 |      an instruction, it will be adjusted to point to the beginning of the
 |      instruction.
 |      
 |      adjust(self, ud)
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |  
 |  beginning(self, *args)
 |      Are we at the first displayable object?.
 |      
 |      beginning(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: true if the current location points to the first displayable
 |                   object
 |  
 |  clone(self, *args)
 |      Clone the location.
 |  
 |  compare(self, *args)
 |      Deprecated. Please consider compare2(const place_t *, void *) instead.
 |      
 |      compare(self, t2) -> int
 |          @param t2 (C++: const  place_t  *)
 |  
 |  compare2(self, *args)
 |      Compare two locations except line numbers (lnnum). This function is
 |      used to organize loops. For example, if the user has selected an
 |      range, its boundaries are remembered as location objects. Any
 |      operation within the selection will have the following look: for (
 |      loc=starting_location; loc < ending_location; loc.next() ) In this
 |      loop, the comparison function is used.
 |      
 |      compare2(self, t2, arg3) -> int
 |          @param t2: the place to compare this one to. (C++: const  place_t  *)
 |          arg3: void *
 |          @retval: -1 - if the current location is less than 't2'
 |          @retval: 0 - if the current location is equal to than 't2'
 |          @retval: 1 - if the current location is greater than 't2'
 |  
 |  copyfrom(self, *args)
 |      Copy the specified location object to the current object.
 |      
 |      copyfrom(self, _from)
 |          @param _from (C++: const  place_t  *)
 |  
 |  deserialize(self, *args)
 |      De-serialize into this instance. 'pptr' should be incremented by as
 |      many bytes as de-serialization consumed.
 |      
 |      deserialize(self, _in) -> bool
 |          in: bytevec_t const &
 |          @return: whether de-serialization was successful
 |  
 |  ending(self, *args)
 |      Are we at the last displayable object?.
 |      
 |      ending(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: true if the current location points to the last displayable
 |                   object
 |  
 |  enter(self, *args)
 |      Visit this place, possibly 'unhiding' a section of text. If entering
 |      that place required some expanding, a 'place_t' should be returned
 |      that represents that section, plus some flags for later use by '
 |      'leave()' '.
 |      
 |      enter(self, arg2) -> place_t
 |          arg2: uint32 *
 |          @return: a  place_t  corresponding to the beginning of the section of
 |                   text that had to be expanded. That  place_t 's  leave()  will
 |                   be called with the flags contained in 'out_flags' when the
 |                   user navigates away from it.
 |  
 |  generate(self, *args)
 |      Generate text lines for the current location.
 |      
 |      generate(self, ud, maxsize) -> PyObject *
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @param maxsize: the maximum number of lines to generate (C++: int)
 |          @return: number of generated lines
 |  
 |  id(self, *args)
 |      Get the place's ID (i.e., the value returned by
 |      'register_place_class()' )
 |  
 |  leave(self, *args)
 |      Leave this place, possibly 'hiding' a section of text that was
 |      previously expanded (at 'enter()' -time.)
 |      
 |      leave(self, arg2)
 |          arg2: uint32
 |  
 |  makeplace(self, *args)
 |      Map a number to a location. When the user clicks on the scrollbar and
 |      drags it, we need to determine the location corresponding to the new
 |      scrollbar position. This function is used to determine it. It builds a
 |      location object for the specified 'x' and returns a pointer to it.
 |      
 |      makeplace(self, ud, x, lnnum) -> place_t
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @param x: number to map (C++: uval_t)
 |          @param lnnum: line number to initialize 'lnnum' (C++: int)
 |          @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
 |  
 |  name(self, *args)
 |      Get this place type name. All instances of a given class must return
 |      the same string.
 |  
 |  next(self, *args)
 |      Move to the next displayable location.
 |      
 |      next(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: success
 |  
 |  prev(self, *args)
 |      Move to the previous displayable location.
 |      
 |      prev(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: success
 |  
 |  rebase(self, *args)
 |      Rebase the place instance
 |      
 |      rebase(self, arg2) -> bool
 |          arg2: segm_move_infos_t const &
 |          @return: true if place was rebased, false otherwise
 |  
 |  serialize(self, *args)
 |      Serialize this instance. It is fundamental that all instances of a
 |      particular subclass of of 'place_t' occupy the same number of bytes
 |      when serialized.
 |  
 |  toea(self, *args)
 |      Map the location to an ea_t.
 |  
 |  touval(self, *args)
 |      Map the location to a number. This mapping is used to draw the
 |      vertical scrollbar.
 |      
 |      touval(self, ud) -> uval_t
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args)
 |      as_enumplace_t(p) -> enumplace_t
 |          p: place_t *
 |  
 |  as_idaplace_t(*args)
 |      as_idaplace_t(p) -> idaplace_t
 |          p: place_t *
 |  
 |  as_simpleline_place_t(*args)
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |          p: place_t *
 |  
 |  as_structplace_t(*args)
 |      as_structplace_t(p) -> structplace_t
 |          p: place_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      place_t_lnnum_get(self) -> int

Help on function error in module ida_kernwin:

error(*args)
    error(format)
    Display a fatal message in a message box and quit IDA
    
    @param format: message to print

Help on function execute_sync in module ida_kernwin:

execute_sync(*args)
    execute_sync(py_callable, reqf) -> int
    Executes a function in the context of the main thread.
    If the current thread not the main thread, then the call is queued and
    executed afterwards.
    
    @param callable: A python callable object, must return an integer value
    @param reqf: one of MFF_ flags
    @return: -1 or the return value of the callable

Help on function execute_ui_requests in module ida_kernwin:

execute_ui_requests(*args)
    execute_ui_requests(py_list) -> bool
    Inserts a list of callables into the UI message processing queue.
    When the UI is ready it will call one callable.
    A callable can request to be called more than once if it returns True.
    
    @param callable_list: A list of python callable objects.
    @note: A callable should return True if it wants to be called more than once.
    @return: Boolean. False if the list contains a non callabale item

Help on function find_widget in module ida_kernwin:

find_widget(*args)
    Find widget with the specified caption (only gui version) (
    'ui_find_widget' ). NB: this callback works only with the tabbed
    widgets!
    
    find_widget(caption) -> TWidget *
        @param caption: title of tab, or window title if widget is not tabbed
                        (C++: const char *)
        @return: pointer to the TWidget, NULL if none is found

Help on function formchgcbfa_close in module ida_kernwin:

formchgcbfa_close(*args)
    formchgcbfa_close(p_fa, close_normally)
        p_fa: size_t
        close_normally: int

Help on function formchgcbfa_enable_field in module ida_kernwin:

formchgcbfa_enable_field(*args)
    formchgcbfa_enable_field(p_fa, fid, enable) -> bool
        p_fa: size_t
        fid: int
        enable: bool

Help on function formchgcbfa_get_field_value in module ida_kernwin:

formchgcbfa_get_field_value(*args)
    formchgcbfa_get_field_value(p_fa, fid, ft, sz) -> PyObject *
        p_fa: size_t
        fid: int
        ft: int
        sz: size_t

Help on function formchgcbfa_get_focused_field in module ida_kernwin:

formchgcbfa_get_focused_field(*args)
    formchgcbfa_get_focused_field(p_fa) -> int
        p_fa: size_t

Help on function formchgcbfa_move_field in module ida_kernwin:

formchgcbfa_move_field(*args)
    formchgcbfa_move_field(p_fa, fid, x, y, w, h) -> bool
        p_fa: size_t
        fid: int
        x: int
        y: int
        w: int
        h: int

Help on function formchgcbfa_refresh_field in module ida_kernwin:

formchgcbfa_refresh_field(*args)
    formchgcbfa_refresh_field(p_fa, fid)
        p_fa: size_t
        fid: int

Help on function formchgcbfa_set_field_value in module ida_kernwin:

formchgcbfa_set_field_value(*args)
    formchgcbfa_set_field_value(p_fa, fid, ft, py_val) -> bool
        p_fa: size_t
        fid: int
        ft: int
        py_val: PyObject *

Help on function formchgcbfa_set_focused_field in module ida_kernwin:

formchgcbfa_set_focused_field(*args)
    formchgcbfa_set_focused_field(p_fa, fid) -> bool
        p_fa: size_t
        fid: int

Help on function formchgcbfa_show_field in module ida_kernwin:

formchgcbfa_show_field(*args)
    formchgcbfa_show_field(p_fa, fid, show) -> bool
        p_fa: size_t
        fid: int
        show: bool

Help on function free_custom_icon in module ida_kernwin:

free_custom_icon(*args)
    free_custom_icon(icon_id)
    Frees an icon loaded with load_custom_icon()

Help on function gen_disasm_text in module ida_kernwin:

gen_disasm_text(*args)
    Generate disassembly text for a range.
    
    gen_disasm_text(text, ea1, ea2, truncate_lines)
        @param text: result (C++: text_t  &)
        @param ea1: start address (C++: ea_t)
        @param ea2: end address (C++: ea_t)
        @param truncate_lines: (on  idainfo::margin ) (C++: bool)

Help on function get_action_checkable in module ida_kernwin:

get_action_checkable(*args)
    Get an action's checkability ( 'ui_get_action_attr' ).
    
    get_action_checkable(name) -> bool
        @param name: the action name (C++: const char *)
        @return: success

Help on function get_action_checked in module ida_kernwin:

get_action_checked(*args)
    Get an action's checked state ( 'ui_get_action_attr' ).
    
    get_action_checked(name) -> bool
        @param name: the action name (C++: const char *)
        @return: success

Help on function get_action_icon in module ida_kernwin:

get_action_icon(*args)
    Get an action's icon ( 'ui_get_action_attr' ).
    
    get_action_icon(name) -> bool
        @param name: the action name (C++: const char *)
        @return: success

Help on function get_action_label in module ida_kernwin:

get_action_label(*args)
    Get an action's label ( 'ui_get_action_attr' ).
    
    get_action_label(name) -> str
        @param name: the action name (C++: const char *)
        @return: success

Help on function get_action_shortcut in module ida_kernwin:

get_action_shortcut(*args)
    Get an action's shortcut ( 'ui_get_action_attr' ).
    
    get_action_shortcut(name) -> str
        @param name: the action name (C++: const char *)
        @return: success

Help on function get_action_state in module ida_kernwin:

get_action_state(*args)
    Get an action's state ( 'ui_get_action_attr' ).
    
    get_action_state(name) -> bool
        @param name: the action name (C++: const char *)
        @return: success

Help on function get_action_tooltip in module ida_kernwin:

get_action_tooltip(*args)
    Get an action's tooltip ( 'ui_get_action_attr' ).
    
    get_action_tooltip(name) -> str
        @param name: the action name (C++: const char *)
        @return: success

Help on function get_action_visibility in module ida_kernwin:

get_action_visibility(*args)
    Get an action's visibility ( 'ui_get_action_attr' ).
    
    get_action_visibility(name) -> bool
        @param name: the action name (C++: const char *)
        @return: success

Help on function get_active_modal_widget in module ida_kernwin:

get_active_modal_widget(*args)
    Get the current, active modal TWidget instance. Note that in this
    context, the "wait dialog" is not considered: this function will
    return NULL even if it is currently shown.

Help on function get_addon_info in module ida_kernwin:

get_addon_info(*args)
    Get info about a registered addon with a given product code. info->cb
    must be valid! NB: all pointers are invalidated by next call to
    register_addon or get_addon_info
    
    get_addon_info(id, info) -> bool
        @param id (C++: const char *)
        @param info (C++: addon_info_t  *)
        @return: false if not found

Help on function get_addon_info_idx in module ida_kernwin:

get_addon_info_idx(*args)
    Get info about a registered addon with specific index. info->cb must
    be valid! NB: all pointers are invalidated by next call to
    register_addon or get_addon_info
    
    get_addon_info_idx(index, info) -> bool
        @param index (C++: int)
        @param info (C++: addon_info_t  *)
        @return: false if index is out of range

Help on function get_chooser_data in module ida_kernwin:

get_chooser_data(*args)
    Get the text corresponding to the index N in the chooser data. Use -1
    to get the header.
    
    get_chooser_data(chooser_caption, n) -> PyObject *
        @param chooser_caption (C++: const char *)
        @param n (C++: int)

Help on function get_chooser_obj in module ida_kernwin:

get_chooser_obj(*args)
    Get the underlying object of the specified chooser (
    'ui_get_chooser_obj' ).This is object is chooser-specific.
    
    get_chooser_obj(chooser_caption) -> void *
        @param chooser_caption (C++: const char *)
        @return: the object that was used to create the chooser

Help on function get_curline in module ida_kernwin:

get_curline(*args)
    Get current line from the disassemble window ( 'ui_get_curline' ).

Help on function get_current_viewer in module ida_kernwin:

get_current_viewer(*args)
    Get current ida viewer (idaview or custom viewer) (
    'ui_get_current_viewer' )

Help on function get_current_widget in module ida_kernwin:

get_current_widget(*args)
    Get a pointer to the current widget ( 'ui_get_current_widget' ).

Help on function get_cursor in module ida_kernwin:

get_cursor(*args)
    Get the cursor position on the screen ( 'ui_get_cursor' ).coordinates
    are 0-based

Help on function get_custom_viewer_curline in module ida_kernwin:

get_custom_viewer_curline(*args)
    Get current line of custom viewer ( 'ui_get_custom_viewer_curline' ).
    The returned line contains color codes
    
    get_custom_viewer_curline(custom_viewer, mouse) -> char const *
        @param custom_viewer: view (C++: TWidget *)
        @param mouse: mouse position (otherwise cursor position) (C++: bool)
        @return: pointer to contents of current line

Help on function get_custom_viewer_location in module ida_kernwin:

get_custom_viewer_location(*args)
    Get the current location in a custom viewer (
    'ui_get_custom_viewer_location' ).
    
    get_custom_viewer_location(out, custom_viewer, mouse=False) -> bool
        @param out (C++: lochist_entry_t  *)
        @param custom_viewer (C++: TWidget *)
        @param mouse (C++: bool)

Help on function get_custom_viewer_place in module ida_kernwin:

get_custom_viewer_place(*args)
    Get current place in a custom viewer ( 'ui_get_curplace' ).See also
    the more complete 'get_custom_viewer_location()'
    
    get_custom_viewer_place(custom_viewer, mouse) -> place_t
        @param custom_viewer: view (C++: TWidget *)
        @param mouse: mouse position (otherwise cursor position) (C++: bool)

Help on function get_ea_viewer_history_info in module ida_kernwin:

get_ea_viewer_history_info(*args)
    Get information about what's in the history (
    'ui_ea_viewer_history_info' ).
    
    get_ea_viewer_history_info(nback, nfwd, v) -> bool
        @param nback: number of available back steps (C++: int *)
        @param nfwd: number of available forward steps (C++: int *)
        @param v: ea viewer (C++: TWidget *)
        @retval: false - if the given ea viewer does not exist
        @retval: true - otherwise

Help on function get_hexdump_ea in module ida_kernwin:

get_hexdump_ea(*args)
    Get the current address in a hex view.
    
    get_hexdump_ea(hexdump_num) -> ea_t
        @param hexdump_num: number of hexview window (C++: int)

Help on function get_highlight in module ida_kernwin:

get_highlight(*args)
    get_highlight(v) -> PyObject *
    Returns the currently highlighted identifier and flags
    
    @return: a tuple (text, flags), or None if nothing
             is highlighted or in case of error.

Help on function get_kernel_version in module ida_kernwin:

get_kernel_version(*args)
    Get IDA kernel version (in a string like "5.1").

Help on function get_key_code in module ida_kernwin:

get_key_code(*args)
    Get keyboard key code by its name ( 'ui_get_key_code' )
    
    get_key_code(keyname) -> ushort
        @param keyname (C++: const char *)

Help on function get_navband_ea in module ida_kernwin:

get_navband_ea(*args)
    Translate the pixel position on the navigation band, into an address.
    
    get_navband_ea(pixel) -> ea_t
        @param pixel (C++: int)

Help on function get_navband_pixel in module ida_kernwin:

get_navband_pixel(*args)
    get_navband_pixel(ea) -> int
    Maps an address, onto a pixel coordinate within the navband
    
    @param ea: The address to map
    @return: a list [pixel, is_vertical]

Help on function get_opnum in module ida_kernwin:

get_opnum(*args)
    Get current operand number, -1 means no operand ( 'ui_get_opnum' )

Help on function get_output_curline in module ida_kernwin:

get_output_curline(*args)
    Get current line of output window ( 'ui_get_output_curline' ).
    
    get_output_curline(mouse) -> str
        @param mouse: current for mouse pointer? (C++: bool)
        @return: false if output contains no text

Help on function get_output_cursor in module ida_kernwin:

get_output_cursor(*args)
    Get coordinates of the output window's cursor ( 'ui_get_output_cursor'
    ).coordinates are 0-basedthis function will succeed even if the output
    window is not visible

Help on function get_output_selected_text in module ida_kernwin:

get_output_selected_text(*args)
    Returns selected text from output window (
    'ui_get_output_selected_text' ).

Help on function get_place_class in module ida_kernwin:

get_place_class(*args)
    Get information about a previously-registered 'place_t' class. See
    also 'register_place_class()' .
    
    get_place_class(out_flags, out_sdk_version, id) -> place_t
        @param out_flags: output flags (can be NULL) (C++: int *)
        @param out_sdk_version: sdk version the place was created with (can be
                                NULL) (C++: int *)
        @param id: place class ID (C++: int)
        @return: the  place_t  template, or NULL if not found

Help on function get_place_class_id in module ida_kernwin:

get_place_class_id(*args)
    Get the place class ID for the place that has been registered as
    'name'.
    
    get_place_class_id(name) -> int
        @param name: the class name (C++: const char *)
        @return: the place class ID, or -1 if not found

Help on function get_place_class_template in module ida_kernwin:

get_place_class_template(*args)
    See 'get_place_class()'
    
    get_place_class_template(id) -> place_t
        @param id (C++: int)

Help on function get_registered_actions in module ida_kernwin:

get_registered_actions(*args)
    Get a list of all currently-registered actions

Help on function get_screen_ea in module ida_kernwin:

get_screen_ea(*args)
    Get the address at the screen cursor ( 'ui_screenea' )

Help on function get_synced_group in module ida_kernwin:

get_synced_group(*args)
    Get the group of widgets/registers this view is synchronized with
    
    get_synced_group(w) -> synced_group_t
        @param w: the widget (C++: const TWidget *)
        @return: the group of widgets/registers, or NULL

Help on function get_tab_size in module ida_kernwin:

get_tab_size(*args)
    Get the size of a tab in spaces ( 'ui_get_tab_size' ).
    
    get_tab_size(path) -> int
        @param path: the path of the source view for which the tab size is
                     requested.   if NULL, the default size is returned. (C++:
                     const char *)

Help on function get_user_strlist_options in module ida_kernwin:

get_user_strlist_options(*args)
    get_user_strlist_options(out)
        @param out (C++: strwinsetup_t  *)

Help on function get_view_renderer_type in module ida_kernwin:

get_view_renderer_type(*args)
    Get the type of renderer currently in use in the given view (
    'ui_get_renderer_type' )
    
    get_view_renderer_type(v) -> tcc_renderer_type_t
        @param v (C++: TWidget *)

Help on function get_viewer_place_type in module ida_kernwin:

get_viewer_place_type(*args)
    Get the type of 'place_t' instances a viewer uses & creates (
    'ui_get_viewer_place_type' ).
    
    get_viewer_place_type(viewer) -> tcc_place_type_t
        @param viewer (C++: TWidget *)

Help on function get_viewer_user_data in module ida_kernwin:

get_viewer_user_data(*args)
    Get the user data from a custom viewer ( 'ui_get_viewer_user_data' )
    
    get_viewer_user_data(viewer) -> void *
        @param viewer (C++: TWidget *)

Help on function get_widget_title in module ida_kernwin:

get_widget_title(*args)
    Get the TWidget's title ( 'ui_get_widget_title' ).
    
    get_widget_title(widget) -> str
        @param widget (C++: TWidget *)

Help on function get_widget_type in module ida_kernwin:

get_widget_type(*args)
    Get the type of the TWidget * ( 'ui_get_widget_type' ).
    
    get_widget_type(widget) -> twidget_type_t
        @param widget (C++: TWidget *)

Help on function get_window_id in module ida_kernwin:

get_window_id(*args)
    Get the system-specific window ID (GUI version only)
    
    get_window_id(name=None) -> void *
        @param name (C++: const char *)
        @return: the low-level window ID

Help on function hide_wait_box in module ida_kernwin:

hide_wait_box(*args)
    Hide the "Please wait dialog box".

Help on class idaplace_t in module ida_kernwin:

class idaplace_t(place_t)
 |  Proxy of C++ idaplace_t class.
 |  
 |  Method resolution order:
 |      idaplace_t
 |      place_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ea
 |      idaplace_t_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_idaplace_t>
 |      delete_idaplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args)
 |      _print(self, out_buf, ud)
 |          out_buf: qstring *
 |          ud: void *
 |  
 |  adjust(self, *args)
 |      Adjust the current location to point to a displayable object. This
 |      function validates the location and makes sure that it points to an
 |      existing object. For example, if the location points to the middle of
 |      an instruction, it will be adjusted to point to the beginning of the
 |      instruction.
 |      
 |      adjust(self, ud)
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |  
 |  beginning(self, *args)
 |      Are we at the first displayable object?.
 |      
 |      beginning(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: true if the current location points to the first displayable
 |                   object
 |  
 |  clone(self, *args)
 |      Clone the location.
 |  
 |  compare(self, *args)
 |      Deprecated. Please consider compare2(const place_t *, void *) instead.
 |      
 |      compare(self, t2) -> int
 |          @param t2 (C++: const  place_t  *)
 |  
 |  compare2(self, *args)
 |      Compare two locations except line numbers (lnnum). This function is
 |      used to organize loops. For example, if the user has selected an
 |      range, its boundaries are remembered as location objects. Any
 |      operation within the selection will have the following look: for (
 |      loc=starting_location; loc < ending_location; loc.next() ) In this
 |      loop, the comparison function is used.
 |      
 |      compare2(self, t2, arg3) -> int
 |          @param t2: the place to compare this one to. (C++: const  place_t  *)
 |          arg3: void *
 |          @retval: -1 - if the current location is less than 't2'
 |          @retval: 0 - if the current location is equal to than 't2'
 |          @retval: 1 - if the current location is greater than 't2'
 |  
 |  copyfrom(self, *args)
 |      Copy the specified location object to the current object.
 |      
 |      copyfrom(self, _from)
 |          @param _from (C++: const  place_t  *)
 |  
 |  deserialize(self, *args)
 |      De-serialize into this instance. 'pptr' should be incremented by as
 |      many bytes as de-serialization consumed.
 |      
 |      deserialize(self, _in) -> bool
 |          in: bytevec_t const &
 |          @return: whether de-serialization was successful
 |  
 |  ending(self, *args)
 |      Are we at the last displayable object?.
 |      
 |      ending(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: true if the current location points to the last displayable
 |                   object
 |  
 |  enter(self, *args)
 |      Visit this place, possibly 'unhiding' a section of text. If entering
 |      that place required some expanding, a 'place_t' should be returned
 |      that represents that section, plus some flags for later use by '
 |      'leave()' '.
 |      
 |      enter(self, arg2) -> place_t
 |          arg2: uint32 *
 |          @return: a  place_t  corresponding to the beginning of the section of
 |                   text that had to be expanded. That  place_t 's  leave()  will
 |                   be called with the flags contained in 'out_flags' when the
 |                   user navigates away from it.
 |  
 |  generate(self, *args)
 |      Generate text lines for the current location.
 |      
 |      generate(self, ud, maxsize) -> PyObject *
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @param maxsize: the maximum number of lines to generate (C++: int)
 |          @return: number of generated lines
 |  
 |  id(self, *args)
 |      Get the place's ID (i.e., the value returned by
 |      'register_place_class()' )
 |  
 |  leave(self, *args)
 |      Leave this place, possibly 'hiding' a section of text that was
 |      previously expanded (at 'enter()' -time.)
 |      
 |      leave(self, arg2)
 |          arg2: uint32
 |  
 |  makeplace(self, *args)
 |      Map a number to a location. When the user clicks on the scrollbar and
 |      drags it, we need to determine the location corresponding to the new
 |      scrollbar position. This function is used to determine it. It builds a
 |      location object for the specified 'x' and returns a pointer to it.
 |      
 |      makeplace(self, ud, x, lnnum) -> place_t
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @param x: number to map (C++: uval_t)
 |          @param lnnum: line number to initialize 'lnnum' (C++: int)
 |          @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
 |  
 |  name(self, *args)
 |      Get this place type name. All instances of a given class must return
 |      the same string.
 |  
 |  next(self, *args)
 |      Move to the next displayable location.
 |      
 |      next(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: success
 |  
 |  prev(self, *args)
 |      Move to the previous displayable location.
 |      
 |      prev(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: success
 |  
 |  rebase(self, *args)
 |      Rebase the place instance
 |      
 |      rebase(self, arg2) -> bool
 |          arg2: segm_move_infos_t const &
 |          @return: true if place was rebased, false otherwise
 |  
 |  serialize(self, *args)
 |      Serialize this instance. It is fundamental that all instances of a
 |      particular subclass of of 'place_t' occupy the same number of bytes
 |      when serialized.
 |  
 |  toea(self, *args)
 |      Map the location to an ea_t.
 |  
 |  touval(self, *args)
 |      Map the location to a number. This mapping is used to draw the
 |      vertical scrollbar.
 |      
 |      touval(self, ud) -> uval_t
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args)
 |      as_enumplace_t(p) -> enumplace_t
 |          p: place_t *
 |  
 |  as_idaplace_t(*args)
 |      as_idaplace_t(p) -> idaplace_t
 |          p: place_t *
 |  
 |  as_simpleline_place_t(*args)
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |          p: place_t *
 |  
 |  as_structplace_t(*args)
 |      as_structplace_t(p) -> structplace_t
 |          p: place_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      place_t_lnnum_get(self) -> int

Help on function info in module ida_kernwin:

info(*args)
    info(format)
        @param format (C++: const char *)

Help on function install_command_interpreter in module ida_kernwin:

install_command_interpreter(*args)
    Install command line interpreter ( 'ui_install_cli' )
    
    install_command_interpreter(py_obj) -> int
        py_obj: PyObject *

Help on function internal_register_place_class in module ida_kernwin:

internal_register_place_class(*args)
    internal_register_place_class(tmplate, flags, owner, sdk_version) -> int
        @param tmplate (C++: const  place_t  *)
        @param flags (C++: int)
        @param owner (C++: const  plugin_t  *)
        @param sdk_version (C++: int)

Help on function is_action_enabled in module ida_kernwin:

is_action_enabled(*args)
    Check if the given action state is one of AST_ENABLE*.
    
    is_action_enabled(s) -> bool
        @param s (C++: action_state_t)

Help on function is_chooser_widget in module ida_kernwin:

is_chooser_widget(*args)
    Does the given widget type specify a chooser widget?
    
    is_chooser_widget(t) -> bool
        @param t (C++: twidget_type_t)

Help on function is_idaq in module ida_kernwin:

is_idaq(*args)
    is_idaq() -> bool
    Returns True or False depending if IDAPython is hosted by IDAQ

Help on function is_msg_inited in module ida_kernwin:

is_msg_inited(*args)
    Can we use msg() functions?

Help on function is_place_class_ea_capable in module ida_kernwin:

is_place_class_ea_capable(*args)
    See 'get_place_class()'
    
    is_place_class_ea_capable(id) -> bool
        @param id (C++: int)

Help on function is_refresh_requested in module ida_kernwin:

is_refresh_requested(*args)
    Get a refresh request state
    
    is_refresh_requested(mask) -> bool
        @param mask: Window refresh flags (C++: uint64)
        @return: the state (set or cleared)

Help on class jobj_wrapper_t in module ida_kernwin:

class jobj_wrapper_t(__builtin__.object)
 |  Proxy of C++ jobj_wrapper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_dict(self, *args)
 |      get_dict(self) -> PyObject *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function jumpto in module ida_kernwin:

jumpto(*args)
    Jump to the specified address ( 'ui_jumpto' ).
    
    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
        @param ea: destination (C++: ea_t)
        @param opnum: -1: don't change x coord (C++: int)
        @param uijmp_flags: Jump flags (C++: int)
        @return: success
    
    
    jumpto(custom_viewer, place, x, y) -> bool
        custom_viewer: TWidget *
        place: place_t *
        x: int
        y: int
        @return: success

Help on class line_rendering_output_entries_refs_t in module ida_kernwin:

class line_rendering_output_entries_refs_t(__builtin__.object)
 |  Proxy of C++ qvector< line_rendering_output_entry_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< line_rendering_output_entry_t * > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> line_rendering_output_entry_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> line_rendering_output_entries_refs_t
 |          x: qvector< line_rendering_output_entry_t * > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< line_rendering_output_entry_t * > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: line_rendering_output_entry_t *const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: line_rendering_output_entry_t *const &
 |  
 |  _internal_push_back(self, *args)
 |      _internal_push_back(self, e)
 |          e: line_rendering_output_entry_t *
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: line_rendering_output_entry_t *const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> line_rendering_output_entry_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< line_rendering_output_entry_t * >::iterator
 |      begin(self) -> qvector< line_rendering_output_entry_t * >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< line_rendering_output_entry_t * >::iterator
 |      end(self) -> qvector< line_rendering_output_entry_t * >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< line_rendering_output_entry_t * >::iterator
 |          it: qvector< line_rendering_output_entry_t * >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< line_rendering_output_entry_t * >::iterator
 |          first: qvector< line_rendering_output_entry_t * >::iterator
 |          last: qvector< line_rendering_output_entry_t * >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> line_rendering_output_entry_t **
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< line_rendering_output_entry_t * >::iterator
 |          x: line_rendering_output_entry_t *const &
 |      
 |      
 |      find(self, x) -> qvector< line_rendering_output_entry_t * >::const_iterator
 |          x: line_rendering_output_entry_t *const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: line_rendering_output_entry_t *const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: line_rendering_output_entry_t **
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< line_rendering_output_entry_t * >::iterator
 |          it: qvector< line_rendering_output_entry_t * >::iterator
 |          x: line_rendering_output_entry_t *const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, e)
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: line_rendering_output_entry_t *const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< line_rendering_output_entry_t * > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_line_rendering_output_ent...
 |      delete_line_rendering_output_entries_refs_t(self)

Help on class line_rendering_output_entry_t in module ida_kernwin:

class line_rendering_output_entry_t(__builtin__.object)
 |  Proxy of C++ line_rendering_output_entry_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: line_rendering_output_entry_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _line, _flags=0, _bg_color=0) -> line_rendering_output_entry_t
 |          _line: twinline_t const *
 |          _flags: uint32
 |          _bg_color: bgcolor_t
 |      
 |      
 |      __init__(self, _line, _cpx, _nchars, _flags, _bg_color) -> line_rendering_output_entry_t
 |          _line: twinline_t const *
 |          _cpx: int
 |          _nchars: int
 |          _flags: uint32
 |          _bg_color: bgcolor_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: line_rendering_output_entry_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  is_bg_color_direct(self, *args)
 |      is_bg_color_direct(self) -> bool
 |  
 |  is_bg_color_empty(self, *args)
 |      is_bg_color_empty(self) -> bool
 |  
 |  is_bg_color_key(self, *args)
 |      is_bg_color_key(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bg_color
 |      line_rendering_output_entry_t_bg_color_get(self) -> bgcolor_t
 |  
 |  cpx
 |      line_rendering_output_entry_t_cpx_get(self) -> int
 |  
 |  flags
 |      line_rendering_output_entry_t_flags_get(self) -> uint32
 |  
 |  line
 |      line_rendering_output_entry_t_line_get(self) -> twinline_t
 |  
 |  nchars
 |      line_rendering_output_entry_t_nchars_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_line_rendering_output_ent...
 |      delete_line_rendering_output_entry_t(self)

Help on class lines_rendering_input_t in module ida_kernwin:

class lines_rendering_input_t(__builtin__.object)
 |  Proxy of C++ lines_rendering_input_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lines_rendering_input_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      lines_rendering_input_t_cb_get(self) -> int
 |  
 |  sections_lines
 |      lines_rendering_input_t_sections_lines_get(self) -> sections_lines_refs_t
 |  
 |  sync_group
 |      lines_rendering_input_t_sync_group_get(self) -> synced_group_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lines_rendering_input_t>
 |      delete_lines_rendering_input_t(self)

Help on class lines_rendering_output_t in module ida_kernwin:

class lines_rendering_output_t(__builtin__.object)
 |  Proxy of C++ lines_rendering_output_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: lines_rendering_output_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lines_rendering_output_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: lines_rendering_output_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: lines_rendering_output_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  entries
 |      lines_rendering_output_t_entries_get(self) -> line_rendering_output_entries_refs_t
 |  
 |  flags
 |      lines_rendering_output_t_flags_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lines_rendering_output_t>
 |      delete_lines_rendering_output_t(self)

Help on function load_custom_icon in module ida_kernwin:

load_custom_icon(file_name=None, data=None, format=None)
    Loads a custom icon and returns an identifier that can be used with other APIs
    
    If file_name is passed then the other two arguments are ignored.
    
    @param file_name: The icon file name
    @param data: The icon data
    @param format: The icon data format
    
    @return: Icon id or 0 on failure.
             Use free_custom_icon() to free it

Help on function load_dbg_dbginfo in module ida_kernwin:

load_dbg_dbginfo(*args)
    Load debugging information from a file.
    
    load_dbg_dbginfo(path, li=None, base=BADADDR, verbose=False) -> bool
        @param path: path to file (C++: const char *)
        @param li: loader input. if NULL, check DBG_NAME_KEY (C++: linput_t *)
        @param base: loading address (C++: ea_t)
        @param verbose: dump status to message window (C++: bool)

Help on function lookup_key_code in module ida_kernwin:

lookup_key_code(*args)
    Get shortcut code previously created by 'ui_get_key_code' .
    
    lookup_key_code(key, shift, is_qt) -> ushort
        @param key: key constant (C++: int)
        @param shift: modifiers (C++: int)
        @param is_qt: are we using gui version? (C++: bool)

Help on function msg in module ida_kernwin:

msg(*args)
    msg(o) -> PyObject *
    Display an UTF-8 string in the message window
    
    The result of the stringification of the arguments
    will be treated as an UTF-8 string.
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts

Help on function msg_clear in module ida_kernwin:

msg_clear(*args)
    Clear the "Output window".

Help on function msg_get_lines in module ida_kernwin:

msg_get_lines(*args)
    Retrieve the last 'count' lines from the output window, in reverse
    order (from most recent, to least recent)
    
    msg_get_lines(count=-1) -> PyObject *
        @param count: The number of lines to retrieve. -1 means: all (C++:
                      int)

Help on function msg_save in module ida_kernwin:

msg_save(*args)
    Save the "Output window" contents into a file
    
    msg_save(path) -> bool
        @param path: The path of the file to save the contents into. An empty
                     path means that the user will be prompted for the
                     destination and, if the file already exists, the user
                     will be asked to confirm before overriding its contents.
                     Upon return, 'path' will contain the path that the user
                     chose. (C++: qstring  &)
        @return: success

Help on function nomem in module ida_kernwin:

nomem(*args)
    nomem(format)
        @param format (C++: const char *)

Help on function open_bpts_window in module ida_kernwin:

open_bpts_window(*args)
    Open the breakpoints window ( 'ui_open_builtin' ).
    
    open_bpts_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window

Help on function open_calls_window in module ida_kernwin:

open_calls_window(*args)
    Open the function calls window ( 'ui_open_builtin' ).
    
    open_calls_window(ea) -> TWidget *
        @param ea (C++: ea_t)
        @return: pointer to resulting window

Help on function open_disasm_window in module ida_kernwin:

open_disasm_window(*args)
    Open a disassembly view ( 'ui_open_builtin' ).
    
    open_disasm_window(window_title, ranges=None) -> TWidget *
        @param window_title: title of view to open (C++: const char *)
        @param ranges: if != NULL, then display a flow chart with the
                       specified ranges (C++: const  rangevec_t  *)
        @return: pointer to resulting window

Help on function open_enums_window in module ida_kernwin:

open_enums_window(*args)
    Open the enums window ( 'ui_open_builtin' ).
    
    open_enums_window(const_id=BADADDR) -> TWidget *
        @param const_id: index of entry to select by default (C++: tid_t)
        @return: pointer to resulting window

Help on function open_exports_window in module ida_kernwin:

open_exports_window(*args)
    Open the exports window ( 'ui_open_builtin' ).
    
    open_exports_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window

Help on function open_form in module ida_kernwin:

open_form(*args)

Help on function open_frame_window in module ida_kernwin:

open_frame_window(*args)
    Open the frame window for the given function ( 'ui_open_builtin' ).
    
    open_frame_window(pfn, offset) -> TWidget *
        @param pfn: function to analyze (C++: func_t  *)
        @param offset: offset where the cursor is placed (C++: uval_t)
        @return: pointer to resulting window if 'pfn' is a valid function and
                 the window was displayed,    NULL otherwise

Help on function open_funcs_window in module ida_kernwin:

open_funcs_window(*args)
    Open the functions window ( 'ui_open_builtin' ).
    
    open_funcs_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window

Help on function open_hexdump_window in module ida_kernwin:

open_hexdump_window(*args)
    Open a hexdump view ( 'ui_open_builtin' ).
    
    open_hexdump_window(window_title) -> TWidget *
        @param window_title: title of view to open (C++: const char *)
        @return: pointer to resulting window

Help on function open_imports_window in module ida_kernwin:

open_imports_window(*args)
    Open the exports window ( 'ui_open_builtin' ).
    
    open_imports_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window

Help on function open_loctypes_window in module ida_kernwin:

open_loctypes_window(*args)
    Open the local types window ( 'ui_open_builtin' ).
    
    open_loctypes_window(ordinal) -> TWidget *
        @param ordinal: ordinal of type to select by default (C++: int)
        @return: pointer to resulting window

Help on function open_modules_window in module ida_kernwin:

open_modules_window(*args)
    Open the modules window ( 'ui_open_builtin' ).

Help on function open_names_window in module ida_kernwin:

open_names_window(*args)
    Open the names window ( 'ui_open_builtin' ).
    
    open_names_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window

Help on function open_navband_window in module ida_kernwin:

open_navband_window(*args)
    Open the navigation band window ( 'ui_open_builtin' ).
    
    open_navband_window(ea, zoom) -> TWidget *
        @param ea: sets the address of the navband arrow (C++: ea_t)
        @param zoom: sets the navband zoom level (C++: int)
        @return: pointer to resulting window

Help on function open_notepad_window in module ida_kernwin:

open_notepad_window(*args)
    Open the notepad window ( 'ui_open_builtin' ).

Help on function open_problems_window in module ida_kernwin:

open_problems_window(*args)
    Open the problems window ( 'ui_open_builtin' ).
    
    open_problems_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window

Help on function open_segments_window in module ida_kernwin:

open_segments_window(*args)
    Open the segments window ( 'ui_open_builtin' ).
    
    open_segments_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window

Help on function open_segregs_window in module ida_kernwin:

open_segregs_window(*args)
    Open the segment registers window ( 'ui_open_builtin' ).
    
    open_segregs_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window

Help on function open_selectors_window in module ida_kernwin:

open_selectors_window(*args)
    Open the selectors window ( 'ui_open_builtin' ).

Help on function open_signatures_window in module ida_kernwin:

open_signatures_window(*args)
    Open the signatures window ( 'ui_open_builtin' ).

Help on function open_stack_window in module ida_kernwin:

open_stack_window(*args)
    Open the call stack window ( 'ui_open_builtin' ).

Help on function open_strings_window in module ida_kernwin:

open_strings_window(*args)
    Open the strings window ( 'ui_open_builtin' ).
    
    open_strings_window(ea, selstart=BADADDR, selend=BADADDR) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @param selstart: only display strings that occur within this range
                         (C++: ea_t)
        @param selend: only display strings that occur within this range (C++:
                       ea_t)
        @return: pointer to resulting window

Help on function open_structs_window in module ida_kernwin:

open_structs_window(*args)
    Open the structs window ( 'ui_open_builtin' ).
    
    open_structs_window(id=BADADDR, offset=0) -> TWidget *
        @param id: index of entry to select by default (C++: tid_t)
        @param offset: offset where the cursor is placed (C++: uval_t)
        @return: pointer to resulting window

Help on function open_threads_window in module ida_kernwin:

open_threads_window(*args)
    Open the threads window ( 'ui_open_builtin' ).

Help on function open_tils_window in module ida_kernwin:

open_tils_window(*args)
    Open the type libraries window ( 'ui_open_builtin' ).

Help on function open_trace_window in module ida_kernwin:

open_trace_window(*args)
    Open the trace window ( 'ui_open_builtin' ).

Help on function open_url in module ida_kernwin:

open_url(*args)
    Open the given url ( 'ui_open_url' )
    
    open_url(url)
        @param url (C++: const char *)

Help on function open_xrefs_window in module ida_kernwin:

open_xrefs_window(*args)
    Open the cross references window ( 'ui_open_builtin' ).
    
    open_xrefs_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window

Help on class place_t in module ida_kernwin:

class place_t(__builtin__.object)
 |  Proxy of C++ place_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self, out_buf, ud)
 |          out_buf: qstring *
 |          ud: void *
 |  
 |  adjust(self, *args)
 |      Adjust the current location to point to a displayable object. This
 |      function validates the location and makes sure that it points to an
 |      existing object. For example, if the location points to the middle of
 |      an instruction, it will be adjusted to point to the beginning of the
 |      instruction.
 |      
 |      adjust(self, ud)
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |  
 |  beginning(self, *args)
 |      Are we at the first displayable object?.
 |      
 |      beginning(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: true if the current location points to the first displayable
 |                   object
 |  
 |  clone(self, *args)
 |      Clone the location.
 |  
 |  compare(self, *args)
 |      Deprecated. Please consider compare2(const place_t *, void *) instead.
 |      
 |      compare(self, t2) -> int
 |          @param t2 (C++: const  place_t  *)
 |  
 |  compare2(self, *args)
 |      Compare two locations except line numbers (lnnum). This function is
 |      used to organize loops. For example, if the user has selected an
 |      range, its boundaries are remembered as location objects. Any
 |      operation within the selection will have the following look: for (
 |      loc=starting_location; loc < ending_location; loc.next() ) In this
 |      loop, the comparison function is used.
 |      
 |      compare2(self, t2, arg3) -> int
 |          @param t2: the place to compare this one to. (C++: const  place_t  *)
 |          arg3: void *
 |          @retval: -1 - if the current location is less than 't2'
 |          @retval: 0 - if the current location is equal to than 't2'
 |          @retval: 1 - if the current location is greater than 't2'
 |  
 |  copyfrom(self, *args)
 |      Copy the specified location object to the current object.
 |      
 |      copyfrom(self, _from)
 |          @param _from (C++: const  place_t  *)
 |  
 |  deserialize(self, *args)
 |      De-serialize into this instance. 'pptr' should be incremented by as
 |      many bytes as de-serialization consumed.
 |      
 |      deserialize(self, _in) -> bool
 |          in: bytevec_t const &
 |          @return: whether de-serialization was successful
 |  
 |  ending(self, *args)
 |      Are we at the last displayable object?.
 |      
 |      ending(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: true if the current location points to the last displayable
 |                   object
 |  
 |  enter(self, *args)
 |      Visit this place, possibly 'unhiding' a section of text. If entering
 |      that place required some expanding, a 'place_t' should be returned
 |      that represents that section, plus some flags for later use by '
 |      'leave()' '.
 |      
 |      enter(self, arg2) -> place_t
 |          arg2: uint32 *
 |          @return: a  place_t  corresponding to the beginning of the section of
 |                   text that had to be expanded. That  place_t 's  leave()  will
 |                   be called with the flags contained in 'out_flags' when the
 |                   user navigates away from it.
 |  
 |  generate(self, *args)
 |      Generate text lines for the current location.
 |      
 |      generate(self, ud, maxsize) -> PyObject *
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @param maxsize: the maximum number of lines to generate (C++: int)
 |          @return: number of generated lines
 |  
 |  id(self, *args)
 |      Get the place's ID (i.e., the value returned by
 |      'register_place_class()' )
 |  
 |  leave(self, *args)
 |      Leave this place, possibly 'hiding' a section of text that was
 |      previously expanded (at 'enter()' -time.)
 |      
 |      leave(self, arg2)
 |          arg2: uint32
 |  
 |  makeplace(self, *args)
 |      Map a number to a location. When the user clicks on the scrollbar and
 |      drags it, we need to determine the location corresponding to the new
 |      scrollbar position. This function is used to determine it. It builds a
 |      location object for the specified 'x' and returns a pointer to it.
 |      
 |      makeplace(self, ud, x, lnnum) -> place_t
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @param x: number to map (C++: uval_t)
 |          @param lnnum: line number to initialize 'lnnum' (C++: int)
 |          @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
 |  
 |  name(self, *args)
 |      Get this place type name. All instances of a given class must return
 |      the same string.
 |  
 |  next(self, *args)
 |      Move to the next displayable location.
 |      
 |      next(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: success
 |  
 |  prev(self, *args)
 |      Move to the previous displayable location.
 |      
 |      prev(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: success
 |  
 |  rebase(self, *args)
 |      Rebase the place instance
 |      
 |      rebase(self, arg2) -> bool
 |          arg2: segm_move_infos_t const &
 |          @return: true if place was rebased, false otherwise
 |  
 |  serialize(self, *args)
 |      Serialize this instance. It is fundamental that all instances of a
 |      particular subclass of of 'place_t' occupy the same number of bytes
 |      when serialized.
 |  
 |  toea(self, *args)
 |      Map the location to an ea_t.
 |  
 |  touval(self, *args)
 |      Map the location to a number. This mapping is used to draw the
 |      vertical scrollbar.
 |      
 |      touval(self, ud) -> uval_t
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  as_enumplace_t(*args)
 |      as_enumplace_t(p) -> enumplace_t
 |          p: place_t *
 |  
 |  as_idaplace_t(*args)
 |      as_idaplace_t(p) -> idaplace_t
 |          p: place_t *
 |  
 |  as_simpleline_place_t(*args)
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |          p: place_t *
 |  
 |  as_structplace_t(*args)
 |      as_structplace_t(p) -> structplace_t
 |          p: place_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      place_t_lnnum_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_place_t>
 |      delete_place_t(self)

Help on function place_t_as_enumplace_t in module ida_kernwin:

place_t_as_enumplace_t(*args)
    place_t_as_enumplace_t(p) -> enumplace_t
        p: place_t *

Help on function place_t_as_idaplace_t in module ida_kernwin:

place_t_as_idaplace_t(*args)
    place_t_as_idaplace_t(p) -> idaplace_t
        p: place_t *

Help on function place_t_as_simpleline_place_t in module ida_kernwin:

place_t_as_simpleline_place_t(*args)
    place_t_as_simpleline_place_t(p) -> simpleline_place_t
        p: place_t *

Help on function place_t_as_structplace_t in module ida_kernwin:

place_t_as_structplace_t(*args)
    place_t_as_structplace_t(p) -> structplace_t
        p: place_t *

Help on function plgform_close in module ida_kernwin:

plgform_close(*args)
    plgform_close(py_link, options)
        py_link: PyObject *
        options: int

Help on function plgform_get_widget in module ida_kernwin:

plgform_get_widget(*args)
    plgform_get_widget(py_link) -> TWidget *
        py_link: PyObject *

Help on function plgform_new in module ida_kernwin:

plgform_new(*args)
    plgform_new() -> PyObject *

Help on function plgform_show in module ida_kernwin:

plgform_show(*args)
    plgform_show(py_link, py_obj, caption, options=WOPN_DP_TAB|WOPN_RESTORE) -> bool
        py_link: PyObject *
        py_obj: PyObject *
        caption: char const *
        options: int

Help on function process_ui_action in module ida_kernwin:

process_ui_action(*args)
    process_ui_action(name, flags=0) -> bool
    Invokes an IDA UI action by name
    
    @param name:  action name
    @return: Boolean

Help on function py_get_ask_form in module ida_kernwin:

py_get_ask_form(*args)
    py_get_ask_form() -> size_t

Help on function py_get_open_form in module ida_kernwin:

py_get_open_form(*args)
    py_get_open_form() -> size_t

Help on function py_load_custom_icon_data in module ida_kernwin:

py_load_custom_icon_data(*args)
    py_load_custom_icon_data(data, format) -> int
        data: PyObject *
        format: char const *

Help on function py_load_custom_icon_fn in module ida_kernwin:

py_load_custom_icon_fn(*args)
    py_load_custom_icon_fn(filename) -> int
        filename: char const *

Help on function py_register_compiled_form in module ida_kernwin:

py_register_compiled_form(*args)
    py_register_compiled_form(py_form)
        py_form: PyObject *

Help on function py_ss_restore_callback in module ida_kernwin:

py_ss_restore_callback(*args)
    py_ss_restore_callback(err_msg, userdata)
        err_msg: char const *
        userdata: void *

Help on function py_unregister_compiled_form in module ida_kernwin:

py_unregister_compiled_form(*args)
    py_unregister_compiled_form(py_form)
        py_form: PyObject *

Help on function pyidag_bind in module ida_kernwin:

pyidag_bind(*args)
    pyidag_bind(_self) -> bool
        self: PyObject *

Help on function pyidag_unbind in module ida_kernwin:

pyidag_unbind(*args)
    pyidag_unbind(_self) -> bool
        self: PyObject *

Help on function pyscv_add_line in module ida_kernwin:

pyscv_add_line(*args)
    pyscv_add_line(py_this, py_sl) -> bool
        py_this: PyObject *
        py_sl: PyObject *

Help on function pyscv_clear_lines in module ida_kernwin:

pyscv_clear_lines(*args)
    pyscv_clear_lines(py_this) -> PyObject *
        py_this: PyObject *

Help on function pyscv_close in module ida_kernwin:

pyscv_close(*args)
    pyscv_close(py_this)
        py_this: PyObject *

Help on function pyscv_count in module ida_kernwin:

pyscv_count(*args)
    pyscv_count(py_this) -> size_t
        py_this: PyObject *

Help on function pyscv_del_line in module ida_kernwin:

pyscv_del_line(*args)
    pyscv_del_line(py_this, nline) -> bool
        py_this: PyObject *
        nline: size_t

Help on function pyscv_edit_line in module ida_kernwin:

pyscv_edit_line(*args)
    pyscv_edit_line(py_this, nline, py_sl) -> bool
        py_this: PyObject *
        nline: size_t
        py_sl: PyObject *

Help on function pyscv_get_current_line in module ida_kernwin:

pyscv_get_current_line(*args)
    pyscv_get_current_line(py_this, mouse, notags) -> PyObject *
        py_this: PyObject *
        mouse: bool
        notags: bool

Help on function pyscv_get_current_word in module ida_kernwin:

pyscv_get_current_word(*args)
    pyscv_get_current_word(py_this, mouse) -> PyObject *
        py_this: PyObject *
        mouse: bool

Help on function pyscv_get_line in module ida_kernwin:

pyscv_get_line(*args)
    pyscv_get_line(py_this, nline) -> PyObject *
        py_this: PyObject *
        nline: size_t

Help on function pyscv_get_pos in module ida_kernwin:

pyscv_get_pos(*args)
    pyscv_get_pos(py_this, mouse) -> PyObject *
        py_this: PyObject *
        mouse: bool

Help on function pyscv_get_selection in module ida_kernwin:

pyscv_get_selection(*args)
    pyscv_get_selection(py_this) -> PyObject *
        py_this: PyObject *

Help on function pyscv_get_widget in module ida_kernwin:

pyscv_get_widget(*args)
    pyscv_get_widget(py_this) -> TWidget *
        py_this: PyObject *

Help on function pyscv_init in module ida_kernwin:

pyscv_init(*args)
    pyscv_init(py_link, title) -> PyObject *
        py_link: PyObject *
        title: char const *

Help on function pyscv_insert_line in module ida_kernwin:

pyscv_insert_line(*args)
    pyscv_insert_line(py_this, nline, py_sl) -> bool
        py_this: PyObject *
        nline: size_t
        py_sl: PyObject *

Help on function pyscv_is_focused in module ida_kernwin:

pyscv_is_focused(*args)
    pyscv_is_focused(py_this) -> bool
        py_this: PyObject *

Help on function pyscv_jumpto in module ida_kernwin:

pyscv_jumpto(*args)
    pyscv_jumpto(py_this, ln, x, y) -> bool
        py_this: PyObject *
        ln: size_t
        x: int
        y: int

Help on function pyscv_patch_line in module ida_kernwin:

pyscv_patch_line(*args)
    pyscv_patch_line(py_this, nline, offs, value) -> bool
        py_this: PyObject *
        nline: size_t
        offs: size_t
        value: int

Help on function pyscv_refresh in module ida_kernwin:

pyscv_refresh(*args)
    pyscv_refresh(py_this) -> bool
        py_this: PyObject *

Help on function pyscv_show in module ida_kernwin:

pyscv_show(*args)
    pyscv_show(py_this) -> bool
        py_this: PyObject *

Help on function qcleanline in module ida_kernwin:

qcleanline(*args)
    Performs some cleanup operations to a line.
    
    qcleanline(cmt_char='\0', flags=((1 << 0)|(1 << 1))|(1 << 2)) -> str
        @param cmt_char: character that denotes the start of a comment:   the
                         entire text is removed if the line begins with this
                         character (ignoring leading spaces)   all text after
                         (and including) this character is removed if flag
                         CLNL_FINDCMT is set (C++: char)
        @param flags: a combination of  line cleanup flags . defaults to
                      CLNL_TRIM (C++: uint32)
        @return: length of line

Help on class quick_widget_commands_t in module ida_kernwin:

class quick_widget_commands_t
 |  # ----------------------------------------------------------------------
 |  # This provides an alternative to register_action()+attach_action_to_popup_menu()
 |  
 |  Methods defined here:
 |  
 |  __init__(self, callback)
 |  
 |  add(self, caption, flags, menu_index, icon, emb, shortcut)
 |  
 |  populate_popup(self, widget, popup)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  _ah_t = <class 'ida_kernwin._ah_t'>
 |  
 |  
 |  _cmd_t = <class ida_kernwin._cmd_t>

Help on function read_range_selection in module ida_kernwin:

read_range_selection(*args)
    Get the address range for the selected range boundaries, this is the
    convenient function for 'read_selection()'
    
    read_range_selection(v) -> bool
        @param v: view, NULL means the last active window containing addresses
                  (C++: TWidget *)
        @retval: 0 - no range is selected
        @retval: 1 - ok, start ea and end ea are filled

Help on function read_selection in module ida_kernwin:

read_selection(*args)
    read_selection(v, p1, p2) -> bool
    Read the user selection, and store its information in p0 (from) and p1 (to).
    
    This can be used as follows:
    
    
    >>> p0 = idaapi.twinpos_t()
    p1 = idaapi.twinpos_t()
    view = idaapi.get_current_viewer()
    idaapi.read_selection(view, p0, p1)
    
    
    At that point, p0 and p1 hold information for the selection.
    But, the 'at' property of p0 and p1 is not properly typed.
    To specialize it, call #place() on it, passing it the view
    they were retrieved from. Like so:
    
    
    >>> place0 = p0.place(view)
    place1 = p1.place(view)
    
    
    This will effectively "cast" the place into a specialized type,
    holding proper information, depending on the view type (e.g.,
    disassembly, structures, enums, ...)
    
    @param view: The view to retrieve the selection for.
    @param p0: Storage for the "from" part of the selection.
    @param p1: Storage for the "to" part of the selection.
    @return: a bool value indicating success.

Help on function refresh_chooser in module ida_kernwin:

refresh_chooser(*args)
    Mark a non-modal custom chooser for a refresh ( 'ui_refresh_chooser'
    ).
    
    refresh_chooser(title) -> bool
        @param title: title of chooser (C++: const char *)
        @return: success

Help on function refresh_choosers in module ida_kernwin:

refresh_choosers(*args)
    refresh_choosers()

Help on function refresh_idaview in module ida_kernwin:

refresh_idaview(*args)
    Refresh marked windows ( 'ui_refreshmarked' )

Help on function refresh_idaview_anyway in module ida_kernwin:

refresh_idaview_anyway(*args)
    Refresh all disassembly views ( 'ui_refresh' ), forces an immediate
    refresh. Please consider 'request_refresh()' instead

Help on function refresh_navband in module ida_kernwin:

refresh_navband(*args)
    Refresh navigation band if changed ( 'ui_refresh_navband' ).
    
    refresh_navband(force)
        @param force: refresh regardless (C++: bool)

Help on function register_action in module ida_kernwin:

register_action(*args)
    Create a new action ( 'ui_register_action' ). After an action has been
    created, it is possible to attach it to menu items (
    'attach_action_to_menu()' ), or to popup menus (
    'attach_action_to_popup()' ).Because the actions will need to call the
    handler's activate() and update() methods at any time, you shouldn't
    build your action handler on the stack.Please see the SDK's "ht_view"
    plugin for an example how to register actions.
    
    register_action(desc) -> bool
        @param desc: action to register (C++: const  action_desc_t  &)
        @return: success

Help on function register_addon in module ida_kernwin:

register_addon(*args)
    Register an add-on. Show its info in the About box. For plugins,
    should be called from init() function (repeated calls with the same
    product code overwrite previous entries) returns: index of the add-on
    in the list, or -1 on error
    
    register_addon(info) -> int
        @param info (C++: const  addon_info_t  *)

Help on function register_and_attach_to_menu in module ida_kernwin:

register_and_attach_to_menu(*args)
    Helper.You are not encouraged to use this, as it mixes flags for both
    'register_action()' , and 'attach_action_to_menu()' .The only reason
    for its existence is to make it simpler to port existing plugins to
    the new actions API.
    
    register_and_attach_to_menu(menupath, name, label, shortcut, flags, handler, owner, action_desc_t_flags) -> bool
        @param menupath (C++: const char *)
        @param name (C++: const char *)
        @param label (C++: const char *)
        @param shortcut (C++: const char *)
        @param flags (C++: int)
        @param handler (C++: action_handler_t  *)
        @param owner (C++: void *)
        @param action_desc_t_flags (C++: int)

Help on function register_timer in module ida_kernwin:

register_timer(*args)
    register_timer(interval, py_callback) -> PyObject *
    Register a timer
    
    @param interval: Interval in milliseconds
    @param callback: A Python callable that takes no parameters and returns an integer.
                     The callback may return:
                     -1   : to unregister the timer
                     >= 0 : the new or same timer interval
    @return: None or a timer object

Help on function remove_command_interpreter in module ida_kernwin:

remove_command_interpreter(*args)
    Remove command line interpreter ( 'ui_install_cli' )
    
    remove_command_interpreter(cli_idx)
        cli_idx: int

Help on class renderer_pos_info_t in module ida_kernwin:

class renderer_pos_info_t(__builtin__.object)
 |  Proxy of C++ renderer_pos_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: renderer_pos_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> renderer_pos_info_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: renderer_pos_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cx
 |      renderer_pos_info_t_cx_get(self) -> short
 |  
 |  cy
 |      renderer_pos_info_t_cy_get(self) -> short
 |  
 |  node
 |      renderer_pos_info_t_node_get(self) -> int
 |  
 |  sx
 |      renderer_pos_info_t_sx_get(self) -> short
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_renderer_pos_info_t>
 |      delete_renderer_pos_info_t(self)

Help on function repaint_custom_viewer in module ida_kernwin:

repaint_custom_viewer(*args)
    Repaint the given widget immediately ( 'ui_repaint_qwidget' )
    
    repaint_custom_viewer(custom_viewer)
        @param custom_viewer (C++: TWidget *)

Help on function replace_wait_box in module ida_kernwin:

replace_wait_box(*args)
    Replace the label of "Please wait dialog box".
    
    replace_wait_box(format)
        @param format (C++: const char *)

Help on function request_refresh in module ida_kernwin:

request_refresh(*args)
    Request a refresh of a builtin window.
    
    request_refresh(mask, cnd=True)
        @param mask: Window refresh flags (C++: uint64)
        @param cnd: set if true or clear flag otherwise (C++: bool)

Help on function restore_database_snapshot in module ida_kernwin:

restore_database_snapshot(*args)
    Restore a database snapshot. Note: This call is asynchronous. When it
    is completed, the callback will be triggered.
    
    restore_database_snapshot(ss, pyfunc_or_none, pytuple_or_none) -> PyObject *
        @param ss: snapshot instance (see  build_snapshot_tree() ) (C++: const
                   snapshot_t  *)
        pyfunc_or_none: PyObject *
        pytuple_or_none: PyObject *
        @return: false if restoration could not be started (snapshot file was
                 not found).    If the returned value is True then check if
                 the operation succeeded from the callback.

Help on class section_lines_refs_t in module ida_kernwin:

class section_lines_refs_t(__builtin__.object)
 |  Proxy of C++ qvector< twinline_t const * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< twinline_t const * > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> twinline_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> section_lines_refs_t
 |          x: qvector< twinline_t const * > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< twinline_t const * > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: twinline_t const *const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: twinline_t const *const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: twinline_t const *const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> twinline_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< twinline_t const * >::iterator
 |      begin(self) -> qvector< twinline_t const * >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< twinline_t const * >::iterator
 |      end(self) -> qvector< twinline_t const * >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< twinline_t const * >::iterator
 |          it: qvector< twinline_t const * >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< twinline_t const * >::iterator
 |          first: qvector< twinline_t const * >::iterator
 |          last: qvector< twinline_t const * >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> twinline_t const **
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< twinline_t const * >::iterator
 |          x: twinline_t const *const &
 |      
 |      
 |      find(self, x) -> qvector< twinline_t const * >::const_iterator
 |          x: twinline_t const *const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: twinline_t const *const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: twinline_t const **
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< twinline_t const * >::iterator
 |          it: qvector< twinline_t const * >::iterator
 |          x: twinline_t const *const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: twinline_t const *const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: twinline_t const *const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< twinline_t const * > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_section_lines_refs_t>
 |      delete_section_lines_refs_t(self)

Help on class sections_lines_refs_t in module ida_kernwin:

class sections_lines_refs_t(__builtin__.object)
 |  Proxy of C++ qvector< section_lines_refs_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< section_lines_refs_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> section_lines_refs_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sections_lines_refs_t
 |          x: qvector< section_lines_refs_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< section_lines_refs_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: section_lines_refs_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: section_lines_refs_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: section_lines_refs_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> section_lines_refs_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< section_lines_refs_t >::iterator
 |      begin(self) -> qvector< section_lines_refs_t >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< section_lines_refs_t >::iterator
 |      end(self) -> qvector< section_lines_refs_t >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< section_lines_refs_t >::iterator
 |          it: qvector< section_lines_refs_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< section_lines_refs_t >::iterator
 |          first: qvector< section_lines_refs_t >::iterator
 |          last: qvector< section_lines_refs_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> section_lines_refs_t
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< section_lines_refs_t >::iterator
 |          x: section_lines_refs_t const &
 |      
 |      
 |      find(self, x) -> qvector< section_lines_refs_t >::const_iterator
 |          x: section_lines_refs_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=section_lines_refs_t())
 |          x: section_lines_refs_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: section_lines_refs_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: section_lines_refs_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< section_lines_refs_t >::iterator
 |          it: qvector< section_lines_refs_t >::iterator
 |          x: section_lines_refs_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: section_lines_refs_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: section_lines_refs_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< section_lines_refs_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_sections_lines_refs_t>
 |      delete_sections_lines_refs_t(self)

Help on function set_cancelled in module ida_kernwin:

set_cancelled(*args)
    Set "Cancelled" flag ( 'ui_set_cancelled' )

Help on function set_code_viewer_handler in module ida_kernwin:

set_code_viewer_handler(*args)
    Set a handler for a code viewer event ( 'ui_set_custom_viewer_handler'
    ).
    
    set_code_viewer_handler(code_viewer, handler_id, handler_or_data) -> void *
        @param code_viewer: the code viewer (C++: TWidget *)
        @param handler_id: one of CDVH_ in  custom_viewer_handler_id_t (C++:
                           custom_viewer_handler_id_t)
        @param handler_or_data: can be a handler or data. see examples in
                                Functions: custom viewer handlers (C++: void
                                *)
        @return: old value of the handler or data

Help on function set_code_viewer_is_source in module ida_kernwin:

set_code_viewer_is_source(*args)
    Specify that the given code viewer is used to display source code (
    'ui_set_custom_viewer_handler' ).
    
    set_code_viewer_is_source(code_viewer) -> bool
        @param code_viewer (C++: TWidget *)

Help on function set_code_viewer_line_handlers in module ida_kernwin:

set_code_viewer_line_handlers(*args)
    Set handlers for code viewer line events. Any of these handlers may be
    NULL
    
    set_code_viewer_line_handlers(code_viewer, click_handler, popup_handler, dblclick_handler, drawicon_handler, linenum_handler)
        @param code_viewer (C++: TWidget *)
        @param click_handler (C++: code_viewer_lines_click_t  *)
        @param popup_handler (C++: code_viewer_lines_click_t  *)
        @param dblclick_handler (C++: code_viewer_lines_click_t  *)
        @param drawicon_handler (C++: code_viewer_lines_icon_t  *)
        @param linenum_handler (C++: code_viewer_lines_linenum_t  *)

Help on function set_code_viewer_lines_alignment in module ida_kernwin:

set_code_viewer_lines_alignment(*args)
    Set alignment for lines in a code viewer (
    'ui_set_custom_viewer_handler' ).
    
    set_code_viewer_lines_alignment(code_viewer, align) -> bool
        @param code_viewer (C++: TWidget *)
        @param align (C++: int)

Help on function set_code_viewer_lines_icon_margin in module ida_kernwin:

set_code_viewer_lines_icon_margin(*args)
    Set space allowed for icons in the margin of a code viewer (
    'ui_set_custom_viewer_handler' ).
    
    set_code_viewer_lines_icon_margin(code_viewer, margin) -> bool
        @param code_viewer (C++: TWidget *)
        @param margin (C++: int)

Help on function set_code_viewer_lines_radix in module ida_kernwin:

set_code_viewer_lines_radix(*args)
    Set radix for values displayed in a code viewer (
    'ui_set_custom_viewer_handler' ).
    
    set_code_viewer_lines_radix(code_viewer, radix) -> bool
        @param code_viewer (C++: TWidget *)
        @param radix (C++: int)

Help on function set_code_viewer_user_data in module ida_kernwin:

set_code_viewer_user_data(*args)
    Set the user data on a code viewer ( 'ui_set_custom_viewer_handler' ).
    
    set_code_viewer_user_data(code_viewer, ud) -> bool
        @param code_viewer (C++: TWidget *)
        @param ud (C++: void *)

Help on function set_custom_viewer_qt_aware in module ida_kernwin:

set_custom_viewer_qt_aware(*args)
    Allow the given viewer to interpret Qt events (
    'ui_set_custom_viewer_handler' )
    
    set_custom_viewer_qt_aware(custom_viewer) -> bool
        @param custom_viewer (C++: TWidget *)

Help on function set_dock_pos in module ida_kernwin:

set_dock_pos(*args)
    set_dock_pos(src_ctrl, dest_ctrl, orient, left=0, top=0, right=0, bottom=0) -> bool
    Sets the dock orientation of a window relatively to another window.
    
    @param src: Source docking control
    @param dest: Destination docking control
    @param orient: One of DOR_XXXX constants
    @param left, top, right, bottom: These parameter if DOR_FLOATING is used, or if you want to specify the width of docked windows
    @return: Boolean
    
    Example:
        set_dock_pos('Structures', 'Enums', DOR_RIGHT) <- docks the Structures window to the right of Enums window

Help on function set_highlight in module ida_kernwin:

set_highlight(*args)
    Set the highlighted identifier in the viewer ( 'ui_set_highlight' ).
    
    set_highlight(viewer, str, flags) -> bool
        @param viewer: the viewer (C++: TWidget *)
        @param str: the text to match, or NULL to remove current (C++: const
                    char *)
        @param flags: combination of HIF_... bits (see  set_highlightr flags )
                      (C++: int)
        @return: false if an error occurred

Help on function set_nav_colorizer in module ida_kernwin:

set_nav_colorizer(*args)
    set_nav_colorizer(new_py_colorizer) -> PyObject *
    Set a new colorizer for the navigation band.
    
    The 'callback' is a function of 2 arguments:
       - ea (the EA to colorize for)
       - nbytes (the number of bytes at that EA)
    and must return a 'long' value.
    
    The previous colorizer is returned, allowing
    the new 'callback' to use 'call_nav_colorizer'
    with it.
    
    Note that the previous colorizer is returned
    only the first time set_nav_colorizer() is called:
    due to the way the colorizers API is defined in C,
    it is impossible to chain more than 2 colorizers
    in IDAPython: the original, IDA-provided colorizer,
    and a user-provided one.
    
    Example: colorizer inverting the color provided by the IDA colorizer:
        def my_colorizer(ea, nbytes):
            global ida_colorizer
            orig = idaapi.call_nav_colorizer(ida_colorizer, ea, nbytes)
            return long(~orig)
    
        ida_colorizer = idaapi.set_nav_colorizer(my_colorizer)

Help on function set_view_renderer_type in module ida_kernwin:

set_view_renderer_type(*args)
    Set the type of renderer to use in a view ( 'ui_set_renderer_type' )
    
    set_view_renderer_type(v, rt)
        @param v (C++: TWidget *)
        @param rt (C++: tcc_renderer_type_t)

Help on function show_wait_box in module ida_kernwin:

show_wait_box(*args)
    Display a dialog box with "Please wait...". If the text message starts
    with "HIDECANCEL\n", the cancel buttonwon't be displayed in the dialog
    box and you don't need to checkfor cancellations with
    'user_cancelled()' . Plugins must call 'hide_wait_box()' to close the
    dialog box, otherwise the user interface will be disabled.Note that,
    if the wait dialog is already visible, 'show_wait_box()' will1) push
    the currently-displayed text on a stack2) display the new textThen,
    when 'hide_wait_box()' is called, if that stack isn't empty its
    toplabel will be popped and restored in the wait dialog.This implies
    that a plugin should call 'hide_wait_box()' exactly as manytimes as it
    called 'show_wait_box()' , or the wait dialog might remainvisible and
    block the UI.Also, in case the plugin knows the wait dialog is
    currently displayed,alternatively it can call 'replace_wait_box()' ,
    to replace the text of thedialog without pushing the currently-
    displayed text on the stack.
    
    show_wait_box(message)
        message: char const *

Help on class simplecustviewer_t in module ida_kernwin:

class simplecustviewer_t(__builtin__.object)
 |  The base class for implementing simple custom viewers
 |  
 |  Methods defined here:
 |  
 |  AddLine(self, line, fgcolor=None, bgcolor=None)
 |      Adds a colored line to the view
 |      @return: Boolean
 |  
 |  ClearLines(self)
 |      Clears all the lines
 |  
 |  Close(self)
 |      Destroys the view.
 |      One has to call Create() afterwards.
 |      Show() can be called and it will call Create() internally.
 |      @return: Boolean
 |  
 |  Count(self)
 |      Returns the number of lines in the view
 |  
 |  Create(self, title)
 |      Creates the custom view. This should be the first method called after instantiation
 |      
 |      @param title: The title of the view
 |      @return: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
 |               In this case better close existing windows
 |  
 |  DelLine(self, lineno)
 |      Deletes an existing line
 |      @return: Boolean
 |  
 |  EditLine(self, lineno, line, fgcolor=None, bgcolor=None)
 |      Edits an existing line.
 |      @return: Boolean
 |  
 |  GetCurrentLine(self, mouse=0, notags=0)
 |      Returns the current line.
 |      @param mouse: Current line at mouse pos
 |      @param notags: If True then tag_remove() will be called before returning the line
 |      @return: Returns the current line (colored or uncolored) or None on failure
 |  
 |  GetCurrentWord(self, mouse=0)
 |      Returns the current word
 |      @param mouse: Use mouse position or cursor position
 |      @return: None if failed or a String containing the current word at mouse or cursor
 |  
 |  GetLine(self, lineno)
 |      Returns a line
 |      @param lineno: The line number
 |      @return:
 |          Returns a tuple (colored_line, fgcolor, bgcolor) or None
 |  
 |  GetLineNo(self, mouse=0)
 |      Calls GetPos() and returns the current line number or -1 on failure
 |  
 |  GetPos(self, mouse=0)
 |      Returns the current cursor or mouse position.
 |      @param mouse: return mouse position
 |      @return: Returns a tuple (lineno, x, y)
 |  
 |  GetSelection(self)
 |      Returns the selected range or None
 |      @return:
 |          - tuple(x1, y1, x2, y2)
 |          - None if no selection
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  InsertLine(self, lineno, line, fgcolor=None, bgcolor=None)
 |      Inserts a line in the given position
 |      @return: Boolean
 |  
 |  IsFocused(self)
 |      Returns True if the current view is the focused view
 |  
 |  Jump(self, lineno, x=0, y=0)
 |  
 |  OnPopup(self, form, popup_handle)
 |      Context menu popup is about to be shown. Create items dynamically if you wish
 |      @return: Boolean. True if you handled the event
 |  
 |  PatchLine(self, lineno, offs, value)
 |      Patches an existing line character at the given offset. This is a low level function. You must know what you're doing
 |  
 |  Refresh(self)
 |  
 |  RefreshCurrent(self)
 |      Refreshes the current line only
 |  
 |  Show(self)
 |      Shows an already created view. It the view was close, then it will call Create() for you
 |      @return: Boolean
 |  
 |  __init__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  _simplecustviewer_t__make_sl_arg = __make_sl_arg(line, fgcolor=None, bgcolor=None)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  UI_Hooks_Trampoline = <class 'ida_kernwin.UI_Hooks_Trampoline'>

Help on class simpleline_place_t in module ida_kernwin:

class simpleline_place_t(place_t)
 |  Proxy of C++ simpleline_place_t class.
 |  
 |  Method resolution order:
 |      simpleline_place_t
 |      place_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  n
 |      simpleline_place_t_n_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_simpleline_place_t>
 |      delete_simpleline_place_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args)
 |      _print(self, out_buf, ud)
 |          out_buf: qstring *
 |          ud: void *
 |  
 |  adjust(self, *args)
 |      Adjust the current location to point to a displayable object. This
 |      function validates the location and makes sure that it points to an
 |      existing object. For example, if the location points to the middle of
 |      an instruction, it will be adjusted to point to the beginning of the
 |      instruction.
 |      
 |      adjust(self, ud)
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |  
 |  beginning(self, *args)
 |      Are we at the first displayable object?.
 |      
 |      beginning(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: true if the current location points to the first displayable
 |                   object
 |  
 |  clone(self, *args)
 |      Clone the location.
 |  
 |  compare(self, *args)
 |      Deprecated. Please consider compare2(const place_t *, void *) instead.
 |      
 |      compare(self, t2) -> int
 |          @param t2 (C++: const  place_t  *)
 |  
 |  compare2(self, *args)
 |      Compare two locations except line numbers (lnnum). This function is
 |      used to organize loops. For example, if the user has selected an
 |      range, its boundaries are remembered as location objects. Any
 |      operation within the selection will have the following look: for (
 |      loc=starting_location; loc < ending_location; loc.next() ) In this
 |      loop, the comparison function is used.
 |      
 |      compare2(self, t2, arg3) -> int
 |          @param t2: the place to compare this one to. (C++: const  place_t  *)
 |          arg3: void *
 |          @retval: -1 - if the current location is less than 't2'
 |          @retval: 0 - if the current location is equal to than 't2'
 |          @retval: 1 - if the current location is greater than 't2'
 |  
 |  copyfrom(self, *args)
 |      Copy the specified location object to the current object.
 |      
 |      copyfrom(self, _from)
 |          @param _from (C++: const  place_t  *)
 |  
 |  deserialize(self, *args)
 |      De-serialize into this instance. 'pptr' should be incremented by as
 |      many bytes as de-serialization consumed.
 |      
 |      deserialize(self, _in) -> bool
 |          in: bytevec_t const &
 |          @return: whether de-serialization was successful
 |  
 |  ending(self, *args)
 |      Are we at the last displayable object?.
 |      
 |      ending(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: true if the current location points to the last displayable
 |                   object
 |  
 |  enter(self, *args)
 |      Visit this place, possibly 'unhiding' a section of text. If entering
 |      that place required some expanding, a 'place_t' should be returned
 |      that represents that section, plus some flags for later use by '
 |      'leave()' '.
 |      
 |      enter(self, arg2) -> place_t
 |          arg2: uint32 *
 |          @return: a  place_t  corresponding to the beginning of the section of
 |                   text that had to be expanded. That  place_t 's  leave()  will
 |                   be called with the flags contained in 'out_flags' when the
 |                   user navigates away from it.
 |  
 |  generate(self, *args)
 |      Generate text lines for the current location.
 |      
 |      generate(self, ud, maxsize) -> PyObject *
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @param maxsize: the maximum number of lines to generate (C++: int)
 |          @return: number of generated lines
 |  
 |  id(self, *args)
 |      Get the place's ID (i.e., the value returned by
 |      'register_place_class()' )
 |  
 |  leave(self, *args)
 |      Leave this place, possibly 'hiding' a section of text that was
 |      previously expanded (at 'enter()' -time.)
 |      
 |      leave(self, arg2)
 |          arg2: uint32
 |  
 |  makeplace(self, *args)
 |      Map a number to a location. When the user clicks on the scrollbar and
 |      drags it, we need to determine the location corresponding to the new
 |      scrollbar position. This function is used to determine it. It builds a
 |      location object for the specified 'x' and returns a pointer to it.
 |      
 |      makeplace(self, ud, x, lnnum) -> place_t
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @param x: number to map (C++: uval_t)
 |          @param lnnum: line number to initialize 'lnnum' (C++: int)
 |          @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
 |  
 |  name(self, *args)
 |      Get this place type name. All instances of a given class must return
 |      the same string.
 |  
 |  next(self, *args)
 |      Move to the next displayable location.
 |      
 |      next(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: success
 |  
 |  prev(self, *args)
 |      Move to the previous displayable location.
 |      
 |      prev(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: success
 |  
 |  rebase(self, *args)
 |      Rebase the place instance
 |      
 |      rebase(self, arg2) -> bool
 |          arg2: segm_move_infos_t const &
 |          @return: true if place was rebased, false otherwise
 |  
 |  serialize(self, *args)
 |      Serialize this instance. It is fundamental that all instances of a
 |      particular subclass of of 'place_t' occupy the same number of bytes
 |      when serialized.
 |  
 |  toea(self, *args)
 |      Map the location to an ea_t.
 |  
 |  touval(self, *args)
 |      Map the location to a number. This mapping is used to draw the
 |      vertical scrollbar.
 |      
 |      touval(self, ud) -> uval_t
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args)
 |      as_enumplace_t(p) -> enumplace_t
 |          p: place_t *
 |  
 |  as_idaplace_t(*args)
 |      as_idaplace_t(p) -> idaplace_t
 |          p: place_t *
 |  
 |  as_simpleline_place_t(*args)
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |          p: place_t *
 |  
 |  as_structplace_t(*args)
 |      as_structplace_t(p) -> structplace_t
 |          p: place_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      place_t_lnnum_get(self) -> int

Help on class simpleline_t in module ida_kernwin:

class simpleline_t(__builtin__.object)
 |  Proxy of C++ simpleline_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> simpleline_t
 |          c: color_t
 |          str: char const *
 |      
 |      
 |      __init__(self, str) -> simpleline_t
 |          str: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bgcolor
 |      simpleline_t_bgcolor_get(self) -> bgcolor_t
 |  
 |  color
 |      simpleline_t_color_get(self) -> color_t
 |  
 |  line
 |      simpleline_t_line_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_simpleline_t>
 |      delete_simpleline_t(self)

Help on function str2ea in module ida_kernwin:

str2ea(*args)
    str2ea(str, screenEA=BADADDR) -> ea_t
    Converts a string express to EA. The expression evaluator may be called as well.
    
    @return: BADADDR or address value

Help on function str2user in module ida_pro:

str2user(*args)
    str2user(str) -> PyObject *
    Insert C-style escape characters to string
    
    @return: new string with escape characters inserted

Help on function strarray in module ida_kernwin:

strarray(*args)
    Find a line with the specified code in the 'strarray_t' array. If the
    last element of the array has code==0 then it is considered as the
    default entry.If no default entry exists and the code is not found,
    'strarray()' returns "".
    
    strarray(array, array_size, code) -> char const *
        @param array (C++: const  strarray_t  *)
        @param array_size (C++: size_t)
        @param code (C++: int)

Help on class strarray_t in module ida_kernwin:

class strarray_t(__builtin__.object)
 |  Proxy of C++ strarray_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strarray_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  code
 |      strarray_t_code_get(self) -> int
 |  
 |  text
 |      strarray_t_text_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_strarray_t>
 |      delete_strarray_t(self)

Help on class structplace_t in module ida_kernwin:

class structplace_t(place_t)
 |  Proxy of C++ structplace_t class.
 |  
 |  Method resolution order:
 |      structplace_t
 |      place_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  idx
 |      structplace_t_idx_get(self) -> uval_t
 |  
 |  offset
 |      structplace_t_offset_get(self) -> uval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_structplace_t>
 |      delete_structplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args)
 |      _print(self, out_buf, ud)
 |          out_buf: qstring *
 |          ud: void *
 |  
 |  adjust(self, *args)
 |      Adjust the current location to point to a displayable object. This
 |      function validates the location and makes sure that it points to an
 |      existing object. For example, if the location points to the middle of
 |      an instruction, it will be adjusted to point to the beginning of the
 |      instruction.
 |      
 |      adjust(self, ud)
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |  
 |  beginning(self, *args)
 |      Are we at the first displayable object?.
 |      
 |      beginning(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: true if the current location points to the first displayable
 |                   object
 |  
 |  clone(self, *args)
 |      Clone the location.
 |  
 |  compare(self, *args)
 |      Deprecated. Please consider compare2(const place_t *, void *) instead.
 |      
 |      compare(self, t2) -> int
 |          @param t2 (C++: const  place_t  *)
 |  
 |  compare2(self, *args)
 |      Compare two locations except line numbers (lnnum). This function is
 |      used to organize loops. For example, if the user has selected an
 |      range, its boundaries are remembered as location objects. Any
 |      operation within the selection will have the following look: for (
 |      loc=starting_location; loc < ending_location; loc.next() ) In this
 |      loop, the comparison function is used.
 |      
 |      compare2(self, t2, arg3) -> int
 |          @param t2: the place to compare this one to. (C++: const  place_t  *)
 |          arg3: void *
 |          @retval: -1 - if the current location is less than 't2'
 |          @retval: 0 - if the current location is equal to than 't2'
 |          @retval: 1 - if the current location is greater than 't2'
 |  
 |  copyfrom(self, *args)
 |      Copy the specified location object to the current object.
 |      
 |      copyfrom(self, _from)
 |          @param _from (C++: const  place_t  *)
 |  
 |  deserialize(self, *args)
 |      De-serialize into this instance. 'pptr' should be incremented by as
 |      many bytes as de-serialization consumed.
 |      
 |      deserialize(self, _in) -> bool
 |          in: bytevec_t const &
 |          @return: whether de-serialization was successful
 |  
 |  ending(self, *args)
 |      Are we at the last displayable object?.
 |      
 |      ending(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: true if the current location points to the last displayable
 |                   object
 |  
 |  enter(self, *args)
 |      Visit this place, possibly 'unhiding' a section of text. If entering
 |      that place required some expanding, a 'place_t' should be returned
 |      that represents that section, plus some flags for later use by '
 |      'leave()' '.
 |      
 |      enter(self, arg2) -> place_t
 |          arg2: uint32 *
 |          @return: a  place_t  corresponding to the beginning of the section of
 |                   text that had to be expanded. That  place_t 's  leave()  will
 |                   be called with the flags contained in 'out_flags' when the
 |                   user navigates away from it.
 |  
 |  generate(self, *args)
 |      Generate text lines for the current location.
 |      
 |      generate(self, ud, maxsize) -> PyObject *
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @param maxsize: the maximum number of lines to generate (C++: int)
 |          @return: number of generated lines
 |  
 |  id(self, *args)
 |      Get the place's ID (i.e., the value returned by
 |      'register_place_class()' )
 |  
 |  leave(self, *args)
 |      Leave this place, possibly 'hiding' a section of text that was
 |      previously expanded (at 'enter()' -time.)
 |      
 |      leave(self, arg2)
 |          arg2: uint32
 |  
 |  makeplace(self, *args)
 |      Map a number to a location. When the user clicks on the scrollbar and
 |      drags it, we need to determine the location corresponding to the new
 |      scrollbar position. This function is used to determine it. It builds a
 |      location object for the specified 'x' and returns a pointer to it.
 |      
 |      makeplace(self, ud, x, lnnum) -> place_t
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @param x: number to map (C++: uval_t)
 |          @param lnnum: line number to initialize 'lnnum' (C++: int)
 |          @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
 |  
 |  name(self, *args)
 |      Get this place type name. All instances of a given class must return
 |      the same string.
 |  
 |  next(self, *args)
 |      Move to the next displayable location.
 |      
 |      next(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: success
 |  
 |  prev(self, *args)
 |      Move to the previous displayable location.
 |      
 |      prev(self, ud) -> bool
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |          @return: success
 |  
 |  rebase(self, *args)
 |      Rebase the place instance
 |      
 |      rebase(self, arg2) -> bool
 |          arg2: segm_move_infos_t const &
 |          @return: true if place was rebased, false otherwise
 |  
 |  serialize(self, *args)
 |      Serialize this instance. It is fundamental that all instances of a
 |      particular subclass of of 'place_t' occupy the same number of bytes
 |      when serialized.
 |  
 |  toea(self, *args)
 |      Map the location to an ea_t.
 |  
 |  touval(self, *args)
 |      Map the location to a number. This mapping is used to draw the
 |      vertical scrollbar.
 |      
 |      touval(self, ud) -> uval_t
 |          @param ud: pointer to user-defined context data. Is supplied by
 |                     linearray_t (C++: void *)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args)
 |      as_enumplace_t(p) -> enumplace_t
 |          p: place_t *
 |  
 |  as_idaplace_t(*args)
 |      as_idaplace_t(p) -> idaplace_t
 |          p: place_t *
 |  
 |  as_simpleline_place_t(*args)
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |          p: place_t *
 |  
 |  as_structplace_t(*args)
 |      as_structplace_t(p) -> structplace_t
 |          p: place_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      place_t_lnnum_get(self) -> int

Help on class sync_source_t in module ida_kernwin:

class sync_source_t(__builtin__.object)
 |  Proxy of C++ sync_source_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, _o) -> bool
 |          _o: sync_source_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _view) -> sync_source_t
 |          _view: TWidget const *
 |      
 |      
 |      __init__(self, _regname) -> sync_source_t
 |          _regname: char const *
 |  
 |  __ne__(self, *args)
 |      __ne__(self, _o) -> bool
 |          _o: sync_source_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_register(self, *args)
 |      get_register(self) -> char const *
 |  
 |  get_widget(self, *args)
 |      get_widget(self) -> TWidget const *
 |  
 |  is_register(self, *args)
 |      is_register(self) -> bool
 |  
 |  is_widget(self, *args)
 |      is_widget(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_sync_source_t>
 |      delete_sync_source_t(self)

Help on class sync_source_vec_t in module ida_kernwin:

class sync_source_vec_t(__builtin__.object)
 |  Proxy of C++ qvector< sync_source_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< sync_source_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> sync_source_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sync_source_vec_t
 |          x: qvector< sync_source_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< sync_source_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: sync_source_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: sync_source_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: sync_source_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> sync_source_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> sync_source_t
 |      begin(self) -> sync_source_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> sync_source_t
 |      end(self) -> sync_source_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> sync_source_t
 |          it: qvector< sync_source_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> sync_source_t
 |          first: qvector< sync_source_t >::iterator
 |          last: qvector< sync_source_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> sync_source_t
 |  
 |  find(self, *args)
 |      find(self, x) -> sync_source_t
 |          x: sync_source_t const &
 |      
 |      
 |      find(self, x) -> sync_source_t
 |          x: sync_source_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: sync_source_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: sync_source_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> sync_source_t
 |          it: qvector< sync_source_t >::iterator
 |          x: sync_source_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: sync_source_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< sync_source_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_sync_source_vec_t>
 |      delete_sync_source_vec_t(self)

Help on function sync_sources in module ida_kernwin:

sync_sources(*args)
    [Un]synchronize sources
    
    sync_sources(what, _with, sync) -> bool
        @param what (C++: const  sync_source_t  &)
        @param _with (C++: const  sync_source_t  &)
        @param sync (C++: bool)
        @return: success

Help on class synced_group_t in module ida_kernwin:

class synced_group_t(sync_source_vec_t)
 |  Proxy of C++ synced_group_t class.
 |  
 |  Method resolution order:
 |      synced_group_t
 |      sync_source_vec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> synced_group_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  has(self, *args)
 |      has(self, ss) -> bool
 |          @param ss (C++: const  sync_source_t  &)
 |  
 |  has_register(self, *args)
 |      has_register(self, r) -> bool
 |          @param r (C++: const char *)
 |  
 |  has_widget(self, *args)
 |      has_widget(self, v) -> bool
 |          @param v (C++: const TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_synced_group_t>
 |      delete_synced_group_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from sync_source_vec_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< sync_source_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> sync_source_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< sync_source_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: sync_source_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: sync_source_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: sync_source_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> sync_source_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> sync_source_t
 |      begin(self) -> sync_source_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> sync_source_t
 |      end(self) -> sync_source_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> sync_source_t
 |          it: qvector< sync_source_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> sync_source_t
 |          first: qvector< sync_source_t >::iterator
 |          last: qvector< sync_source_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> sync_source_t
 |  
 |  find(self, *args)
 |      find(self, x) -> sync_source_t
 |          x: sync_source_t const &
 |      
 |      
 |      find(self, x) -> sync_source_t
 |          x: sync_source_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: sync_source_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> sync_source_t
 |          it: qvector< sync_source_t >::iterator
 |          x: sync_source_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: sync_source_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< sync_source_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from sync_source_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function take_database_snapshot in module ida_kernwin:

take_database_snapshot(*args)
    Take a database snapshot ( 'ui_take_database_snapshot' ).
    
    take_database_snapshot(ss) -> PyObject *
        @param ss: in/out parameter.   in: description, flags   out: filename,
                   id (C++: snapshot_t  *)
        @return: success

Help on class text_t in module ida_kernwin:

class text_t(__builtin__.object)
 |  Proxy of C++ qvector< twinline_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> twinline_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> text_t
 |          x: qvector< twinline_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: twinline_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> twinline_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> twinline_t
 |      begin(self) -> twinline_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> twinline_t
 |      end(self) -> twinline_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> twinline_t
 |          it: qvector< twinline_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> twinline_t
 |          first: qvector< twinline_t >::iterator
 |          last: qvector< twinline_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> twinline_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=twinline_t())
 |          x: twinline_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: twinline_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> twinline_t
 |          it: qvector< twinline_t >::iterator
 |          x: twinline_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: twinline_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: twinline_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< twinline_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_text_t>
 |      delete_text_t(self)

Help on class textctrl_info_t in module ida_kernwin:

class textctrl_info_t(ida_idaapi.py_clinked_object_t)
 |  Class representing textctrl_info_t
 |  
 |  Method resolution order:
 |      textctrl_info_t
 |      ida_idaapi.py_clinked_object_t
 |      ida_idaapi.pyidc_opaque_object_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __get_flags__(self)
 |      Returns the flags value
 |  
 |  __get_tabsize__(self)
 |      Returns the tabsize value
 |  
 |  __init__(self, text='', flags=0, tabsize=0)
 |  
 |  __set_flags__(self, flags)
 |      Sets the flags value
 |  
 |  __set_tabsize__(self, tabsize)
 |      Sets the tabsize value
 |  
 |  _create_clink(self)
 |  
 |  _del_clink(self, lnk)
 |  
 |  _get_clink_ptr(self)
 |  
 |  _textctrl_info_t__get_text = __get_text(self)
 |      Sets the text value
 |  
 |  _textctrl_info_t__set_text = __set_text(self, s)
 |      Sets the text value
 |  
 |  assign(self, other)
 |      Copies the contents of 'other' to 'self'
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  flags
 |      Returns the flags value
 |  
 |  tabsize
 |      Returns the tabsize value
 |  
 |  text
 |      Sets the text value
 |  
 |  value
 |      Sets the text value
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  TXTF_ACCEPTTABS = 2
 |  
 |  TXTF_AUTOINDENT = 1
 |  
 |  TXTF_FIXEDFONT = 32
 |  
 |  TXTF_MODIFIED = 16
 |  
 |  TXTF_READONLY = 4
 |  
 |  TXTF_SELECTED = 8
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  __del__(self)
 |      Delete the link upon object destruction (only if not static)
 |  
 |  _free(self)
 |      Explicitly delete the link (only if not static)
 |  
 |  copy(self)
 |      Returns a new copy of this class
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  clink
 |  
 |  clink_ptr
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on function textctrl_info_t_assign in module ida_kernwin:

textctrl_info_t_assign(*args)
    textctrl_info_t_assign(_self, other) -> bool
        self: PyObject *
        other: PyObject *

Help on function textctrl_info_t_create in module ida_kernwin:

textctrl_info_t_create(*args)
    textctrl_info_t_create() -> PyObject *

Help on function textctrl_info_t_destroy in module ida_kernwin:

textctrl_info_t_destroy(*args)
    textctrl_info_t_destroy(py_obj) -> bool
        py_obj: PyObject *

Help on function textctrl_info_t_get_clink in module ida_kernwin:

textctrl_info_t_get_clink(*args)
    textctrl_info_t_get_clink(_self) -> textctrl_info_t *
        self: PyObject *

Help on function textctrl_info_t_get_clink_ptr in module ida_kernwin:

textctrl_info_t_get_clink_ptr(*args)
    textctrl_info_t_get_clink_ptr(_self) -> PyObject *
        self: PyObject *

Help on function textctrl_info_t_get_flags in module ida_kernwin:

textctrl_info_t_get_flags(*args)
    textctrl_info_t_get_flags(_self) -> unsigned int
        self: PyObject *

Help on function textctrl_info_t_get_tabsize in module ida_kernwin:

textctrl_info_t_get_tabsize(*args)
    textctrl_info_t_get_tabsize(_self) -> unsigned int
        self: PyObject *

Help on function textctrl_info_t_get_text in module ida_kernwin:

textctrl_info_t_get_text(*args)
    textctrl_info_t_get_text(_self) -> char const *
        self: PyObject *

Help on function textctrl_info_t_set_flags in module ida_kernwin:

textctrl_info_t_set_flags(*args)
    textctrl_info_t_set_flags(_self, flags) -> bool
        self: PyObject *
        flags: unsigned int

Help on function textctrl_info_t_set_tabsize in module ida_kernwin:

textctrl_info_t_set_tabsize(*args)
    textctrl_info_t_set_tabsize(_self, tabsize) -> bool
        self: PyObject *
        tabsize: unsigned int

Help on function textctrl_info_t_set_text in module ida_kernwin:

textctrl_info_t_set_text(*args)
    textctrl_info_t_set_text(_self, s) -> bool
        self: PyObject *
        s: char const *

Help on class twinline_t in module ida_kernwin:

class twinline_t(__builtin__.object)
 |  Proxy of C++ twinline_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> twinline_t
 |          t: place_t *
 |          pc: color_t
 |          bc: bgcolor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  at
 |      twinline_t_at_get(self) -> place_t
 |  
 |  bg_color
 |      twinline_t_bg_color_get(self) -> bgcolor_t
 |  
 |  is_default
 |      twinline_t_is_default_get(self) -> bool
 |  
 |  line
 |      twinline_t_line_get(self) -> qstring *
 |  
 |  prefix_color
 |      twinline_t_prefix_color_get(self) -> color_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_twinline_t>
 |      delete_twinline_t(self)

Help on class twinpos_t in module ida_kernwin:

class twinpos_t(__builtin__.object)
 |  Proxy of C++ twinpos_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> twinpos_t
 |          t: place_t *
 |      
 |      
 |      __init__(self, t, x0) -> twinpos_t
 |          t: place_t *
 |          x0: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  place(self, view)
 |  
 |  place_as_enumplace_t(self)
 |  
 |  place_as_idaplace_t(self)
 |  
 |  place_as_simpleline_place_t(self)
 |  
 |  place_as_structplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  at
 |      twinpos_t_at_get(self) -> place_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      twinpos_t_x_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_twinpos_t>
 |      delete_twinpos_t(self)

Help on function ui_load_new_file in module ida_kernwin:

ui_load_new_file(*args)
    Display a load file dialog and load file ( 'ui_load_file' ).
    
    ui_load_new_file(temp_file, filename, pli, neflags, ploaders) -> bool
        @param temp_file: name of the file with the extracted archive member.
                          (C++: qstring  *)
        @param filename: the name of input file as is, library or archive name
                         (C++: qstring  *)
        @param pli: loader input source, may be changed to point to temp_file
                    (C++: linput_t **)
        @param neflags: combination of NEF_... bits (see  Load file flags )
                        (C++: ushort)
        @param ploaders: list of loaders which accept file, may be changed for
                         loaders of temp_file (C++: load_info_t  **)
        @retval: true - file was successfully loaded
        @retval: false - otherwise

Help on class ui_requests_t in module ida_kernwin:

class ui_requests_t(__builtin__.object)
 |  Proxy of C++ ui_requests_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_requests_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ui_requests_t>
 |      delete_ui_requests_t(self)

Help on function ui_run_debugger in module ida_kernwin:

ui_run_debugger(*args)
    Load a debugger plugin and run the specified program ( 'ui_run_dbg' ).
    
    ui_run_debugger(dbgopts, exename, argc, argv) -> bool
        @param dbgopts: value of the -r command line switch (C++: const char
                        *)
        @param exename: name of the file to run (C++: const char *)
        @param argc: number of arguments for the executable (C++: int)
        @param argv: argument vector (C++: const char *const *)
        @return: success

Help on function unmark_selection in module ida_kernwin:

unmark_selection(*args)
    Unmark selection ( 'ui_unmarksel' )

Help on function unregister_action in module ida_kernwin:

unregister_action(*args)
    Delete a previously-registered action ( 'ui_unregister_action' ).
    
    unregister_action(name) -> bool
        @param name: name of action (C++: const char *)
        @return: success

Help on function unregister_timer in module ida_kernwin:

unregister_timer(*args)
    unregister_timer(py_timerctx) -> bool
    Unregister a timer
    
    @param timer_obj: a timer object previously returned by a register_timer()
    @return: Boolean
    @note: After the timer has been deleted, the timer_obj will become invalid.

Help on function update_action_checkable in module ida_kernwin:

update_action_checkable(*args)
    Update an action's checkability ( 'ui_update_action_attr' ).
    
    update_action_checkable(name, checkable) -> bool
        @param name: action name (C++: const char *)
        @param checkable: new checkability (C++: bool)
        @return: success

Help on function update_action_checked in module ida_kernwin:

update_action_checked(*args)
    Update an action's checked state ( 'ui_update_action_attr' ).
    
    update_action_checked(name, checked) -> bool
        @param name: action name (C++: const char *)
        @param checked: new checked state (C++: bool)
        @return: success

Help on function update_action_icon in module ida_kernwin:

update_action_icon(*args)
    Update an action's icon ( 'ui_update_action_attr' ).
    
    update_action_icon(name, icon) -> bool
        @param name: action name (C++: const char *)
        @param icon: new icon id (C++: int)
        @return: success

Help on function update_action_label in module ida_kernwin:

update_action_label(*args)
    Update an action's label ( 'ui_update_action_attr' ).
    
    update_action_label(name, label) -> bool
        @param name: action name (C++: const char *)
        @param label: new label (C++: const char *)
        @return: success

Help on function update_action_shortcut in module ida_kernwin:

update_action_shortcut(*args)
    Update an action's shortcut ( 'ui_update_action_attr' ).
    
    update_action_shortcut(name, shortcut) -> bool
        @param name: action name (C++: const char *)
        @param shortcut: new shortcut (C++: const char *)
        @return: success

Help on function update_action_state in module ida_kernwin:

update_action_state(*args)
    Update an action's state ( 'ui_update_action_attr' ).
    
    update_action_state(name, state) -> bool
        @param name: action name (C++: const char *)
        @param state: new state (C++: action_state_t)
        @return: success

Help on function update_action_tooltip in module ida_kernwin:

update_action_tooltip(*args)
    Update an action's tooltip ( 'ui_update_action_attr' ).
    
    update_action_tooltip(name, tooltip) -> bool
        @param name: action name (C++: const char *)
        @param tooltip: new tooltip (C++: const char *)
        @return: success

Help on function update_action_visibility in module ida_kernwin:

update_action_visibility(*args)
    Update an action's visibility ( 'ui_update_action_attr' ).
    
    update_action_visibility(name, visible) -> bool
        @param name: action name (C++: const char *)
        @param visible: new visibility (C++: bool)
        @return: success

Help on function user_cancelled in module ida_kernwin:

user_cancelled(*args)
    Test the ctrl-break flag ( 'ui_test_cancelled' ).

Help on class view_mouse_event_location_t in module ida_kernwin:

class view_mouse_event_location_t(__builtin__.object)
 |  Proxy of C++ view_mouse_event_location_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> view_mouse_event_location_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      view_mouse_event_location_t_ea_get(self) -> ea_t
 |  
 |  item
 |      view_mouse_event_location_t_item_get(self) -> selection_item_t const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_view_mouse_event_location...
 |      delete_view_mouse_event_location_t(self)

Help on class view_mouse_event_t in module ida_kernwin:

class view_mouse_event_t(__builtin__.object)
 |  Proxy of C++ view_mouse_event_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> view_mouse_event_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  button
 |      view_mouse_event_t_button_get(self) -> vme_button_t
 |  
 |  location
 |      view_mouse_event_t_location_get(self) -> view_mouse_event_location_t
 |  
 |  renderer_pos
 |      view_mouse_event_t_renderer_pos_get(self) -> renderer_pos_info_t
 |  
 |  rtype
 |      view_mouse_event_t_rtype_get(self) -> tcc_renderer_type_t
 |  
 |  state
 |      view_mouse_event_t_state_get(self) -> view_event_state_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      view_mouse_event_t_x_get(self) -> uint32
 |  
 |  y
 |      view_mouse_event_t_y_get(self) -> uint32
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_view_mouse_event_t>
 |      delete_view_mouse_event_t(self)

Help on function warning in module ida_kernwin:

warning(*args)
    warning(format)
    Display a message in a message box
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts
    The user will be able to hide messages if they appear twice in a row on
    the screen

=== ida_kernwin EPYDOC INJECTIONS ===
ida_kernwin.ACF_HAS_FIELD_DIRTREE_SELECTION
"""
'cur_enum_member' and 'dirtree_selection' fields are present
"""

ida_kernwin.ACF_HAS_SELECTION
"""
there is currently a valid selection
"""

ida_kernwin.ACF_XTRN_EA
"""
cur_ea is in 'externs' segment
"""

ida_kernwin.ADF_GLOBAL
"""
available even if no IDB is present

Register the action globally, so that it's
"""

ida_kernwin.ADF_NO_HIGHLIGHT
"""
according to what's under the cursor (listings only.)

After activating, do not update the highlight
"""

ida_kernwin.ADF_NO_UNDO
"""
useful for actions that do not modify the database.

the action does not create an undo point.
"""

ida_kernwin.ADF_OT_MASK
"""
Owner type mask.
"""

ida_kernwin.ADF_OT_PLUGIN
"""
Owner is a 'plugin_t' .
"""

ida_kernwin.ADF_OT_PLUGMOD
"""
Owner is a 'plugmod_t' .
"""

ida_kernwin.ADF_OT_PROCMOD
"""
Owner is a 'procmod_t' .
"""

ida_kernwin.ADF_OWN_HANDLER
"""
handler is owned by the action; it'll be destroyed when the action is
unregistered. You shouldn't have to use this.
"""

ida_kernwin.AHF_VERSION
"""
action handler version (used by 'action_handler_t::flags' )
"""

ida_kernwin.AHF_VERSION_MASK
"""
mask for 'action_handler_t::flags'
"""

ida_kernwin.ASKBTN_BTN1
"""
First (Yes) button.
"""

ida_kernwin.ASKBTN_BTN2
"""
Second (No) button.
"""

ida_kernwin.ASKBTN_BTN3
"""
Third (Cancel) button.
"""

ida_kernwin.ASKBTN_CANCEL
"""
Cancel button.
"""

ida_kernwin.ASKBTN_NO
"""
No button.
"""

ida_kernwin.ASKBTN_YES
"""
Yes button.
"""

ida_kernwin.BWN_ADDRWATCH
"""
the 'Watch List' window
"""

ida_kernwin.BWN_BPTS
"""
breakpoints
"""

ida_kernwin.BWN_CALLS
"""
function calls
"""

ida_kernwin.BWN_CALLS_CALLEES
"""
function calls, callees
"""

ida_kernwin.BWN_CALLS_CALLERS
"""
function calls, callers
"""

ida_kernwin.BWN_CALL_STACK
"""
call stack
"""

ida_kernwin.BWN_CHOOSER
"""
a non-builtin chooser
"""

ida_kernwin.BWN_CLI
"""
the command-line, in the output window
"""

ida_kernwin.BWN_CMDPALCSR
"""
the command palette chooser (Qt version only)
"""

ida_kernwin.BWN_CMDPALWIN
"""
the command palette window (Qt version only)
"""

ida_kernwin.BWN_CPUREGS
"""
one of the 'General registers', 'FPU register', ... debugger windows
"""

ida_kernwin.BWN_CUSTVIEW
"""
custom viewers
"""

ida_kernwin.BWN_CV_LINE_INFOS
"""
custom viewers' lineinfo widget
"""

ida_kernwin.BWN_DISASM
"""
disassembly views
"""

ida_kernwin.BWN_DISASMS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_DISASM_ARROWS
"""
disassembly arrows widget
"""

ida_kernwin.BWN_DUMP
"""
hex dumps
"""

ida_kernwin.BWN_DUMPS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_ENUMS
"""
enumerations
"""

ida_kernwin.BWN_EXPORTS
"""
exports
"""

ida_kernwin.BWN_FRAME
"""
function frame
"""

ida_kernwin.BWN_FUNCS
"""
functions
"""

ida_kernwin.BWN_IMPORTS
"""
imports
"""

ida_kernwin.BWN_LOCALS
"""
the 'locals' debugger window
"""

ida_kernwin.BWN_LOCTYPS
"""
local types
"""

ida_kernwin.BWN_MDVIEWCSR
"""
lumina metadata view chooser
"""

ida_kernwin.BWN_MODULES
"""
modules
"""

ida_kernwin.BWN_NAMES
"""
names
"""

ida_kernwin.BWN_NAVBAND
"""
navigation band
"""

ida_kernwin.BWN_NOTEPAD
"""
notepad
"""

ida_kernwin.BWN_OUTPUT
"""
the text area, in the output window
"""

ida_kernwin.BWN_PROBS
"""
problems
"""

ida_kernwin.BWN_PSEUDOCODE
"""
hexrays decompiler views
"""

ida_kernwin.BWN_SCRIPTS_CSR
"""
the "Recent scripts" chooser
"""

ida_kernwin.BWN_SEARCH
"""
search results
"""

ida_kernwin.BWN_SEARCHS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_SEGREGS
"""
segment registers
"""

ida_kernwin.BWN_SEGS
"""
segments
"""

ida_kernwin.BWN_SELS
"""
selectors
"""

ida_kernwin.BWN_SHORTCUTCSR
"""
the shortcuts chooser (Qt version only)
"""

ida_kernwin.BWN_SHORTCUTWIN
"""
the shortcuts window (Qt version only)
"""

ida_kernwin.BWN_SIGNS
"""
signatures
"""

ida_kernwin.BWN_SNIPPETS
"""
the 'Execute script' window
"""

ida_kernwin.BWN_SNIPPETS_CSR
"""
the list of snippets in the 'Execute script' window
"""

ida_kernwin.BWN_SO_OFFSETS
"""
the 'Structure offsets' dialog's offset panel
"""

ida_kernwin.BWN_SO_STRUCTS
"""
the 'Structure offsets' dialog's 'Structures and Unions' panel
"""

ida_kernwin.BWN_SRCPTHMAP_CSR
"""
"Source paths..."'s path mappings chooser
"""

ida_kernwin.BWN_SRCPTHUND_CSR
"""
"Source paths..."'s undesired paths chooser
"""

ida_kernwin.BWN_STACK
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_STKVIEW
"""
the 'Stack view' debugger window
"""

ida_kernwin.BWN_STRINGS
"""
strings
"""

ida_kernwin.BWN_STRUCTS
"""
structures
"""

ida_kernwin.BWN_THREADS
"""
threads
"""

ida_kernwin.BWN_TILS
"""
type libraries
"""

ida_kernwin.BWN_TRACE
"""
trace view
"""

ida_kernwin.BWN_UNDOHIST
"""
Undo history.
"""

ida_kernwin.BWN_UNKNOWN
"""
unknown window
"""

ida_kernwin.BWN_WATCH
"""
the 'watches' debugger window
"""

ida_kernwin.BWN_XREFS
"""
xrefs
"""

ida_kernwin.CHCOL_DEC
"""
decimal number
"""

ida_kernwin.CHCOL_DEFHIDDEN
"""
column should be hidden by default
"""

ida_kernwin.CHCOL_DRAGHINT
"""
the column number that will be used to build hints for the dragging
undo label. This should be provided for at most one column for any
given chooser.
"""

ida_kernwin.CHCOL_EA
"""
address
"""

ida_kernwin.CHCOL_FNAME
"""
function name
"""

ida_kernwin.CHCOL_FORMAT
"""
column format mask
"""

ida_kernwin.CHCOL_HEX
"""
hexadecimal number
"""

ida_kernwin.CHCOL_INODENAME
"""
if CH_HAS_DIRTREE has been specified, this instructs the chooser that
this column shows the inode name. This should be provided for at most
one column for any given chooser.
"""

ida_kernwin.CHCOL_PATH
"""
file path
"""

ida_kernwin.CHCOL_PLAIN
"""
plain string
"""

ida_kernwin.CHITEM_BOLD
"""
display the item in bold
"""

ida_kernwin.CHITEM_GRAY
"""
gray out the item
"""

ida_kernwin.CHITEM_ITALIC
"""
display the item in italic
"""

ida_kernwin.CHITEM_STRIKE
"""
strikeout the item
"""

ida_kernwin.CHITEM_UNDER
"""
underline the item
"""

ida_kernwin.CHOOSER_MENU_EDIT
"""
Values of the 'menu_index' parameter.

Obsolete. Please don't use
"""

ida_kernwin.CHOOSER_MENU_JUMP
"""
Obsolete. Please don't use.
"""

ida_kernwin.CHOOSER_MENU_SEARCH
"""
Obsolete. Please don't use.
"""

ida_kernwin.CHOOSER_MULTI_SELECTION
"""
enable for multiple selections. A callback of type
'chooser_multi_cb_t' will be called for all selected items.
"""

ida_kernwin.CHOOSER_NO_SELECTION
"""
Flags.

enable even if there's no selected item. 'n' will be NO_SELECTION for
a callback.
"""

ida_kernwin.CHOOSER_POPUP_MENU
"""
Add command to the popup menu.
"""

ida_kernwin.CH_ATTRS
"""
generate ui_get_chooser_item_attrs (gui only)
"""

ida_kernwin.CH_BUILTIN_MASK
"""
Mask for builtin chooser numbers. Plugins should not use them.
"""

ida_kernwin.CH_CAN_DEL
"""
allow to delete existing item(s)
"""

ida_kernwin.CH_CAN_EDIT
"""
allow to edit existing item(s)
"""

ida_kernwin.CH_CAN_INS
"""
allow to insert new items
"""

ida_kernwin.CH_CAN_REFRESH
"""
allow to refresh chooser
"""

ida_kernwin.CH_FORCE_DEFAULT
"""
if a non-modal chooser was already open, change selection to the
default one
"""

ida_kernwin.CH_HAS_DIRTREE
"""
The chooser can provide a 'dirtree_t' , meaning a tree-like structure
can be provided to the user (instead of a flat table)
"""

ida_kernwin.CH_KEEP
"""
The chooser instance's lifecycle is not tied to the lifecycle of the
widget showing its contents. Closing the widget will not destroy the
chooser structure. This allows for, e.g., static global chooser
instances that don't need to be allocated on the heap. Also stack-
allocated chooser instances must set this bit.
"""

ida_kernwin.CH_MODAL
"""
Modal chooser.
"""

ida_kernwin.CH_MULTI
"""
Obsolete.

The chooser will allow multi-selection (only for GUI choosers). This
bit is set when using the 'chooser_multi_t' structure.
"""

ida_kernwin.CH_NOBTNS
"""
do not display ok/cancel/help/search buttons. Meaningful only for gui
modal windows because non-modal windows do not have any buttons
anyway. Text mode does not have them neither.
"""

ida_kernwin.CH_NOIDB
"""
use the chooser before opening the database
"""

ida_kernwin.CH_NO_STATUS_BAR
"""
don't show a status bar
"""

ida_kernwin.CH_QFLT
"""
open with quick filter enabled and focused
"""

ida_kernwin.CH_QFTYP_DEFAULT
"""
set quick filtering type to the possible existing default for this
chooser
"""

ida_kernwin.CH_QFTYP_FUZZY
"""
fuzzy search quick filter type
"""

ida_kernwin.CH_QFTYP_NORMAL
"""
normal (i.e., lexicographical) quick filter type
"""

ida_kernwin.CH_QFTYP_REGEX
"""
regex quick filter type
"""

ida_kernwin.CH_QFTYP_WHOLE_WORDS
"""
whole words quick filter type
"""

ida_kernwin.CH_RESTORE
"""
restore floating position if present (equivalent of WOPN_RESTORE) (GUI
version only)
"""

ida_kernwin.CH_TM_FOLDERS_ONLY
"""
chooser will show in folders-only mode
"""

ida_kernwin.CH_TM_FULL_TREE
"""
chooser will show in no-tree mode
"""

ida_kernwin.CH_TM_NO_TREE
"""
chooser will show up in no-tree mode
"""

ida_kernwin.CK_EXTRA1
"""
extra background overlay #1
"""

ida_kernwin.CK_EXTRA10
"""
extra background overlay #10
"""

ida_kernwin.CK_EXTRA11
"""
extra background overlay #11
"""

ida_kernwin.CK_EXTRA12
"""
extra background overlay #12
"""

ida_kernwin.CK_EXTRA13
"""
extra background overlay #13
"""

ida_kernwin.CK_EXTRA14
"""
extra background overlay #14
"""

ida_kernwin.CK_EXTRA15
"""
extra background overlay #15
"""

ida_kernwin.CK_EXTRA16
"""
extra background overlay #16
"""

ida_kernwin.CK_EXTRA2
"""
extra background overlay #2
"""

ida_kernwin.CK_EXTRA3
"""
extra background overlay #3
"""

ida_kernwin.CK_EXTRA4
"""
extra background overlay #4
"""

ida_kernwin.CK_EXTRA5
"""
extra background overlay #5
"""

ida_kernwin.CK_EXTRA6
"""
extra background overlay #6
"""

ida_kernwin.CK_EXTRA7
"""
extra background overlay #7
"""

ida_kernwin.CK_EXTRA8
"""
extra background overlay #8
"""

ida_kernwin.CK_EXTRA9
"""
extra background overlay #9
"""

ida_kernwin.CK_TRACE
"""
traced address
"""

ida_kernwin.CK_TRACE_OVL
"""
overlay trace address
"""

ida_kernwin.CLNL_FINDCMT
"""
Search for the comment symbol everywhere in the line, not only at the
beginning.
"""

ida_kernwin.CLNL_LTRIM
"""
Remove leading space characters.
"""

ida_kernwin.CLNL_RTRIM
"""
Remove trailing space characters.
"""

ida_kernwin.CREATETB_ADV
"""
toolbar is for 'advanced mode' only
"""

ida_kernwin.DP_BEFORE
"""
used with 'DP_INSIDE' .

place src_form before dst_form in the tab bar instead of after
"""

ida_kernwin.DP_BOTTOM
"""
Dock src_form below dest_form.
"""

ida_kernwin.DP_FLOATING
"""
Make src_form floating.
"""

ida_kernwin.DP_INSIDE
"""
Create a new tab bar with both src_form and dest_form.
"""

ida_kernwin.DP_LEFT
"""
Dock src_form to the left of dest_form.
"""

ida_kernwin.DP_RIGHT
"""
Dock src_form to the right of dest_form.
"""

ida_kernwin.DP_TAB
"""
Place src_form into a tab next to dest_form, if dest_form is in a tab
bar (otherwise the same as 'DP_INSIDE' )
"""

ida_kernwin.DP_TOP
"""
Dock src_form above dest_form.
"""

ida_kernwin.HIF_IDENTIFIER
"""
text is an identifier (i.e., when searching for the current highlight,
SEARCH_IDENT will be used)
"""

ida_kernwin.HIF_LOCKED
"""
locked; clicking/moving the cursor around doesn't change the highlight
"""

ida_kernwin.HIF_NOCASE
"""
case insensitive
"""

ida_kernwin.HIF_REGISTER
"""
text represents a register (aliases/subregisters will be highlit as
well)
"""

ida_kernwin.HIST_CMD
"""
commands
"""

ida_kernwin.HIST_CMT
"""
comments
"""

ida_kernwin.HIST_DIR
"""
directory names (text version only)
"""

ida_kernwin.HIST_FILE
"""
file names
"""

ida_kernwin.HIST_IDENT
"""
names
"""

ida_kernwin.HIST_SEG
"""
segment names
"""

ida_kernwin.HIST_SRCH
"""
search substrings
"""

ida_kernwin.HIST_TYPE
"""
type declarations
"""

ida_kernwin.IWID_ADDRWATCH
"""
address watches (47)
"""

ida_kernwin.IWID_ALL
"""
mask
"""

ida_kernwin.IWID_BPTS
"""
breakpoints (13)
"""

ida_kernwin.IWID_CALLS
"""
function calls (11)
"""

ida_kernwin.IWID_CALLS_CALLEES
"""
funcalls, callees (50)
"""

ida_kernwin.IWID_CALLS_CALLERS
"""
funcalls, callers (49)
"""

ida_kernwin.IWID_CALL_STACK
"""
call stack (17)
"""

ida_kernwin.IWID_CHOOSER
"""
chooser (37)
"""

ida_kernwin.IWID_CLI
"""
input line (33)
"""

ida_kernwin.IWID_CMDPALCSR
"""
command palette (43)
"""

ida_kernwin.IWID_CMDPALWIN
"""
command palette (44)
"""

ida_kernwin.IWID_CPUREGS
"""
registers (40)
"""

ida_kernwin.IWID_CUSTVIEW
"""
custom viewers (46)
"""

ida_kernwin.IWID_CV_LINE_INFOS
"""
lineinfo widget (53)
"""

ida_kernwin.IWID_DISASM
"""
disassembly views (29)
"""

ida_kernwin.IWID_DISASM_ARROWS
"""
arrows widget (52)
"""

ida_kernwin.IWID_DUMP
"""
hex dumps (30)
"""

ida_kernwin.IWID_ENUMS
"""
enumerations (27)
"""

ida_kernwin.IWID_EXPORTS
"""
exports (0)
"""

ida_kernwin.IWID_FRAME
"""
function frame (25)
"""

ida_kernwin.IWID_FUNCS
"""
functions (3)
"""

ida_kernwin.IWID_IMPORTS
"""
imports (1)
"""

ida_kernwin.IWID_LOCALS
"""
locals (35)
"""

ida_kernwin.IWID_LOCTYPS
"""
local types (10)
"""

ida_kernwin.IWID_MDVIEWCSR
"""
lumina md view (51)
"""

ida_kernwin.IWID_MODULES
"""
modules (15)
"""

ida_kernwin.IWID_NAMES
"""
names (2)
"""

ida_kernwin.IWID_NAVBAND
"""
navigation band (26)
"""

ida_kernwin.IWID_NOTEPAD
"""
notepad (31)
"""

ida_kernwin.IWID_OUTPUT
"""
output (32)
"""

ida_kernwin.IWID_PROBS
"""
problems (12)
"""

ida_kernwin.IWID_PSEUDOCODE
"""
decompiler (48)
"""

ida_kernwin.IWID_SCRIPTS_CSR
"""
recent scripts (58)
"""

ida_kernwin.IWID_SEARCH
"""
search results (19)
"""

ida_kernwin.IWID_SEGREGS
"""
segment registers (6)
"""

ida_kernwin.IWID_SEGS
"""
segments (5)
"""

ida_kernwin.IWID_SELS
"""
selectors (7)
"""

ida_kernwin.IWID_SHORTCUTCSR
"""
shortcuts chooser (38)
"""

ida_kernwin.IWID_SHORTCUTWIN
"""
shortcuts window (39)
"""

ida_kernwin.IWID_SIGNS
"""
signatures (8)
"""

ida_kernwin.IWID_SNIPPETS
"""
snippets (45)
"""

ida_kernwin.IWID_SNIPPETS_CSR
"""
snippets chooser (57)
"""

ida_kernwin.IWID_SO_OFFSETS
"""
stroff (42)
"""

ida_kernwin.IWID_SO_STRUCTS
"""
stroff (41)
"""

ida_kernwin.IWID_SRCPTHMAP_CSR
"""
mappings chooser (54)
"""

ida_kernwin.IWID_SRCPTHUND_CSR
"""
undesired chooser (55)
"""

ida_kernwin.IWID_STACK
"""
Alias. Some IWID_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.IWID_STKVIEW
"""
stack view (36)
"""

ida_kernwin.IWID_STRINGS
"""
strings (4)
"""

ida_kernwin.IWID_STRUCTS
"""
structures (28)
"""

ida_kernwin.IWID_THREADS
"""
threads (14)
"""

ida_kernwin.IWID_TILS
"""
type libraries (9)
"""

ida_kernwin.IWID_TRACE
"""
trace view (16)
"""

ida_kernwin.IWID_UNDOHIST
"""
Undo history (56)
"""

ida_kernwin.IWID_WATCH
"""
watches (34)
"""

ida_kernwin.IWID_XREFS
"""
xrefs (18)
"""

ida_kernwin.LROEF_CPS_RANGE
"""
background for range of chars
"""

ida_kernwin.LROEF_FULL_LINE
"""
full line background
"""

ida_kernwin.MFF_FAST
"""
Execute code as soon as possible. this mode is ok for calling ui
related functions that do not query the database.
"""

ida_kernwin.MFF_NOWAIT
"""
Do not wait for the request to be executed. the caller should ensure
that the request is not destroyed until the execution completes. if
not, the request will be ignored. the request must be created using
the 'new' operator to use it with this flag. it can be used in
'cancel_exec_request()' . This flag can be used to delay the code
execution until the next UI loop run even from the main thread.
"""

ida_kernwin.MFF_READ
"""
Execute code only when ida is idle and it is safe to query the
database. this mode is recommended only for code that does not modify
the database. (nb: ida may be in the middle of executing another user
request, for example it may be waiting for him to enter values into a
modal dialog box)
"""

ida_kernwin.MFF_WRITE
"""
Execute code only when ida is idle and it is safe to modify the
database. in particular, this flag will suspend execution if there is
a modal dialog box on the screen this mode can be used to call any ida
api function 'MFF_WRITE' implies 'MFF_READ'
"""

ida_kernwin.PCF_EA_CAPABLE
"""
toea() implementation returns meaningful data
"""

ida_kernwin.PCF_MAKEPLACE_ALLOCATES
"""
makeplace() returns a freshly allocated (i.e., non-static) instance.
All new code should pass that flag to 'register_place_class()' , and
the corresponding makeplace() class implementation should return new
instances.
"""

ida_kernwin.SETMENU_APP
"""
add menu item after the specified path
"""

ida_kernwin.SETMENU_FIRST
"""
add item to the beginning of menu
"""

ida_kernwin.SETMENU_INS
"""
add menu item before the specified path (default)
"""

ida_kernwin.UIJMP_ACTIVATE
"""
activate the new window
"""

ida_kernwin.UIJMP_ANYVIEW
"""
jump in any ea_t-capable view
"""

ida_kernwin.UIJMP_DONTPUSH
"""
in the navigation history

do not remember the current address
"""

ida_kernwin.UIJMP_IDAVIEW
"""
jump in idaview
"""

ida_kernwin.UIJMP_IDAVIEW_NEW
"""
jump in new idaview
"""

ida_kernwin.VES_SHIFT
"""
state & 1 => Shift is pressedstate & 2 => Alt is pressedstate & 4 =>
Ctrl is pressedstate & 8 => Mouse left button is pressedstate & 16 =>
Mouse right button is pressedstate & 32 => Mouse middle button is
pressedstate & 128 => Meta is pressed (OSX only)
"""
=== ida_kernwin EPYDOC INJECTIONS END ===
Help on function COLSTR in module ida_lines:

COLSTR(str, tag)
    Utility function to create a colored line
    @param str: The string
    @param tag: Color tag constant. One of SCOLOR_XXXX

Help on function add_extra_cmt in module ida_lines:

add_extra_cmt(*args)
    Add anterior/posterior comment line(s).
    
    add_extra_cmt(ea, isprev, format) -> bool
        @param ea: linear address (C++: ea_t)
        @param isprev: do we add anterior lines? (0-no, posterior) (C++: bool)
        @param format: printf() style format string. may contain \n to denote
                       new lines. The resulting string should not contain
                       comment characters (;), the kernel will add them
                       automatically. (C++: const char *)
        @return: true if success

Help on function add_extra_line in module ida_lines:

add_extra_line(*args)
    Add anterior/posterior non-comment line(s).
    
    add_extra_line(ea, isprev, format) -> bool
        @param ea: linear address (C++: ea_t)
        @param isprev: do we add anterior lines? (0-no, posterior) (C++: bool)
        @param format: printf() style format string. may contain \n to denote
                       new lines. (C++: const char *)
        @return: true if success

Help on function add_pgm_cmt in module ida_lines:

add_pgm_cmt(*args)
    Add anterior comment line(s) at the start of program.
    
    add_pgm_cmt(format) -> bool
        @param format: printf() style format string. may contain \n to denote
                       new lines. The resulting string should not contain
                       comment characters (;), the kernel will add them
                       automatically. (C++: const char *)
        @return: true if success

Help on function add_sourcefile in module ida_lines:

add_sourcefile(*args)
    Mark a range of address as belonging to a source file. An address
    range may belong only to one source file. A source file may be
    represented by several address ranges.
    
    add_sourcefile(ea1, ea2, filename) -> bool
        @param ea1: linear address of start of the address range (C++: ea_t)
        @param ea2: linear address of end of the address range (excluded)
                    (C++: ea_t)
        @param filename: name of source file. (C++: const char *)
        @return: success

Help on function calc_bg_color in module ida_lines:

calc_bg_color(*args)
    Get background color for line at 'ea'
    
    calc_bg_color(ea) -> bgcolor_t
        @param ea (C++: ea_t)
        @return: RGB color

Help on function calc_prefix_color in module ida_lines:

calc_prefix_color(*args)
    Get prefix color for line at 'ea'
    
    calc_prefix_color(ea) -> color_t
        @param ea (C++: ea_t)
        @return: Line prefix colors

Help on function create_encoding_helper in module ida_lines:

create_encoding_helper(*args)
    create_encoding_helper(encidx=-1, nr=nr_once) -> encoder_t *
        encidx: int
        nr: enum encoder_t::notify_recerr_t

Help on function del_extra_cmt in module ida_lines:

del_extra_cmt(*args)
    del_extra_cmt(ea, what)
        ea: ea_t
        what: int

Help on function del_sourcefile in module ida_lines:

del_sourcefile(*args)
    Delete information about the source file.
    
    del_sourcefile(ea) -> bool
        @param ea: linear address (C++: ea_t)
        @return: success

Help on function delete_extra_cmts in module ida_lines:

delete_extra_cmts(*args)
    delete_extra_cmts(ea, what)
        ea: ea_t
        what: int

Help on function generate_disasm_line in module ida_lines:

generate_disasm_line(*args)
    generate_disasm_line(ea, flags=0) -> str
        ea: ea_t
        flags: int

Help on function generate_disassembly in module ida_lines:

generate_disassembly(*args)
    generate_disassembly(ea, max_lines, as_stack, notags) -> PyObject *
    Generate disassembly lines (many lines) and put them into a buffer
    
    @param ea: address to generate disassembly for
    @param max_lines: how many lines max to generate
    @param as_stack: Display undefined items as 2/4/8 bytes
    @return:
        - None on failure
        - tuple(most_important_line_number, tuple(lines)) : Returns a tuple containing
          the most important line number and a tuple of generated lines

Help on function get_extra_cmt in module ida_lines:

get_extra_cmt(*args)
    get_extra_cmt(ea, what) -> ssize_t
        ea: ea_t
        what: int

Help on function get_first_free_extra_cmtidx in module ida_lines:

get_first_free_extra_cmtidx(*args)
    get_first_free_extra_cmtidx(ea, start) -> int
        ea: ea_t
        start: int

Help on function get_sourcefile in module ida_lines:

get_sourcefile(*args)
    Get name of source file occupying the given address.
    
    get_sourcefile(ea, bounds=None) -> char const *
        @param ea: linear address (C++: ea_t)
        @param bounds: pointer to the output buffer with the address range for
                       the current file. May be NULL. (C++: range_t  *)
        @return: NULL if source file information is not found, otherwise
                 returns pointer to file name

Help on function install_user_defined_prefix in module ida_lines:

install_user_defined_prefix(*args)
    User-defined line-prefixes are displayed just after the autogenerated
    line prefixes in the disassembly listing. There is no need to call
    this function explicitly. Use the 'user_defined_prefix_t' class.
    
    install_user_defined_prefix(prefix_len, udp, owner) -> bool
        @param prefix_len: prefixed length. if 0, then uninstall UDP (C++:
                           size_t)
        @param udp: object to generate user-defined prefix (C++: struct
                    user_defined_prefix_t  *)
        @param owner: pointer to the  plugin_t  that owns UDP if non-NULL,
                      then the object will be uninstalled and destroyed when
                      the plugin gets unloaded (C++: const void *)

Help on function requires_color_esc in module ida_lines:

requires_color_esc(c)
    Checks if the given character requires escaping
    @param c: character (string of one char)
    @return: Boolean

Help on function set_user_defined_prefix in module ida_lines:

set_user_defined_prefix(*args)
    set_user_defined_prefix(width, pycb) -> PyObject *
    Deprecated. Please use install_user_defined_prefix() instead

Help on function tag_addr in module ida_lines:

tag_addr(*args)
    Insert an address mark into a string.
    
    tag_addr(ea) -> PyObject *
        @param ea: address to include (C++: ea_t)

Help on function tag_advance in module ida_lines:

tag_advance(*args)
    Move pointer to a 'line' to 'cnt' positions right. Take into account
    escape sequences.
    
    tag_advance(line, cnt) -> int
        @param line: pointer to string (C++: const char *)
        @param cnt: number of positions to move right (C++: int)
        @return: moved pointer

Help on function tag_remove in module ida_lines:

tag_remove(*args)
    Remove color escape sequences from a string.
    
    tag_remove(nonnul_instr) -> PyObject *
        nonnul_instr: char const *
        @return: length of resulting string, -1 if error

Help on function tag_skipcode in module ida_lines:

tag_skipcode(*args)
    Skip one color code. This function should be used if you are
    interested in color codes and want to analyze all of them. Otherwise
    'tag_skipcodes()' function is better since it will skip all colors at
    once. This function will skip the current color code if there is one.
    If the current symbol is not a color code, it will return the input.
    
    tag_skipcode(line) -> int
        @param line (C++: const char *)
        @return: moved pointer

Help on function tag_skipcodes in module ida_lines:

tag_skipcodes(*args)
    Move the pointer past all color codes.
    
    tag_skipcodes(line) -> int
        @param line: can't be NULL (C++: const char *)
        @return: moved pointer, can't be NULL

Help on function tag_strlen in module ida_lines:

tag_strlen(*args)
    Calculate length of a colored string This function computes the length
    in unicode codepoints of a line
    
    tag_strlen(line) -> ssize_t
        @param line (C++: const char *)
        @return: the number of codepoints in the line, or -1 on error

Help on function update_extra_cmt in module ida_lines:

update_extra_cmt(*args)
    update_extra_cmt(ea, what, str)
        ea: ea_t
        what: int
        str: char const *

Help on class user_defined_prefix_t in module ida_lines:

class user_defined_prefix_t(__builtin__.object)
 |  Proxy of C++ user_defined_prefix_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, prefix_len, owner) -> user_defined_prefix_t
 |          prefix_len: size_t
 |          owner: void const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_user_defined_prefix(self, *args)
 |      This callback must be overridden by the derived class.
 |      
 |      get_user_defined_prefix(self, ea, insn, lnnum, indent, line)
 |          @param ea: the current address (C++: ea_t)
 |          @param insn: the current instruction. if the current item is not an
 |                       instruction, then insn.itype is zero.  - an
 |                       ida_ua.insn_t, or an address (C++: const insn_t &)
 |          @param lnnum (C++: int)
 |          @param indent: see explanations for gen_printf() (C++: int)
 |          @param line: the line to be generated. the line usually contains color
 |                       tags. this argument can be examined to decide whether to
 |                       generate the prefix. (C++: const char *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_user_defined_prefix_t>
 |      delete_user_defined_prefix_t(self)

=== ida_lines EPYDOC INJECTIONS ===
ida_lines.COLOR_ADDR_SIZE
"""
Size of a tagged address (see 'COLOR_ADDR' )
"""

ida_lines.COLOR_BG_MAX
"""
Max color number.
"""

ida_lines.COLOR_CODE
"""
Single instruction.
"""

ida_lines.COLOR_CURITEM
"""
Current item.
"""

ida_lines.COLOR_CURLINE
"""
Current line.
"""

ida_lines.COLOR_DATA
"""
Data bytes.
"""

ida_lines.COLOR_DEFAULT
"""
Default.
"""

ida_lines.COLOR_ESC
"""
Escape character (Quote next character). This is needed to output '\\1'
and '\\2' characters.
"""

ida_lines.COLOR_EXTERN
"""
External name definition segment.
"""

ida_lines.COLOR_HIDLINE
"""
Hidden line.
"""

ida_lines.COLOR_INV
"""
Escape character (Inverse foreground and background colors). This
escape character has no corresponding 'COLOR_OFF' . Its action
continues until the next 'COLOR_INV' or end of line.
"""

ida_lines.COLOR_LIBFUNC
"""
Library function.
"""

ida_lines.COLOR_LUMFUNC
"""
Lumina function.
"""

ida_lines.COLOR_OFF
"""
Followed by a color code ( 'color_t' ).

Escape character (OFF).
"""

ida_lines.COLOR_ON
"""
Followed by a color code ( 'color_t' ).

Escape character (ON).
"""

ida_lines.COLOR_REGFUNC
"""
Regular function.
"""

ida_lines.COLOR_SELECTED
"""
Selected.
"""

ida_lines.COLOR_UNKNOWN
"""
Unexplored byte.
"""

ida_lines.SCOLOR_ADDR
"""
Hidden address mark.
"""

ida_lines.SCOLOR_ALTOP
"""
Alternative operand.
"""

ida_lines.SCOLOR_ASMDIR
"""
Assembler directive.
"""

ida_lines.SCOLOR_AUTOCMT
"""
Automatic comment.
"""

ida_lines.SCOLOR_BINPREF
"""
Binary line prefix bytes.
"""

ida_lines.SCOLOR_CHAR
"""
Char constant in instruction.
"""

ida_lines.SCOLOR_CNAME
"""
Regular code name.
"""

ida_lines.SCOLOR_CODNAME
"""
Dummy code name.
"""

ida_lines.SCOLOR_COLLAPSED
"""
Collapsed line.
"""

ida_lines.SCOLOR_CREF
"""
Code reference.
"""

ida_lines.SCOLOR_CREFTAIL
"""
Code reference to tail byte.
"""

ida_lines.SCOLOR_DATNAME
"""
Dummy Data Name.
"""

ida_lines.SCOLOR_DCHAR
"""
Char constant in data directive.
"""

ida_lines.SCOLOR_DEFAULT
"""
Default.
"""

ida_lines.SCOLOR_DEMNAME
"""
Demangled Name.
"""

ida_lines.SCOLOR_DNAME
"""
Regular Data Name.
"""

ida_lines.SCOLOR_DNUM
"""
Numeric constant in data directive.
"""

ida_lines.SCOLOR_DREF
"""
Data reference.
"""

ida_lines.SCOLOR_DREFTAIL
"""
Data reference to tail byte.
"""

ida_lines.SCOLOR_DSTR
"""
String constant in data directive.
"""

ida_lines.SCOLOR_ERROR
"""
Error or problem.
"""

ida_lines.SCOLOR_ESC
"""
Escape character (Quote next character)
"""

ida_lines.SCOLOR_EXTRA
"""
Extra line.
"""

ida_lines.SCOLOR_HIDNAME
"""
Hidden name.
"""

ida_lines.SCOLOR_IMPNAME
"""
Imported name.
"""

ida_lines.SCOLOR_INSN
"""
Instruction.
"""

ida_lines.SCOLOR_INV
"""
Escape character (Inverse colors)
"""

ida_lines.SCOLOR_KEYWORD
"""
Keywords.
"""

ida_lines.SCOLOR_LIBNAME
"""
Library function name.
"""

ida_lines.SCOLOR_LOCNAME
"""
Local variable name.
"""

ida_lines.SCOLOR_MACRO
"""
Macro.
"""

ida_lines.SCOLOR_NUMBER
"""
Numeric constant in instruction.
"""

ida_lines.SCOLOR_OFF
"""
Escape character (OFF)
"""

ida_lines.SCOLOR_ON
"""
Escape character (ON)
"""

ida_lines.SCOLOR_PREFIX
"""
Line prefix.
"""

ida_lines.SCOLOR_REG
"""
Register name.
"""

ida_lines.SCOLOR_REGCMT
"""
Regular comment.
"""

ida_lines.SCOLOR_RPTCMT
"""
Repeatable comment (defined not here)
"""

ida_lines.SCOLOR_SEGNAME
"""
Segment name.
"""

ida_lines.SCOLOR_STRING
"""
String constant in instruction.
"""

ida_lines.SCOLOR_SYMBOL
"""
Punctuation.
"""

ida_lines.SCOLOR_UNAME
"""
Regular unknown name.
"""

ida_lines.SCOLOR_UNKNAME
"""
Dummy unknown name.
"""

ida_lines.SCOLOR_VOIDOP
"""
Void operand.
"""
=== ida_lines EPYDOC INJECTIONS END ===
Help on function base2file in module ida_loader:

base2file(*args)
    Unload database to a binary file. This function works for wide byte
    processors too.
    
    base2file(fp, pos, ea1, ea2) -> int
        @param fp: pointer to file (C++: FILE *)
        @param pos: position in the file (C++: qoff64_t)
        @param ea1: range of source linear addresses (C++: ea_t)
        @param ea2: range of source linear addresses (C++: ea_t)
        @return: 1-ok(always), write error leads to immediate exit

Help on function build_snapshot_tree in module ida_loader:

build_snapshot_tree(*args)
    Build the snapshot tree.
    
    build_snapshot_tree(root) -> bool
        @param root: snapshot root that will contain the snapshot tree
                     elements. (C++: snapshot_t  *)
        @return: success

Help on function clr_database_flag in module ida_loader:

clr_database_flag(*args)
    clr_database_flag(dbfl)
        @param dbfl (C++: uint32)

Help on function extract_module_from_archive in module ida_loader:

extract_module_from_archive(*args)
    Extract a module for an archive file. Parse an archive file, show the
    list of modules to the user, allow him to select a module, extract the
    selected module to a file (if the extract module is an archive, repeat
    the process). This function can handle ZIP, AR, AIXAR, OMFLIB files.
    The temporary file will be automatically deleted by IDA at the end.
    
    extract_module_from_archive(fname, is_remote=False) -> PyObject *
        fname: char const *
        @param is_remote: is the input file remote? (C++: bool)
        @retval: true - ok
        @retval: false - something bad happened (error message has been
                         displayed to the user)

Help on function file2base in module ida_loader:

file2base(*args)
    Load portion of file into the database. This function will include
    (ea1..ea2) into the addressing space of the program (make it enabled)
    
    file2base(li, pos, ea1, ea2, patchable) -> int
        @param li: pointer of input source (C++: linput_t *)
        @param pos: position in the file (C++: qoff64_t)
        @param ea1: range of destination linear addresses (C++: ea_t)
        @param ea2: range of destination linear addresses (C++: ea_t)
        @param patchable: should the kernel remember correspondence of file
                          offsets to linear addresses. (C++: int)
        @retval: 1 - ok
        @retval: 0 - read error, a warning is displayed

Help on function find_plugin in module ida_loader:

find_plugin(*args)
    Find a user-defined plugin and optionally load it.
    
    find_plugin(name, load_if_needed=False) -> plugin_t *
        @param name: short plugin name without path and extension, or absolute
                     path to the file name (C++: const char *)
        @param load_if_needed: if the plugin is not present in the memory, try
                               to load it (C++: bool)
        @return: pointer to plugin description block

Help on function flush_buffers in module ida_loader:

flush_buffers(*args)
    Flush buffers to the disk.

Help on function gen_exe_file in module ida_loader:

gen_exe_file(*args)
    Generate an exe file (unload the database in binary form).
    
    gen_exe_file(fp) -> int
        @param fp (C++: FILE *)
        @return: fp the output file handle. if fp == NULL then return:   1:
                 can generate an executable file   0: can't generate an
                 executable file
        @retval: 1 - ok
        @retval: 0 - failed

Help on function gen_file in module ida_loader:

gen_file(*args)
    Generate an output file. 'OFILE_EXE' :
    
    gen_file(otype, fp, ea1, ea2, flags) -> int
        @param otype: type of output file. (C++: ofile_type_t)
        @param fp: the output file handle (C++: FILE *)
        @param ea1: start address. For some file types this argument is
                    ignored (C++: ea_t)
        @param ea2: end address. For some file types this argument is ignored
                    as usual in ida, the end address of the range is not
                    included (C++: ea_t)
        @param flags: Generate file flags (C++: int)
        @return: number of the generated lines. -1 if an error occurred
        @retval: 0 - can't generate exe file
        @retval: 1 - ok

Help on function get_basic_file_type in module ida_loader:

get_basic_file_type(*args)
    Get the input file type. This function can recognize libraries and zip
    files.
    
    get_basic_file_type(li) -> filetype_t
        @param li (C++: linput_t *)

Help on function get_elf_debug_file_directory in module ida_loader:

get_elf_debug_file_directory(*args)
    Get the value of the ELF_DEBUG_FILE_DIRECTORY configuration directive.

Help on function get_file_type_name in module ida_loader:

get_file_type_name(*args)
    Get name of the current file type. The current file type is kept in
    \inf{filetype}.

Help on function get_fileregion_ea in module ida_loader:

get_fileregion_ea(*args)
    Get linear address which corresponds to the specified input file
    offset. If can't be found, return 'BADADDR'
    
    get_fileregion_ea(offset) -> ea_t
        @param offset (C++: qoff64_t)

Help on function get_fileregion_offset in module ida_loader:

get_fileregion_offset(*args)
    Get offset in the input file which corresponds to the given ea. If the
    specified ea can't be mapped into the input file offset, return -1.
    
    get_fileregion_offset(ea) -> qoff64_t
        @param ea (C++: ea_t)

Help on function get_path in module ida_loader:

get_path(*args)
    Get the file path
    
    get_path(pt) -> char const *
        @param pt: file path type  Types of the file pathes (C++: path_type_t)
        @return: file path, never returns NULL

Help on function get_plugin_options in module ida_loader:

get_plugin_options(*args)
    Get plugin options from the command line. If the user has specified
    the options in the -Oplugin_name:options format, them this function
    will return the 'options' part of it The 'plugin' parameter should
    denote the plugin name Returns NULL if there we no options specified
    
    get_plugin_options(plugin) -> char const *
        @param plugin (C++: const char *)

Help on class idp_desc_t in module ida_loader:

class idp_desc_t(__builtin__.object)
 |  Proxy of C++ idp_desc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idp_desc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  checked
 |      idp_desc_t_checked_get(self) -> bool
 |  
 |  family
 |      idp_desc_t_family_get(self) -> qstring *
 |  
 |  is_script
 |      idp_desc_t_is_script_get(self) -> bool
 |  
 |  mtime
 |      idp_desc_t_mtime_get(self) -> time_t
 |  
 |  names
 |      idp_desc_t_names_get(self) -> idp_names_t *
 |  
 |  path
 |      idp_desc_t_path_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_idp_desc_t>
 |      delete_idp_desc_t(self)

Help on class idp_name_t in module ida_loader:

class idp_name_t(__builtin__.object)
 |  Proxy of C++ idp_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idp_name_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hidden
 |      idp_name_t_hidden_get(self) -> bool
 |  
 |  lname
 |      idp_name_t_lname_get(self) -> qstring *
 |  
 |  sname
 |      idp_name_t_sname_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_idp_name_t>
 |      delete_idp_name_t(self)

Help on function is_database_flag in module ida_loader:

is_database_flag(*args)
    Get the current database flag
    
    is_database_flag(dbfl) -> bool
        @param dbfl: flag  Database flags (C++: uint32)
        @return: the state of the flag (set or cleared)

Help on function is_trusted_idb in module ida_loader:

is_trusted_idb(*args)
    Is the database considered as trusted?

Help on function load_and_run_plugin in module ida_loader:

load_and_run_plugin(*args)
    Load & run a plugin.
    
    load_and_run_plugin(name, arg) -> bool
        @param name (C++: const char *)
        @param arg (C++: size_t)

Help on function load_binary_file in module ida_loader:

load_binary_file(*args)
    Load a binary file into the database. This function usually is called
    from ui.
    
    load_binary_file(filename, li, _neflags, fileoff, basepara, binoff, nbytes) -> bool
        @param filename: the name of input file as is (if the input file is
                         from library, then this is the name from the library)
                         (C++: const char *)
        @param li: loader input source (C++: linput_t *)
        @param _neflags: Load file flags . For the first file, the flag
                         NEF_FIRST  must be set. (C++: ushort)
        @param fileoff: Offset in the input file (C++: qoff64_t)
        @param basepara: Load address in paragraphs (C++: ea_t)
        @param binoff: Load offset (load_address=(basepara<<4)+binoff) (C++:
                       ea_t)
        @param nbytes: Number of bytes to load from the file.   0: up to the
                       end of the file (C++: uint64)
        @retval: true - ok
        @retval: false - failed (couldn't open the file)

Help on function load_ids_module in module ida_loader:

load_ids_module(*args)
    Load and apply IDS file. This function loads the specified IDS file
    and applies it to the database. If the program imports functions from
    a module with the same name as the name of the ids file being loaded,
    then only functions from this module will be affected. Otherwise (i.e.
    when the program does not import a module with this name) any function
    in the program may be affected.
    
    load_ids_module(fname) -> int
        @param fname: name of file to apply (C++: char *)
        @retval: 1 - ok
        @retval: 0 - some error (a message is displayed). if the ids file does
                     not exist, no message is displayed

Help on function load_plugin in module ida_loader:

load_plugin(*args)
    load_plugin(name) -> PyObject *
    Loads a plugin
    @return:
        - None if plugin could not be loaded
        - An opaque object representing the loaded plugin

Help on class loader_t in module ida_loader:

class loader_t(__builtin__.object)
 |  Proxy of C++ loader_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> loader_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      loader_t_flags_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  version
 |      loader_t_version_get(self) -> uint32
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_loader_t>
 |      delete_loader_t(self)

Help on function mem2base in module ida_loader:

mem2base(*args)
    mem2base(py_mem, ea, fpos=-1) -> int
    Load database from the memory.
    @param mem: the buffer
    @param ea: start linear addresses
    @param fpos: position in the input file the data is taken from.
                 if == -1, then no file position correspond to the data.
    @return:
        - Returns zero if the passed buffer was not a string
        - Otherwise 1 is returned

Help on class plugin_info_t in module ida_loader:

class plugin_info_t(__builtin__.object)
 |  Proxy of C++ plugin_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> plugin_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  arg
 |      plugin_info_t_arg_get(self) -> size_t
 |  
 |  comment
 |      plugin_info_t_comment_get(self) -> char *
 |  
 |  dllmem
 |      plugin_info_t_dllmem_get(self) -> idadll_t *
 |  
 |  entry
 |      plugin_info_t_entry_get(self) -> plugin_t *
 |  
 |  flags
 |      plugin_info_t_flags_get(self) -> int
 |  
 |  hotkey
 |      plugin_info_t_hotkey_get(self) -> ushort
 |  
 |  name
 |      plugin_info_t_name_get(self) -> char *
 |  
 |  next
 |      plugin_info_t_next_get(self) -> plugin_info_t
 |  
 |  org_hotkey
 |      plugin_info_t_org_hotkey_get(self) -> ushort
 |  
 |  org_name
 |      plugin_info_t_org_name_get(self) -> char *
 |  
 |  path
 |      plugin_info_t_path_get(self) -> char *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_plugin_info_t>
 |      delete_plugin_info_t(self)

Help on function process_archive in module ida_loader:

process_archive(*args)
    Calls 'loader_t::process_archive()' For parameters and return value
    description look at 'loader_t::process_archive()' . Additional
    parameter:
    
    process_archive(temp_file, li, module_name, neflags, defmember, loader) -> str
        @param temp_file (C++: qstring  *)
        @param li (C++: linput_t *)
        @param module_name (C++: qstring  *)
        @param neflags (C++: ushort  *)
        @param defmember (C++: const char *)
        @param loader: pointer to  load_info_t  structure. (C++: const
                       load_info_t  *)

Help on class qvector_snapshotvec_t in module ida_loader:

class qvector_snapshotvec_t(__builtin__.object)
 |  Proxy of C++ qvector< snapshot_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< snapshot_t * > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> snapshot_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_snapshotvec_t
 |          x: qvector< snapshot_t * > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< snapshot_t * > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: snapshot_t *const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: snapshot_t *const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: snapshot_t *const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> snapshot_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< snapshot_t * >::iterator
 |      begin(self) -> qvector< snapshot_t * >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< snapshot_t * >::iterator
 |      end(self) -> qvector< snapshot_t * >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< snapshot_t * >::iterator
 |          it: qvector< snapshot_t * >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< snapshot_t * >::iterator
 |          first: qvector< snapshot_t * >::iterator
 |          last: qvector< snapshot_t * >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> snapshot_t **
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< snapshot_t * >::iterator
 |          x: snapshot_t *const &
 |      
 |      
 |      find(self, x) -> qvector< snapshot_t * >::const_iterator
 |          x: snapshot_t *const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: snapshot_t *const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: snapshot_t **
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< snapshot_t * >::iterator
 |          it: qvector< snapshot_t * >::iterator
 |          x: snapshot_t *const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: snapshot_t *const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: snapshot_t *const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< snapshot_t * > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qvector_snapshotvec_t>
 |      delete_qvector_snapshotvec_t(self)

Help on function reload_file in module ida_loader:

reload_file(*args)
    Reload the input file. This function reloads the byte values from the
    input file. It doesn't modify the segmentation, names, comments, etc.
    
    reload_file(file, is_remote) -> bool
        @param file: name of the input file. if file == NULL then returns:
                     1: can reload the input file   0: can't reload the input
                     file (C++: const char *)
        @param is_remote: is the file located on a remote computer with the
                          debugger server? (C++: bool)
        @return: success

Help on function run_plugin in module ida_loader:

run_plugin(*args)
    run_plugin(plg, arg) -> bool
    Runs a plugin
    @param plg: A plugin object (returned by load_plugin())
    @return: Boolean

Help on function save_database in module ida_loader:

save_database(*args)
    Save current database using a new file name.when both root and attr
    are not NULL then the snapshot attributes will be updated, otherwise
    the snapshot attributes will be inherited from the current database.
    
    save_database(outfile, flags, root=None, attr=None) -> bool
        @param outfile: output database file name (C++: const char *)
        @param flags: Database flags (C++: uint32)
        @param root: optional: snapshot tree root. (C++: const  snapshot_t  *)
        @param attr: optional: snapshot attributes (C++: const  snapshot_t  *)
        @return: success

Help on function set_database_flag in module ida_loader:

set_database_flag(*args)
    Set or clear database flag
    
    set_database_flag(dbfl, cnd=True)
        @param dbfl: flag  Database flags (C++: uint32)
        @param cnd: set if true or clear flag otherwise (C++: bool)

Help on function set_path in module ida_loader:

set_path(*args)
    Set the file path
    
    set_path(pt, path)
        @param pt: file path type  Types of the file pathes (C++: path_type_t)
        @param path: new file path, use NULL or empty string to clear the file
                     path (C++: const char *)

Help on class snapshot_t in module ida_loader:

class snapshot_t(__builtin__.object)
 |  Proxy of C++ snapshot_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: snapshot_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: snapshot_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: snapshot_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> snapshot_t
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: snapshot_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: snapshot_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: snapshot_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  children
 |      snapshot_t_children_get(self) -> qvector_snapshotvec_t
 |  
 |  desc
 |      snapshot_t_desc_get(self) -> char [128]
 |  
 |  filename
 |      snapshot_t_filename_get(self) -> char [QMAXPATH]
 |  
 |  flags
 |      snapshot_t_flags_get(self) -> uint16
 |  
 |  id
 |      snapshot_t_id_get(self) -> qtime64_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_snapshot_t>
 |      delete_snapshot_t(self)

=== ida_loader EPYDOC INJECTIONS ===
ida_loader.ACCEPT_ARCHIVE
"""
Specify that a file format is served by archive loader See
'loader_t::accept_file'
"""

ida_loader.ACCEPT_CONTINUE
"""
Specify that the function must be called another time See
'loader_t::accept_file'
"""

ida_loader.ACCEPT_FIRST
"""
Specify that a file format should be place first in "load file" dialog
box. See 'loader_t::accept_file'
"""

ida_loader.DBFL_BAK
"""
create backup file (if !DBFL_KILL)
"""

ida_loader.DBFL_COMP
"""
collect garbage
"""

ida_loader.DBFL_KILL
"""
delete unpacked database
"""

ida_loader.DBFL_TEMP
"""
temporary database
"""

ida_loader.FILEREG_NOTPATCHABLE
"""
form in the file.

the data is kept in some encoded
"""

ida_loader.FILEREG_PATCHABLE
"""
means that the input file may be patched (i.e. no compression, no
iterated data, etc)
"""

ida_loader.GENFLG_ASMINC
"""
'OFILE_ASM' , 'OFILE_LST' : gen information only about types
"""

ida_loader.GENFLG_ASMTYPE
"""
'OFILE_ASM' , 'OFILE_LST' : gen information about types too
"""

ida_loader.GENFLG_GENHTML
"""
'OFILE_ASM' , 'OFILE_LST' : generate html ( 'ui_genfile_callback'
will be used)
"""

ida_loader.GENFLG_IDCTYPE
"""
'OFILE_IDC' : gen only information about types
"""

ida_loader.GENFLG_MAPDMNG
"""
'OFILE_MAP' : demangle names
"""

ida_loader.GENFLG_MAPLOC
"""
'OFILE_MAP' : include local names
"""

ida_loader.GENFLG_MAPNAME
"""
'OFILE_MAP' : include dummy names
"""

ida_loader.GENFLG_MAPSEG
"""
'OFILE_MAP' : generate map of segments
"""

ida_loader.LDRF_RELOAD
"""
loader recognizes 'NEF_RELOAD' flag
"""

ida_loader.LDRF_REQ_PROC
"""
Requires a processor to be set. if this bit is not set, load_file()
must call set_processor_type(..., SETPROC_LOADER)
"""

ida_loader.MAX_DATABASE_DESCRIPTION
"""
Maximum database snapshot description length.
"""

ida_loader.NEF_CODE
"""
load as a code segment

for 'load_binary_file()' :
"""

ida_loader.NEF_FILL
"""
Fill segment gaps.
"""

ida_loader.NEF_FIRST
"""
into the database.

This is the first file loaded
"""

ida_loader.NEF_FLAT
"""
Autocreate FLAT group (PE)
"""

ida_loader.NEF_IMPS
"""
Create import segment.
"""

ida_loader.NEF_LALL
"""
Load all segments without questions.
"""

ida_loader.NEF_LOPT
"""
Display additional loader options dialog.
"""

ida_loader.NEF_MAN
"""
Manual load.
"""

ida_loader.NEF_MINI
"""
Create mini database (do not copy segment bytes from the input file;
use only the file header metadata)
"""

ida_loader.NEF_NAME
"""
Rename entries.
"""

ida_loader.NEF_RELOAD
"""
reload the file at the same place: - don't create segmentsdon't create
fixup infodon't import segmentsetc load only the bytes into the base.
a loader should have 'LDRF_RELOAD' bit set
"""

ida_loader.NEF_RSCS
"""
Load resources.
"""

ida_loader.NEF_SEGS
"""
Create segments.
"""

ida_loader.PLUGIN_DLL
"""
Pattern to find plugin files.
"""

ida_loader.SSF_AUTOMATIC
"""
automatic snapshot
"""

ida_loader.SSUF_DESC
"""
Update the description.
"""

ida_loader.SSUF_FLAGS
"""
Update the flags.
"""

ida_loader.SSUF_PATH
"""
Update the path.
"""
=== ida_loader EPYDOC INJECTIONS END ===
Help on class bookmarks_t in module ida_moves:

class bookmarks_t(__builtin__.object)
 |  Proxy of C++ bookmarks_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  erase(*args)
 |      erase(e, index, ud) -> bool
 |          e: lochist_entry_t const &
 |          index: uint32
 |          ud: void *
 |  
 |  find_index(*args)
 |      find_index(e, ud) -> uint32
 |          e: lochist_entry_t const &
 |          ud: void *
 |  
 |  get(*args)
 |      get(out_entry, out_desc, index, ud) -> bool
 |          out_entry: lochist_entry_t *
 |          out_desc: qstring *
 |          index: uint32 *
 |          ud: void *
 |  
 |  get_desc(*args)
 |      get_desc(e, index, ud) -> bool
 |          e: lochist_entry_t const &
 |          index: uint32
 |          ud: void *
 |  
 |  mark(*args)
 |      mark(e, index, title, desc, ud) -> uint32
 |          e: lochist_entry_t const &
 |          index: uint32
 |          title: char const *
 |          desc: char const *
 |          ud: void *
 |  
 |  size(*args)
 |      size(e, ud) -> uint32
 |          e: lochist_entry_t const &
 |          ud: void *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function bookmarks_t_erase in module ida_moves:

bookmarks_t_erase(*args)
    bookmarks_t_erase(e, index, ud) -> bool
        e: lochist_entry_t const &
        index: uint32
        ud: void *

Help on function bookmarks_t_find_index in module ida_moves:

bookmarks_t_find_index(*args)
    bookmarks_t_find_index(e, ud) -> uint32
        e: lochist_entry_t const &
        ud: void *

Help on function bookmarks_t_get in module ida_moves:

bookmarks_t_get(*args)
    bookmarks_t_get(out_entry, out_desc, index, ud) -> bool
        out_entry: lochist_entry_t *
        out_desc: qstring *
        index: uint32 *
        ud: void *

Help on function bookmarks_t_get_desc in module ida_moves:

bookmarks_t_get_desc(*args)
    bookmarks_t_get_desc(e, index, ud) -> str
        e: lochist_entry_t const &
        index: uint32
        ud: void *

Help on function bookmarks_t_mark in module ida_moves:

bookmarks_t_mark(*args)
    bookmarks_t_mark(e, index, title, desc, ud) -> uint32
        e: lochist_entry_t const &
        index: uint32
        title: char const *
        desc: char const *
        ud: void *

Help on function bookmarks_t_size in module ida_moves:

bookmarks_t_size(*args)
    bookmarks_t_size(e, ud) -> uint32
        e: lochist_entry_t const &
        ud: void *

Help on class graph_location_info_t in module ida_moves:

class graph_location_info_t(__builtin__.object)
 |  Proxy of C++ graph_location_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: graph_location_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_location_info_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: graph_location_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  orgx
 |      graph_location_info_t_orgx_get(self) -> double
 |  
 |  orgy
 |      graph_location_info_t_orgy_get(self) -> double
 |  
 |  thisown
 |      The membership flag
 |  
 |  zoom
 |      graph_location_info_t_zoom_get(self) -> double
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_graph_location_info_t>
 |      delete_graph_location_info_t(self)

Help on class lochist_entry_t in module ida_moves:

class lochist_entry_t(__builtin__.object)
 |  Proxy of C++ lochist_entry_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lochist_entry_t
 |          p: place_t const *
 |          r: renderer_info_t const &
 |      
 |      
 |      __init__(self, other) -> lochist_entry_t
 |          other: lochist_entry_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  acquire_place(self, *args)
 |      acquire_place(self, in_p)
 |          @param in_p (C++: place_t  *)
 |  
 |  is_valid(self, *args)
 |      is_valid(self) -> bool
 |  
 |  place(self, *args)
 |      place(self) -> place_t
 |      place(self) -> place_t
 |  
 |  renderer_info(self, *args)
 |      renderer_info(self) -> renderer_info_t
 |      renderer_info(self) -> renderer_info_t
 |  
 |  set_place(self, *args)
 |      set_place(self, p)
 |          @param p (C++: const  place_t  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  plce
 |      lochist_entry_t_plce_get(self) -> place_t
 |  
 |  rinfo
 |      lochist_entry_t_rinfo_get(self) -> renderer_info_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lochist_entry_t>
 |      delete_lochist_entry_t(self)

Help on class lochist_t in module ida_moves:

class lochist_t(__builtin__.object)
 |  Proxy of C++ lochist_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lochist_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  back(self, *args)
 |      back(self, cnt, try_to_unhide) -> bool
 |          @param cnt (C++: uint32)
 |          @param try_to_unhide (C++: bool)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  current_index(self, *args)
 |      current_index(self) -> uint32
 |  
 |  fwd(self, *args)
 |      fwd(self, cnt, try_to_unhide) -> bool
 |          @param cnt (C++: uint32)
 |          @param try_to_unhide (C++: bool)
 |  
 |  get(self, *args)
 |      get(self, out, index) -> bool
 |          @param out (C++: lochist_entry_t  *)
 |          @param index (C++: uint32)
 |  
 |  get_current(self, *args)
 |      get_current(self) -> lochist_entry_t
 |  
 |  get_place_id(self, *args)
 |      get_place_id(self) -> int
 |  
 |  get_template_place(self, *args)
 |      get_template_place(self) -> place_t
 |  
 |  init(self, *args)
 |      init(self, stream_name, _defpos, _ud, _flags) -> bool
 |          @param stream_name (C++: const char *)
 |          @param _defpos (C++: const  place_t  *)
 |          @param _ud (C++: void *)
 |          @param _flags (C++: uint32)
 |  
 |  is_history_enabled(self, *args)
 |      is_history_enabled(self) -> bool
 |  
 |  jump(self, *args)
 |      jump(self, try_to_unhide, e)
 |          @param try_to_unhide (C++: bool)
 |          @param e (C++: const  lochist_entry_t  &)
 |  
 |  netcode(self, *args)
 |      netcode(self) -> nodeidx_t
 |  
 |  save(self, *args)
 |      save(self)
 |  
 |  seek(self, *args)
 |      seek(self, index, try_to_unhide) -> bool
 |          @param index (C++: uint32)
 |          @param try_to_unhide (C++: bool)
 |  
 |  set(self, *args)
 |      set(self, index, e)
 |          @param index (C++: uint32)
 |          @param e (C++: const  lochist_entry_t  &)
 |  
 |  set_current(self, *args)
 |      set_current(self, e)
 |          @param e (C++: const  lochist_entry_t  &)
 |  
 |  size(self, *args)
 |      size(self) -> uint32
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lochist_t>
 |      delete_lochist_t(self)

Help on class renderer_info_pos_t in module ida_moves:

class renderer_info_pos_t(__builtin__.object)
 |  Proxy of C++ renderer_info_pos_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: renderer_info_pos_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> renderer_info_pos_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: renderer_info_pos_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cx
 |      renderer_info_pos_t_cx_get(self) -> short
 |  
 |  cy
 |      renderer_info_pos_t_cy_get(self) -> short
 |  
 |  node
 |      renderer_info_pos_t_node_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_renderer_info_pos_t>
 |      delete_renderer_info_pos_t(self)

Help on class renderer_info_t in module ida_moves:

class renderer_info_t(__builtin__.object)
 |  Proxy of C++ renderer_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: renderer_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> renderer_info_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: renderer_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  gli
 |      renderer_info_t_gli_get(self) -> graph_location_info_t
 |  
 |  pos
 |      renderer_info_t_pos_get(self) -> renderer_info_pos_t
 |  
 |  rtype
 |      renderer_info_t_rtype_get(self) -> tcc_renderer_type_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_renderer_info_t>
 |      delete_renderer_info_t(self)

Help on class segm_move_info_t in module ida_moves:

class segm_move_info_t(__builtin__.object)
 |  Proxy of C++ segm_move_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: segm_move_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _from=0, _to=0, _sz=0) -> segm_move_info_t
 |          _from: ea_t
 |          _to: ea_t
 |          _sz: size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: segm_move_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  _from
 |      segm_move_info_t__from_get(self) -> ea_t
 |  
 |  size
 |      segm_move_info_t_size_get(self) -> size_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  to
 |      segm_move_info_t_to_get(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_segm_move_info_t>
 |      delete_segm_move_info_t(self)

Help on class segm_move_info_vec_t in module ida_moves:

class segm_move_info_vec_t(__builtin__.object)
 |  Proxy of C++ qvector< segm_move_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< segm_move_info_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> segm_move_info_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> segm_move_info_vec_t
 |          x: qvector< segm_move_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< segm_move_info_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: segm_move_info_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: segm_move_info_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: segm_move_info_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> segm_move_info_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> segm_move_info_t
 |      begin(self) -> segm_move_info_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> segm_move_info_t
 |      end(self) -> segm_move_info_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> segm_move_info_t
 |          it: qvector< segm_move_info_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> segm_move_info_t
 |          first: qvector< segm_move_info_t >::iterator
 |          last: qvector< segm_move_info_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> segm_move_info_t
 |  
 |  find(self, *args)
 |      find(self, x) -> segm_move_info_t
 |          x: segm_move_info_t const &
 |      
 |      
 |      find(self, x) -> segm_move_info_t
 |          x: segm_move_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=segm_move_info_t())
 |          x: segm_move_info_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: segm_move_info_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: segm_move_info_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> segm_move_info_t
 |          it: qvector< segm_move_info_t >::iterator
 |          x: segm_move_info_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: segm_move_info_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: segm_move_info_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< segm_move_info_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_segm_move_info_vec_t>
 |      delete_segm_move_info_vec_t(self)

Help on class segm_move_infos_t in module ida_moves:

class segm_move_infos_t(segm_move_info_vec_t)
 |  Proxy of C++ segm_move_infos_t class.
 |  
 |  Method resolution order:
 |      segm_move_infos_t
 |      segm_move_info_vec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> segm_move_infos_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  find(self, *args)
 |      find(self, ea) -> segm_move_info_t
 |          @param ea (C++: ea_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_segm_move_infos_t>
 |      delete_segm_move_infos_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from segm_move_info_vec_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< segm_move_info_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> segm_move_info_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< segm_move_info_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: segm_move_info_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: segm_move_info_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: segm_move_info_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> segm_move_info_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> segm_move_info_t
 |      begin(self) -> segm_move_info_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> segm_move_info_t
 |      end(self) -> segm_move_info_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> segm_move_info_t
 |          it: qvector< segm_move_info_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> segm_move_info_t
 |          first: qvector< segm_move_info_t >::iterator
 |          last: qvector< segm_move_info_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> segm_move_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=segm_move_info_t())
 |          x: segm_move_info_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: segm_move_info_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: segm_move_info_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> segm_move_info_t
 |          it: qvector< segm_move_info_t >::iterator
 |          x: segm_move_info_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: segm_move_info_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: segm_move_info_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< segm_move_info_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from segm_move_info_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function get_switch_info in module ida_nalt:

get_switch_info(*args)
    get_switch_info(out, ea) -> ssize_t
        @param out (C++: switch_info_t  *)
        @param ea (C++: ea_t)

Help on function add_encoding in module ida_nalt:

add_encoding(*args)
    Add a new encoding (e.g. "UTF-8").
    
    add_encoding(encoding) -> int
        @param encoding (C++: const char *)
        @return: its index (1-based) if it's already in the list, return its
                 index

Help on class array_parameters_t in module ida_nalt:

class array_parameters_t(__builtin__.object)
 |  Proxy of C++ array_parameters_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_parameters_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  alignment
 |      array_parameters_t_alignment_get(self) -> int32
 |  
 |  flags
 |      array_parameters_t_flags_get(self) -> int32
 |  
 |  lineitems
 |      array_parameters_t_lineitems_get(self) -> int32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_array_parameters_t>
 |      delete_array_parameters_t(self)

Help on function clr__bnot0 in module ida_nalt:

clr__bnot0(*args)
    clr__bnot0(ea)
        @param ea (C++: ea_t)

Help on function clr__bnot1 in module ida_nalt:

clr__bnot1(*args)
    clr__bnot1(ea)
        @param ea (C++: ea_t)

Help on function clr__invsign0 in module ida_nalt:

clr__invsign0(*args)
    clr__invsign0(ea)
        @param ea (C++: ea_t)

Help on function clr__invsign1 in module ida_nalt:

clr__invsign1(*args)
    clr__invsign1(ea)
        @param ea (C++: ea_t)

Help on function clr_abits in module ida_nalt:

clr_abits(*args)
    clr_abits(ea, bits)
        @param ea (C++: ea_t)
        @param bits (C++: uint32)

Help on function clr_align_flow in module ida_nalt:

clr_align_flow(*args)
    clr_align_flow(ea)
        @param ea (C++: ea_t)

Help on function clr_colored_item in module ida_nalt:

clr_colored_item(*args)
    clr_colored_item(ea)
        @param ea (C++: ea_t)

Help on function clr_fixed_spd in module ida_nalt:

clr_fixed_spd(*args)
    clr_fixed_spd(ea)
        @param ea (C++: ea_t)

Help on function clr_has_lname in module ida_nalt:

clr_has_lname(*args)
    clr_has_lname(ea)
        @param ea (C++: ea_t)

Help on function clr_has_ti in module ida_nalt:

clr_has_ti(*args)
    clr_has_ti(ea)
        @param ea (C++: ea_t)

Help on function clr_has_ti0 in module ida_nalt:

clr_has_ti0(*args)
    clr_has_ti0(ea)
        @param ea (C++: ea_t)

Help on function clr_has_ti1 in module ida_nalt:

clr_has_ti1(*args)
    clr_has_ti1(ea)
        @param ea (C++: ea_t)

Help on function clr_libitem in module ida_nalt:

clr_libitem(*args)
    clr_libitem(ea)
        @param ea (C++: ea_t)

Help on function clr_lzero0 in module ida_nalt:

clr_lzero0(*args)
    clr_lzero0(ea)
        @param ea (C++: ea_t)

Help on function clr_lzero1 in module ida_nalt:

clr_lzero1(*args)
    clr_lzero1(ea)
        @param ea (C++: ea_t)

Help on function clr_noret in module ida_nalt:

clr_noret(*args)
    clr_noret(ea)
        @param ea (C++: ea_t)

Help on function clr_notcode in module ida_nalt:

clr_notcode(*args)
    Clear not-code mark.
    
    clr_notcode(ea)
        @param ea (C++: ea_t)

Help on function clr_notproc in module ida_nalt:

clr_notproc(*args)
    clr_notproc(ea)
        @param ea (C++: ea_t)

Help on function clr_retfp in module ida_nalt:

clr_retfp(*args)
    clr_retfp(ea)
        @param ea (C++: ea_t)

Help on function clr_terse_struc in module ida_nalt:

clr_terse_struc(*args)
    clr_terse_struc(ea)
        @param ea (C++: ea_t)

Help on function clr_tilcmt in module ida_nalt:

clr_tilcmt(*args)
    clr_tilcmt(ea)
        @param ea (C++: ea_t)

Help on function clr_usemodsp in module ida_nalt:

clr_usemodsp(*args)
    clr_usemodsp(ea)
        @param ea (C++: ea_t)

Help on function clr_usersp in module ida_nalt:

clr_usersp(*args)
    clr_usersp(ea)
        @param ea (C++: ea_t)

Help on function clr_userti in module ida_nalt:

clr_userti(*args)
    clr_userti(ea)
        @param ea (C++: ea_t)

Help on function clr_zstroff in module ida_nalt:

clr_zstroff(*args)
    clr_zstroff(ea)
        @param ea (C++: ea_t)

Help on class custom_data_type_ids_fids_array in module ida_nalt:

class custom_data_type_ids_fids_array(__builtin__.object)
 |  Proxy of C++ wrapped_array_t< int16,8 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> short const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> custom_data_type_ids_fids_array
 |          data: short (&)[8]
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: short const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  data
 |      custom_data_type_ids_fids_array_data_get(self) -> short (&)[8]
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_custom_data_type_ids_fids...
 |      delete_custom_data_type_ids_fids_array(self)

Help on class custom_data_type_ids_t in module ida_nalt:

class custom_data_type_ids_t(__builtin__.object)
 |  Proxy of C++ custom_data_type_ids_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> custom_data_type_ids_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _custom_data_type_ids_t__getFids = __getFids(self, *args)
 |      __getFids(self) -> custom_data_type_ids_fids_array
 |  
 |  set(self, *args)
 |      set(self, tid)
 |          @param tid (C++: tid_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dtid
 |      custom_data_type_ids_t_dtid_get(self) -> int16
 |  
 |  fids
 |      __getFids(self) -> custom_data_type_ids_fids_array
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_custom_data_type_ids_t>
 |      delete_custom_data_type_ids_t(self)

Help on function dbg_get_input_path in module ida_nalt:

dbg_get_input_path(*args)
    Get debugger input file name/path (see 'LFLG_DBG_NOPATH' )

Help on function del_absbase in module ida_nalt:

del_absbase(*args)
    del_absbase(ea)
        @param ea (C++: ea_t)

Help on function del_aflags in module ida_nalt:

del_aflags(*args)
    del_aflags(ea)
        @param ea (C++: ea_t)

Help on function del_alignment in module ida_nalt:

del_alignment(*args)
    del_alignment(ea)
        @param ea (C++: ea_t)

Help on function del_array_parameters in module ida_nalt:

del_array_parameters(*args)
    del_array_parameters(ea)
        @param ea (C++: ea_t)

Help on function del_custom_data_type_ids in module ida_nalt:

del_custom_data_type_ids(*args)
    del_custom_data_type_ids(ea)
        @param ea (C++: ea_t)

Help on function del_encoding in module ida_nalt:

del_encoding(*args)
    Delete an encoding (1-based)
    
    del_encoding(idx) -> bool
        @param idx (C++: int)

Help on function del_ind_purged in module ida_nalt:

del_ind_purged(*args)
    del_ind_purged(ea)
        @param ea (C++: ea_t)

Help on function del_item_color in module ida_nalt:

del_item_color(*args)
    del_item_color(ea) -> bool
        @param ea (C++: ea_t)

Help on function del_op_tinfo in module ida_nalt:

del_op_tinfo(*args)
    del_op_tinfo(ea, n)
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function del_refinfo in module ida_nalt:

del_refinfo(*args)
    del_refinfo(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function del_source_linnum in module ida_nalt:

del_source_linnum(*args)
    del_source_linnum(ea)
        @param ea (C++: ea_t)

Help on function del_str_type in module ida_nalt:

del_str_type(*args)
    del_str_type(ea)
        @param ea (C++: ea_t)

Help on function del_switch_info in module ida_nalt:

del_switch_info(*args)
    del_switch_info(ea)
        @param ea (C++: ea_t)

Help on function del_switch_parent in module ida_nalt:

del_switch_parent(*args)
    del_switch_parent(ea)
        @param ea (C++: ea_t)

Help on function del_tinfo in module ida_nalt:

del_tinfo(*args)
    del_tinfo(ea)
        @param ea (C++: ea_t)

Help on function delete_imports in module ida_nalt:

delete_imports(*args)
    Delete all imported modules information.

Help on function ea2node in module ida_nalt:

ea2node(*args)
    Get netnode for the specified address.
    
    ea2node(ea) -> nodeidx_t
        @param ea (C++: ea_t)

Help on function encoding_from_strtype in module ida_nalt:

encoding_from_strtype(*args)
    Get encoding name for this strtype.
    
    encoding_from_strtype(strtype) -> char const *
        @param strtype (C++: int32)

Help on class enum_const_t in module ida_nalt:

class enum_const_t(__builtin__.object)
 |  Proxy of C++ enum_const_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_const_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  serial
 |      enum_const_t_serial_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      enum_const_t_tid_get(self) -> tid_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_enum_const_t>
 |      delete_enum_const_t(self)

Help on function enum_import_names in module ida_nalt:

enum_import_names(*args)
    enum_import_names(mod_index, py_cb) -> int
    Enumerate imports from a specific module.
    Please refer to ex_imports.py example.
    
    @param mod_index: The module index
    @param callback: A callable object that will be invoked with an ea, name (could be None) and ordinal.
    @return: 1-finished ok, -1 on error, otherwise callback return value (<=0)

Help on function find_custom_refinfo in module ida_nalt:

find_custom_refinfo(*args)
    Get id of a custom refinfo type.
    
    find_custom_refinfo(name) -> int
        @param name (C++: const char *)

Help on function get_abi_name in module ida_nalt:

get_abi_name(*args)

Help on function get_absbase in module ida_nalt:

get_absbase(*args)
    get_absbase(ea) -> ea_t
        @param ea (C++: ea_t)

Help on function get_aflags in module ida_nalt:

get_aflags(*args)
    get_aflags(ea) -> uint32
        @param ea (C++: ea_t)

Help on function get_alignment in module ida_nalt:

get_alignment(*args)
    get_alignment(ea) -> uint32
        @param ea (C++: ea_t)

Help on function get_archive_path in module ida_nalt:

get_archive_path(*args)
    Get archive file path from which input file was extracted.

Help on function get_array_parameters in module ida_nalt:

get_array_parameters(*args)
    get_array_parameters(out, ea) -> ssize_t
        @param out (C++: array_parameters_t  *)
        @param ea (C++: ea_t)

Help on function get_asm_inc_file in module ida_nalt:

get_asm_inc_file(*args)
    Get name of the include file.

Help on function get_custom_data_type_ids in module ida_nalt:

get_custom_data_type_ids(*args)
    get_custom_data_type_ids(cdis, ea) -> int
        @param cdis (C++: custom_data_type_ids_t  *)
        @param ea (C++: ea_t)

Help on function get_custom_refinfo in module ida_nalt:

get_custom_refinfo(*args)
    Get definition of a registered custom refinfo type.
    
    get_custom_refinfo(crid) -> custom_refinfo_handler_t const *
        @param crid (C++: int)

Help on function get_default_encoding_idx in module ida_nalt:

get_default_encoding_idx(*args)
    Get default encoding index for a specific string type.
    
    get_default_encoding_idx(bpu) -> int
        @param bpu: the amount of bytes per unit (e.g., 1 for ASCII, CP1252,
                    UTF-8..., 2 for UTF-16, 4 for UTF-32) 0 means no specific
                    encoding is set - byte values are displayed without
                    conversion. (C++: int)

Help on function get_encoding_bpu in module ida_nalt:

get_encoding_bpu(*args)
    Get the amount of bytes per unit (e.g., 2 for UTF-16, 4 for UTF-32)
    for the encoding with the given index.
    
    get_encoding_bpu(idx) -> int
        @param idx: the encoding index (C++: int)
        @return: the number of bytes per units (1/2/4); -1 means error

Help on function get_encoding_name in module ida_nalt:

get_encoding_name(*args)
    Get encoding name for specific index (1-based).
    
    get_encoding_name(idx) -> char const *
        @param idx (C++: int)
        @return: NULL if idx is out of bounds

Help on function get_encoding_qty in module ida_nalt:

get_encoding_qty(*args)
    Get total number of encodings (counted from 0)

Help on function get_gotea in module ida_nalt:

get_gotea(*args)
    get_gotea() -> ea_t

Help on function get_ids_modnode in module ida_nalt:

get_ids_modnode(*args)
    Get ids modnode.

Help on function get_imagebase in module ida_nalt:

get_imagebase(*args)
    Get image base address.

Help on function get_import_module_name in module ida_nalt:

get_import_module_name(*args)
    get_import_module_name(mod_index) -> PyObject *
    Returns the name of an imported module given its index
    @return: None or the module name

Help on function get_import_module_qty in module ida_nalt:

get_import_module_qty(*args)
    Get number of import modules.

Help on function get_ind_purged in module ida_nalt:

get_ind_purged(*args)
    get_ind_purged(ea) -> ea_t
        @param ea (C++: ea_t)

Help on function get_input_file_path in module ida_nalt:

get_input_file_path(*args)
    Get full path of the input file.

Help on function get_item_color in module ida_nalt:

get_item_color(*args)
    get_item_color(ea) -> bgcolor_t
        @param ea (C++: ea_t)

Help on function get_op_tinfo in module ida_nalt:

get_op_tinfo(*args)
    get_op_tinfo(tif, ea, n) -> bool
        @param tif (C++: tinfo_t  *)
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function get_outfile_encoding_idx in module ida_nalt:

get_outfile_encoding_idx(*args)
    Get the index of the encoding used when producing files 0 means no
    that the IDB's default 1 byte-per-unit encoding is used

Help on function get_refinfo in module ida_nalt:

get_refinfo(*args)
    get_refinfo(ri, ea, n) -> bool
        @param ri (C++: refinfo_t  *)
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function get_reftype_by_size in module ida_nalt:

get_reftype_by_size(*args)
    Get REF_... constant from size Supported sizes: 1,2,4,8,16 For other
    sizes returns reftype_t(-1)
    
    get_reftype_by_size(size) -> reftype_t
        @param size (C++: size_t)

Help on function get_root_filename in module ida_nalt:

get_root_filename(*args)
    Get file name only of the input file.

Help on function get_source_linnum in module ida_nalt:

get_source_linnum(*args)
    get_source_linnum(ea) -> uval_t
        @param ea (C++: ea_t)

Help on function get_str_encoding_idx in module ida_nalt:

get_str_encoding_idx(*args)
    Get index of the string encoding for this string.
    
    get_str_encoding_idx(strtype) -> uchar
        @param strtype (C++: int32)

Help on function get_str_term1 in module ida_nalt:

get_str_term1(*args)
    get_str_term1(strtype) -> char
        @param strtype (C++: int32)

Help on function get_str_term2 in module ida_nalt:

get_str_term2(*args)
    get_str_term2(strtype) -> char
        @param strtype (C++: int32)

Help on function get_str_type in module ida_nalt:

get_str_type(*args)
    get_str_type(ea) -> uint32
        @param ea (C++: ea_t)

Help on function get_str_type_code in module ida_nalt:

get_str_type_code(*args)
    get_str_type_code(strtype) -> uchar
        @param strtype (C++: int32)

Help on function get_str_type_prefix_length in module ida_nalt:

get_str_type_prefix_length(*args)
    get_str_type_prefix_length(strtype) -> size_t
        @param strtype (C++: int32)

Help on function get_strtype_bpu in module ida_nalt:

get_strtype_bpu(*args)
    get_strtype_bpu(strtype) -> int
        @param strtype (C++: int32)

Help on function get_switch_info in module ida_nalt:

get_switch_info(*args)

Help on function get_switch_parent in module ida_nalt:

get_switch_parent(*args)
    get_switch_parent(ea) -> ea_t
        @param ea (C++: ea_t)

Help on function get_tinfo in module ida_nalt:

get_tinfo(*args)
    get_tinfo(tif, ea) -> bool
        @param tif (C++: tinfo_t  *)
        @param ea (C++: ea_t)

Help on function getnode in module ida_nalt:

getnode(*args)
    getnode(ea) -> netnode
        @param ea (C++: ea_t)

Help on function has_lname in module ida_nalt:

has_lname(*args)
    has_lname(ea) -> bool
        @param ea (C++: ea_t)

Help on function has_ti in module ida_nalt:

has_ti(*args)
    has_ti(ea) -> bool
        @param ea (C++: ea_t)

Help on function has_ti0 in module ida_nalt:

has_ti0(*args)
    has_ti0(ea) -> bool
        @param ea (C++: ea_t)

Help on function has_ti1 in module ida_nalt:

has_ti1(*args)
    has_ti1(ea) -> bool
        @param ea (C++: ea_t)

Help on function hide_border in module ida_nalt:

hide_border(*args)
    hide_border(ea)
        @param ea (C++: ea_t)

Help on function hide_item in module ida_nalt:

hide_item(*args)
    hide_item(ea)
        @param ea (C++: ea_t)

Help on function is__bnot0 in module ida_nalt:

is__bnot0(*args)
    is__bnot0(ea) -> bool
        @param ea (C++: ea_t)

Help on function is__bnot1 in module ida_nalt:

is__bnot1(*args)
    is__bnot1(ea) -> bool
        @param ea (C++: ea_t)

Help on function is__invsign0 in module ida_nalt:

is__invsign0(*args)
    is__invsign0(ea) -> bool
        @param ea (C++: ea_t)

Help on function is__invsign1 in module ida_nalt:

is__invsign1(*args)
    is__invsign1(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_align_flow in module ida_nalt:

is_align_flow(*args)
    is_align_flow(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_colored_item in module ida_nalt:

is_colored_item(*args)
    is_colored_item(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_finally_visible_item in module ida_nalt:

is_finally_visible_item(*args)
    Is instruction visible?
    
    is_finally_visible_item(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_fixed_spd in module ida_nalt:

is_fixed_spd(*args)
    is_fixed_spd(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_hidden_border in module ida_nalt:

is_hidden_border(*args)
    is_hidden_border(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_hidden_item in module ida_nalt:

is_hidden_item(*args)
    is_hidden_item(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_libitem in module ida_nalt:

is_libitem(*args)
    is_libitem(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_lzero0 in module ida_nalt:

is_lzero0(*args)
    is_lzero0(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_lzero1 in module ida_nalt:

is_lzero1(*args)
    is_lzero1(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_noret in module ida_nalt:

is_noret(*args)
    is_noret(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_notcode in module ida_nalt:

is_notcode(*args)
    Is the address marked as not-code?
    
    is_notcode(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_notproc in module ida_nalt:

is_notproc(*args)
    is_notproc(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_pascal in module ida_nalt:

is_pascal(*args)
    is_pascal(strtype) -> bool
        @param strtype (C++: int32)

Help on function is_reftype_target_optional in module ida_nalt:

is_reftype_target_optional(*args)
    Can the target be calculated using operand value?
    
    is_reftype_target_optional(type) -> bool
        @param type (C++: reftype_t)

Help on function is_retfp in module ida_nalt:

is_retfp(*args)
    is_retfp(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_terse_struc in module ida_nalt:

is_terse_struc(*args)
    is_terse_struc(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_tilcmt in module ida_nalt:

is_tilcmt(*args)
    is_tilcmt(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_usersp in module ida_nalt:

is_usersp(*args)
    is_usersp(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_userti in module ida_nalt:

is_userti(*args)
    is_userti(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_visible_item in module ida_nalt:

is_visible_item(*args)
    Test visibility of item at given ea.
    
    is_visible_item(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_zstroff in module ida_nalt:

is_zstroff(*args)
    is_zstroff(ea) -> bool
        @param ea (C++: ea_t)

Help on function node2ea in module ida_nalt:

node2ea(*args)
    node2ea(ndx) -> ea_t
        @param ndx (C++: nodeidx_t)

Help on class opinfo_t in module ida_nalt:

class opinfo_t(__builtin__.object)
 |  Proxy of C++ opinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> opinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cd
 |      opinfo_t_cd_get(self) -> custom_data_type_ids_t
 |  
 |  ec
 |      opinfo_t_ec_get(self) -> enum_const_t
 |  
 |  path
 |      opinfo_t_path_get(self) -> strpath_t
 |  
 |  ri
 |      opinfo_t_ri_get(self) -> refinfo_t
 |  
 |  strtype
 |      opinfo_t_strtype_get(self) -> int32
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      opinfo_t_tid_get(self) -> tid_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_opinfo_t>
 |      delete_opinfo_t(self)

Help on class printop_t in module ida_nalt:

class printop_t(__builtin__.object)
 |  Proxy of C++ printop_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> printop_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_ti(self, *args)
 |      get_ti(self) -> opinfo_t
 |  
 |  is_aflags_initialized(self, *args)
 |      is_aflags_initialized(self) -> bool
 |  
 |  is_ti_initialized(self, *args)
 |      is_ti_initialized(self) -> bool
 |  
 |  set_aflags_initialized(self, *args)
 |      set_aflags_initialized(self, v=True)
 |          @param v (C++: bool)
 |  
 |  set_ti_initialized(self, *args)
 |      set_ti_initialized(self, v=True)
 |          @param v (C++: bool)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  aflags
 |      printop_t_aflags_get(self) -> flags_t
 |  
 |  features
 |      printop_t_features_get(self) -> uchar
 |  
 |  flags
 |      printop_t_flags_get(self) -> flags_t
 |  
 |  is_ti_valid
 |      is_ti_initialized(self) -> bool
 |  
 |  suspop
 |      printop_t_suspop_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ti
 |      printop_t_ti_get(self) -> opinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_printop_t>
 |      delete_printop_t(self)

Help on class refinfo_t in module ida_nalt:

class refinfo_t(__builtin__.object)
 |  Proxy of C++ refinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> refinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  init(self, *args)
 |      init(self, reft_and_flags, _base=0, _target=BADADDR, _tdelta=0)
 |          @param reft_and_flags (C++: uint32)
 |          @param _base (C++: ea_t)
 |          @param _target (C++: ea_t)
 |          @param _tdelta (C++: adiff_t)
 |  
 |  is_custom(self, *args)
 |      is_custom(self) -> bool
 |  
 |  is_pastend(self, *args)
 |      is_pastend(self) -> bool
 |  
 |  is_rvaoff(self, *args)
 |      is_rvaoff(self) -> bool
 |  
 |  is_signed(self, *args)
 |      is_signed(self) -> bool
 |  
 |  is_subtract(self, *args)
 |      is_subtract(self) -> bool
 |  
 |  is_target_optional(self, *args)
 |      < 'is_reftype_target_optional()'
 |  
 |  no_base_xref(self, *args)
 |      no_base_xref(self) -> bool
 |  
 |  set_type(self, *args)
 |      set_type(self, rt)
 |          @param rt (C++: reftype_t)
 |  
 |  type(self, *args)
 |      type(self) -> reftype_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  base
 |      refinfo_t_base_get(self) -> ea_t
 |  
 |  flags
 |      refinfo_t_flags_get(self) -> uint32
 |  
 |  target
 |      refinfo_t_target_get(self) -> ea_t
 |  
 |  tdelta
 |      refinfo_t_tdelta_get(self) -> adiff_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_refinfo_t>
 |      delete_refinfo_t(self)

Help on function rename_encoding in module ida_nalt:

rename_encoding(*args)
    Change name for an encoding (1-based)
    
    rename_encoding(idx, encoding) -> bool
        @param idx (C++: int)
        @param encoding (C++: const char *)

Help on function retrieve_input_file_crc32 in module ida_nalt:

retrieve_input_file_crc32(*args)
    Get input file crc32 stored in the database. it can be used to check
    that the input file has not been changed.

Help on function retrieve_input_file_md5 in module ida_nalt:

retrieve_input_file_md5(*args)
    Get input file md5.

Help on function retrieve_input_file_sha256 in module ida_nalt:

retrieve_input_file_sha256(*args)
    Get input file sha256.

Help on function retrieve_input_file_size in module ida_nalt:

retrieve_input_file_size(*args)
    Get size of input file in bytes.

Help on function set__bnot0 in module ida_nalt:

set__bnot0(*args)
    set__bnot0(ea)
        @param ea (C++: ea_t)

Help on function set__bnot1 in module ida_nalt:

set__bnot1(*args)
    set__bnot1(ea)
        @param ea (C++: ea_t)

Help on function set__invsign0 in module ida_nalt:

set__invsign0(*args)
    set__invsign0(ea)
        @param ea (C++: ea_t)

Help on function set__invsign1 in module ida_nalt:

set__invsign1(*args)
    set__invsign1(ea)
        @param ea (C++: ea_t)

Help on function set_abits in module ida_nalt:

set_abits(*args)
    set_abits(ea, bits)
        @param ea (C++: ea_t)
        @param bits (C++: uint32)

Help on function set_absbase in module ida_nalt:

set_absbase(*args)
    set_absbase(ea, x)
        @param ea (C++: ea_t)
        @param x (C++: ea_t)

Help on function set_aflags in module ida_nalt:

set_aflags(*args)
    set_aflags(ea, flags)
        @param ea (C++: ea_t)
        @param flags (C++: uint32)

Help on function set_align_flow in module ida_nalt:

set_align_flow(*args)
    set_align_flow(ea)
        @param ea (C++: ea_t)

Help on function set_alignment in module ida_nalt:

set_alignment(*args)
    set_alignment(ea, x)
        @param ea (C++: ea_t)
        @param x (C++: uint32)

Help on function set_archive_path in module ida_nalt:

set_archive_path(*args)
    Set archive file path from which input file was extracted.
    
    set_archive_path(file) -> bool
        @param file (C++: const char *)

Help on function set_array_parameters in module ida_nalt:

set_array_parameters(*args)
    set_array_parameters(ea, _in)
        @param ea (C++: ea_t)
        in: array_parameters_t const *

Help on function set_asm_inc_file in module ida_nalt:

set_asm_inc_file(*args)
    Set name of the include file.
    
    set_asm_inc_file(file) -> bool
        @param file (C++: const char *)

Help on function set_colored_item in module ida_nalt:

set_colored_item(*args)
    set_colored_item(ea)
        @param ea (C++: ea_t)

Help on function set_custom_data_type_ids in module ida_nalt:

set_custom_data_type_ids(*args)
    set_custom_data_type_ids(ea, cdis)
        @param ea (C++: ea_t)
        @param cdis (C++: const  custom_data_type_ids_t  *)

Help on function set_default_encoding_idx in module ida_nalt:

set_default_encoding_idx(*args)
    set default encoding for a string type
    
    set_default_encoding_idx(bpu, idx) -> bool
        @param bpu: the amount of bytes per unit (C++: int)
        @param idx: the encoding index idx can be 0 to disable encoding
                    conversion (C++: int)

Help on function set_fixed_spd in module ida_nalt:

set_fixed_spd(*args)
    set_fixed_spd(ea)
        @param ea (C++: ea_t)

Help on function set_gotea in module ida_nalt:

set_gotea(*args)
    set_gotea(gotea)
        @param gotea (C++: ea_t)

Help on function set_has_lname in module ida_nalt:

set_has_lname(*args)
    set_has_lname(ea)
        @param ea (C++: ea_t)

Help on function set_has_ti in module ida_nalt:

set_has_ti(*args)
    set_has_ti(ea)
        @param ea (C++: ea_t)

Help on function set_has_ti0 in module ida_nalt:

set_has_ti0(*args)
    set_has_ti0(ea)
        @param ea (C++: ea_t)

Help on function set_has_ti1 in module ida_nalt:

set_has_ti1(*args)
    set_has_ti1(ea)
        @param ea (C++: ea_t)

Help on function set_ids_modnode in module ida_nalt:

set_ids_modnode(*args)
    Set ids modnode.
    
    set_ids_modnode(id)
        @param id (C++: netnode)

Help on function set_imagebase in module ida_nalt:

set_imagebase(*args)
    Set image base address.
    
    set_imagebase(base)
        @param base (C++: ea_t)

Help on function set_item_color in module ida_nalt:

set_item_color(*args)
    set_item_color(ea, color)
        @param ea (C++: ea_t)
        @param color (C++: bgcolor_t)

Help on function set_libitem in module ida_nalt:

set_libitem(*args)
    set_libitem(ea)
        @param ea (C++: ea_t)

Help on function set_lzero0 in module ida_nalt:

set_lzero0(*args)
    set_lzero0(ea)
        @param ea (C++: ea_t)

Help on function set_lzero1 in module ida_nalt:

set_lzero1(*args)
    set_lzero1(ea)
        @param ea (C++: ea_t)

Help on function set_noret in module ida_nalt:

set_noret(*args)
    set_noret(ea)
        @param ea (C++: ea_t)

Help on function set_notcode in module ida_nalt:

set_notcode(*args)
    Mark address so that it cannot be converted to instruction.
    
    set_notcode(ea)
        @param ea (C++: ea_t)

Help on function set_notproc in module ida_nalt:

set_notproc(*args)
    set_notproc(ea)
        @param ea (C++: ea_t)

Help on function set_op_tinfo in module ida_nalt:

set_op_tinfo(*args)
    set_op_tinfo(ea, n, tif) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param tif (C++: const  tinfo_t  *)

Help on function set_outfile_encoding_idx in module ida_nalt:

set_outfile_encoding_idx(*args)
    set encoding to be used when producing files
    
    set_outfile_encoding_idx(idx) -> bool
        @param idx: <snipped>
                    <snipped>

Help on function set_refinfo in module ida_nalt:

set_refinfo(*args)
    set_refinfo(ea, n, type, target=BADADDR, base=0, tdelta=0) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param type (C++: reftype_t)
        @param target (C++: ea_t)
        @param base (C++: ea_t)
        @param tdelta (C++: adiff_t)

Help on function set_refinfo_ex in module ida_nalt:

set_refinfo_ex(*args)
    set_refinfo_ex(ea, n, ri) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param ri (C++: const  refinfo_t  *)

Help on function set_retfp in module ida_nalt:

set_retfp(*args)
    set_retfp(ea)
        @param ea (C++: ea_t)

Help on function set_root_filename in module ida_nalt:

set_root_filename(*args)
    Set full path of the input file.
    
    set_root_filename(file)
        @param file (C++: const char *)

Help on function set_source_linnum in module ida_nalt:

set_source_linnum(*args)
    set_source_linnum(ea, lnnum)
        @param ea (C++: ea_t)
        @param lnnum (C++: uval_t)

Help on function set_str_type in module ida_nalt:

set_str_type(*args)
    set_str_type(ea, x)
        @param ea (C++: ea_t)
        @param x (C++: uint32)

Help on function set_switch_info in module ida_nalt:

set_switch_info(*args)
    set_switch_info(ea, _in)
        @param ea (C++: ea_t)
        in: switch_info_t const &

Help on function set_switch_parent in module ida_nalt:

set_switch_parent(*args)
    set_switch_parent(ea, x)
        @param ea (C++: ea_t)
        @param x (C++: ea_t)

Help on function set_terse_struc in module ida_nalt:

set_terse_struc(*args)
    set_terse_struc(ea)
        @param ea (C++: ea_t)

Help on function set_tilcmt in module ida_nalt:

set_tilcmt(*args)
    set_tilcmt(ea)
        @param ea (C++: ea_t)

Help on function set_tinfo in module ida_nalt:

set_tinfo(*args)
    set_tinfo(ea, tif) -> bool
        @param ea (C++: ea_t)
        @param tif (C++: const  tinfo_t  *)

Help on function set_usemodsp in module ida_nalt:

set_usemodsp(*args)
    set_usemodsp(ea)
        @param ea (C++: ea_t)

Help on function set_usersp in module ida_nalt:

set_usersp(*args)
    set_usersp(ea)
        @param ea (C++: ea_t)

Help on function set_userti in module ida_nalt:

set_userti(*args)
    set_userti(ea)
        @param ea (C++: ea_t)

Help on function set_visible_item in module ida_nalt:

set_visible_item(*args)
    Change visibility of item at given ea.
    
    set_visible_item(ea, visible)
        @param ea (C++: ea_t)
        @param visible (C++: bool)

Help on function set_zstroff in module ida_nalt:

set_zstroff(*args)
    set_zstroff(ea)
        @param ea (C++: ea_t)

Help on class strpath_ids_array in module ida_nalt:

class strpath_ids_array(__builtin__.object)
 |  Proxy of C++ wrapped_array_t< tid_t,32 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &↗
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> strpath_ids_array
 |          data: unsigned-ea-like-numeric-type (&)[32]↗
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: unsigned-ea-like-numeric-type const &↗
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  data
 |      strpath_ids_array_data_get(self) -> unsigned-ea-like-numeric-type (&)[32]↗
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_strpath_ids_array>
 |      delete_strpath_ids_array(self)

Help on class strpath_t in module ida_nalt:

class strpath_t(__builtin__.object)
 |  Proxy of C++ strpath_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strpath_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _strpath_t__getIds = __getIds(self, *args)
 |      __getIds(self) -> strpath_ids_array
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  delta
 |      strpath_t_delta_get(self) -> adiff_t
 |  
 |  ids
 |      __getIds(self) -> strpath_ids_array
 |  
 |  len
 |      strpath_t_len_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_strpath_t>
 |      delete_strpath_t(self)

Help on class switch_info_t in module ida_nalt:

class switch_info_t(__builtin__.object)
 |  Proxy of C++ switch_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> switch_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _get_values_lowcase(self, *args)
 |      _get_values_lowcase(self) -> ea_t
 |  
 |  _set_values_lowcase(self, *args)
 |      _set_values_lowcase(self, values)
 |          values: ea_t
 |  
 |  assign(self, *args)
 |      assign(self, other)
 |          other: switch_info_t const &
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  get_jrange_vrange(self, *args)
 |      get separate parts of the switch
 |      
 |      get_jrange_vrange(self, jrange=None, vrange=None) -> bool
 |          @param jrange (C++: range_t  *)
 |          @param vrange (C++: range_t  *)
 |  
 |  get_jtable_element_size(self, *args)
 |      get_jtable_element_size(self) -> int
 |  
 |  get_jtable_size(self, *args)
 |      get_jtable_size(self) -> int
 |  
 |  get_lowcase(self, *args)
 |      get_lowcase(self) -> sval_t
 |  
 |  get_shift(self, *args)
 |      See 'SWI_SHIFT_MASK' . possible answers: 0..3.
 |  
 |  get_version(self, *args)
 |      get_version(self) -> int
 |  
 |  get_vtable_element_size(self, *args)
 |      get_vtable_element_size(self) -> int
 |  
 |  has_default(self, *args)
 |      has_default(self) -> bool
 |  
 |  has_elbase(self, *args)
 |      has_elbase(self) -> bool
 |  
 |  is_custom(self, *args)
 |      is_custom(self) -> bool
 |  
 |  is_indirect(self, *args)
 |      is_indirect(self) -> bool
 |  
 |  is_nolowcase(self, *args)
 |      is_nolowcase(self) -> bool
 |  
 |  is_sparse(self, *args)
 |      is_sparse(self) -> bool
 |  
 |  is_subtract(self, *args)
 |      is_subtract(self) -> bool
 |  
 |  set_elbase(self, *args)
 |      set_elbase(self, base)
 |          @param base (C++: ea_t)
 |  
 |  set_expr(self, *args)
 |      set_expr(self, r, dt)
 |          @param r (C++: int)
 |          @param dt (C++: op_dtype_t)
 |  
 |  set_jtable_element_size(self, *args)
 |      set_jtable_element_size(self, size)
 |          @param size (C++: int)
 |  
 |  set_jtable_size(self, *args)
 |      set_jtable_size(self, size)
 |          @param size (C++: int)
 |  
 |  set_shift(self, *args)
 |      See 'SWI_SHIFT_MASK' .
 |      
 |      set_shift(self, shift)
 |          @param shift (C++: int)
 |  
 |  set_vtable_element_size(self, *args)
 |      set_vtable_element_size(self, size)
 |          @param size (C++: int)
 |  
 |  use_std_table(self, *args)
 |      use_std_table(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  custom
 |      switch_info_t_custom_get(self) -> uval_t
 |  
 |  defjump
 |      switch_info_t_defjump_get(self) -> ea_t
 |  
 |  elbase
 |      switch_info_t_elbase_get(self) -> ea_t
 |  
 |  expr_ea
 |      switch_info_t_expr_ea_get(self) -> ea_t
 |  
 |  flags
 |      switch_info_t_flags_get(self) -> uint32
 |  
 |  ind_lowcase
 |      switch_info_t_ind_lowcase_get(self) -> sval_t
 |  
 |  jcases
 |      switch_info_t_jcases_get(self) -> int
 |  
 |  jumps
 |      switch_info_t_jumps_get(self) -> ea_t
 |  
 |  lowcase
 |      _get_values_lowcase(self) -> ea_t
 |  
 |  marks
 |      switch_info_t_marks_get(self) -> eavec_t *
 |  
 |  ncases
 |      switch_info_t_ncases_get(self) -> ushort
 |  
 |  regdtype
 |      switch_info_t_regdtype_get(self) -> op_dtype_t
 |  
 |  regnum
 |      switch_info_t_regnum_get(self) -> int
 |  
 |  startea
 |      switch_info_t_startea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  values
 |      _get_values_lowcase(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  SWITCH_INFO_VERSION = 2
 |  
 |  __swig_destroy__ = <built-in function delete_switch_info_t>
 |      delete_switch_info_t(self)

Help on function switch_info_t__from_ptrval__ in module ida_nalt:

switch_info_t__from_ptrval__(*args)
    switch_info_t__from_ptrval__(ptrval) -> switch_info_t
        ptrval: size_t

Help on function unhide_border in module ida_nalt:

unhide_border(*args)
    unhide_border(ea)
        @param ea (C++: ea_t)

Help on function unhide_item in module ida_nalt:

unhide_item(*args)
    unhide_item(ea)
        @param ea (C++: ea_t)

Help on function uses_modsp in module ida_nalt:

uses_modsp(*args)
    uses_modsp(ea) -> bool
        @param ea (C++: ea_t)

Help on function validate_idb_names in module ida_nalt:

validate_idb_names(*args)
    validate_idb_names(do_repair) -> int
        do_repair: bool

=== ida_nalt EPYDOC INJECTIONS ===
ida_nalt.AFL_ALIGNFLOW
"""
the previous insn was created for alignment purposes only
"""

ida_nalt.AFL_BNOT0
"""
the 1st operand is bitwise negated
"""

ida_nalt.AFL_BNOT1
"""
the 2nd operand is bitwise negated
"""

ida_nalt.AFL_COLORED
"""
has user defined instruction color?
"""

ida_nalt.AFL_FIXEDSPD
"""
should not be modified by modules

sp delta value is fixed by analysis.
"""

ida_nalt.AFL_HIDDEN
"""
the item is hidden completely
"""

ida_nalt.AFL_LIB
"""
item from the standard library. low level flag, is used to set
'FUNC_LIB' of 'func_t'
"""

ida_nalt.AFL_LINNUM
"""
has line number info
"""

ida_nalt.AFL_LNAME
"""
has local name too ( 'FF_NAME' should be set)
"""

ida_nalt.AFL_LZERO0
"""
toggle leading zeroes for the 1st operand
"""

ida_nalt.AFL_LZERO1
"""
toggle leading zeroes for the 2nd operand
"""

ida_nalt.AFL_MANUAL
"""
the instruction/data is specified by the user
"""

ida_nalt.AFL_NOBRD
"""
the code/data border is hidden
"""

ida_nalt.AFL_NORET
"""
for imported function pointers: doesn't return. this flag can also be
used for any instruction which halts or finishes the program execution
"""

ida_nalt.AFL_NOTCODE
"""
autoanalysis should not create code here
"""

ida_nalt.AFL_NOTPROC
"""
autoanalysis should not create proc here
"""

ida_nalt.AFL_PUBNAM
"""
name is public (inter-file linkage)
"""

ida_nalt.AFL_RETFP
"""
function returns a floating point value
"""

ida_nalt.AFL_SIGN0
"""
code: toggle sign of the 1st operand
"""

ida_nalt.AFL_SIGN1
"""
code: toggle sign of the 2nd operand
"""

ida_nalt.AFL_TERSESTR
"""
terse structure variable display?
"""

ida_nalt.AFL_TI
"""
has typeinfo? ( 'NSUP_TYPEINFO' )
"""

ida_nalt.AFL_TI0
"""
has typeinfo for operand 0? ( 'NSUP_OPTYPES' )
"""

ida_nalt.AFL_TI1
"""
has typeinfo for operand 1? ( 'NSUP_OPTYPES' +1)
"""

ida_nalt.AFL_TILCMT
"""
has type comment? (such a comment may be changed by IDA)
"""

ida_nalt.AFL_USEMODSP
"""
example: pop [rsp+N]

insn modifes SP and uses the modified value
"""

ida_nalt.AFL_USERSP
"""
user-defined SP value
"""

ida_nalt.AFL_USERTI
"""
(comes from the user or type library)

the type information is definitive.
"""

ida_nalt.AFL_WEAKNAM
"""
name is weak
"""

ida_nalt.AFL_ZSTROFF
"""
display struct field name at 0 offset when displaying an offset.
example: \\v{offset somestruct.field_0} if this flag is clear, then
\\v{offset somestruct}
"""

ida_nalt.AP_ALLOWDUPS
"""
use 'dup' construct
"""

ida_nalt.AP_ARRAY
"""
create as array (this flag is not stored in database)
"""

ida_nalt.AP_IDXBASEMASK
"""
mask for number base of the indexes
"""

ida_nalt.AP_IDXBIN
"""
display indexes in binary
"""

ida_nalt.AP_IDXDEC
"""
display indexes in decimal
"""

ida_nalt.AP_IDXHEX
"""
display indexes in hex
"""

ida_nalt.AP_IDXOCT
"""
display indexes in octal
"""

ida_nalt.AP_INDEX
"""
display array element indexes as comments
"""

ida_nalt.AP_SIGNED
"""
treats numbers as signed
"""

ida_nalt.MAXSTRUCPATH
"""
maximal inclusion depth of unions
"""

ida_nalt.NALT_ABSBASE
"""
absolute segment location
"""

ida_nalt.NALT_AFLAGS
"""
additional flags for an item
"""

ida_nalt.NALT_ALIGN
"""
(should by equal to power of 2)

alignment value if the item is 'FF_ALIGN'
"""

ida_nalt.NALT_COLOR
"""
instruction/data background color
"""

ida_nalt.NALT_CREF_FROM
"""
code xref from, idx: source address
"""

ida_nalt.NALT_CREF_TO
"""
code xref to, idx: target address
"""

ida_nalt.NALT_DREF_FROM
"""
data xref from, idx: source address
"""

ida_nalt.NALT_DREF_TO
"""
data xref to, idx: target address
"""

ida_nalt.NALT_ENUM0
"""
enum id for the first operand
"""

ida_nalt.NALT_ENUM1
"""
enum id for the second operand
"""

ida_nalt.NALT_GR_LAYX
"""
group layout ptrs, hash: md5 of 'belongs'
"""

ida_nalt.NALT_LINNUM
"""
source line number
"""

ida_nalt.NALT_PURGE
"""
number of bytes purged from the stack when a function is called
indirectly
"""

ida_nalt.NALT_STRTYPE
"""
type of string item
"""

ida_nalt.NALT_STRUCT
"""
struct id
"""

ida_nalt.NALT_SWITCH
"""
switch idiom address (used at jump targets)
"""

ida_nalt.NSUP_ARGEAS
"""
instructions that initialize call arguments
"""

ida_nalt.NSUP_ARRAY
"""
array parameters
"""

ida_nalt.NSUP_CMT
"""
regular comment
"""

ida_nalt.NSUP_CUSTDT
"""
custom data type id
"""

ida_nalt.NSUP_FOP1
"""
forced operand 1
"""

ida_nalt.NSUP_FOP2
"""
forced operand 2
"""

ida_nalt.NSUP_FOP3
"""
forced operand 3
"""

ida_nalt.NSUP_FOP4
"""
forced operand 4
"""

ida_nalt.NSUP_FOP5
"""
forced operand 5
"""

ida_nalt.NSUP_FOP6
"""
forced operand 6
"""

ida_nalt.NSUP_FOP7
"""
forced operand 7
"""

ida_nalt.NSUP_FOP8
"""
forced operand 8
"""

ida_nalt.NSUP_FTAILS
"""
function tails or tail referers values NSUP_FTAILS..NSUP_FTAILS+0x1000
are reserved
"""

ida_nalt.NSUP_GROUP
"""
graph group information values NSUP_GROUP..NSUP_GROUP+0x1000 are
reserved
"""

ida_nalt.NSUP_GROUPS
"""
SEG_GRP: pack_dd encoded list of selectors.
"""

ida_nalt.NSUP_GR_INFO
"""
group node info: color, ea, text
"""

ida_nalt.NSUP_GR_LAYT
"""
group layouts, idx: layout pointer
"""

ida_nalt.NSUP_JINFO
"""
jump table info
"""

ida_nalt.NSUP_LLABEL
"""
local labels. values NSUP_LLABEL..NSUP_LLABEL+0x1000 are reserved
"""

ida_nalt.NSUP_MANUAL
"""
manual instruction. values NSUP_MANUAL..NSUP_MANUAL+0x1000 are
reserved
"""

ida_nalt.NSUP_OMFGRP
"""
OMF: group of segments (not used anymore)
"""

ida_nalt.NSUP_OPTYPES
"""
operand type information. values NSUP_OPTYPES..NSUP_OPTYPES+0x100000
are reserved
"""

ida_nalt.NSUP_OREF0
"""
outer complex reference information for operand 1
"""

ida_nalt.NSUP_OREF1
"""
outer complex reference information for operand 2
"""

ida_nalt.NSUP_OREF2
"""
outer complex reference information for operand 3
"""

ida_nalt.NSUP_OREF3
"""
outer complex reference information for operand 4
"""

ida_nalt.NSUP_OREF4
"""
outer complex reference information for operand 5
"""

ida_nalt.NSUP_OREF5
"""
outer complex reference information for operand 6
"""

ida_nalt.NSUP_OREF6
"""
outer complex reference information for operand 7
"""

ida_nalt.NSUP_OREF7
"""
outer complex reference information for operand 8
"""

ida_nalt.NSUP_ORIGFMD
"""
function metadata before lumina information was applied values
NSUP_ORIGFMD..NSUP_ORIGFMD+0x1000 are reserved
"""

ida_nalt.NSUP_POINTS
"""
SP change points blob (see funcs.cpp). values
NSUP_POINTS..NSUP_POINTS+0x1000 are reserved
"""

ida_nalt.NSUP_REF0
"""
complex reference information for operand 1
"""

ida_nalt.NSUP_REF1
"""
complex reference information for operand 2
"""

ida_nalt.NSUP_REF2
"""
complex reference information for operand 3
"""

ida_nalt.NSUP_REF3
"""
complex reference information for operand 4
"""

ida_nalt.NSUP_REF4
"""
complex reference information for operand 5
"""

ida_nalt.NSUP_REF5
"""
complex reference information for operand 6
"""

ida_nalt.NSUP_REF6
"""
complex reference information for operand 7
"""

ida_nalt.NSUP_REF7
"""
complex reference information for operand 8
"""

ida_nalt.NSUP_REGARG
"""
register argument type/name descriptions values
NSUP_REGARG..NSUP_REGARG+0x1000 are reserved
"""

ida_nalt.NSUP_REGVAR
"""
register variables. values NSUP_REGVAR..NSUP_REGVAR+0x1000 are
reserved
"""

ida_nalt.NSUP_REPCMT
"""
repeatable comment
"""

ida_nalt.NSUP_SEGTRANS
"""
segment translations
"""

ida_nalt.NSUP_STROFF0
"""
stroff: struct path for the first operand
"""

ida_nalt.NSUP_STROFF1
"""
stroff: struct path for the second operand
"""

ida_nalt.NSUP_SWITCH
"""
switch information
"""

ida_nalt.NSUP_TYPEINFO
"""
type information. values NSUP_TYPEINFO..NSUP_TYPEINFO+0x1000 are
reserved
"""

ida_nalt.NSUP_XREFPOS
"""
saved xref address and type in the xrefs window
"""

ida_nalt.PATCH_TAG
"""
Patch netnode tag.
"""

ida_nalt.REFINFO_CUSTOM
"""
a custom reference the kernel will call \\ph{notify}(ph.custom_offset,
.... that can change all arguments used for calculations. This flag is
useful for custom fixups
"""

ida_nalt.REFINFO_NOBASE
"""
don't create the base xref implies that the base can be any value nb:
base xrefs are created only if the offset base points to the middle of
a segment
"""

ida_nalt.REFINFO_PASTEND
"""
reference past an item it may point to an nonexistent address do not
destroy alignment dirs
"""

ida_nalt.REFINFO_RVAOFF
"""
based reference (rva) 'refinfo_t::base' will be forced to
'get_imagebase()' such a reference is displayed with the \\ash{a_rva}
keyword
"""

ida_nalt.REFINFO_SIGNEDOP
"""
the operand value is sign-extended (only supported for
REF_OFF8/16/32/64)
"""

ida_nalt.REFINFO_SUBTRACT
"""
the reference value is subtracted from the base value instead of (as
usual) being added to it
"""

ida_nalt.REFINFO_TYPE
"""
reference type
"""

ida_nalt.RIDX_ABINAME
"""
ABI name (processor specific)
"""

ida_nalt.RIDX_ARCHIVE_PATH
"""
archive file path
"""

ida_nalt.RIDX_C_MACROS
"""
C predefined macros.
"""

ida_nalt.RIDX_DBG_BINPATHS
"""
unused (20 indexes)
"""

ida_nalt.RIDX_DUALOP_GRAPH
"""
Graph text representation options.
"""

ida_nalt.RIDX_DUALOP_TEXT
"""
Text text representation options.
"""

ida_nalt.RIDX_FILE_FORMAT_NAME
"""
file format name for loader modules
"""

ida_nalt.RIDX_GROUPS
"""
segment group information (see init_groups())
"""

ida_nalt.RIDX_H_PATH
"""
C header path.
"""

ida_nalt.RIDX_IDA_VERSION
"""
version of ida which created the database
"""

ida_nalt.RIDX_INCLUDE
"""
assembler include file name
"""

ida_nalt.RIDX_MD5
"""
MD5 of the input file.
"""

ida_nalt.RIDX_NOTEPAD
"""
notepad blob, occupies 1000 indexes (1MB of text)
"""

ida_nalt.RIDX_PROBLEMS
"""
problem lists
"""

ida_nalt.RIDX_SELECTED_EXTLANG
"""
last selected extlang name (from the execute script box)
"""

ida_nalt.RIDX_SELECTORS
"""
2..63 are for selector_t blob (see init_selectors())
"""

ida_nalt.RIDX_SHA256
"""
SHA256 of the input file.
"""

ida_nalt.RIDX_SMALL_IDC
"""
Instant IDC statements, blob.
"""

ida_nalt.RIDX_SMALL_IDC_OLD
"""
Instant IDC statements (obsolete)
"""

ida_nalt.RIDX_SRCDBG_PATHS
"""
source debug paths, occupies 20 indexes
"""

ida_nalt.RIDX_SRCDBG_UNDESIRED
"""
user-closed source files, occupies 20 indexes
"""

ida_nalt.RIDX_STR_ENCODINGS
"""
a list of encodings for the program strings
"""

ida_nalt.STRENC_DEFAULT
"""
use default encoding for this type (see 'get_default_encoding_idx()' )
"""

ida_nalt.STRENC_NONE
"""
force no-conversion encoding
"""

ida_nalt.STRTYPE_C
"""
Zero-terminated 16bit chars.
"""

ida_nalt.STRTYPE_C_16
"""
Zero-terminated 32bit chars.
"""

ida_nalt.STRTYPE_C_32
"""
Pascal-style, one-byte length prefix.
"""

ida_nalt.STRTYPE_LEN2
"""
Pascal-style, 16bit chars, two-byte length prefix.
"""

ida_nalt.STRTYPE_LEN2_16
"""
Pascal-style, four-byte length prefix.
"""

ida_nalt.STRTYPE_LEN4
"""
Pascal-style, 16bit chars, four-byte length prefix.
"""

ida_nalt.STRTYPE_PASCAL
"""
Pascal-style, 16bit chars, one-byte length prefix.
"""

ida_nalt.STRTYPE_PASCAL_16
"""
Pascal-style, two-byte length prefix.
"""

ida_nalt.STRTYPE_TERMCHR
"""
C-style string.

< Character-terminated string. The termination characters are kept in
the next bytes of string type.
"""

ida_nalt.SWI_CUSTOM
"""
custom jump table. \\ph{create_switch_xrefs} will be called to create
code xrefs for the table. Custom jump table must be created by the
module (see also 'SWI_STDTBL' )
"""

ida_nalt.SWI_DEFRET
"""
return in the default case (defjump==BADADDR)
"""

ida_nalt.SWI_DEF_IN_TBL
"""
default case is an entry in the jump table. This flag is applicable in
2 cases:The sparse indirect switch (i.e. a switch with a values table)
<jump table="" size>=""> ==+ 1. The default case entry is the last one
in the table (or the first one in the case of an inversed jump
table).The switch with insns in the jump table. The default case entry
is before the first entry of the table. See also the
find_defjump_from_table() helper function.
"""

ida_nalt.SWI_ELBASE
"""
segment will be used)

elbase is present (otherwise the base of the switch
"""

ida_nalt.SWI_HXNOLOWCASE
"""
lowcase value should not be used by the decompiler (internal flag)
"""

ida_nalt.SWI_INDIRECT
"""
(for sparse switches)

value table elements are used as indexes into the jump table
"""

ida_nalt.SWI_J32
"""
32-bit jump offsets
"""

ida_nalt.SWI_JMPINSN
"""
jump table entries are insns. For such entries SHIFT has a different
meaning. It denotes the number of insns in the entry. For example, 0 -
the entry contains the jump to the case, 1 - the entry contains one
insn like a 'mov' and jump to the end of case, and so on.
"""

ida_nalt.SWI_JMP_INV
"""
for first entry in values table)

jumptable is inversed. (last entry is
"""

ida_nalt.SWI_JSIZE
"""
jump offset expansion bit
"""

ida_nalt.SWI_RESERVED
"""
was: SWI_DEFAULT
"""

ida_nalt.SWI_SELFREL
"""
jump address is relative to the element not to ELBASE
"""

ida_nalt.SWI_SEPARATE
"""
create an array of individual elements (otherwise separate items)
"""

ida_nalt.SWI_SHIFT_MASK
"""
use formula (element<<shift) + elbase to find jump targets
"""

ida_nalt.SWI_SIGNED
"""
jump table entries are signed
"""

ida_nalt.SWI_SPARSE
"""
otherwise lowcase present

sparse switch (value table present)
"""

ida_nalt.SWI_STDTBL
"""
custom jump table with standard table formatting. ATM IDA doesn't use
SWI_CUSTOM for switches with standard table formatting. So this flag
can be considered as obsolete.
"""

ida_nalt.SWI_SUBTRACT
"""
table values are subtracted from the elbase instead of being added
"""

ida_nalt.SWI_V32
"""
32-bit values in table
"""

ida_nalt.SWI_VERSION
"""
the structure contains the VERSION member
"""

ida_nalt.SWI_VSIZE
"""
value table element size expansion bit
"""

ida_nalt.SWI_VSPLIT
"""
value table is split (only for 32-bit values)
"""
=== ida_nalt EPYDOC INJECTIONS END ===
Help on class NearestName in module ida_name:

class NearestName(__builtin__.object)
 |  Utility class to help find the nearest name in a given ea/name dictionary
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, index)
 |      Returns the tupple (ea, name, index)
 |  
 |  __init__(self, ea_names)
 |  
 |  __iter__(self)
 |  
 |  _get_item(self, index)
 |  
 |  find(self, ea)
 |      Returns a tupple (ea, name, pos) that is the nearest to the passed ea
 |      If no name is matched then None is returned
 |  
 |  update(self, ea_names)
 |      Updates the ea/names map
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function append_struct_fields in module ida_name:

append_struct_fields(*args)
    Append names of struct fields to a name if the name is a struct name.
    
    append_struct_fields(disp, n, path, flags, delta, appzero) -> str
        @param disp: displacement from the name (C++: adiff_t *)
        @param n: number of operand n which the name appears (C++: int)
        @param path: path in the struct. path is an array of id's. maximal
                     length of array is  MAXSTRUCPATH . the first element of
                     the array is the structure id. consecutive elements are
                     id's of used union members (if any). (C++: const  tid_t
                     *)
        @param flags: the input flags. they will be returned if the struct
                      cannot be found. (C++: flags_t)
        @param delta: delta to add to displacement (C++: adiff_t)
        @param appzero: should append a struct field name if the displacement
                        is zero? (C++: bool)
        @return: flags of the innermost struct member or the input flags

Help on function calc_gtn_flags in module ida_name:

calc_gtn_flags(fromaddr, ea)
    Calculate flags for get_ea_name() function
    
    @param fromaddr: the referring address. May be BADADDR.
    @param ea: linear address
    
    @return: flags

Help on function cleanup_name in module ida_name:

cleanup_name(*args)
    cleanup_name(ea, name, flags=0) -> str
        @param ea (C++: ea_t)
        @param name (C++: const char *)
        @param flags (C++: uint32)

Help on function del_debug_names in module ida_name:

del_debug_names(*args)
    del_debug_names(ea1, ea2)
        @param ea1 (C++: ea_t)
        @param ea2 (C++: ea_t)

Help on function del_global_name in module ida_name:

del_global_name(*args)
    del_global_name(ea) -> bool
        @param ea (C++: ea_t)

Help on function del_local_name in module ida_name:

del_local_name(*args)
    del_local_name(ea) -> bool
        @param ea (C++: ea_t)

Help on function demangle_name in module ida_name:

demangle_name(*args)
    Demangle a name.
    
    demangle_name(name, disable_mask, demreq=DQT_FULL) -> str
        @param name: name to demangle (C++: const char *)
        @param disable_mask: bits to inhibit parts of demangled name (see
                             MNG_). by the M_COMPILER bits a specific compiler
                             can be selected (see MT_). (C++: uint32)
        @param demreq (C++: demreq_type_t)
        @return: ME_... or MT__ bitmasks from  demangle.hpp

Help on class ea_name_t in module ida_name:

class ea_name_t(__builtin__.object)
 |  Proxy of C++ ea_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ea_name_t
 |          _ea: ea_t
 |          _name: qstring const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea_name_t_ea_get(self) -> ea_t
 |  
 |  name
 |      ea_name_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ea_name_t>
 |      delete_ea_name_t(self)

Help on class ea_name_vec_t in module ida_name:

class ea_name_vec_t(__builtin__.object)
 |  Proxy of C++ qvector< ea_name_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> ea_name_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ea_name_vec_t
 |          x: qvector< ea_name_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: ea_name_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> ea_name_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> ea_name_t
 |      begin(self) -> ea_name_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> ea_name_t
 |      end(self) -> ea_name_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> ea_name_t
 |          it: qvector< ea_name_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> ea_name_t
 |          first: qvector< ea_name_t >::iterator
 |          last: qvector< ea_name_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> ea_name_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=ea_name_t())
 |          x: ea_name_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: ea_name_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> ea_name_t
 |          it: qvector< ea_name_t >::iterator
 |          x: ea_name_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: ea_name_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: ea_name_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< ea_name_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ea_name_vec_t>
 |      delete_ea_name_vec_t(self)

Help on function extract_name in module ida_name:

extract_name(*args)
    Extract a name or address from the specified string.
    
    extract_name(line, x) -> str
        @param line: input string (C++: const char *)
        @param x: x coordinate of cursor (C++: int)
        @return: -1 if cannot extract. otherwise length of the name

Help on function force_name in module ida_name:

force_name(*args)
    force_name(ea, name, flags=0) -> bool
        @param ea (C++: ea_t)
        @param name (C++: const char *)
        @param flags (C++: int)

Help on function get_colored_demangled_name in module ida_name:

get_colored_demangled_name(*args)
    get_colored_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring
        @param ea (C++: ea_t)
        @param inhibitor (C++: int32)
        @param demform (C++: int)
        @param gtn_flags (C++: int)

Help on function get_colored_long_name in module ida_name:

get_colored_long_name(*args)
    get_colored_long_name(ea, gtn_flags=0) -> qstring
        @param ea (C++: ea_t)
        @param gtn_flags (C++: int)

Help on function get_colored_name in module ida_name:

get_colored_name(*args)
    get_colored_name(ea) -> qstring
        @param ea (C++: ea_t)

Help on function get_colored_short_name in module ida_name:

get_colored_short_name(*args)
    get_colored_short_name(ea, gtn_flags=0) -> qstring
        @param ea (C++: ea_t)
        @param gtn_flags (C++: int)

Help on function get_cp_validity in module ida_name:

get_cp_validity(*args)
    Is the given codepoint (or range) acceptable in the given context? If
    'endcp' is not BADCP, it is considered to be the end of the range:
    [cp, endcp), and is not included in the range
    
    get_cp_validity(kind, cp, endcp=wchar32_t(-1)) -> bool
        @param kind (C++: ucdr_kind_t)
        @param cp (C++: wchar32_t)
        @param endcp (C++: wchar32_t)

Help on function get_debug_name in module ida_name:

get_debug_name(*args)
    get_debug_name(ea_ptr, how) -> str
        @param ea_ptr (C++: ea_t *)
        @param how (C++: debug_name_how_t)

Help on function get_debug_name_ea in module ida_name:

get_debug_name_ea(*args)
    get_debug_name_ea(name) -> ea_t
        @param name (C++: const char *)

Help on function get_debug_names in module ida_name:

get_debug_names(*args)
    get_debug_names(names, ea1, ea2)
        @param names (C++: ea_name_vec_t  *)
        @param ea1 (C++: ea_t)
        @param ea2 (C++: ea_t)
    
    
    get_debug_names(ea1, ea2, return_list=False) -> PyObject *
        @param ea1 (C++: ea_t)
        @param ea2 (C++: ea_t)
        return_list: bool

Help on function get_demangled_name in module ida_name:

get_demangled_name(*args)
    get_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring
        @param ea (C++: ea_t)
        @param inhibitor (C++: int32)
        @param demform (C++: int)
        @param gtn_flags (C++: int)

Help on function get_ea_name in module ida_name:

get_ea_name(*args)
    Get name at the specified address.
    
    get_ea_name(ea, gtn_flags=0) -> qstring
        @param ea: linear address (C++: ea_t)
        @param gtn_flags: how exactly the name should be retrieved.
                          combination of  bits for get_ea_name() function.
                          There is a convenience  bits (C++: int)
        @return: success

Help on function get_long_name in module ida_name:

get_long_name(*args)
    get_long_name(ea, gtn_flags=0) -> qstring
        @param ea (C++: ea_t)
        @param gtn_flags (C++: int)

Help on function get_name in module ida_name:

get_name(*args)
    get_name(ea) -> qstring
        @param ea (C++: ea_t)

Help on function get_name_base_ea in module ida_name:

get_name_base_ea(*args)
    Get address of the name used in the expression for the address
    
    get_name_base_ea(_from, to) -> ea_t
        @param _from: address of the operand which references to the address
                      (C++: ea_t)
        @param to: the referenced address (C++: ea_t)
        @return: address of the name used to represent the operand

Help on function get_name_color in module ida_name:

get_name_color(*args)
    Calculate flags for 'get_ea_name()' function.
    
    Get name color.
    
    get_name_color(_from, ea) -> color_t
        @param _from: linear address where the name is used. if not
                      applicable, then should be  BADADDR . The kernel returns
                      a local name color if the reference is within a
                      function, i.e. 'from' and 'ea' belong to the same
                      function. (C++: ea_t)
        @param ea: linear address (C++: ea_t)

Help on function get_name_ea in module ida_name:

get_name_ea(*args)
    Get address of the name. Dummy names (like byte_xxxx where xxxx are
    hex digits) are parsed by this function to obtain the address. The
    database is not consulted for them. This function works only with
    regular names.
    
    get_name_ea(_from, name) -> ea_t
        @param _from: linear address where the name is used. if not
                      applicable, then should be  BADADDR . (C++: ea_t)
        @param name: any name in the program or NULL (C++: const char *)
        @return: address of the name or  BADADDR

Help on function get_name_expr in module ida_name:

get_name_expr(*args)
    Convert address to name expression (name with a displacement). This
    function takes into account fixup information and returns a colored
    name expression (in the form <name> +/- <offset>). It also knows about
    structure members and arrays. If the specified address doesn't have a
    name, a dummy name is generated.
    
    get_name_expr(_from, n, ea, off, flags=0x0001) -> str
        @param _from: linear address of instruction operand or data referring
                      to the name. This address will be used to get fixup
                      information, so it should point to exact position of the
                      operand in the instruction. (C++: ea_t)
        @param n: number of referencing operand. for data items specify 0
                  (C++: int)
        @param ea: address to convert to name expression (C++: ea_t)
        @param off: the value of name expression. this parameter is used only
                    to check that the name expression will have the wanted
                    value. 'off' may be equal to BADADDR but this is
                    discouraged because it prohibits checks. (C++: uval_t)
        @param flags: Name expression flags (C++: int)
        @return: < 0 if address is not valid, no segment or other failure.
                 otherwise the length of the name expression in characters.

Help on function get_name_value in module ida_name:

get_name_value(*args)
    Get value of the name. This function knows about: regular names,
    enums, special segments, etc.
    
    get_name_value(_from, name) -> int
        @param _from: linear address where the name is used if not applicable,
                      then should be BADADDR (C++: ea_t)
        @param name: any name in the program or NULL (C++: const char *)
        @return: Name value result codes

Help on function get_nice_colored_name in module ida_name:

get_nice_colored_name(*args)
    Get a nice colored name at the specified address. Ex:segment:sub+offse
    tsegment:sub:local_labelsegment:labelsegment:addresssegment:address+of
    fset
    
    get_nice_colored_name(ea, flags=0) -> str
        @param ea (C++: ea_t)
        @param flags (C++: int)
        @return: the length of the generated name in bytes.

Help on function get_nlist_ea in module ida_name:

get_nlist_ea(*args)
    Get address from the list at 'idx'.
    
    get_nlist_ea(idx) -> ea_t
        @param idx (C++: size_t)

Help on function get_nlist_idx in module ida_name:

get_nlist_idx(*args)
    Get index of the name in the listreturns the closest match. may return
    idx >= size.
    
    get_nlist_idx(ea) -> size_t
        @param ea (C++: ea_t)

Help on function get_nlist_name in module ida_name:

get_nlist_name(*args)
    Get name using idx.
    
    get_nlist_name(idx) -> char const *
        @param idx (C++: size_t)

Help on function get_nlist_size in module ida_name:

get_nlist_size(*args)
    Get number of names in the list.

Help on function get_short_name in module ida_name:

get_short_name(*args)
    get_short_name(ea, gtn_flags=0) -> qstring
        @param ea (C++: ea_t)
        @param gtn_flags (C++: int)

Help on function get_visible_name in module ida_name:

get_visible_name(*args)
    get_visible_name(ea, gtn_flags=0) -> qstring
        @param ea (C++: ea_t)
        @param gtn_flags (C++: int)

Help on function hide_name in module ida_name:

hide_name(*args)
    Remove name from the list of names
    
    hide_name(ea)
        @param ea: address of the name (C++: ea_t)

Help on function is_ident in module ida_name:

is_ident(*args)
    Is a valid name? (including ::MangleChars)
    
    is_ident(name) -> bool
        @param name (C++: const char *)

Help on function is_ident_cp in module ida_name:

is_ident_cp(*args)
    Can a character appear in a name? (present in ::NameChars or
    ::MangleChars)
    
    is_ident_cp(cp) -> bool
        @param cp (C++: wchar32_t)

Help on function is_in_nlist in module ida_name:

is_in_nlist(*args)
    Is name included into names list?
    
    is_in_nlist(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_name_defined_locally in module ida_name:

is_name_defined_locally(*args)
    Is the name defined locally in the specified function?
    
    is_name_defined_locally(pfn, name, ignore_name_def, ea1=BADADDR, ea2=BADADDR) -> bool
        @param pfn: pointer to function (C++: func_t  *)
        @param name: name to check (C++: const char *)
        @param ignore_name_def: which names to ignore when checking (C++:
                                ignore_name_def_t)
        @param ea1: the starting address of the range inside the function
                    (optional) (C++: ea_t)
        @param ea2: the ending address of the range inside the function
                    (optional) (C++: ea_t)
        @return: true if the name has been defined

Help on function is_public_name in module ida_name:

is_public_name(*args)
    is_public_name(ea) -> bool
        @param ea (C++: ea_t)

Help on function is_strlit_cp in module ida_name:

is_strlit_cp(*args)
    Can a character appear in a string literal (present in ::StrlitChars)
    If 'specific_ranges' are specified, those will be used instead of the
    ones corresponding to the current culture (only if ::StrlitChars is
    configured to use the current culture)
    
    is_strlit_cp(cp, specific_ranges=None) -> bool
        @param cp (C++: wchar32_t)
        @param specific_ranges (C++: const  rangeset_crefvec_t  *)

Help on function is_uname in module ida_name:

is_uname(*args)
    Is valid user-specified name? (valid name & !dummy prefix).
    
    is_uname(name) -> bool
        @param name: name to test. may be NULL. (C++: const char *)
        @retval: 1 - yes
        @retval: 0 - no

Help on function is_valid_cp in module ida_name:

is_valid_cp(*args)
    Is the given codepoint acceptable in the given context?
    
    is_valid_cp(cp, kind, data=None) -> bool
        @param cp (C++: wchar32_t)
        @param kind (C++: nametype_t)
        @param data (C++: void *)

Help on function is_valid_typename in module ida_name:

is_valid_typename(*args)
    Is valid type name?
    
    is_valid_typename(name) -> bool
        @param name: name to test. may be NULL. (C++: const char *)
        @retval: 1 - yes
        @retval: 0 - no

Help on function is_visible_cp in module ida_name:

is_visible_cp(*args)
    Can a character be displayed in a name? (present in ::NameChars)
    
    is_visible_cp(cp) -> bool
        @param cp (C++: wchar32_t)

Help on function is_weak_name in module ida_name:

is_weak_name(*args)
    is_weak_name(ea) -> bool
        @param ea (C++: ea_t)

Help on function make_name_auto in module ida_name:

make_name_auto(*args)
    make_name_auto(ea) -> bool
        @param ea (C++: ea_t)

Help on function make_name_non_public in module ida_name:

make_name_non_public(*args)
    make_name_non_public(ea)
        @param ea (C++: ea_t)

Help on function make_name_non_weak in module ida_name:

make_name_non_weak(*args)
    make_name_non_weak(ea)
        @param ea (C++: ea_t)

Help on function make_name_public in module ida_name:

make_name_public(*args)
    make_name_public(ea)
        @param ea (C++: ea_t)

Help on function make_name_user in module ida_name:

make_name_user(*args)
    make_name_user(ea) -> bool
        @param ea (C++: ea_t)

Help on function make_name_weak in module ida_name:

make_name_weak(*args)
    make_name_weak(ea)
        @param ea (C++: ea_t)

Help on function rebuild_nlist in module ida_name:

rebuild_nlist(*args)
    Rebuild names list.

Help on function reorder_dummy_names in module ida_name:

reorder_dummy_names(*args)
    Renumber dummy names.

Help on function set_cp_validity in module ida_name:

set_cp_validity(*args)
    Mark the given codepoint (or range) as acceptable or unacceptable in
    the given context If 'endcp' is not BADCP, it is considered to be the
    end of the range: [cp, endcp), and is not included in the range
    
    set_cp_validity(kind, cp, endcp=wchar32_t(-1), valid=True)
        @param kind (C++: ucdr_kind_t)
        @param cp (C++: wchar32_t)
        @param endcp (C++: wchar32_t)
        @param valid (C++: bool)

Help on function set_debug_name in module ida_name:

set_debug_name(*args)
    set_debug_name(ea, name) -> bool
        @param ea (C++: ea_t)
        @param name (C++: const char *)

Help on function set_dummy_name in module ida_name:

set_dummy_name(*args)
    Give an autogenerated (dummy) name. Autogenerated names have special
    prefixes (loc_...).
    
    set_dummy_name(_from, ea) -> bool
        @param _from: linear address of the operand which references to the
                      address (C++: ea_t)
        @param ea: linear address (C++: ea_t)
        @retval: 1 - ok, dummy name is generated or the byte already had a
                     name
        @retval: 0 - failure, invalid address or tail byte

Help on function set_name in module ida_name:

set_name(*args)
    Set or delete name of an item at the specified address. An item can be
    anything: instruction, function, data byte, word, string, structure,
    etc... Include name into the list of names.
    
    set_name(ea, name, flags=0) -> bool
        @param ea: linear address. do nothing if ea is not valid (return 0).
                   tail bytes can't have names. (C++: ea_t)
        @param name: new name.   NULL: do nothing (return 0).   "" : delete
                     name.   otherwise this is a new name. (C++: const char *)
        @param flags: Set name flags . If a bit is not specified, then the
                      corresponding action is not performed and the name will
                      retain the same bits as before calling this function.
                      For new names, default is: non-public, non-weak, non-
                      auto. (C++: int)
        @retval: 1 - ok, name is changed
        @retval: 0 - failure, a warning is displayed

Help on function show_name in module ida_name:

show_name(*args)
    Insert name to the list of names.
    
    show_name(ea)
        @param ea (C++: ea_t)

Help on function validate_name in module ida_name:

validate_name(*args)
    Validate a name. This function replaces all invalid characters in the
    name with SUBSTCHAR. However, it will return false if name is valid
    but not allowed to be an identifier (is a register name).
    
    validate_name(name, type, flags=0) -> PyObject *
        @param name: ptr to name. the name will be modified (C++: qstring  *)
        @param type: the type of name we want to validate (C++: nametype_t)
        @param flags: see SN_* . Only SN_IDBENC is currently considered (C++:
                      int)
        @return: success

=== ida_name EPYDOC INJECTIONS ===
ida_name.FUNC_IMPORT_PREFIX
"""
Name prefix used by IDA for the imported functions.
"""

ida_name.GETN_APPZERO
"""
append a struct field name if the field offset is zero?

meaningful only if the name refers to a structure.
"""

ida_name.GETN_NODUMMY
"""
do not create a new dummy name but pretend it exists
"""

ida_name.GETN_NOFIXUP
"""
ignore the fixup information when producing the name
"""

ida_name.GNCN_NOCOLOR
"""
generate an uncolored name
"""

ida_name.GNCN_NODBGNM
"""
don't use debug names
"""

ida_name.GNCN_NOFUNC
"""
don't generate funcname+... expressions
"""

ida_name.GNCN_NOLABEL
"""
don't generate labels
"""

ida_name.GNCN_NOSEG
"""
ignore the segment prefix when producing the name
"""

ida_name.GNCN_PREFDBG
"""
if using debug names, prefer debug names over function names
"""

ida_name.GNCN_REQFUNC
"""
return 0 if the address does not belong to a function
"""

ida_name.GNCN_REQNAME
"""
return 0 if the address can only be represented as a hex number
"""

ida_name.GNCN_SEGNUM
"""
segment part is displayed as a hex number
"""

ida_name.GNCN_SEG_FUNC
"""
generate both segment and function names (default is to omit segment
name if a function name is present)
"""

ida_name.GN_COLORED
"""
return colored name
"""

ida_name.GN_DEMANGLED
"""
return demangled name
"""

ida_name.GN_ISRET
"""
for dummy names: use retloc
"""

ida_name.GN_LOCAL
"""
try to get local name first; if failed, get global
"""

ida_name.GN_LONG
"""
use long form of demangled name
"""

ida_name.GN_NOT_DUMMY
"""
do not return a dummy name
"""

ida_name.GN_NOT_ISRET
"""
for dummy names: do not use retloc
"""

ida_name.GN_SHORT
"""
use short form of demangled name
"""

ida_name.GN_STRICT
"""
fail if cannot demangle
"""

ida_name.GN_VISIBLE
"""
replace forbidden characters by SUBSTCHAR
"""

ida_name.MAXNAMELEN
"""
Maximum length of a name in IDA (with the trailing zero)
"""

ida_name.NT_ABS
"""
name is absolute symbol ( 'SEG_ABSSYM' )
"""

ida_name.NT_BMASK
"""
name is a bit group mask name
"""

ida_name.NT_BYTE
"""
name is byte name (regular name)
"""

ida_name.NT_ENUM
"""
name is symbolic constant
"""

ida_name.NT_LOCAL
"""
name is local label
"""

ida_name.NT_NONE
"""
name doesn't exist or has no value
"""

ida_name.NT_REGVAR
"""
name is a renamed register (*value is idx into pfn->regvars)
"""

ida_name.NT_SEG
"""
name is segment or segment register name
"""

ida_name.NT_STKVAR
"""
name is stack variable name
"""

ida_name.NT_STROFF
"""
name is structure member
"""

ida_name.SN_AUTO
"""
if set, make name autogenerated
"""

ida_name.SN_DELTAIL
"""
delete the hindering item

if name cannot be set because of a tail byte,
"""

ida_name.SN_FORCE
"""
if the specified name is already present in the database, try
variations with a numerical suffix like "_123"
"""

ida_name.SN_IDBENC
"""
the name is given in the IDB encoding; non-ASCII bytes will be decoded
accordingly. Specifying SN_IDBENC also implies SN_NODUMMY
"""

ida_name.SN_LOCAL
"""
create local name. a function should exist. local names can't be
public or weak. also they are not included into the list of names they
can't have dummy prefixes.
"""

ida_name.SN_NOCHECK
"""
Don't fail if the name contains invalid characters. If this bit is
clear, all invalid chars (those !is_ident_cp()) will be replaced by
SUBSTCHAR List of valid characters is defined in ida.cfg
"""

ida_name.SN_NODUMMY
"""
automatically prepend the name with '_' if it begins with a dummy
suffix such as 'sub_'. See also SN_IDBENC
"""

ida_name.SN_NOLIST
"""
if set, exclude name from the list. if not set, then include the name
into the list (however, if other bits are set, the name might be
immediately excluded from the list).
"""

ida_name.SN_NON_AUTO
"""
if set, make name non-autogenerated
"""

ida_name.SN_NON_PUBLIC
"""
if set, make name non-public
"""

ida_name.SN_NON_WEAK
"""
if set, make name non-weak
"""

ida_name.SN_NOWARN
"""
don't display a warning if failed
"""

ida_name.SN_PUBLIC
"""
if set, make name public
"""

ida_name.SN_WEAK
"""
if set, make name weak
"""
=== ida_name EPYDOC INJECTIONS END ===
Help on function exist in module ida_netnode:

exist(*args)
    exist(n) -> bool
        n: netnode const &

Help on class netnode in module ida_netnode:

class netnode(__builtin__.object)
 |  Proxy of C++ netnode class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, n) -> bool
 |          n: netnode &
 |      
 |      
 |      __eq__(self, x) -> bool
 |          x: nodeidx_t
 |  
 |  __init__(self, *args)
 |      __init__(self, num=nodeidx_t(-1)) -> netnode
 |          num: nodeidx_t
 |      
 |      
 |      __init__(self, _name, namlen=0, do_create=False) -> netnode
 |          _name: char const *
 |          namlen: size_t
 |          do_create: bool
 |  
 |  __ne__(self, *args)
 |      __ne__(self, n) -> bool
 |          n: netnode &
 |      
 |      
 |      __ne__(self, x) -> bool
 |          x: nodeidx_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  altdel(self, *args)
 |      altdel(self, alt, tag=atag) -> bool
 |          alt: nodeidx_t
 |          tag: uchar
 |  
 |  altdel_all(self, *args)
 |      altdel_all(self, tag=atag) -> bool
 |          tag: uchar
 |  
 |  altdel_ea(self, *args)
 |      altdel_ea(self, ea, tag=atag) -> bool
 |          ea: ea_t
 |          tag: uchar
 |  
 |  altdel_idx8(self, *args)
 |      altdel_idx8(self, alt, tag) -> bool
 |          alt: uchar
 |          tag: uchar
 |  
 |  altfirst(self, *args)
 |      altfirst(self, tag=atag) -> nodeidx_t
 |          tag: uchar
 |  
 |  altfirst_idx8(self, *args)
 |      altfirst_idx8(self, tag) -> nodeidx_t
 |          tag: uchar
 |  
 |  altlast(self, *args)
 |      altlast(self, tag=atag) -> nodeidx_t
 |          tag: uchar
 |  
 |  altlast_idx8(self, *args)
 |      altlast_idx8(self, tag) -> nodeidx_t
 |          tag: uchar
 |  
 |  altnext(self, *args)
 |      altnext(self, cur, tag=atag) -> nodeidx_t
 |          cur: nodeidx_t
 |          tag: uchar
 |  
 |  altnext_idx8(self, *args)
 |      altnext_idx8(self, cur, tag) -> nodeidx_t
 |          cur: uchar
 |          tag: uchar
 |  
 |  altprev(self, *args)
 |      altprev(self, cur, tag=atag) -> nodeidx_t
 |          cur: nodeidx_t
 |          tag: uchar
 |  
 |  altprev_idx8(self, *args)
 |      altprev_idx8(self, cur, tag) -> nodeidx_t
 |          cur: uchar
 |          tag: uchar
 |  
 |  altset(self, *args)
 |      altset(self, alt, value, tag=atag) -> bool
 |          alt: nodeidx_t
 |          value: nodeidx_t
 |          tag: uchar
 |  
 |  altset_ea(self, *args)
 |      altset_ea(self, ea, value, tag=atag) -> bool
 |          ea: ea_t
 |          value: nodeidx_t
 |          tag: uchar
 |  
 |  altset_idx8(self, *args)
 |      altset_idx8(self, alt, val, tag) -> bool
 |          alt: uchar
 |          val: nodeidx_t
 |          tag: uchar
 |  
 |  altshift(self, *args)
 |      altshift(self, _from, to, size, tag=atag) -> size_t
 |          from: nodeidx_t
 |          to: nodeidx_t
 |          size: nodeidx_t
 |          tag: uchar
 |  
 |  altval(self, *args)
 |      altval(self, alt, tag=atag) -> nodeidx_t
 |          alt: nodeidx_t
 |          tag: uchar
 |  
 |  altval_ea(self, *args)
 |      altval_ea(self, ea, tag=atag) -> nodeidx_t
 |          ea: ea_t
 |          tag: uchar
 |  
 |  altval_idx8(self, *args)
 |      altval_idx8(self, alt, tag) -> nodeidx_t
 |          alt: uchar
 |          tag: uchar
 |  
 |  blobsize(self, *args)
 |      blobsize(self, _start, tag) -> size_t
 |          _start: nodeidx_t
 |          tag: uchar
 |  
 |  blobsize_ea(self, *args)
 |      blobsize_ea(self, ea, tag) -> size_t
 |          ea: ea_t
 |          tag: uchar
 |  
 |  chardel(self, *args)
 |      chardel(self, alt, tag) -> bool
 |          alt: nodeidx_t
 |          tag: uchar
 |  
 |  chardel_ea(self, *args)
 |      chardel_ea(self, ea, tag) -> bool
 |          ea: ea_t
 |          tag: uchar
 |  
 |  chardel_idx8(self, *args)
 |      chardel_idx8(self, alt, tag) -> bool
 |          alt: uchar
 |          tag: uchar
 |  
 |  charfirst(self, *args)
 |      charfirst(self, tag) -> nodeidx_t
 |          tag: uchar
 |  
 |  charfirst_idx8(self, *args)
 |      charfirst_idx8(self, tag) -> nodeidx_t
 |          tag: uchar
 |  
 |  charlast(self, *args)
 |      charlast(self, tag) -> nodeidx_t
 |          tag: uchar
 |  
 |  charlast_idx8(self, *args)
 |      charlast_idx8(self, tag) -> nodeidx_t
 |          tag: uchar
 |  
 |  charnext(self, *args)
 |      charnext(self, cur, tag) -> nodeidx_t
 |          cur: nodeidx_t
 |          tag: uchar
 |  
 |  charnext_idx8(self, *args)
 |      charnext_idx8(self, cur, tag) -> nodeidx_t
 |          cur: uchar
 |          tag: uchar
 |  
 |  charprev(self, *args)
 |      charprev(self, cur, tag) -> nodeidx_t
 |          cur: nodeidx_t
 |          tag: uchar
 |  
 |  charprev_idx8(self, *args)
 |      charprev_idx8(self, cur, tag) -> nodeidx_t
 |          cur: uchar
 |          tag: uchar
 |  
 |  charset(self, *args)
 |      charset(self, alt, val, tag) -> bool
 |          alt: nodeidx_t
 |          val: uchar
 |          tag: uchar
 |  
 |  charset_ea(self, *args)
 |      charset_ea(self, ea, val, tag) -> bool
 |          ea: ea_t
 |          val: uchar
 |          tag: uchar
 |  
 |  charset_idx8(self, *args)
 |      charset_idx8(self, alt, val, tag) -> bool
 |          alt: uchar
 |          val: uchar
 |          tag: uchar
 |  
 |  charshift(self, *args)
 |      charshift(self, _from, to, size, tag) -> size_t
 |          from: nodeidx_t
 |          to: nodeidx_t
 |          size: nodeidx_t
 |          tag: uchar
 |  
 |  charval(self, *args)
 |      charval(self, alt, tag) -> uchar
 |          alt: nodeidx_t
 |          tag: uchar
 |  
 |  charval_ea(self, *args)
 |      charval_ea(self, ea, tag) -> uchar
 |          ea: ea_t
 |          tag: uchar
 |  
 |  charval_idx8(self, *args)
 |      charval_idx8(self, alt, tag) -> uchar
 |          alt: uchar
 |          tag: uchar
 |  
 |  copyto(self, *args)
 |      copyto(self, target, count=1) -> size_t
 |          target: netnode
 |          count: nodeidx_t
 |  
 |  create(self, *args)
 |      create(self, _name, namlen=0) -> bool
 |          _name: char const *
 |          namlen: size_t
 |  
 |  delblob(self, *args)
 |      delblob(self, _start, tag) -> int
 |          _start: nodeidx_t
 |          tag: uchar
 |  
 |  delblob_ea(self, *args)
 |      delblob_ea(self, ea, tag) -> int
 |          ea: ea_t
 |          tag: uchar
 |  
 |  delvalue(self, *args)
 |      delvalue(self) -> bool
 |  
 |  eadel(self, *args)
 |      eadel(self, ea, tag) -> bool
 |          ea: ea_t
 |          tag: uchar
 |  
 |  eadel_idx8(self, *args)
 |      eadel_idx8(self, idx, tag) -> bool
 |          idx: uchar
 |          tag: uchar
 |  
 |  eaget(self, *args)
 |      eaget(self, ea, tag) -> ea_t
 |          ea: ea_t
 |          tag: uchar
 |  
 |  eaget_idx(self, *args)
 |      eaget_idx(self, idx, tag) -> ea_t
 |          idx: nodeidx_t
 |          tag: uchar
 |  
 |  eaget_idx8(self, *args)
 |      eaget_idx8(self, idx, tag) -> ea_t
 |          idx: uchar
 |          tag: uchar
 |  
 |  easet(self, *args)
 |      easet(self, ea, addr, tag) -> bool
 |          ea: ea_t
 |          addr: ea_t
 |          tag: uchar
 |  
 |  easet_idx(self, *args)
 |      easet_idx(self, idx, addr, tag) -> bool
 |          idx: nodeidx_t
 |          addr: ea_t
 |          tag: uchar
 |  
 |  easet_idx8(self, *args)
 |      easet_idx8(self, idx, addr, tag) -> bool
 |          idx: uchar
 |          addr: ea_t
 |          tag: uchar
 |  
 |  end(self, *args)
 |      end(self) -> bool
 |  
 |  get_name(self, *args)
 |      get_name(self) -> ssize_t
 |  
 |  getblob(self, *args)
 |      getblob(self, start, tag) -> PyObject *
 |          start: nodeidx_t
 |          tag: char
 |  
 |  getblob_ea(self, *args)
 |      getblob_ea(self, ea, tag) -> PyObject *
 |          ea: ea_t
 |          tag: char
 |  
 |  getclob(self, *args)
 |      getclob(self, start, tag) -> PyObject *
 |          start: nodeidx_t
 |          tag: char
 |  
 |  hashdel(self, *args)
 |      hashdel(self, idx, tag=htag) -> bool
 |          idx: char const *
 |          tag: uchar
 |  
 |  hashdel_all(self, *args)
 |      hashdel_all(self, tag=htag) -> bool
 |          tag: uchar
 |  
 |  hashfirst(self, *args)
 |      hashfirst(self, tag=htag) -> ssize_t
 |          tag: uchar
 |  
 |  hashlast(self, *args)
 |      hashlast(self, tag=htag) -> ssize_t
 |          tag: uchar
 |  
 |  hashnext(self, *args)
 |      hashnext(self, idx, tag=htag) -> ssize_t
 |          idx: char const *
 |          tag: uchar
 |  
 |  hashprev(self, *args)
 |      hashprev(self, idx, tag=htag) -> ssize_t
 |          idx: char const *
 |          tag: uchar
 |  
 |  hashset(self, *args)
 |      hashset(self, idx, value, tag=htag) -> bool
 |          idx: char const *
 |          value: void const *
 |          tag: uchar
 |  
 |  hashset_buf(self, *args)
 |      hashset_buf(self, idx, py_str, tag=htag) -> bool
 |          idx: char const *
 |          py_str: PyObject *
 |          tag: char
 |  
 |  hashset_idx(self, *args)
 |      hashset_idx(self, idx, value, tag=htag) -> bool
 |          idx: char const *
 |          value: nodeidx_t
 |          tag: uchar
 |  
 |  hashstr(self, *args)
 |      hashstr(self, idx, tag=htag) -> ssize_t
 |          idx: char const *
 |          tag: uchar
 |  
 |  hashstr_buf(self, *args)
 |      hashstr_buf(self, idx, tag=htag) -> PyObject *
 |          idx: char const *
 |          tag: char
 |  
 |  hashval(self, *args)
 |      hashval(self, idx, tag=htag) -> ssize_t
 |          idx: char const *
 |          tag: uchar
 |  
 |  hashval_long(self, *args)
 |      hashval_long(self, idx, tag=htag) -> nodeidx_t
 |          idx: char const *
 |          tag: uchar
 |  
 |  index(self, *args)
 |      index(self) -> nodeidx_t
 |  
 |  kill(self, *args)
 |      kill(self)
 |  
 |  long_value(self, *args)
 |      long_value(self) -> nodeidx_t
 |  
 |  lower_bound(self, *args)
 |      lower_bound(self, cur, tag=stag) -> nodeidx_t
 |          cur: nodeidx_t
 |          tag: uchar
 |  
 |  lower_bound_ea(self, *args)
 |      lower_bound_ea(self, ea, tag=stag) -> nodeidx_t
 |          ea: ea_t
 |          tag: uchar
 |  
 |  lower_bound_idx8(self, *args)
 |      lower_bound_idx8(self, alt, tag) -> nodeidx_t
 |          alt: uchar
 |          tag: uchar
 |  
 |  moveto(self, *args)
 |      moveto(self, target, count=1) -> size_t
 |          target: netnode
 |          count: nodeidx_t
 |  
 |  next(self, *args)
 |      next(self) -> bool
 |  
 |  prev(self, *args)
 |      prev(self) -> bool
 |  
 |  rename(self, *args)
 |      rename(self, newname, namlen=0) -> bool
 |          newname: char const *
 |          namlen: size_t
 |  
 |  set(self, *args)
 |      set(self, value) -> bool
 |          value: void const *
 |  
 |  set_long(self, *args)
 |      set_long(self, x) -> bool
 |          x: nodeidx_t
 |  
 |  setblob(self, *args)
 |      setblob(self, buf, _start, tag) -> bool
 |          buf: void const *
 |          _start: nodeidx_t
 |          tag: uchar
 |  
 |  setblob_ea(self, *args)
 |      setblob_ea(self, buf, ea, tag) -> bool
 |          buf: void const *
 |          ea: ea_t
 |          tag: uchar
 |  
 |  start(self, *args)
 |      start(self) -> bool
 |  
 |  supdel(self, *args)
 |      supdel(self, alt, tag=stag) -> bool
 |          alt: nodeidx_t
 |          tag: uchar
 |  
 |  supdel_all(self, *args)
 |      supdel_all(self, tag) -> bool
 |          tag: uchar
 |  
 |  supdel_ea(self, *args)
 |      supdel_ea(self, ea, tag=stag) -> bool
 |          ea: ea_t
 |          tag: uchar
 |  
 |  supdel_idx8(self, *args)
 |      supdel_idx8(self, alt, tag) -> bool
 |          alt: uchar
 |          tag: uchar
 |  
 |  supdel_range(self, *args)
 |      supdel_range(self, idx1, idx2, tag) -> int
 |          idx1: nodeidx_t
 |          idx2: nodeidx_t
 |          tag: uchar
 |  
 |  supdel_range_idx8(self, *args)
 |      supdel_range_idx8(self, idx1, idx2, tag) -> int
 |          idx1: uchar
 |          idx2: uchar
 |          tag: uchar
 |  
 |  supfirst(self, *args)
 |      supfirst(self, tag=stag) -> nodeidx_t
 |          tag: uchar
 |  
 |  supfirst_idx8(self, *args)
 |      supfirst_idx8(self, tag) -> nodeidx_t
 |          tag: uchar
 |  
 |  suplast(self, *args)
 |      suplast(self, tag=stag) -> nodeidx_t
 |          tag: uchar
 |  
 |  suplast_idx8(self, *args)
 |      suplast_idx8(self, tag) -> nodeidx_t
 |          tag: uchar
 |  
 |  supnext(self, *args)
 |      supnext(self, cur, tag=stag) -> nodeidx_t
 |          cur: nodeidx_t
 |          tag: uchar
 |  
 |  supnext_idx8(self, *args)
 |      supnext_idx8(self, alt, tag) -> nodeidx_t
 |          alt: uchar
 |          tag: uchar
 |  
 |  supprev(self, *args)
 |      supprev(self, cur, tag=stag) -> nodeidx_t
 |          cur: nodeidx_t
 |          tag: uchar
 |  
 |  supprev_idx8(self, *args)
 |      supprev_idx8(self, alt, tag) -> nodeidx_t
 |          alt: uchar
 |          tag: uchar
 |  
 |  supset(self, *args)
 |      supset(self, alt, value, tag=stag) -> bool
 |          alt: nodeidx_t
 |          value: void const *
 |          tag: uchar
 |  
 |  supset_ea(self, *args)
 |      supset_ea(self, ea, value, tag=stag) -> bool
 |          ea: ea_t
 |          value: void const *
 |          tag: uchar
 |  
 |  supset_idx8(self, *args)
 |      supset_idx8(self, alt, value, tag) -> bool
 |          alt: uchar
 |          value: void const *
 |          tag: uchar
 |  
 |  supshift(self, *args)
 |      supshift(self, _from, to, size, tag=stag) -> size_t
 |          from: nodeidx_t
 |          to: nodeidx_t
 |          size: nodeidx_t
 |          tag: uchar
 |  
 |  supstr(self, *args)
 |      supstr(self, alt, tag=stag) -> ssize_t
 |          alt: nodeidx_t
 |          tag: uchar
 |  
 |  supstr_ea(self, *args)
 |      supstr_ea(self, ea, tag=stag) -> ssize_t
 |          ea: ea_t
 |          tag: uchar
 |  
 |  supstr_idx8(self, *args)
 |      supstr_idx8(self, alt, tag) -> ssize_t
 |          alt: uchar
 |          tag: uchar
 |  
 |  supval(self, *args)
 |      supval(self, alt, tag=stag) -> ssize_t
 |          alt: nodeidx_t
 |          tag: uchar
 |  
 |  supval_ea(self, *args)
 |      supval_ea(self, ea, tag=stag) -> ssize_t
 |          ea: ea_t
 |          tag: uchar
 |  
 |  supval_idx8(self, *args)
 |      supval_idx8(self, alt, tag) -> ssize_t
 |          alt: uchar
 |          tag: uchar
 |  
 |  valobj(self, *args)
 |      valobj(self) -> ssize_t
 |  
 |  valstr(self, *args)
 |      valstr(self) -> ssize_t
 |  
 |  value_exists(self, *args)
 |      value_exists(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_netnode>
 |      delete_netnode(self)

=== ida_netnode EPYDOC INJECTIONS ===
ida_netnode.BADNODE
"""
A number to represent a bad netnode reference.
"""
=== ida_netnode EPYDOC INJECTIONS END ===
Help on function add_refinfo_dref in module ida_offset:

add_refinfo_dref(*args)
    Add xrefs for a reference from the given instruction (\insn_t{ea}).
    This function creates a cross references to the target and the base.
    'insn_t::add_off_drefs()' calls this function to create xrefs for
    'offset' operand.
    
    add_refinfo_dref(insn, _from, ri, opval, type, opoff) -> ea_t
        @param insn: the referencing instruction  - an ida_ua.insn_t, or an
                     address (C++: const insn_t &)
        @param _from: the referencing instruction/data address (C++: ea_t)
        @param ri: reference info block from the database (C++: const
                   refinfo_t  &)
        @param opval: operand value (usually  op_t::value  or  op_t::addr )
                      (C++: adiff_t)
        @param type: type of xref (C++: dref_t)
        @param opoff: offset of the operand from the start of instruction
                      (C++: int)
        @return: the target address of the reference

Help on function calc_basevalue in module ida_offset:

calc_basevalue(*args)
    Calculate the value of the reference base.
    
    calc_basevalue(target, base) -> ea_t
        @param target (C++: ea_t)
        @param base (C++: ea_t)

Help on function calc_offset_base in module ida_offset:

calc_offset_base(*args)
    Try to calculate the offset base This function takes into account the
    fixup information, current ds and cs values.
    
    calc_offset_base(ea, n) -> ea_t
        @param ea: the referencing instruction/data address (C++: ea_t)
        @param n: operand number   0: first operand   1: other operand (C++:
                  int)
        @return: output base address or  BADADDR

Help on function calc_probable_base_by_value in module ida_offset:

calc_probable_base_by_value(*args)
    Try to calculate the offset base. 2 bases are checked: current ds and
    cs. If fails, return 'BADADDR'
    
    calc_probable_base_by_value(ea, off) -> ea_t
        @param ea (C++: ea_t)
        @param off (C++: uval_t)

Help on function calc_reference_data in module ida_offset:

calc_reference_data(*args)
    Calculate the target and base addresses of an offset expression. The
    calculated target and base addresses are returned in the locations
    pointed by 'base' and 'target'. In case 'ri.base' is 'BADADDR' , the
    function calculates the offset base address from the referencing
    instruction/data address. The target address is copied from ri.target.
    If ri.target is 'BADADDR' then the target is calculated using the base
    address and 'opval'. This function also checks if 'opval' matches the
    full value of the reference and takes in account the memory-mapping.
    
    calc_reference_data(target, base, _from, ri, opval) -> bool
        @param target: output target address (C++: ea_t *)
        @param base: output base address (C++: ea_t *)
        @param _from: the referencing instruction/data address (C++: ea_t)
        @param ri: reference info block from the database (C++: const
                   refinfo_t  &)
        @param opval: operand value (usually  op_t::value  or  op_t::addr )
                      (C++: adiff_t)
        @return: success

Help on function calc_target in module ida_offset:

calc_target(*args)
    Calculates the target, using the provided 'refinfo_t' .
    
    calc_target(_from, opval, ri) -> ea_t
        @param _from (C++: ea_t)
        @param opval (C++: adiff_t)
        @param ri (C++: const  refinfo_t  &)
    
    
    calc_target(_from, ea, n, opval) -> ea_t
        @param _from (C++: ea_t)
        ea: ea_t
        n: int
        @param opval (C++: adiff_t)

Help on function can_be_off32 in module ida_offset:

can_be_off32(*args)
    Does the specified address contain a valid OFF32 value?. For symbols
    in special segments the displacement is not taken into account. If
    yes, then the target address of OFF32 will be returned. If not, then
    'BADADDR' is returned.
    
    can_be_off32(ea) -> ea_t
        @param ea (C++: ea_t)

Help on function get_default_reftype in module ida_offset:

get_default_reftype(*args)
    Get default reference type depending on the segment.
    
    get_default_reftype(ea) -> reftype_t
        @param ea (C++: ea_t)
        @return: one of  REF_OFF8 , REF_OFF16 , REF_OFF32

Help on function get_offbase in module ida_offset:

get_offbase(*args)
    Get offset base value
    
    get_offbase(ea, n) -> ea_t
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (C++: int)
        @return: offset base or  BADADDR

Help on function get_offset_expr in module ida_offset:

get_offset_expr(*args)
    See 'get_offset_expression()'
    
    get_offset_expr(ea, n, ri, _from, offset, getn_flags=0) -> str
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param ri (C++: const  refinfo_t  &)
        @param _from (C++: ea_t)
        @param offset (C++: adiff_t)
        @param getn_flags (C++: int)

Help on function get_offset_expression in module ida_offset:

get_offset_expression(*args)
    Get offset expression (in the form "offset name+displ"). This function
    uses offset translation function (\ph{translate}) if your IDP module
    has such a function. Translation function is used to map linear
    addresses in the program (only for offsets).Example: suppose we have
    instruction at linear address 0x00011000: \v{mov ax, [bx+7422h]} and
    at ds:7422h: \v{array dw ...} We want to represent the second operand
    with an offset expression, so then we call: \v{
    get_offset_expresion(0x001100, 1, 0x001102, 0x7422, buf); | | | | | |
    | | | +output buffer | | | +value of offset expression | | +address
    offset value in the instruction | +the second operand +address of
    instruction } and the function will return a colored string: \v{offset
    array}
    
    get_offset_expression(ea, n, _from, offset, getn_flags=0) -> str
        @param ea: start of instruction or data with the offset expression
                   (C++: ea_t)
        @param n: number of operand (may be ORed with  OPND_OUTER )   0: first
                  operand   1: second operand (C++: int)
        @param _from: linear address of instruction operand or data referring
                      to the name. This address will be used to get fixup
                      information, so it should point to exact position of
                      operand in the instruction. (C++: ea_t)
        @param offset: value of operand or its part. The function will return
                       text representation of this value as offset expression.
                       (C++: adiff_t)
        @param getn_flags: combination of:   GETN_APPZERO : meaningful only if
                           the name refers to a structure. appends the struct
                           field name if the field offset is zero
                           GETN_NODUMMY : do not generate dummy names for the
                           expression but pretend they already exist (useful
                           to verify that the offset expression can be
                           represented) (C++: int)
        @retval: 0 - can't convert to offset expression
        @retval: 1 - ok, a simple offset expression
        @retval: 2 - ok, a complex offset expression

Help on function op_offset in module ida_offset:

op_offset(*args)
    See 'op_offset_ex()'
    
    op_offset(ea, n, type, target=BADADDR, base=0, tdelta=0) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param type (C++: reftype_t)
        @param target (C++: ea_t)
        @param base (C++: ea_t)
        @param tdelta (C++: adiff_t)

Help on function op_offset_ex in module ida_offset:

op_offset_ex(*args)
    Convert operand to a reference. To delete an offset, use
    'clr_op_type()' function.
    
    op_offset_ex(ea, n, ri) -> bool
        @param ea: linear address. if 'ea' has unexplored bytes, try to
                   convert them to   no segment: fail   16bit segment: to
                   16bit word data   32bit segment: to dword (C++: ea_t)
        @param n: number of operand (may be ORed with  OPND_OUTER )   0: first
                  1: second   2: third   OPND_MASK : all operands (C++: int)
        @param ri: reference information (C++: const  refinfo_t  *)
        @return: success

Help on function op_plain_offset in module ida_offset:

op_plain_offset(*args)
    Convert operand to a reference with the default reference type.
    
    op_plain_offset(ea, n, base) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param base (C++: ea_t)

Help on class __qmutex_t in module ida_pro:

class __qmutex_t(__builtin__.object)
 |  Proxy of C++ __qmutex_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qmutex_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete___qmutex_t>
 |      delete___qmutex_t(self)

Help on class __qsemaphore_t in module ida_pro:

class __qsemaphore_t(__builtin__.object)
 |  Proxy of C++ __qsemaphore_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qsemaphore_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete___qsemaphore_t>
 |      delete___qsemaphore_t(self)

Help on class __qthread_t in module ida_pro:

class __qthread_t(__builtin__.object)
 |  Proxy of C++ __qthread_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qthread_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete___qthread_t>
 |      delete___qthread_t(self)

Help on class _qstrvec_t in module ida_pro:

class _qstrvec_t(ida_idaapi.py_clinked_object_t)
 |  WARNING: It is very unlikely an IDAPython user should ever, ever
 |  have to use this type. It should only be used for IDAPython internals.
 |  
 |  For example, in py_askusingform.py, we ctypes-expose to the IDA
 |  kernel & UI a qstrvec instance, in case a DropdownListControl is
 |  constructed.
 |  That's because that's what ask_form expects, and we have no
 |  choice but to make a DropdownListControl hold a qstrvec_t.
 |  This is, afaict, the only situation where a Python
 |  _qstrvec_t is required.
 |  
 |  Method resolution order:
 |      _qstrvec_t
 |      ida_idaapi.py_clinked_object_t
 |      ida_idaapi.pyidc_opaque_object_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, idx)
 |      Gets the string at the given index
 |  
 |  __init__(self, items=None)
 |  
 |  __setitem__(self, idx, s)
 |      Sets string at the given index
 |  
 |  _create_clink(self)
 |  
 |  _del_clink(self, lnk)
 |  
 |  _get_clink_ptr(self)
 |  
 |  _qstrvec_t__get_size = __get_size(self)
 |  
 |  add(self, s)
 |      Add a string to the vector
 |  
 |  addressof(self, idx)
 |      Returns the address (as number) of the qstring at the given index
 |  
 |  assign(self, other)
 |      Copies the contents of 'other' to 'self'
 |  
 |  clear(self, qclear=False)
 |      Clears all strings from the vector.
 |      @param qclear: Just reset the size but do not actually free the memory
 |  
 |  from_list(self, lst)
 |      Populates the vector from a Python string list
 |  
 |  insert(self, idx, s)
 |      Insert a string into the vector
 |  
 |  remove(self, idx)
 |      Removes a string from the vector
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  size
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  __del__(self)
 |      Delete the link upon object destruction (only if not static)
 |  
 |  _free(self)
 |      Explicitly delete the link (only if not static)
 |  
 |  copy(self)
 |      Returns a new copy of this class
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  clink
 |  
 |  clink_ptr
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on class boolvec_t in module ida_pro:

class boolvec_t(__builtin__.object)
 |  Proxy of C++ qvector< bool > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< bool > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> bool const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> boolvec_t
 |          x: qvector< bool > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< bool > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: bool const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: bool const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: bool const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< bool >::iterator
 |      begin(self) -> qvector< bool >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< bool >::iterator
 |      end(self) -> qvector< bool >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< bool >::iterator
 |          it: qvector< bool >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< bool >::iterator
 |          first: qvector< bool >::iterator
 |          last: qvector< bool >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> bool *
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< bool >::iterator
 |          x: bool const &
 |      
 |      
 |      find(self, x) -> qvector< bool >::const_iterator
 |          x: bool const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=bool())
 |          x: bool const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: bool const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: bool *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< bool >::iterator
 |          it: qvector< bool >::iterator
 |          x: bool const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: bool const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: bool const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< bool > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_boolvec_t>
 |      delete_boolvec_t(self)

Help on class channel_redir_t in module ida_pro:

class channel_redir_t(__builtin__.object)
 |  Proxy of C++ channel_redir_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> channel_redir_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  is_append(self, *args)
 |      is_append(self) -> bool
 |  
 |  is_input(self, *args)
 |      is_input(self) -> bool
 |  
 |  is_output(self, *args)
 |      is_output(self) -> bool
 |  
 |  is_quoted(self, *args)
 |      is_quoted(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fd
 |      channel_redir_t_fd_get(self) -> int
 |  
 |  file
 |      channel_redir_t_file_get(self) -> qstring *
 |  
 |  flags
 |      channel_redir_t_flags_get(self) -> int
 |  
 |  length
 |      channel_redir_t_length_get(self) -> int
 |  
 |  start
 |      channel_redir_t_start_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_channel_redir_t>
 |      delete_channel_redir_t(self)

Help on function check_process_exit in module ida_pro:

check_process_exit(*args)
    Check whether process has terminated or not.
    
    check_process_exit(handle, exit_code, msecs=-1) -> int
        @param handle: process handle to wait for (C++: void *)
        @param exit_code: pointer to the buffer for the exit code (C++: int *)
        msecs: int
        @retval: 0 - process has exited, and the exit code is available. if
                     *exit_code < 0: the process was killed with a signal
                     -*exit_code
        @retval: 1 - process has not exited yet
        @retval: -1 - error happened, see error code for  winerr()  in
                      *exit_code

Help on function clear_bits in module ida_pro:

clear_bits(*args)
    Clear bits between [low, high) in 'bitmap'.
    
    clear_bits(bitmap, low, high)
        @param bitmap (C++: uchar  *)
        @param low (C++: size_t)
        @param high (C++: size_t)

Help on class ea_array in module ida_pro:

class ea_array(__builtin__.object)
 |  Proxy of C++ ea_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, index) -> ea_t
 |          index: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> ea_array
 |          nelements: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, index, value)
 |          index: size_t
 |          value: ea_t
 |  
 |  cast(self, *args)
 |      cast(self) -> ea_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args)
 |      frompointer(t) -> ea_array
 |          t: ea_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ea_array>
 |      delete_ea_array(self)

Help on function ea_array_frompointer in module ida_pro:

ea_array_frompointer(*args)
    ea_array_frompointer(t) -> ea_array
        t: ea_t *

Help on class ea_pointer in module ida_pro:

class ea_pointer(__builtin__.object)
 |  Proxy of C++ ea_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ea_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  assign(self, *args)
 |      assign(self, value)
 |          value: ea_t
 |  
 |  cast(self, *args)
 |      cast(self) -> ea_t *
 |  
 |  value(self, *args)
 |      value(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args)
 |      frompointer(t) -> ea_pointer
 |          t: ea_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ea_pointer>
 |      delete_ea_pointer(self)

Help on function ea_pointer_frompointer in module ida_pro:

ea_pointer_frompointer(*args)
    ea_pointer_frompointer(t) -> ea_pointer
        t: ea_t *

Help on function extend_sign in module ida_pro:

extend_sign(*args)
    Sign-, or zero-extend the value 'v' to occupy 64 bits. The value 'v'
    is considered to be of size 'nbytes'.
    
    extend_sign(v, nbytes, sign_extend) -> uint64
        @param v (C++: uint64)
        @param nbytes (C++: int)
        @param sign_extend (C++: bool)

Help on class instant_dbgopts_t in module ida_pro:

class instant_dbgopts_t(__builtin__.object)
 |  Proxy of C++ instant_dbgopts_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> instant_dbgopts_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  _pass
 |      instant_dbgopts_t__pass_get(self) -> qstring *
 |  
 |  attach
 |      instant_dbgopts_t_attach_get(self) -> bool
 |  
 |  debmod
 |      instant_dbgopts_t_debmod_get(self) -> qstring *
 |  
 |  env
 |      instant_dbgopts_t_env_get(self) -> qstring *
 |  
 |  event_id
 |      instant_dbgopts_t_event_id_get(self) -> int
 |  
 |  host
 |      instant_dbgopts_t_host_get(self) -> qstring *
 |  
 |  pid
 |      instant_dbgopts_t_pid_get(self) -> int
 |  
 |  port
 |      instant_dbgopts_t_port_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_instant_dbgopts_t>
 |      delete_instant_dbgopts_t(self)

Help on class longlongvec_t in module ida_pro:

class longlongvec_t(__builtin__.object)
 |  Proxy of C++ qvector< long long > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< long long > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> long long const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> longlongvec_t
 |          x: qvector< long long > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< long long > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: long long const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: long long const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: long long const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< long long >::iterator
 |      begin(self) -> qvector< long long >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< long long >::iterator
 |      end(self) -> qvector< long long >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< long long >::iterator
 |          it: qvector< long long >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< long long >::iterator
 |          first: qvector< long long >::iterator
 |          last: qvector< long long >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> long long *
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< long long >::iterator
 |          x: long long const &
 |      
 |      
 |      find(self, x) -> qvector< long long >::const_iterator
 |          x: long long const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: long long const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: long long *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< long long >::iterator
 |          it: qvector< long long >::iterator
 |          x: long long const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: long long const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: long long const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< long long > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_longlongvec_t>
 |      delete_longlongvec_t(self)

Help on class int_pointer in module ida_pro:

class int_pointer(__builtin__.object)
 |  Proxy of C++ int_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> int_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  assign(self, *args)
 |      assign(self, value)
 |          value: int
 |  
 |  cast(self, *args)
 |      cast(self) -> int *
 |  
 |  value(self, *args)
 |      value(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args)
 |      frompointer(t) -> int_pointer
 |          t: int *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_int_pointer>
 |      delete_int_pointer(self)

Help on function int_pointer_frompointer in module ida_pro:

int_pointer_frompointer(*args)
    int_pointer_frompointer(t) -> int_pointer
        t: int *

Help on class intvec_t in module ida_pro:

class intvec_t(__builtin__.object)
 |  Proxy of C++ qvector< int > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< int > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> int const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> intvec_t
 |          x: qvector< int > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< int > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: int const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: int const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: int const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< int >::iterator
 |      begin(self) -> qvector< int >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< int >::iterator
 |      end(self) -> qvector< int >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< int >::iterator
 |          it: qvector< int >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< int >::iterator
 |          first: qvector< int >::iterator
 |          last: qvector< int >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> int *
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< int >::iterator
 |          x: int const &
 |      
 |      
 |      find(self, x) -> qvector< int >::const_iterator
 |          x: int const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: int const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: int *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< int >::iterator
 |          it: qvector< int >::iterator
 |          x: int const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: int const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: int const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< int > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_intvec_t>
 |      delete_intvec_t(self)

Help on function is_control_tty in module ida_pro:

is_control_tty(*args)
    Check if the current process is the owner of the TTY specified by 'fd'
    (typically an opened descriptor to /dev/tty).
    
    is_control_tty(fd) -> enum tty_control_t
        @param fd (C++: int)

Help on function is_main_thread in module ida_pro:

is_main_thread(*args)
    Are we running in the main thread?

Help on function log2ceil in module ida_pro:

log2ceil(*args)
    calculate ceil(log2(d64)) or floor(log2(d64)), it returns 0 if d64 ==
    0
    
    log2ceil(d64) -> int
        @param d64 (C++: uint64)

Help on function log2floor in module ida_pro:

log2floor(*args)
    log2floor(d64) -> int
        @param d64 (C++: uint64)

Help on function parse_dbgopts in module ida_pro:

parse_dbgopts(*args)
    Parse the -r command line switch (for instant debugging). r_switch
    points to the value of the -r switch. Example: win32@localhost+
    
    parse_dbgopts(ido, r_switch) -> bool
        @param ido (C++: struct  instant_dbgopts_t  *)
        @param r_switch (C++: const char *)
        @return: true-ok, false-parse error

Help on function qatoll in module ida_pro:

qatoll(*args)
    qatoll(nptr) -> int64
        @param nptr (C++: const char *)

Help on function qcontrol_tty in module ida_pro:

qcontrol_tty(*args)
    Make the current terminal the controlling terminal of the calling
    process.The current terminal is supposed to be /dev/tty

Help on function qdetach_tty in module ida_pro:

qdetach_tty(*args)
    If the current terminal is the controlling terminal of the calling
    process, give up this controlling terminal.The current terminal is
    supposed to be /dev/tty

Help on function qexit in module ida_pro:

qexit(*args)
    Call qatexit functions, shut down UI and kernel, and exit.
    
    qexit(code)
        @param code: exit code (C++: int)

Help on class qmutex_locker_t in module ida_pro:

class qmutex_locker_t(__builtin__.object)
 |  Proxy of C++ qmutex_locker_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _lock) -> qmutex_locker_t
 |          _lock: qmutex_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qmutex_locker_t>
 |      delete_qmutex_locker_t(self)

Help on class qrefcnt_obj_t in module ida_pro:

class qrefcnt_obj_t(__builtin__.object)
 |  Proxy of C++ qrefcnt_obj_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  release(self, *args)
 |      Call destructor. We use 'release()' instead of operator delete() to
 |      maintain binary compatibility with all compilers (vc and gcc use
 |      different vtable layouts for operator delete)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  refcnt
 |      qrefcnt_obj_t_refcnt_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_qrefcnt_obj_t>
 |      delete_qrefcnt_obj_t(self)

Help on function qstrvec_t_add in module ida_pro:

qstrvec_t_add(*args)
    qstrvec_t_add(_self, s) -> bool
        self: PyObject *
        s: char const *

Help on function qstrvec_t_addressof in module ida_pro:

qstrvec_t_addressof(*args)
    qstrvec_t_addressof(_self, idx) -> PyObject *
        self: PyObject *
        idx: size_t

Help on function qstrvec_t_assign in module ida_pro:

qstrvec_t_assign(*args)
    qstrvec_t_assign(_self, other) -> bool
        self: PyObject *
        other: PyObject *

Help on function qstrvec_t_clear in module ida_pro:

qstrvec_t_clear(*args)
    qstrvec_t_clear(_self, qclear) -> bool
        self: PyObject *
        qclear: bool

Help on function qstrvec_t_create in module ida_pro:

qstrvec_t_create(*args)
    qstrvec_t_create() -> PyObject *

Help on function qstrvec_t_destroy in module ida_pro:

qstrvec_t_destroy(*args)
    qstrvec_t_destroy(py_obj) -> bool
        py_obj: PyObject *

Help on function qstrvec_t_from_list in module ida_pro:

qstrvec_t_from_list(*args)
    qstrvec_t_from_list(_self, py_list) -> bool
        self: PyObject *
        py_list: PyObject *

Help on function qstrvec_t_get in module ida_pro:

qstrvec_t_get(*args)
    qstrvec_t_get(_self, idx) -> PyObject *
        self: PyObject *
        idx: size_t

Help on function qstrvec_t_get_clink in module ida_pro:

qstrvec_t_get_clink(*args)
    qstrvec_t_get_clink(_self) -> qstrvec_t *
        self: PyObject *

Help on function qstrvec_t_get_clink_ptr in module ida_pro:

qstrvec_t_get_clink_ptr(*args)
    qstrvec_t_get_clink_ptr(_self) -> PyObject *
        self: PyObject *

Help on function qstrvec_t_insert in module ida_pro:

qstrvec_t_insert(*args)
    qstrvec_t_insert(_self, idx, s) -> bool
        self: PyObject *
        idx: size_t
        s: char const *

Help on function qstrvec_t_remove in module ida_pro:

qstrvec_t_remove(*args)
    qstrvec_t_remove(_self, idx) -> bool
        self: PyObject *
        idx: size_t

Help on function qstrvec_t_set in module ida_pro:

qstrvec_t_set(*args)
    qstrvec_t_set(_self, idx, s) -> bool
        self: PyObject *
        idx: size_t
        s: char const *

Help on function qstrvec_t_size in module ida_pro:

qstrvec_t_size(*args)
    qstrvec_t_size(_self) -> size_t
        self: PyObject *

Help on function qthread_equal in module ida_pro:

qthread_equal(*args)
    Are two threads equal?
    
    qthread_equal(q1, q2) -> bool
        @param q1 (C++: qthread_t)
        @param q2 (C++: qthread_t)

Help on function quote_cmdline_arg in module ida_pro:

quote_cmdline_arg(*args)
    Quote a command line argument if it contains escape characters. For
    example, *.c will be converted into "*.c" because * may be
    inadvertently expanded by the shell
    
    quote_cmdline_arg(arg) -> bool
        @param arg (C++: qstring  *)
        @return: true: modified 'arg'

Help on function qvector_reserve in module ida_pro:

qvector_reserve(*args)
    Change capacity of given qvector.
    
    qvector_reserve(vec, old, cnt, elsize) -> void *
        @param vec: a pointer to a qvector (C++: void *)
        @param old: a pointer to the qvector's array (C++: void *)
        @param cnt: number of elements to reserve (C++: size_t)
        @param elsize: size of each element (C++: size_t)
        @return: a pointer to the newly allocated array

Help on function readbytes in module ida_pro:

readbytes(*args)
    Read at most 4 bytes from file.
    
    readbytes(h, res, size, mf) -> int
        @param h: file handle (C++: int)
        @param res: value read from file (C++: uint32  *)
        @param size: size of value in bytes (1,2,4) (C++: int)
        @param mf: is MSB first? (C++: bool)
        @return: 0 on success, nonzero otherwise

Help on function reloc_value in module ida_pro:

reloc_value(*args)
    reloc_value(value, size, delta, mf)
        @param value (C++: void *)
        @param size (C++: int)
        @param delta (C++: adiff_t)
        @param mf (C++: bool)

Help on function relocate_relobj in module ida_pro:

relocate_relobj(*args)
    relocate_relobj(_relobj, ea, mf) -> bool
        @param _relobj (C++: struct  relobj_t  *)
        @param ea (C++: ea_t)
        @param mf (C++: bool)

Help on class sel_array in module ida_pro:

class sel_array(__builtin__.object)
 |  Proxy of C++ sel_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, index) -> sel_t
 |          index: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> sel_array
 |          nelements: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, index, value)
 |          index: size_t
 |          value: sel_t
 |  
 |  cast(self, *args)
 |      cast(self) -> sel_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args)
 |      frompointer(t) -> sel_array
 |          t: sel_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_sel_array>
 |      delete_sel_array(self)

Help on function sel_array_frompointer in module ida_pro:

sel_array_frompointer(*args)
    sel_array_frompointer(t) -> sel_array
        t: sel_t *

Help on class sel_pointer in module ida_pro:

class sel_pointer(__builtin__.object)
 |  Proxy of C++ sel_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sel_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  assign(self, *args)
 |      assign(self, value)
 |          value: sel_t
 |  
 |  cast(self, *args)
 |      cast(self) -> sel_t *
 |  
 |  value(self, *args)
 |      value(self) -> sel_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args)
 |      frompointer(t) -> sel_pointer
 |          t: sel_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_sel_pointer>
 |      delete_sel_pointer(self)

Help on function sel_pointer_frompointer in module ida_pro:

sel_pointer_frompointer(*args)
    sel_pointer_frompointer(t) -> sel_pointer
        t: sel_t *

Help on function set_bits in module ida_pro:

set_bits(*args)
    Set bits between [low, high) in 'bitmap'.
    
    set_bits(bitmap, low, high)
        @param bitmap (C++: uchar  *)
        @param low (C++: size_t)
        @param high (C++: size_t)

Help on class sizevec_t in module ida_pro:

class sizevec_t(__builtin__.object)
 |  Proxy of C++ qvector< size_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< size_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> size_t const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sizevec_t
 |          x: qvector< size_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< size_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: size_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: size_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: size_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> size_t const &
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< size_t >::iterator
 |      begin(self) -> qvector< size_t >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< size_t >::iterator
 |      end(self) -> qvector< size_t >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< size_t >::iterator
 |          it: qvector< size_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< size_t >::iterator
 |          first: qvector< size_t >::iterator
 |          last: qvector< size_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> size_t *
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< size_t >::iterator
 |          x: size_t const &
 |      
 |      
 |      find(self, x) -> qvector< size_t >::const_iterator
 |          x: size_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=size_t())
 |          x: size_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: size_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: size_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< size_t >::iterator
 |          it: qvector< size_t >::iterator
 |          x: size_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: size_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: size_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< size_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_sizevec_t>
 |      delete_sizevec_t(self)

Help on function str2user in module ida_pro:

str2user(*args)
    str2user(str) -> PyObject *
    Insert C-style escape characters to string
    
    @return: new string with escape characters inserted

Help on class strvec_t in module ida_pro:

class strvec_t(__builtin__.object)
 |  Proxy of C++ qvector< simpleline_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> simpleline_t const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strvec_t
 |          x: qvector< simpleline_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: simpleline_t const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< simpleline_t >::iterator
 |      begin(self) -> qvector< simpleline_t >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< simpleline_t >::iterator
 |      end(self) -> qvector< simpleline_t >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< simpleline_t >::iterator
 |          it: qvector< simpleline_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< simpleline_t >::iterator
 |          first: qvector< simpleline_t >::iterator
 |          last: qvector< simpleline_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> simpleline_t *
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=simpleline_t())
 |          x: simpleline_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: simpleline_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< simpleline_t >::iterator
 |          it: qvector< simpleline_t >::iterator
 |          x: simpleline_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: simpleline_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: simpleline_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< simpleline_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_strvec_t>
 |      delete_strvec_t(self)

Help on class sval_pointer in module ida_pro:

class sval_pointer(__builtin__.object)
 |  Proxy of C++ sval_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sval_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  assign(self, *args)
 |      assign(self, value)
 |          value: sval_t
 |  
 |  cast(self, *args)
 |      cast(self) -> sval_t *
 |  
 |  value(self, *args)
 |      value(self) -> sval_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args)
 |      frompointer(t) -> sval_pointer
 |          t: sval_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_sval_pointer>
 |      delete_sval_pointer(self)

Help on function sval_pointer_frompointer in module ida_pro:

sval_pointer_frompointer(*args)
    sval_pointer_frompointer(t) -> sval_pointer
        t: sval_t *

Help on class tid_array in module ida_pro:

class tid_array(__builtin__.object)
 |  Proxy of C++ tid_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, index) -> tid_t
 |          index: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> tid_array
 |          nelements: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, index, value)
 |          index: size_t
 |          value: tid_t
 |  
 |  cast(self, *args)
 |      cast(self) -> tid_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args)
 |      frompointer(t) -> tid_array
 |          t: tid_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_tid_array>
 |      delete_tid_array(self)

Help on function tid_array_frompointer in module ida_pro:

tid_array_frompointer(*args)
    tid_array_frompointer(t) -> tid_array
        t: tid_t *

Help on class uchar_array in module ida_pro:

class uchar_array(__builtin__.object)
 |  Proxy of C++ uchar_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, index) -> uchar
 |          index: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> uchar_array
 |          nelements: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, index, value)
 |          index: size_t
 |          value: uchar
 |  
 |  cast(self, *args)
 |      cast(self) -> uchar *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args)
 |      frompointer(t) -> uchar_array
 |          t: uchar *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_uchar_array>
 |      delete_uchar_array(self)

Help on function uchar_array_frompointer in module ida_pro:

uchar_array_frompointer(*args)
    uchar_array_frompointer(t) -> uchar_array
        t: uchar *

Help on class ulonglongvec_t in module ida_pro:

class ulonglongvec_t(__builtin__.object)
 |  Proxy of C++ qvector< unsigned long long > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< unsigned long long > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> unsigned long long const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ulonglongvec_t
 |          x: qvector< unsigned long long > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< unsigned long long > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: unsigned long long const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: unsigned long long const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: unsigned long long const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< unsigned long long >::iterator
 |      begin(self) -> qvector< unsigned long long >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< unsigned long long >::iterator
 |      end(self) -> qvector< unsigned long long >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< unsigned long long >::iterator
 |          it: qvector< unsigned long long >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< unsigned long long >::iterator
 |          first: qvector< unsigned long long >::iterator
 |          last: qvector< unsigned long long >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> unsigned long long *
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< unsigned long long >::iterator
 |          x: unsigned long long const &
 |      
 |      
 |      find(self, x) -> qvector< unsigned long long >::const_iterator
 |          x: unsigned long long const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: unsigned long long const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: unsigned long long *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< unsigned long long >::iterator
 |          it: qvector< unsigned long long >::iterator
 |          x: unsigned long long const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: unsigned long long const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: unsigned long long const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< unsigned long long > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ulonglongvec_t>
 |      delete_ulonglongvec_t(self)

Help on class uintvec_t in module ida_pro:

class uintvec_t(__builtin__.object)
 |  Proxy of C++ qvector< unsigned int > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< unsigned int > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> unsigned int const &
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> uintvec_t
 |          x: qvector< unsigned int > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< unsigned int > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: unsigned int const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: unsigned int const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: unsigned int const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< unsigned int >::iterator
 |      begin(self) -> qvector< unsigned int >::const_iterator
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< unsigned int >::iterator
 |      end(self) -> qvector< unsigned int >::const_iterator
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< unsigned int >::iterator
 |          it: qvector< unsigned int >::iterator
 |      
 |      
 |      erase(self, first, last) -> qvector< unsigned int >::iterator
 |          first: qvector< unsigned int >::iterator
 |          last: qvector< unsigned int >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> unsigned int *
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< unsigned int >::iterator
 |          x: unsigned int const &
 |      
 |      
 |      find(self, x) -> qvector< unsigned int >::const_iterator
 |          x: unsigned int const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: unsigned int const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: unsigned int *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< unsigned int >::iterator
 |          it: qvector< unsigned int >::iterator
 |          x: unsigned int const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: unsigned int const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: unsigned int const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< unsigned int > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_uintvec_t>
 |      delete_uintvec_t(self)

Help on class uval_array in module ida_pro:

class uval_array(__builtin__.object)
 |  Proxy of C++ uval_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, index) -> uval_t
 |          index: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> uval_array
 |          nelements: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, index, value)
 |          index: size_t
 |          value: uval_t
 |  
 |  cast(self, *args)
 |      cast(self) -> uval_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args)
 |      frompointer(t) -> uval_array
 |          t: uval_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_uval_array>
 |      delete_uval_array(self)

Help on function uval_array_frompointer in module ida_pro:

uval_array_frompointer(*args)
    uval_array_frompointer(t) -> uval_array
        t: uval_t *

Help on function writebytes in module ida_pro:

writebytes(*args)
    Write at most 4 bytes to file.
    
    writebytes(h, l, size, mf) -> int
        @param h: file handle (C++: int)
        @param l: value to write (C++: uint32)
        @param size: size of value in bytes (1,2,4) (C++: int)
        @param mf: is MSB first? (C++: bool)
        @return: 0 on success, nonzero otherwise

=== ida_pro EPYDOC INJECTIONS ===
ida_pro.CP_UTF16
"""
UTF-16 codepage.
"""

ida_pro.IDA_SDK_VERSION
"""
IDA SDK v7.5.
"""

ida_pro.IDBDEC_ESCAPE
"""
convert non-printable characters to C escapes (, \\xNN, \\uNNNN)
"""

ida_pro.IOREDIR_APPEND
"""
append, do not overwrite the output file
"""

ida_pro.IOREDIR_INPUT
"""
input redirection
"""

ida_pro.IOREDIR_OUTPUT
"""
output redirection
"""

ida_pro.IOREDIR_QUOTED
"""
the file name was quoted
"""

ida_pro.MAXSTR
"""
maximum string size
"""

ida_pro.SUBSTCHAR
"""
default char, used if a char cannot be represented in a codepage
"""

ida_pro.__MF__
"""
byte sex of our platform (Most significant byte First). 0: little
endian (Intel 80x86). 1: big endian (PowerPC).
"""
=== ida_pro EPYDOC INJECTIONS END ===
Help on function forget_problem in module ida_problems:

forget_problem(*args)
    Remove an address from a problem list
    
    forget_problem(type, ea) -> bool
        @param type: problem list type (C++: problist_id_t)
        @param ea: linear address (C++: ea_t)
        @return: success

Help on function get_problem in module ida_problems:

get_problem(*args)
    Get an address from the specified problem list. The address is not
    removed from the list.
    
    get_problem(type, lowea) -> ea_t
        @param type: problem list type (C++: problist_id_t)
        @param lowea: the returned address will be higher or equal than the
                      specified address (C++: ea_t)
        @return: linear address or  BADADDR

Help on function get_problem_desc in module ida_problems:

get_problem_desc(*args)
    Get the human-friendly description of the problem, if one was provided
    to remember_problem.
    
    get_problem_desc(t, ea) -> str
        @param t: problem list type. (C++: problist_id_t)
        @param ea: linear address. (C++: ea_t)
        @return: the message length or -1 if none

Help on function get_problem_name in module ida_problems:

get_problem_name(*args)
    Get problem list description.
    
    get_problem_name(type, longname=True) -> char const *
        @param type (C++: problist_id_t)
        @param longname (C++: bool)

Help on function is_problem_present in module ida_problems:

is_problem_present(*args)
    Check if the specified address is present in the problem list.
    
    is_problem_present(t, ea) -> bool
        @param t (C++: problist_id_t)
        @param ea (C++: ea_t)

Help on function remember_problem in module ida_problems:

remember_problem(*args)
    Insert an address to a list of problems. Display a message saying
    about the problem (except of 'PR_ATTN' , 'PR_FINAL' ) 'PR_JUMP' is
    temporarily ignored.
    
    remember_problem(type, ea, msg=None)
        @param type: problem list type (C++: problist_id_t)
        @param ea: linear address (C++: ea_t)
        @param msg: a user-friendly message to be displayed instead of the
                    default more generic one associated with the type of
                    problem. Defaults to NULL. (C++: const char *)

Help on function was_ida_decision in module ida_problems:

was_ida_decision(*args)
    was_ida_decision(ea) -> bool
        @param ea (C++: ea_t)

Help on class array_of_rangesets in module ida_range:

class array_of_rangesets(__builtin__.object)
 |  Proxy of C++ qvector< rangeset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< rangeset_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> rangeset_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_of_rangesets
 |          x: qvector< rangeset_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< rangeset_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: rangeset_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: rangeset_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: rangeset_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> rangeset_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> rangeset_t
 |      begin(self) -> rangeset_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> rangeset_t
 |      end(self) -> rangeset_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> rangeset_t
 |          it: qvector< rangeset_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> rangeset_t
 |          first: qvector< rangeset_t >::iterator
 |          last: qvector< rangeset_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> rangeset_t
 |  
 |  find(self, *args)
 |      find(self, x) -> rangeset_t
 |          x: rangeset_t const &
 |      
 |      
 |      find(self, x) -> rangeset_t
 |          x: rangeset_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=rangeset_t())
 |          x: rangeset_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: rangeset_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: rangeset_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> rangeset_t
 |          it: qvector< rangeset_t >::iterator
 |          x: rangeset_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: rangeset_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: rangeset_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< rangeset_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_array_of_rangesets>
 |      delete_array_of_rangesets(self)

Help on class range_t in module ida_range:

class range_t(__builtin__.object)
 |  Proxy of C++ range_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> range_t
 |          ea1: ea_t
 |          ea2: ea_t
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self) -> size_t
 |  
 |  clear(self, *args)
 |      Set 'start_ea' , 'end_ea' to 0.
 |  
 |  compare(self, *args)
 |      Compare two 'range_t' instances, based on the start_ea.
 |      
 |      compare(self, r) -> int
 |          @param r (C++: const  range_t  &)
 |  
 |  contains(self, *args)
 |      Is 'ea' in the address range?
 |      
 |      contains(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |      
 |      
 |      contains(self, r) -> bool
 |          r: range_t const &
 |  
 |  empty(self, *args)
 |      Is the size of the 'range_t' <= 0?
 |  
 |  extend(self, *args)
 |      Ensure that the 'range_t' includes 'ea'.
 |      
 |      extend(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  intersect(self, *args)
 |      Assign the 'range_t' to the intersection between the 'range_t' and
 |      'r'.
 |      
 |      intersect(self, r)
 |          @param r (C++: const  range_t  &)
 |  
 |  overlaps(self, *args)
 |      Is there an ea in 'r' that is also in this 'range_t' ?
 |      
 |      overlaps(self, r) -> bool
 |          @param r (C++: const  range_t  &)
 |  
 |  size(self, *args)
 |      Get 'end_ea' - 'start_ea' .
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_range_t>
 |      delete_range_t(self)

Help on function range_t_print in module ida_range:

range_t_print(*args)
    Helper function. Should not be called directly!
    
    range_t_print(cb) -> str
        cb: range_t const *

Help on class rangeset_t in module ida_range:

class rangeset_t(__builtin__.object)
 |  Proxy of C++ rangeset_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, aset) -> bool
 |          aset: rangeset_t const &
 |  
 |  __getitem__(self, idx)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rangeset_t
 |          range: range_t const &
 |      
 |      
 |      __init__(self, ivs) -> rangeset_t
 |          ivs: rangeset_t const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = nranges(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, aset) -> bool
 |          aset: rangeset_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self) -> size_t
 |  
 |  add(self, *args)
 |      Add an address range to the set. If 'range' intersects an existing
 |      element e, then e is extended to include 'range', and any superfluous
 |      elements (subsets of e) are removed.
 |      
 |      add(self, range) -> bool
 |          @param range: address range to add. cannot be empty (C++: const
 |                        range_t  &)
 |          @return: false if no elements were added (the set was unchanged)
 |      
 |      
 |      add(self, start, _end) -> bool
 |          start: ea_t
 |          _end: ea_t
 |          @return: false if no elements were added (the set was unchanged)
 |      
 |      
 |      add(self, aset) -> bool
 |          aset: rangeset_t const &
 |          @return: false if no elements were added (the set was unchanged)
 |  
 |  begin(self, *args)
 |      Get an iterator that points to the first element in the set.
 |  
 |  cached_range(self, *args)
 |      When searching the rangeset, we keep a cached element to help speed up
 |      searches.
 |  
 |  clear(self, *args)
 |      Delete all elements from the set. See 'qvector::clear()'
 |  
 |  contains(self, *args)
 |      Does an element of the rangeset contain 'ea'? See
 |      range_t::contains(ea_t)
 |      
 |      contains(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |      
 |      
 |      contains(self, aset) -> bool
 |          aset: rangeset_t const &
 |  
 |  empty(self, *args)
 |      Does the set have zero elements.
 |  
 |  end(self, *args)
 |      Get an iterator that points to the end of the set. (This is NOT the
 |      last element)
 |  
 |  find_range(self, *args)
 |      Get the element from the set that contains 'ea'.
 |      
 |      find_range(self, ea) -> range_t
 |          @param ea (C++: ea_t)
 |          @return: NULL if there is no such element
 |  
 |  getrange(self, *args)
 |      Get the 'range_t' at index 'idx'.
 |      
 |      getrange(self, idx) -> range_t
 |          @param idx (C++: int)
 |  
 |  has_common(self, *args)
 |      Is there an ea in 'range' that is also in the rangeset?
 |      
 |      has_common(self, range) -> bool
 |          @param range (C++: const  range_t  &)
 |      
 |      
 |      has_common(self, aset) -> bool
 |          aset: rangeset_t const &
 |  
 |  includes(self, *args)
 |      Is every ea in 'range' contained in the rangeset?
 |      
 |      includes(self, range) -> bool
 |          @param range (C++: const  range_t  &)
 |  
 |  intersect(self, *args)
 |      Set the rangeset to its intersection with 'aset'.
 |      
 |      intersect(self, aset) -> bool
 |          @param aset (C++: const  rangeset_t  &)
 |          @return: false if the set was unchanged
 |  
 |  is_equal(self, *args)
 |      Do this rangeset and 'aset' have identical elements?
 |      
 |      is_equal(self, aset) -> bool
 |          @param aset (C++: const  rangeset_t  &)
 |  
 |  is_subset_of(self, *args)
 |      Is every element in the rangeset contained in an element of 'aset'?
 |      
 |      is_subset_of(self, aset) -> bool
 |          @param aset (C++: const  rangeset_t  &)
 |  
 |  lastrange(self, *args)
 |      Get the last 'range_t' in the set.
 |  
 |  next_addr(self, *args)
 |      Get the smallest ea_t value greater than 'ea' contained in the
 |      rangeset.
 |      
 |      next_addr(self, ea) -> ea_t
 |          @param ea (C++: ea_t)
 |  
 |  next_range(self, *args)
 |      Get the smallest ea_t value greater than 'ea' that is not in the same
 |      range as 'ea'.
 |      
 |      next_range(self, ea) -> ea_t
 |          @param ea (C++: ea_t)
 |  
 |  nranges(self, *args)
 |      Get the number of 'range_t' elements in the set.
 |  
 |  prev_addr(self, *args)
 |      Get the largest ea_t value less than 'ea' contained in the rangeset.
 |      
 |      prev_addr(self, ea) -> ea_t
 |          @param ea (C++: ea_t)
 |  
 |  prev_range(self, *args)
 |      Get the largest ea_t value less than 'ea' that is not in the same
 |      range as 'ea'.
 |      
 |      prev_range(self, ea) -> ea_t
 |          @param ea (C++: ea_t)
 |  
 |  sub(self, *args)
 |      Subtract an address range from the set. All subsets of 'range' will be
 |      removed, and all elements that intersect 'range' will be
 |      truncated/split so they do not include 'range'.
 |      
 |      sub(self, range) -> bool
 |          @param range: address range to subtract. cannot be empty. (C++: const
 |                        range_t  &)
 |          @return: false if nothing was subtracted (the set was unchanged)
 |      
 |      
 |      sub(self, ea) -> bool
 |          ea: ea_t
 |          @return: false if nothing was subtracted (the set was unchanged)
 |      
 |      
 |      sub(self, aset) -> bool
 |          aset: rangeset_t const &
 |          @return: false if nothing was subtracted (the set was unchanged)
 |  
 |  swap(self, *args)
 |      Set this = 'r' and 'r' = this. See 'qvector::swap()'
 |      
 |      swap(self, r)
 |          @param r (C++: rangeset_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_rangeset_t>
 |      delete_rangeset_t(self)

Help on class rangevec_base_t in module ida_range:

class rangevec_base_t(__builtin__.object)
 |  Proxy of C++ qvector< range_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> range_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rangevec_base_t
 |          x: qvector< range_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: range_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: range_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: range_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> range_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> range_t
 |          it: qvector< range_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> range_t
 |          first: qvector< range_t >::iterator
 |          last: qvector< range_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> range_t
 |  
 |  find(self, *args)
 |      find(self, x) -> range_t
 |          x: range_t const &
 |      
 |      
 |      find(self, x) -> range_t
 |          x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=range_t())
 |          x: range_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: range_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: range_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> range_t
 |          it: qvector< range_t >::iterator
 |          x: range_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: range_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: range_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< range_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_rangevec_base_t>
 |      delete_rangevec_base_t(self)

Help on class rangevec_t in module ida_range:

class rangevec_t(rangevec_base_t)
 |  Proxy of C++ rangevec_t class.
 |  
 |  Method resolution order:
 |      rangevec_t
 |      rangevec_base_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rangevec_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_rangevec_t>
 |      delete_rangevec_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from rangevec_base_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> range_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: range_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: range_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: range_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> range_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> range_t
 |          it: qvector< range_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> range_t
 |          first: qvector< range_t >::iterator
 |          last: qvector< range_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> range_t
 |  
 |  find(self, *args)
 |      find(self, x) -> range_t
 |          x: range_t const &
 |      
 |      
 |      find(self, x) -> range_t
 |          x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=range_t())
 |          x: range_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: range_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: range_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> range_t
 |          it: qvector< range_t >::iterator
 |          x: range_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: range_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: range_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< range_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function reg_data_type in module ida_registry:

reg_data_type(*args)
    Get data type of a given value.
    
    reg_data_type(name, subkey=None) -> regval_type_t
        @param name: value name (C++: const char *)
        @param subkey: key name (C++: const char *)
        @return: false if the [key+]value doesn't exist

Help on function reg_delete in module ida_registry:

reg_delete(*args)
    Delete a value from the registry.
    
    reg_delete(name, subkey=None) -> bool
        @param name: value name (C++: const char *)
        @param subkey: parent key (C++: const char *)
        @return: success

Help on function reg_delete_subkey in module ida_registry:

reg_delete_subkey(*args)
    Delete a key from the registry.
    
    reg_delete_subkey(name) -> bool
        @param name (C++: const char *)

Help on function reg_delete_tree in module ida_registry:

reg_delete_tree(*args)
    Delete a subtree from the registry.
    
    reg_delete_tree(name) -> bool
        @param name (C++: const char *)

Help on function reg_exists in module ida_registry:

reg_exists(*args)
    Is there already a value with the given name?
    
    reg_exists(name, subkey=None) -> bool
        @param name: value name (C++: const char *)
        @param subkey: parent key (C++: const char *)

Help on function reg_flush in module ida_registry:

reg_flush(*args)
    reg_flush()

Help on function reg_load in module ida_registry:

reg_load(*args)
    reg_load()

Help on function reg_read_binary in module ida_registry:

reg_read_binary(*args)
    Read binary data from the registry.
    
    reg_read_binary(name, subkey=None) -> PyObject *
        @param name: value name (C++: const char *)
        @param subkey: key name (C++: const char *)
        @return: success

Help on function reg_read_bool in module ida_registry:

reg_read_bool(*args)
    Read boolean value from the registry.
    
    reg_read_bool(name, defval, subkey=None) -> bool
        @param name: value name (C++: const char *)
        @param defval: default value (C++: bool)
        @param subkey: key name (C++: const char *)
        @return: boolean read from registry, or 'defval' if the read failed

Help on function reg_read_int in module ida_registry:

reg_read_int(*args)
    Read integer value from the registry.
    
    reg_read_int(name, defval, subkey=None) -> int
        @param name: value name (C++: const char *)
        @param defval: default value (C++: int)
        @param subkey: key name (C++: const char *)
        @return: the value read from the registry, or 'defval' if the read
                 failed

Help on function reg_read_string in module ida_registry:

reg_read_string(*args)
    Read a string from the registry.
    
    reg_read_string(name, subkey=None, _def=None) -> PyObject *
        @param name: value name (C++: const char *)
        @param subkey: key name (C++: const char *)
        def: char const *
        @return: success

Help on function reg_read_strlist in module ida_registry:

reg_read_strlist(*args)
    Retrieve all string values associated with the given key. Also see
    'reg_update_strlist()' .
    
    reg_read_strlist(subkey)
        @param subkey (C++: const char *)

Help on function reg_subkey_exists in module ida_registry:

reg_subkey_exists(*args)
    Is there already a key with the given name?
    
    reg_subkey_exists(name) -> bool
        @param name (C++: const char *)

Help on function reg_subkey_subkeys in module ida_registry:

reg_subkey_subkeys(*args)
    Get all subkey names of given key.
    
    reg_subkey_subkeys(name) -> PyObject *
        @param name (C++: const char *)

Help on function reg_subkey_values in module ida_registry:

reg_subkey_values(*args)
    Get all value names under given key.
    
    reg_subkey_values(name) -> PyObject *
        @param name (C++: const char *)

Help on function reg_update_filestrlist in module ida_registry:

reg_update_filestrlist(*args)
    Update registry with a file list. Case sensitivity will vary depending
    on the target OS.'add' and 'rem' must be UTF-8, just like for regular
    string operations.
    
    reg_update_filestrlist(subkey, add, maxrecs, rem=None)
        @param subkey (C++: const char *)
        @param add (C++: const char *)
        @param maxrecs (C++: size_t)
        @param rem (C++: const char *)

Help on function reg_update_strlist in module ida_registry:

reg_update_strlist(*args)
    Update list of strings associated with given key.
    
    reg_update_strlist(subkey, add, maxrecs, rem=None, ignorecase=False)
        @param subkey: key name (C++: const char *)
        @param add: string to be added to list, can be NULL (C++: const char
                    *)
        @param maxrecs: limit list to this size (C++: size_t)
        @param rem: string to be removed from list, can be NULL (C++: const
                    char *)
        @param ignorecase: ignore case for 'add' and 'rem' (C++: bool)

Help on function reg_write_binary in module ida_registry:

reg_write_binary(*args)
    Write binary data to the registry.
    
    reg_write_binary(name, py_bytes, subkey=None) -> PyObject *
        @param name: value name (C++: const char *)
        py_bytes: PyObject *
        @param subkey: key name (C++: const char *)

Help on function reg_write_bool in module ida_registry:

reg_write_bool(*args)
    Write boolean value to the registry.
    
    reg_write_bool(name, value, subkey=None)
        @param name: value name (C++: const char *)
        @param value: boolean to write (nonzero = true) (C++: int)
        @param subkey: key name (C++: const char *)

Help on function reg_write_int in module ida_registry:

reg_write_int(*args)
    Write integer value to the registry.
    
    reg_write_int(name, value, subkey=None)
        @param name: value name (C++: const char *)
        @param value: value to write (C++: int)
        @param subkey: key name (C++: const char *)

Help on function reg_write_string in module ida_registry:

reg_write_string(*args)
    Write a string to the registry.
    
    reg_write_string(name, utf8, subkey=None)
        @param name: value name (C++: const char *)
        @param utf8: utf8-encoded string (C++: const char *)
        @param subkey: key name (C++: const char *)

=== ida_registry EPYDOC INJECTIONS ===
ida_registry.ROOT_KEY_NAME
"""
Key used to store IDA settings in registry (Windows version).this name
is automatically prepended to all key names passed to functions in
this file.
"""
=== ida_registry EPYDOC INJECTIONS END ===
Help on function find_binary in module ida_search:

find_binary(*args)
    find_binary(arg1, arg2, arg3, arg4, arg5) -> ea_t
    Deprecated. Please use ida_bytes.bin_search() instead.

Help on function find_code in module ida_search:

find_code(*args)
    Find next code address.
    
    find_code(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_data in module ida_search:

find_data(*args)
    Find next data address.
    
    find_data(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_defined in module ida_search:

find_defined(*args)
    Find next ea that is the start of an instruction or data.
    
    find_defined(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_error in module ida_search:

find_error(*args)
    Find next error or problem.
    
    find_error(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_imm in module ida_search:

find_imm(*args)
    Find next immediate operand with the given value.
    
    find_imm(ea, sflag, search_value) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)
        @param search_value (C++: uval_t)

Help on function find_not_func in module ida_search:

find_not_func(*args)
    Find next code address that does not belong to a function.
    
    find_not_func(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_notype in module ida_search:

find_notype(*args)
    Find next operand without any type info.
    
    find_notype(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_reg_access in module ida_search:

find_reg_access(*args)
    Find access to a register.This function does not care about the
    control flow and probes all instructions in the specified range,
    starting from START_EA. Only direct references to registers are
    detected. Function calls and system traps are ignored.
    
    find_reg_access(out, start_ea, end_ea, regname, sflag) -> ea_t
        @param out: pointer to the output buffer. must be non-null. upon
                    success contains info about the found register. upon
                    failed search for a read access out->range contains the
                    info about the non-redefined parts of the register. (C++:
                    struct  reg_access_t  *)
        @param start_ea: starting address (C++: ea_t)
        @param end_ea: ending address. BADADDR means that the end limit is
                       missing. otherwise, if the search direction is
                       SEARCH_UP, END_EA must be lower than START_EA. (C++:
                       ea_t)
        @param regname: the register to search for. (C++: const char *)
        @param sflag: combination of  Search flags  bits. (C++: int)
        @return: the found address. BADADDR if not found or error.

Help on function find_suspop in module ida_search:

find_suspop(*args)
    Find next suspicious operand.
    
    find_suspop(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_text in module ida_search:

find_text(*args)
    See 'search()'
    
    find_text(start_ea, y, x, ustr, sflag) -> ea_t
        @param start_ea (C++: ea_t)
        @param y (C++: int)
        @param x (C++: int)
        @param ustr (C++: const char *)
        @param sflag (C++: int)

Help on function find_unknown in module ida_search:

find_unknown(*args)
    Find next unexplored address.
    
    find_unknown(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function search_down in module ida_search:

search_down(*args)
    Is the 'SEARCH_DOWN' bit set?
    
    search_down(sflag) -> bool
        @param sflag (C++: int)

=== ida_search EPYDOC INJECTIONS ===
ida_search.SEARCH_BRK
"""
return 'BADADDR' if the search was cancelled.
"""

ida_search.SEARCH_CASE
"""
case-sensitive search (case-insensitive otherwise)
"""

ida_search.SEARCH_DEF
"""
find_reg_access: search for a definition (write access)
"""

ida_search.SEARCH_DOWN
"""
search towards higher addresses
"""

ida_search.SEARCH_IDENT
"""
search for an identifier (text search). it means that the characters
before and after the match cannot be is_visible_char().
"""

ida_search.SEARCH_NEXT
"""
skip the starting address when searching. this bit is useful only for
'search()' , 'bin_search2()' , 'find_reg_access()' . find_.. functions
skip the starting address automatically.
"""

ida_search.SEARCH_NOBRK
"""
do not test if the user clicked cancel to interrupt the search
"""

ida_search.SEARCH_NOSHOW
"""
do not display the search progress/refresh screen
"""

ida_search.SEARCH_REGEX
"""
regular expressions in search string (supported only for the text
search)
"""

ida_search.SEARCH_UP
"""
search towards lower addresses
"""

ida_search.SEARCH_USE
"""
find_reg_access: search for a use (read access)
"""
=== ida_search EPYDOC INJECTIONS END ===
Help on function add_segm in module ida_segment:

add_segm(*args)
    Add a new segment, second form. Segment alignment is set to
    'saRelByte' . Segment combination is "public" or "stack" (if segment
    class is "STACK"). Addressing mode of segment is taken as default
    (16bit or 32bit). Default segment registers are set to 'BADSEL' . If a
    segment already exists at the specified range of addresses, this
    segment will be truncated. Instructions and data in the old segment
    will be deleted if the new segment has another addressing mode or
    another segment base address.
    
    add_segm(para, start, end, name, sclass, flags=0) -> bool
        @param para: segment base paragraph. if paragraph can't fit in 16bit,
                     then a new selector is allocated and mapped to the
                     paragraph. (C++: ea_t)
        @param start: start address of the segment. if start== BADADDR  then
                      start <- to_ea(para,0). (C++: ea_t)
        @param end: end address of the segment. end address should be higher
                    than start address. For emulate empty segments, use
                    SEG_NULL  segment type. If the end address is lower than
                    start address, then fail. If end== BADADDR , then a
                    segment up to the next segment will be created (if the
                    next segment doesn't exist, then 1 byte segment will be
                    created). If 'end' is too high and the new segment would
                    overlap the next segment, 'end' is adjusted properly.
                    (C++: ea_t)
        @param name: name of new segment. may be NULL (C++: const char *)
        @param sclass: class of the segment. may be NULL. type of the new
                       segment is modified if class is one of predefined
                       names:   "CODE" ->  SEG_CODE   "DATA" ->  SEG_DATA
                       "CONST" ->  SEG_DATA   "STACK" ->  SEG_BSS   "BSS" ->
                       SEG_BSS   "XTRN" ->  SEG_XTRN   "COMM" ->  SEG_COMM
                       "ABS" ->  SEG_ABSSYM (C++: const char *)
        @param flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, a warning message is displayed

Help on function add_segm_ex in module ida_segment:

add_segm_ex(*args)
    Add a new segment. If a segment already exists at the specified range
    of addresses, this segment will be truncated. Instructions and data in
    the old segment will be deleted if the new segment has another
    addressing mode or another segment base address.
    
    add_segm_ex(s, name, sclass, flags) -> bool
        @param s: pointer to filled segment structure. segment
                          selector should have proper mapping (see
                          set_selector() ).   if s.start_ea== BADADDR  then
                          s.start_ea <- get_segm_base(&s)   if s.end_ea==
                          BADADDR , then a segment up to the next segment will
                          be created (if the next segment doesn't exist, then
                          1 byte segment will be created).   if the s.end_ea <
                          s.start_ea, then fail.   if s.end_ea is too high and
                          the new segment would overlap the next segment,
                          s.end_ea is adjusted properly. (C++: segment_t  *)
        @param name: name of new segment. may be NULL. if specified, the
                     segment is immediately renamed (C++: const char *)
        @param sclass: class of the segment. may be NULL. if specified, the
                       segment class is immediately changed (C++: const char
                       *)
        @param flags: Add segment flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, a warning message is displayed

Help on function add_segment_translation in module ida_segment:

add_segment_translation(*args)
    Add segment translation.
    
    add_segment_translation(segstart, mappedseg) -> bool
        @param segstart: start address of the segment to add translation to
                         (C++: ea_t)
        @param mappedseg: start address of the overlayed segment (C++: ea_t)
        @retval: 1 - ok
        @retval: 0 - too many translations or bad segstart

Help on function allocate_selector in module ida_segment:

allocate_selector(*args)
    Allocate a selector for a segment unconditionally. You must call this
    function before calling 'add_segm_ex()' . 'add_segm()' calls this
    function itself, so you don't need to allocate a selector. This
    function will allocate a new free selector and setup its mapping using
    'find_free_selector()' and 'set_selector()' functions.
    
    allocate_selector(segbase) -> sel_t
        @param segbase: a new segment base paragraph (C++: ea_t)
        @return: the allocated selector number

Help on function change_segment_status in module ida_segment:

change_segment_status(*args)
    Convert a debugger segment to a regular segment and vice versa. When
    converting debug->regular, the memory contents will be copied to the
    database.
    
    change_segment_status(s, is_deb_segm) -> int
        @param s: segment to modify (C++: segment_t  *)
        @param is_deb_segm: new status of the segment (C++: bool)
        @return: Change segment status result codes

Help on function del_segm in module ida_segment:

del_segm(*args)
    Delete a segment.
    
    del_segm(ea, flags) -> bool
        @param ea: any address belonging to the segment (C++: ea_t)
        @param flags: Segment modification flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, no segment at 'ea'.

Help on function del_segment_translations in module ida_segment:

del_segment_translations(*args)
    Delete the translation list
    
    del_segment_translations(segstart)
        @param segstart: start address of the segment to delete translation
                         list (C++: ea_t)

Help on function del_selector in module ida_segment:

del_selector(*args)
    Delete mapping of a selector. Be wary of deleting selectors that are
    being used in the program, this can make a mess in the segments.
    
    del_selector(selector)
        @param selector: number of selector to remove from the translation
                         table (C++: sel_t)

Help on function find_free_selector in module ida_segment:

find_free_selector(*args)
    Find first unused selector.

Help on function find_selector in module ida_segment:

find_selector(*args)
    Find a selector that has mapping to the specified paragraph.
    
    find_selector(base) -> sel_t
        @param base: paragraph to search in the translation table (C++: ea_t)
        @return: selector value or base

Help on function get_defsr in module ida_segment:

get_defsr(*args)
    get_defsr(s, reg) -> sel_t
        s: segment_t *
        reg: int

Help on function get_first_seg in module ida_segment:

get_first_seg(*args)
    Get pointer to the first segment.

Help on function get_group_selector in module ida_segment:

get_group_selector(*args)
    Get common selector for a group of segments.
    
    get_group_selector(grpsel) -> sel_t
        @param grpsel: selector of group segment (C++: sel_t)
        @return: common selector of the group or 'grpsel' if no such group is
                 found

Help on function get_last_seg in module ida_segment:

get_last_seg(*args)
    Get pointer to the last segment.

Help on function get_next_seg in module ida_segment:

get_next_seg(*args)
    Get pointer to the next segment.
    
    get_next_seg(ea) -> segment_t
        @param ea (C++: ea_t)

Help on function get_prev_seg in module ida_segment:

get_prev_seg(*args)
    Get pointer to the previous segment.
    
    get_prev_seg(ea) -> segment_t
        @param ea (C++: ea_t)

Help on function get_segm_base in module ida_segment:

get_segm_base(*args)
    Get segment base linear address. Segment base linear address is used
    to calculate virtual addresses. The virtual address of the first byte
    of the segment will be (start address of segment - segment base linear
    address)
    
    get_segm_base(s) -> ea_t
        @param s: pointer to segment (C++: const  segment_t  *)
        @return: 0 if s == NULL, otherwise segment base linear address

Help on function get_segm_by_name in module ida_segment:

get_segm_by_name(*args)
    Get pointer to segment by its name. If there are several segments with
    the same name, returns the first of them.
    
    get_segm_by_name(name) -> segment_t
        @param name: segment name. may be NULL. (C++: const char *)
        @return: NULL or pointer to segment structure

Help on function get_segm_by_sel in module ida_segment:

get_segm_by_sel(*args)
    Get pointer to segment structure. This function finds a segment by its
    selector. If there are several segments with the same selectors, the
    last one will be returned.
    
    get_segm_by_sel(selector) -> segment_t
        @param selector: a segment with the specified selector will be
                         returned (C++: sel_t)
        @return: pointer to segment or NULL

Help on function get_segm_class in module ida_segment:

get_segm_class(*args)
    Get segment class. Segment class is arbitrary text (max 8 characters).
    
    get_segm_class(s) -> str
        @param s: pointer to segment (C++: const  segment_t  *)
        @return: size of segment class (-1 if s==NULL or bufsize<=0)

Help on function get_segm_name in module ida_segment:

get_segm_name(*args)
    Get true segment name by pointer to segment.
    
    get_segm_name(s, flags=0) -> str
        @param s: pointer to segment (C++: const  segment_t  *)
        @param flags: 0-return name as is; 1-substitute bad symbols with _ 1
                      corresponds to GN_VISIBLE (C++: int)
        @return: size of segment name (-1 if s==NULL)

Help on function get_segm_num in module ida_segment:

get_segm_num(*args)
    Get number of segment by address.
    
    get_segm_num(ea) -> int
        @param ea: linear address belonging to the segment (C++: ea_t)
        @return: -1 if no segment occupies the specified address. otherwise
                 returns number of the specified segment (0.. get_segm_qty()
                 -1)

Help on function get_segm_para in module ida_segment:

get_segm_para(*args)
    Get segment base paragraph. Segment base paragraph may be converted to
    segment base linear address using 'to_ea()' function. In fact,
    to_ea(get_segm_para(s), 0) == get_segm_base(s).
    
    get_segm_para(s) -> ea_t
        @param s: pointer to segment (C++: const  segment_t  *)
        @return: 0 if s == NULL, the segment base paragraph

Help on function get_segm_qty in module ida_segment:

get_segm_qty(*args)
    Get number of segments.

Help on function get_segment_alignment in module ida_segment:

get_segment_alignment(*args)
    Get text representation of segment alignment code.
    
    get_segment_alignment(align) -> char const *
        @param align (C++: uchar)
        @return: text digestable by IBM PC assembler.

Help on function get_segment_cmt in module ida_segment:

get_segment_cmt(*args)
    Get segment comment.
    
    get_segment_cmt(s, repeatable) -> str
        @param s: pointer to segment structure (C++: const  segment_t  *)
        @param repeatable: 0: get regular comment. 1: get repeatable comment.
                           (C++: bool)
        @return: size of comment or -1

Help on function get_segment_combination in module ida_segment:

get_segment_combination(*args)
    Get text representation of segment combination code.
    
    get_segment_combination(comb) -> char const *
        @param comb (C++: uchar)
        @return: text digestable by IBM PC assembler.

Help on function get_segment_translations in module ida_segment:

get_segment_translations(*args)
    Get segment translation list.
    
    get_segment_translations(transmap, segstart) -> ssize_t
        @param transmap: vector of segment start addresses for the translation
                         list (C++: eavec_t  *)
        @param segstart: start address of the segment to get information about
                         (C++: ea_t)
        @return: -1 if no translation list or bad segstart. otherwise returns
                 size of translation list.

Help on function get_selector_qty in module ida_segment:

get_selector_qty(*args)
    Get number of defined selectors.

Help on function get_visible_segm_name in module ida_segment:

get_visible_segm_name(*args)
    Get segment name by pointer to segment.
    
    get_visible_segm_name(s) -> str
        @param s: pointer to segment (C++: const  segment_t  *)
        @return: size of segment name (-1 if s==NULL)

Help on function getn_selector in module ida_segment:

getn_selector(*args)
    Get description of selector (0.. 'get_selector_qty()' -1)
    
    getn_selector(n) -> bool
        @param n (C++: int)

Help on function getnseg in module ida_segment:

getnseg(*args)
    Get pointer to segment by its number.Obsoleted because it can slow
    down the debugger (it has to refresh the whole memory segmentation to
    calculate the correct answer)
    
    getnseg(n) -> segment_t
        @param n: segment number in the range (0.. get_segm_qty() -1) (C++:
                  int)
        @return: NULL or pointer to segment structure

Help on function getseg in module ida_segment:

getseg(*args)
    Get pointer to segment by linear address.
    
    getseg(ea) -> segment_t
        @param ea: linear address belonging to the segment (C++: ea_t)
        @return: NULL or pointer to segment structure

Help on function is_finally_visible_segm in module ida_segment:

is_finally_visible_segm(*args)
    See 'SFL_HIDDEN' , 'SCF_SHHID_SEGM' .
    
    is_finally_visible_segm(s) -> bool
        @param s (C++: segment_t  *)

Help on function is_miniidb in module ida_segment:

is_miniidb(*args)
    Is the database a miniidb created by the debugger?.

Help on function is_segm_locked in module ida_segment:

is_segm_locked(*args)
    Is a segment pointer locked?
    
    is_segm_locked(segm) -> bool
        @param segm (C++: const  segment_t  *)

Help on function is_spec_ea in module ida_segment:

is_spec_ea(*args)
    Does the address belong to a segment with a special type?. (
    'SEG_XTRN' , 'SEG_GRP' , 'SEG_ABSSYM' , 'SEG_COMM' )
    
    is_spec_ea(ea) -> bool
        @param ea: linear address (C++: ea_t)

Help on function is_spec_segm in module ida_segment:

is_spec_segm(*args)
    Has segment a special type?. ( 'SEG_XTRN' , 'SEG_GRP' , 'SEG_ABSSYM' ,
    'SEG_COMM' )
    
    is_spec_segm(seg_type) -> bool
        @param seg_type (C++: uchar)

Help on function is_visible_segm in module ida_segment:

is_visible_segm(*args)
    See 'SFL_HIDDEN' .
    
    is_visible_segm(s) -> bool
        @param s (C++: segment_t  *)

Help on function lock_segm in module ida_segment:

lock_segm(*args)
    Lock segment pointer Locked pointers are guaranteed to remain valid
    until they are unlocked. Ranges with locked pointers cannot be deleted
    or moved.
    
    lock_segm(segm, lock)
        @param segm (C++: const  segment_t  *)
        @param lock (C++: bool)

Help on class lock_segment in module ida_segment:

class lock_segment(__builtin__.object)
 |  Proxy of C++ lock_segment class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _segm) -> lock_segment
 |          _segm: segment_t const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lock_segment>
 |      delete_lock_segment(self)

Help on function move_segm in module ida_segment:

move_segm(*args)
    Move a segment to a new address. This function moves all information
    to the new address. It fixes up address sensitive information in the
    kernel. The total effect is equal to reloading the segment to the
    target address. For the file format dependent address sensitive
    information, 'loader_t::move_segm' is called. Also IDB notification
    event 'idb_event::segm_moved' is called.
    
    move_segm(s, to, flags=0) -> int
        @param s: segment to move (C++: segment_t  *)
        @param to: new segment start address (C++: ea_t)
        @param flags: Move segment flags (C++: int)
        @return: Move segment result codes

Help on function move_segm_start in module ida_segment:

move_segm_start(*args)
    Move segment start. The main difference between this function and
    'set_segm_start()' is that this function may expand the previous
    segment while 'set_segm_start()' never does it. So, this function
    allows to change bounds of two segments simultaneously. If the
    previous segment and the specified segment have the same addressing
    mode and segment base, then instructions and data are not destroyed -
    they simply move from one segment to another. Otherwise all
    instructions/data which migrate from one segment to another are
    destroyed.this function never disables addresses.
    
    move_segm_start(ea, newstart, mode) -> bool
        @param ea: any address belonging to the segment (C++: ea_t)
        @param newstart: new start address of the segment note that segment
                         start address should be higher than segment base
                         linear address. (C++: ea_t)
        @param mode: policy for destroying defined items   0: if it is
                     necessary to destroy defined items, display a dialog box
                     and ask confirmation   1: if it is necessary to destroy
                     defined items, just destroy them without asking the user
                     -1: if it is necessary to destroy defined items, don't
                     destroy them (i.e. function will fail)   -2: don't
                     destroy defined items (function will succeed) (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, a warning message is displayed

Help on function rebase_program in module ida_segment:

rebase_program(*args)
    Rebase the whole program by 'delta' bytes.
    
    rebase_program(delta, flags) -> int
        @param delta: number of bytes to move the program (C++: adiff_t)
        @param flags: Move segment flags  it is recommended to use
                      MSF_FIXONCE  so that the loader takes care of global
                      variables it stored in the database (C++: int)
        @return: Move segment result codes

Help on function segm_adjust_diff in module ida_segment:

segm_adjust_diff(*args)
    Truncate and sign extend a delta depending on the segment.
    
    segm_adjust_diff(s, delta) -> adiff_t
        @param s (C++: const  segment_t  *)
        @param delta (C++: adiff_t)

Help on function segm_adjust_ea in module ida_segment:

segm_adjust_ea(*args)
    Truncate an address depending on the segment.
    
    segm_adjust_ea(s, ea) -> ea_t
        @param s (C++: const  segment_t  *)
        @param ea (C++: ea_t)

Help on class segment_t in module ida_segment:

class segment_t(ida_range.range_t)
 |  Proxy of C++ segment_t class.
 |  
 |  Method resolution order:
 |      segment_t
 |      ida_range.range_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> segment_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  abits(self, *args)
 |      Get number of address bits.
 |  
 |  abytes(self, *args)
 |      Get number of address bytes.
 |  
 |  clr_comorg(self, *args)
 |      clr_comorg(self)
 |  
 |  clr_ob_ok(self, *args)
 |      clr_ob_ok(self)
 |  
 |  comorg(self, *args)
 |      comorg(self) -> bool
 |  
 |  is_header_segm(self, *args)
 |      is_header_segm(self) -> bool
 |  
 |  is_hidden_segtype(self, *args)
 |      is_hidden_segtype(self) -> bool
 |  
 |  is_loader_segm(self, *args)
 |      is_loader_segm(self) -> bool
 |  
 |  is_visible_segm(self, *args)
 |      is_visible_segm(self) -> bool
 |  
 |  ob_ok(self, *args)
 |      ob_ok(self) -> bool
 |  
 |  set_comorg(self, *args)
 |      set_comorg(self)
 |  
 |  set_debugger_segm(self, *args)
 |      set_debugger_segm(self, debseg)
 |          debseg: bool
 |  
 |  set_header_segm(self, *args)
 |      set_header_segm(self, on)
 |          on: bool
 |  
 |  set_hidden_segtype(self, *args)
 |      set_hidden_segtype(self, hide)
 |          hide: bool
 |  
 |  set_loader_segm(self, *args)
 |      set_loader_segm(self, ldrseg)
 |          ldrseg: bool
 |  
 |  set_ob_ok(self, *args)
 |      set_ob_ok(self)
 |  
 |  set_visible_segm(self, *args)
 |      set_visible_segm(self, visible)
 |          visible: bool
 |  
 |  update(self, *args)
 |      Update segment information. You must call this function after
 |      modification of segment characteristics. Note that not all fields of
 |      segment structure may be modified directly, there are special
 |      functions to modify some fields.
 |  
 |  use32(self, *args)
 |      Use 32 bit segment addressing?
 |  
 |  use64(self, *args)
 |      Use 64 bit segment addressing?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  align
 |      segment_t_align_get(self) -> uchar
 |  
 |  bitness
 |      segment_t_bitness_get(self) -> uchar
 |  
 |  color
 |      segment_t_color_get(self) -> bgcolor_t
 |  
 |  comb
 |      segment_t_comb_get(self) -> uchar
 |  
 |  defsr
 |      segment_t_defsr_get(self) -> sel_t [16]
 |  
 |  end_ea
 |      segment_t_end_ea_get(self) -> ea_t
 |  
 |  flags
 |      segment_t_flags_get(self) -> ushort
 |  
 |  name
 |      segment_t_name_get(self) -> uval_t
 |  
 |  orgbase
 |      segment_t_orgbase_get(self) -> uval_t
 |  
 |  perm
 |      segment_t_perm_get(self) -> uchar
 |  
 |  sclass
 |      segment_t_sclass_get(self) -> uval_t
 |  
 |  sel
 |      segment_t_sel_get(self) -> sel_t
 |  
 |  start_ea
 |      segment_t_start_ea_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      segment_t_type_get(self) -> uchar
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_segment_t>
 |      delete_segment_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: range_t const &
 |  
 |  _print(self, *args)
 |      _print(self) -> size_t
 |  
 |  clear(self, *args)
 |      Set 'start_ea' , 'end_ea' to 0.
 |  
 |  compare(self, *args)
 |      Compare two 'range_t' instances, based on the start_ea.
 |      
 |      compare(self, r) -> int
 |          @param r (C++: const  range_t  &)
 |  
 |  contains(self, *args)
 |      Is 'ea' in the address range?
 |      
 |      contains(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |      
 |      
 |      contains(self, r) -> bool
 |          r: range_t const &
 |  
 |  empty(self, *args)
 |      Is the size of the 'range_t' <= 0?
 |  
 |  extend(self, *args)
 |      Ensure that the 'range_t' includes 'ea'.
 |      
 |      extend(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  intersect(self, *args)
 |      Assign the 'range_t' to the intersection between the 'range_t' and
 |      'r'.
 |      
 |      intersect(self, r)
 |          @param r (C++: const  range_t  &)
 |  
 |  overlaps(self, *args)
 |      Is there an ea in 'r' that is also in this 'range_t' ?
 |      
 |      overlaps(self, r) -> bool
 |          @param r (C++: const  range_t  &)
 |  
 |  size(self, *args)
 |      Get 'end_ea' - 'start_ea' .
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  startEA

Help on function segtype in module ida_segment:

segtype(*args)
    Get segment type.
    
    segtype(ea) -> uchar
        @param ea: any linear address within the segment (C++: ea_t)
        @return: Segment types ,  SEG_UNDF  if no segment found at 'ea'

Help on function sel2ea in module ida_segment:

sel2ea(*args)
    Get mapping of a selector as a linear address.
    
    sel2ea(selector) -> ea_t
        @param selector: number of selector to translate to linear address
                         (C++: sel_t)
        @return: linear address the specified selector is mapped to. if there
                 is no mapping, returns to_ea(selector,0);

Help on function sel2para in module ida_segment:

sel2para(*args)
    Get mapping of a selector.
    
    sel2para(selector) -> ea_t
        @param selector: number of selector to translate (C++: sel_t)
        @return: paragraph the specified selector is mapped to. if there is no
                 mapping, returns 'selector'.

Help on function set_defsr in module ida_segment:

set_defsr(*args)
    set_defsr(s, reg, value)
        s: segment_t *
        reg: int
        value: sel_t

Help on function set_group_selector in module ida_segment:

set_group_selector(*args)
    Create a new group of segments (used OMF files).
    
    set_group_selector(grp, sel) -> int
        @param grp: selector of group segment (segment type is  SEG_GRP ) You
                    should create an 'empty' (1 byte) group segment It won't
                    contain anything and will be used to redirect references
                    to the group of segments to the common selector. (C++:
                    sel_t)
        @param sel: common selector of all segments belonging to the segment
                    You should create all segments within the group with the
                    same selector value. (C++: sel_t)
        @return: 1 ok

Help on function set_segm_addressing in module ida_segment:

set_segm_addressing(*args)
    Change segment addressing mode (16, 32, 64 bits). You must use this
    function to change segment addressing, never change the 'bitness'
    field directly. This function will delete all instructions, comments
    and names in the segment
    
    set_segm_addressing(s, bitness) -> bool
        @param s: pointer to segment (C++: segment_t  *)
        @param bitness: new addressing mode of segment   2: 64bit segment   1:
                        32bit segment   0: 16bit segment (C++: size_t)
        @return: success

Help on function set_segm_base in module ida_segment:

set_segm_base(*args)
    Internal function.
    
    set_segm_base(s, newbase) -> bool
        @param s (C++: segment_t  *)
        @param newbase (C++: ea_t)

Help on function set_segm_class in module ida_segment:

set_segm_class(*args)
    Set segment class.
    
    set_segm_class(s, sclass, flags=0) -> int
        @param s: pointer to segment (may be NULL) (C++: segment_t  *)
        @param sclass: segment class (may be NULL). If segment type is
                       SEG_NORM  and segment class is one of predefined names,
                       then segment type is changed to:   "CODE" ->  SEG_CODE
                       "DATA" ->  SEG_DATA   "STACK" ->  SEG_BSS   "BSS" ->
                       SEG_BSS   if "UNK" then segment type is reset to
                       SEG_NORM . (C++: const char *)
        @param flags (C++: int)
        @retval: 1 - ok, name is good and segment is renamed
        @retval: 0 - failure, name is NULL or bad or segment is NULL

Help on function set_segm_end in module ida_segment:

set_segm_end(*args)
    Set segment end address. The next segment is shrinked to allow
    expansion of the specified segment. The kernel might even delete the
    next segment if necessary. The kernel will ask the user for a
    permission to destroy instructions or data going out of segment scope
    if such instructions exist.
    
    set_segm_end(ea, newend, flags) -> bool
        @param ea: any address belonging to the segment (C++: ea_t)
        @param newend: new end address of the segment (C++: ea_t)
        @param flags: Segment modification flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, a warning message is displayed

Help on function set_segm_name in module ida_segment:

set_segm_name(*args)
    Rename segment. The new name is validated (see validate_name). A
    segment always has a name. If you hadn't specified a name, the kernel
    will assign it "seg###" name where ### is segment number.
    
    set_segm_name(s, name, flags=0) -> int
        @param s: pointer to segment (may be NULL) (C++: segment_t  *)
        @param name: new segment name (C++: const char *)
        @param flags: ADDSEG_IDBENC or 0 (C++: int)
        @retval: 1 - ok, name is good and segment is renamed
        @retval: 0 - failure, name is bad or segment is NULL

Help on function set_segm_start in module ida_segment:

set_segm_start(*args)
    Set segment start address. The previous segment is trimmed to allow
    expansion of the specified segment. The kernel might even delete the
    previous segment if necessary. The kernel will ask the user for a
    permission to destroy instructions or data going out of segment scope
    if such instructions exist.
    
    set_segm_start(ea, newstart, flags) -> bool
        @param ea: any address belonging to the segment (C++: ea_t)
        @param newstart: new start address of the segment note that segment
                         start address should be higher than segment base
                         linear address. (C++: ea_t)
        @param flags: Segment modification flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, a warning message is displayed

Help on function set_segment_cmt in module ida_segment:

set_segment_cmt(*args)
    Set segment comment.
    
    set_segment_cmt(s, cmt, repeatable)
        @param s: pointer to segment structure (C++: const  segment_t  *)
        @param cmt: comment string, may be multiline (with '  '). maximal size
                    is 4096 bytes. Use empty str ("") to delete comment (C++:
                    const char *)
        @param repeatable: 0: set regular comment. 1: set repeatable comment.
                           (C++: bool)

Help on function set_segment_translations in module ida_segment:

set_segment_translations(*args)
    Set new translation list.
    
    set_segment_translations(segstart, transmap) -> bool
        @param segstart: start address of the segment to add translation to
                         (C++: ea_t)
        @param transmap: vector of segment start addresses for the translation
                         list. If transmap is empty, the translation list is
                         deleted. (C++: const  eavec_t  &)
        @retval: 1 - ok
        @retval: 0 - too many translations or bad segstart

Help on function set_selector in module ida_segment:

set_selector(*args)
    Set mapping of selector to a paragraph. You should call this
    functionbeforecreating a segment which uses the selector, otherwise
    the creation of the segment will fail.
    
    set_selector(selector, paragraph) -> int
        @param selector: number of selector to map   if selector ==  BADSEL ,
                         then return 0 (fail)   if the selector has had a
                         mapping, old mapping is destroyed   if the selector
                         number is equal to paragraph value, then the mapping
                         is destroyed because we don't need to keep trivial
                         mappings. (C++: sel_t)
        @param paragraph: paragraph to map selector (C++: ea_t)
        @retval: 1 - ok
        @retval: 0 - failure (bad selector or too many mappings)

Help on function set_visible_segm in module ida_segment:

set_visible_segm(*args)
    See 'SFL_HIDDEN' .
    
    set_visible_segm(s, visible)
        @param s (C++: segment_t  *)
        @param visible (C++: bool)

Help on function setup_selector in module ida_segment:

setup_selector(*args)
    Allocate a selector for a segment if necessary. You must call this
    function before calling 'add_segm_ex()' . 'add_segm()' calls this
    function itself, so you don't need to allocate a selector. This
    function will allocate a selector if 'segbase' requires more than 16
    bits and the current processor is IBM PC. Otherwise it will return the
    segbase value.
    
    setup_selector(segbase) -> sel_t
        @param segbase: a new segment base paragraph (C++: ea_t)
        @return: the allocated selector number

Help on function std_out_segm_footer in module ida_segment:

std_out_segm_footer(*args)
    Generate segment footer line as a comment line. This function may be
    used in IDP modules to generate segment footer if the target assembler
    doesn't have 'ends' directive.
    
    std_out_segm_footer(ctx, seg)
        @param ctx (C++: struct  outctx_t  &)
        @param seg (C++: segment_t  *)

Help on function take_memory_snapshot in module ida_segment:

take_memory_snapshot(*args)
    Take a memory snapshot of the running process.
    
    take_memory_snapshot(only_loader_segs) -> bool
        @param only_loader_segs: only is_loader_segm() segments will be
                                 affected (C++: bool)
        @return: success

Help on function update_segm in module ida_segment:

update_segm(*args)
    update_segm(s) -> bool
        @param s (C++: segment_t  *)

=== ida_segment EPYDOC INJECTIONS ===
ida_segment.ADDSEG_FILLGAP
"""
fill gap between new segment and previous one. i.e. if such a gap
exists, and this gap is less than 64K, then fill the gap by extending
the previous segment and adding .align directive to it. This way we
avoid gaps between segments. too many gaps lead to a virtual array
failure. it cannot hold more than ~1000 gaps.
"""

ida_segment.ADDSEG_IDBENC
"""
non-ASCII bytes will be decoded accordingly

'name' and 'sclass' are given in the IDB encoding;
"""

ida_segment.ADDSEG_NOAA
"""
do not mark new segment for auto-analysis
"""

ida_segment.ADDSEG_NOSREG
"""
(undefine all default segment registers)

set all default segment register values to 'BADSEL'
"""

ida_segment.ADDSEG_NOTRUNC
"""
destroy/truncate old segments instead.

don't truncate the new segment at the beginning of the next segment if
they overlap.
"""

ida_segment.ADDSEG_OR_DIE
"""
'qexit()' if can't add a segment
"""

ida_segment.ADDSEG_QUIET
"""
silent mode, no "Adding segment..." in the messages window
"""

ida_segment.ADDSEG_SPARSE
"""
use sparse storage method for the new segment
"""

ida_segment.CSS_BREAK
"""
memory reading process stopped by user
"""

ida_segment.CSS_NODBG
"""
debugger is not running
"""

ida_segment.CSS_NOMEM
"""
is too big)

not enough memory (might be because the segment
"""

ida_segment.CSS_NORANGE
"""
could not find corresponding memory range
"""

ida_segment.CSS_OK
"""
ok
"""

ida_segment.MAX_GROUPS
"""
max number of segment groups
"""

ida_segment.MAX_SEGM_TRANSLATIONS
"""
max number of segment translations
"""

ida_segment.MOVE_SEGM_CHUNK
"""
Too many chunks are defined, can't move.
"""

ida_segment.MOVE_SEGM_DEBUG
"""
Debugger segments cannot be moved.
"""

ida_segment.MOVE_SEGM_IDP
"""
IDP module forbids moving the segment.
"""

ida_segment.MOVE_SEGM_LOADER
"""
The segment has been moved but the loader complained.
"""

ida_segment.MOVE_SEGM_ODD
"""
Cannot move segments by an odd number of bytes.
"""

ida_segment.MOVE_SEGM_OK
"""
all ok
"""

ida_segment.MOVE_SEGM_ORPHAN
"""
Orphan bytes hinder segment movement.
"""

ida_segment.MOVE_SEGM_PARAM
"""
The specified segment does not exist.
"""

ida_segment.MOVE_SEGM_ROOM
"""
Not enough free room at the target address.
"""

ida_segment.MSF_FIXONCE
"""
valid for 'rebase_program()' . see 'loader_t::move_segm' .

call loader only once with the special calling method.
"""

ida_segment.MSF_LDKEEP
"""
keep the loader in the memory (optimization)
"""

ida_segment.MSF_NETNODES
"""
valid for 'rebase_program()'

move netnodes instead of changing inf.netdelta (this is slower)
"""

ida_segment.MSF_NOFIX
"""
don't call the loader to fix relocations
"""

ida_segment.MSF_PRIORITY
"""
valid for 'move_segm()'

loader segments will overwrite any existing debugger segments when
moved.
"""

ida_segment.MSF_SILENT
"""
don't display a "please wait" box on the screen
"""

ida_segment.SEGMOD_KEEP
"""
keep information (code & data, etc)
"""

ida_segment.SEGMOD_KEEP0
"""
flag for internal use, don't set
"""

ida_segment.SEGMOD_KEEPSEL
"""
do not try to delete unused selector
"""

ida_segment.SEGMOD_KILL
"""
disable addresses if segment gets shrinked or deleted
"""

ida_segment.SEGMOD_NOMOVE
"""
(for 'set_segm_start()' )

don't move info from the start of segment to the new start address
"""

ida_segment.SEGMOD_SILENT
"""
be silent
"""

ida_segment.SEGMOD_SPARSE
"""
(for 'set_segm_start()' , 'set_segm_end()' )

use sparse storage if extending the segment
"""

ida_segment.SEGPERM_EXEC
"""
Execute.
"""

ida_segment.SEGPERM_READ
"""
Read.
"""

ida_segment.SEGPERM_WRITE
"""
Write.
"""

ida_segment.SEG_ABSSYM
"""
segment with definitions of absolute symbols
"""

ida_segment.SEG_BSS
"""
uninitialized segment
"""

ida_segment.SEG_CODE
"""
code segment
"""

ida_segment.SEG_COMM
"""
segment with communal definitions
"""

ida_segment.SEG_DATA
"""
data segment
"""

ida_segment.SEG_GRP
"""
group of segments
"""

ida_segment.SEG_IMEM
"""
internal processor memory & sfr (8051)
"""

ida_segment.SEG_IMP
"""
java: implementation segment
"""

ida_segment.SEG_NORM
"""
unknown type, no assumptions
"""

ida_segment.SEG_NULL
"""
zero-length segment
"""

ida_segment.SEG_UNDF
"""
undefined segment type (not used)
"""

ida_segment.SEG_XTRN
"""
no instructions are allowed

segment with 'extern' definitions.
"""

ida_segment.SFL_COMORG
"""
IDP dependent field (IBM PC: if set, ORG directive is not commented
out)
"""

ida_segment.SFL_DEBUG
"""
Is the segment created for the debugger?. Such segments are temporary
and do not have permanent flags.
"""

ida_segment.SFL_HEADER
"""
Header segment (do not create offsets to it in the disassembly)
"""

ida_segment.SFL_HIDDEN
"""
Is the segment hidden?
"""

ida_segment.SFL_HIDETYPE
"""
Hide segment type (do not print it in the listing)
"""

ida_segment.SFL_LOADER
"""
Is the segment created by the loader?
"""

ida_segment.SFL_OBOK
"""
Orgbase is present? (IDP dependent field)
"""

ida_segment.SREG_NUM
"""
Maximum number of segment registers is 16 (see 'segregs.hpp' )
"""

ida_segment.saAbs
"""
Absolute segment.
"""

ida_segment.saGroup
"""
Segment group.
"""

ida_segment.saRel1024Bytes
"""
1024 bytes
"""

ida_segment.saRel128Bytes
"""
128 bytes
"""

ida_segment.saRel2048Bytes
"""
2048 bytes
"""

ida_segment.saRel32Bytes
"""
32 bytes
"""

ida_segment.saRel4K
"""
alignment. It is not supported by LINK.

This value is used by the PharLap OMF for page (4K)
"""

ida_segment.saRel512Bytes
"""
512 bytes
"""

ida_segment.saRel64Bytes
"""
64 bytes
"""

ida_segment.saRelByte
"""
Relocatable, byte aligned.
"""

ida_segment.saRelDble
"""
boundary.

Relocatable, aligned on a double word (4-byte)
"""

ida_segment.saRelPage
"""
Relocatable, aligned on 256-byte boundary.
"""

ida_segment.saRelPara
"""
Relocatable, paragraph (16-byte) aligned.
"""

ida_segment.saRelQword
"""
8 bytes
"""

ida_segment.saRelWord
"""
Relocatable, word (2-byte) aligned.
"""

ida_segment.scCommon
"""
Common. Combine by overlay using maximum size.
"""

ida_segment.scGroup
"""
Segment group.
"""

ida_segment.scPriv
"""
segment.

Private. Do not combine with any other program
"""

ida_segment.scPub
"""
the alignment requirement.

Public. Combine by appending at an offset that meets
"""

ida_segment.scPub2
"""
As defined by Microsoft, same as C=2 (public).
"""

ida_segment.scPub3
"""
As defined by Microsoft, same as C=2 (public).
"""

ida_segment.scStack
"""
byte alignment.

Stack. Combine as for C=2. This combine type forces
"""
=== ida_segment EPYDOC INJECTIONS END ===
Help on function copy_sreg_ranges in module ida_segregs:

copy_sreg_ranges(*args)
    Duplicate segment register ranges.
    
    copy_sreg_ranges(dst_rg, src_rg, map_selector=False)
        @param dst_rg: number of destination segment register (C++: int)
        @param src_rg: copy ranges from (C++: int)
        @param map_selector: map selectors to linear addresses using  sel2ea()
                             (C++: bool)

Help on function del_sreg_range in module ida_segregs:

del_sreg_range(*args)
    Delete segment register range started at ea. When a segment register
    range is deleted, the previous range is extended to cover the empty
    space. The segment register range at the beginning of a segment cannot
    be deleted.
    
    del_sreg_range(ea, rg) -> bool
        @param ea: start_ea of the deleted range (C++: ea_t)
        @param rg: the segment register number (C++: int)
        @return: success

Help on function get_prev_sreg_range in module ida_segregs:

get_prev_sreg_range(*args)
    Get segment register range previous to one with address.more efficient
    then get_sreg_range(reg, ea-1)
    
    get_prev_sreg_range(out, ea, rg) -> bool
        @param out: segment register range (C++: sreg_range_t  *)
        @param ea: any linear address in the program (C++: ea_t)
        @param rg: the segment register number (C++: int)
        @return: success

Help on function get_sreg in module ida_segregs:

get_sreg(*args)
    Get value of a segment register. This function uses segment register
    range and default segment register values stored in the segment
    structure.
    
    get_sreg(ea, rg) -> sel_t
        @param ea: linear address in the program (C++: ea_t)
        @param rg: number of the segment register (C++: int)
        @return: value of the segment register,  BADSEL  if value is unknown.

Help on function get_sreg_range in module ida_segregs:

get_sreg_range(*args)
    Get segment register range by linear address.
    
    get_sreg_range(out, ea, rg) -> bool
        @param out: segment register range (C++: sreg_range_t  *)
        @param ea: any linear address in the program (C++: ea_t)
        @param rg: the segment register number (C++: int)
        @return: success

Help on function get_sreg_range_num in module ida_segregs:

get_sreg_range_num(*args)
    Get number of segment register range by address.
    
    get_sreg_range_num(ea, rg) -> int
        @param ea: any address in the range (C++: ea_t)
        @param rg: the segment register number (C++: int)
        @return: -1 if no range occupies the specified address. otherwise
                 returns number of the specified range
                 (0..get_srranges_qty()-1)

Help on function get_sreg_ranges_qty in module ida_segregs:

get_sreg_ranges_qty(*args)
    Get number of segment register ranges.
    
    get_sreg_ranges_qty(rg) -> size_t
        @param rg: the segment register number (C++: int)

Help on function getn_sreg_range in module ida_segregs:

getn_sreg_range(*args)
    Get segment register range by its number.
    
    getn_sreg_range(out, rg, n) -> bool
        @param out: segment register range (C++: sreg_range_t  *)
        @param rg: the segment register number (C++: int)
        @param n: number of range (0..qty()-1) (C++: int)
        @return: success

Help on function set_default_dataseg in module ida_segregs:

set_default_dataseg(*args)
    Set default value of DS register for all segments.
    
    set_default_dataseg(ds_sel)
        @param ds_sel (C++: sel_t)

Help on function set_default_sreg_value in module ida_segregs:

set_default_sreg_value(*args)
    Set default value of a segment register for a segment.
    
    set_default_sreg_value(sg, rg, value) -> bool
        @param sg: pointer to segment structure if NULL, then set the register
                   for all segments (C++: segment_t  *)
        @param rg: number of segment register (C++: int)
        @param value: its default value. this value will be used by
                      get_sreg()  if value of the register is unknown at the
                      specified address. (C++: sel_t)
        @return: success

Help on function set_sreg_at_next_code in module ida_segregs:

set_sreg_at_next_code(*args)
    Set the segment register value at the next instruction. This function
    is designed to be called from 'idb_event::sgr_changed' handler in
    order to contain the effect of changing a segment register value only
    until the next instruction.It is useful, for example, in the ARM
    module: the modification of the T register does not affect existing
    instructions later in the code.
    
    set_sreg_at_next_code(ea1, ea2, rg, value)
        @param ea1: address to start to search for an instruction (C++: ea_t)
        @param ea2: the maximal address (C++: ea_t)
        @param rg: the segment register number (C++: int)
        @param value: the segment register value (C++: sel_t)

Help on function split_sreg_range in module ida_segregs:

split_sreg_range(*args)
    Create a new segment register range. This function is used when the
    IDP emulator detects that a segment register changes its value.
    
    split_sreg_range(ea, rg, v, tag, silent=False) -> bool
        @param ea: linear address where the segment register will have a new
                   value. if ea== BADADDR , nothing to do. (C++: ea_t)
        @param rg: the number of the segment register (C++: int)
        @param v: the new value of the segment register. If the value is
                  unknown, you should specify  BADSEL . (C++: sel_t)
        @param tag: the register info tag. see  Segment register range tags
                    (C++: uchar)
        @param silent: if false, display a warning() in the case of failure
                       (C++: bool)
        @return: success

Help on class sreg_range_t in module ida_segregs:

class sreg_range_t(ida_range.range_t)
 |  Proxy of C++ sreg_range_t class.
 |  
 |  Method resolution order:
 |      sreg_range_t
 |      ida_range.range_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sreg_range_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  tag
 |      sreg_range_t_tag_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  val
 |      sreg_range_t_val_get(self) -> sel_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_sreg_range_t>
 |      delete_sreg_range_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: range_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: range_t const &
 |  
 |  _print(self, *args)
 |      _print(self) -> size_t
 |  
 |  clear(self, *args)
 |      Set 'start_ea' , 'end_ea' to 0.
 |  
 |  compare(self, *args)
 |      Compare two 'range_t' instances, based on the start_ea.
 |      
 |      compare(self, r) -> int
 |          @param r (C++: const  range_t  &)
 |  
 |  contains(self, *args)
 |      Is 'ea' in the address range?
 |      
 |      contains(self, ea) -> bool
 |          @param ea (C++: ea_t)
 |      
 |      
 |      contains(self, r) -> bool
 |          r: range_t const &
 |  
 |  empty(self, *args)
 |      Is the size of the 'range_t' <= 0?
 |  
 |  extend(self, *args)
 |      Ensure that the 'range_t' includes 'ea'.
 |      
 |      extend(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  intersect(self, *args)
 |      Assign the 'range_t' to the intersection between the 'range_t' and
 |      'r'.
 |      
 |      intersect(self, r)
 |          @param r (C++: const  range_t  &)
 |  
 |  overlaps(self, *args)
 |      Is there an ea in 'r' that is also in this 'range_t' ?
 |      
 |      overlaps(self, r) -> bool
 |          @param r (C++: const  range_t  &)
 |  
 |  size(self, *args)
 |      Get 'end_ea' - 'start_ea' .
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  endEA
 |  
 |  end_ea
 |      range_t_end_ea_get(self) -> ea_t
 |  
 |  startEA
 |  
 |  start_ea
 |      range_t_start_ea_get(self) -> ea_t

=== ida_segregs EPYDOC INJECTIONS ===
ida_segregs.SR_auto
"""
the value is determined by IDA
"""

ida_segregs.SR_autostart
"""
used as 'SR_auto' for segment starting address
"""

ida_segregs.SR_inherit
"""
the value is inherited from the previous range
"""

ida_segregs.SR_user
"""
the value is specified by the user
"""
=== ida_segregs EPYDOC INJECTIONS END ===
Help on function build_strlist in module ida_strlist:

build_strlist(*args)
    Build the string list. You should initialize options before this call
    using the restore_config() or setup_strings_window() methods.

Help on function clear_strlist in module ida_strlist:

clear_strlist(*args)
    Clear the string list.

Help on function get_strlist_item in module ida_strlist:

get_strlist_item(*args)
    Get nth element of the string list (n=0.. 'get_strlist_qty()' -1)
    
    get_strlist_item(si, n) -> bool
        @param si (C++: string_info_t  *)
        @param n (C++: size_t)

Help on function get_strlist_options in module ida_strlist:

get_strlist_options(*args)
    Get access to the static string list options.

Help on function get_strlist_qty in module ida_strlist:

get_strlist_qty(*args)
    Get number of elements in the string list.

Help on class string_info_t in module ida_strlist:

class string_info_t(__builtin__.object)
 |  Proxy of C++ string_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> string_info_t
 |          _ea: ea_t
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: string_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      string_info_t_ea_get(self) -> ea_t
 |  
 |  length
 |      string_info_t_length_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      string_info_t_type_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_string_info_t>
 |      delete_string_info_t(self)

Help on class strwinsetup_t in module ida_strlist:

class strwinsetup_t(__builtin__.object)
 |  Proxy of C++ strwinsetup_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strwinsetup_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _get_strtypes(self, *args)
 |      _get_strtypes(self) -> PyObject *
 |  
 |  _set_strtypes(self, *args)
 |      _set_strtypes(self, py_t) -> PyObject *
 |          py_t: PyObject *
 |  
 |  is_initialized(self, *args)
 |      is_initialized(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  display_only_existing_strings
 |      strwinsetup_t_display_only_existing_strings_get(self) -> uchar
 |  
 |  ignore_heads
 |      strwinsetup_t_ignore_heads_get(self) -> uchar
 |  
 |  minlen
 |      strwinsetup_t_minlen_get(self) -> sval_t
 |  
 |  only_7bit
 |      strwinsetup_t_only_7bit_get(self) -> uchar
 |  
 |  strtypes
 |      _get_strtypes(self) -> PyObject *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_strwinsetup_t>
 |      delete_strwinsetup_t(self)

Help on function add_struc in module ida_struct:

add_struc(*args)
    Create a structure type. if idx== 'BADADDR' then add as the last idx.
    if name==NULL then a name will be generated "struct_%d".
    
    add_struc(idx, name, is_union=False) -> tid_t
        @param idx (C++: uval_t)
        @param name (C++: const char *)
        @param is_union (C++: bool)

Help on function add_struc_member in module ida_struct:

add_struc_member(*args)
    Add member to existing structure.
    
    add_struc_member(sptr, fieldname, offset, flag, mt, nbytes) -> struc_error_t
        @param sptr: structure to modify (C++: struc_t  *)
        @param fieldname: if NULL, then "anonymous_#" name will be generated
                          (C++: const char *)
        @param offset: BADADDR  means add to the end of structure (C++: ea_t)
        @param flag: type + representation bits (C++: flags_t)
        @param mt: additional info about member type. must be present for
                   structs, offsets, enums, strings, struct offsets. (C++:
                   const  opinfo_t  *)
        @param nbytes: if == 0 then the structure will be a varstruct. in this
                       case the member should be the last member in the
                       structure (C++: asize_t)

Help on function del_member_tinfo in module ida_struct:

del_member_tinfo(*args)
    Delete tinfo for given member.
    
    del_member_tinfo(sptr, mptr) -> bool
        @param sptr (C++: struc_t  *)
        @param mptr (C++: member_t  *)

Help on function del_struc in module ida_struct:

del_struc(*args)
    Delete a structure type.
    
    del_struc(sptr) -> bool
        @param sptr (C++: struc_t  *)

Help on function del_struc_member in module ida_struct:

del_struc_member(*args)
    Delete member at given offset.
    
    del_struc_member(sptr, offset) -> bool
        @param sptr (C++: struc_t  *)
        @param offset (C++: ea_t)

Help on function del_struc_members in module ida_struct:

del_struc_members(*args)
    Delete members which occupy range of offsets (off1..off2).
    
    del_struc_members(sptr, off1, off2) -> int
        @param sptr (C++: struc_t  *)
        @param off1 (C++: ea_t)
        @param off2 (C++: ea_t)
        @return: number of deleted members or -1 on error

Help on class dyn_member_ref_array in module ida_struct:

class dyn_member_ref_array(__builtin__.object)
 |  Proxy of C++ dynamic_wrapped_array_t< member_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> member_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_member_ref_array
 |          _data: member_t *
 |          _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: member_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      dyn_member_ref_array_count_get(self) -> size_t
 |  
 |  data
 |      dyn_member_ref_array_data_get(self) -> member_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_dyn_member_ref_array>
 |      delete_dyn_member_ref_array(self)

Help on function expand_struc in module ida_struct:

expand_struc(*args)
    Expand/Shrink structure type.
    
    expand_struc(sptr, offset, delta, recalc=True) -> bool
        @param sptr (C++: struc_t  *)
        @param offset (C++: ea_t)
        @param delta (C++: adiff_t)
        @param recalc (C++: bool)

Help on function get_best_fit_member in module ida_struct:

get_best_fit_member(*args)
    Get member that is most likely referenced by the specified offset.
    Useful for offsets > sizeof(struct).
    
    get_best_fit_member(sptr, offset) -> member_t
        @param sptr (C++: const  struc_t  *)
        @param offset (C++: asize_t)

Help on function get_first_struc_idx in module ida_struct:

get_first_struc_idx(*args)
    Get index of first structure.

Help on function get_last_struc_idx in module ida_struct:

get_last_struc_idx(*args)
    Get index of last structure.

Help on function get_max_offset in module ida_struct:

get_max_offset(*args)
    For unions: returns number of members, for structs: returns size of
    structure.
    
    get_max_offset(sptr) -> ea_t
        @param sptr (C++: struc_t  *)

Help on function get_member in module ida_struct:

get_member(*args)
    Get member at given offset.
    
    get_member(sptr, offset) -> member_t
        @param sptr (C++: const  struc_t  *)
        @param offset (C++: asize_t)

Help on function get_member_by_fullname in module ida_struct:

get_member_by_fullname(*args)
    Get a member by its fully qualified name, "struct.field".
    
    get_member_by_fullname(fullname) -> member_t
        @param fullname (C++: const char *)

Help on function get_member_by_id in module ida_struct:

get_member_by_id(*args)
    Check if the specified member id points to a struct member.
    
    get_member_by_id(mid) -> member_t
        @param mid (C++: tid_t)

Help on function get_member_by_name in module ida_struct:

get_member_by_name(*args)
    Get a member by its name, like "field44".
    
    get_member_by_name(sptr, membername) -> member_t
        @param sptr (C++: const  struc_t  *)
        @param membername (C++: const char *)

Help on function get_member_cmt in module ida_struct:

get_member_cmt(*args)
    Get comment of structure member.
    
    get_member_cmt(mid, repeatable) -> str
        @param mid (C++: tid_t)
        @param repeatable (C++: bool)

Help on function get_member_fullname in module ida_struct:

get_member_fullname(*args)
    Get a member's fully qualified name, "struct.field".
    
    get_member_fullname(mid) -> str
        @param mid (C++: tid_t)

Help on function get_member_id in module ida_struct:

get_member_id(*args)
    Get member id at given offset.
    
    get_member_id(sptr, offset) -> tid_t
        @param sptr (C++: const  struc_t  *)
        @param offset (C++: asize_t)

Help on function get_member_name in module ida_struct:

get_member_name(*args)
    Get name of structure member.
    
    get_member_name(mid) -> str
        @param mid (C++: tid_t)

Help on function get_member_size in module ida_struct:

get_member_size(*args)
    Get size of structure member. May return 0 for the last member of
    varstruct. For union members, returns 'member_t::eoff' .
    
    get_member_size(mptr) -> asize_t
        @param mptr (C++: const  member_t  *)

Help on function get_member_struc in module ida_struct:

get_member_struc(*args)
    Get containing structure of member by its full name "struct.field".
    
    get_member_struc(fullname) -> struc_t
        @param fullname (C++: const char *)

Help on function get_member_tinfo in module ida_struct:

get_member_tinfo(*args)
    Get tinfo for given member.
    
    get_member_tinfo(tif, mptr) -> bool
        @param tif (C++: tinfo_t  *)
        @param mptr (C++: const  member_t  *)

Help on function get_next_member_idx in module ida_struct:

get_next_member_idx(*args)
    Get the next member idx, if it does not exist, return -1.
    
    get_next_member_idx(sptr, off) -> ssize_t
        @param sptr (C++: const  struc_t  *)
        @param off (C++: asize_t)

Help on function get_next_struc_idx in module ida_struct:

get_next_struc_idx(*args)
    Get next struct index.
    
    get_next_struc_idx(idx) -> uval_t
        @param idx (C++: uval_t)
        @return: BADADDR  if resulting index is out of bounds, otherwise idx++

Help on function get_or_guess_member_tinfo in module ida_struct:

get_or_guess_member_tinfo(*args)
    Try to get tinfo for given member - if failed, generate a tinfo using
    information about the member id from the disassembly
    
    get_or_guess_member_tinfo(tif, mptr) -> bool
        @param tif (C++: tinfo_t  *)
        @param mptr (C++: const  member_t  *)

Help on function get_prev_member_idx in module ida_struct:

get_prev_member_idx(*args)
    Get the prev member idx, if it does not exist, return -1.
    
    get_prev_member_idx(sptr, off) -> ssize_t
        @param sptr (C++: const  struc_t  *)
        @param off (C++: asize_t)

Help on function get_prev_struc_idx in module ida_struct:

get_prev_struc_idx(*args)
    Get previous struct index.
    
    get_prev_struc_idx(idx) -> uval_t
        @param idx (C++: uval_t)
        @return: BADADDR  if resulting index is negative, otherwise idx - 1

Help on function get_sptr in module ida_struct:

get_sptr(*args)
    Get child struct if member is a struct.
    
    get_sptr(mptr) -> struc_t
        @param mptr (C++: const  member_t  *)

Help on function get_struc in module ida_struct:

get_struc(*args)
    Get pointer to struct type info.
    
    get_struc(id) -> struc_t
        @param id (C++: tid_t)

Help on function get_struc_by_idx in module ida_struct:

get_struc_by_idx(*args)
    Get struct id by struct number.
    
    get_struc_by_idx(idx) -> tid_t
        @param idx (C++: uval_t)

Help on function get_struc_cmt in module ida_struct:

get_struc_cmt(*args)
    Get struct comment.
    
    get_struc_cmt(id, repeatable) -> str
        @param id (C++: tid_t)
        @param repeatable (C++: bool)

Help on function get_struc_first_offset in module ida_struct:

get_struc_first_offset(*args)
    Get offset of first member.
    
    get_struc_first_offset(sptr) -> ea_t
        @param sptr (C++: const  struc_t  *)
        @return: BADADDR  if memqty == 0

Help on function get_struc_id in module ida_struct:

get_struc_id(*args)
    Get struct id by name.
    
    get_struc_id(name) -> tid_t
        @param name (C++: const char *)

Help on function get_struc_idx in module ida_struct:

get_struc_idx(*args)
    Get internal number of the structure.
    
    get_struc_idx(id) -> uval_t
        @param id (C++: tid_t)

Help on function get_struc_last_offset in module ida_struct:

get_struc_last_offset(*args)
    Get offset of last member.
    
    get_struc_last_offset(sptr) -> ea_t
        @param sptr (C++: const  struc_t  *)
        @return: BADADDR  if memqty == 0

Help on function get_struc_name in module ida_struct:

get_struc_name(*args)
    Get struct name by id
    
    get_struc_name(id, flags=0) -> str
        @param id: struct id (C++: tid_t)
        @param flags: Struct name flags (C++: int)

Help on function get_struc_next_offset in module ida_struct:

get_struc_next_offset(*args)
    Get offset of member with smallest offset larger than 'offset'.
    
    get_struc_next_offset(sptr, offset) -> ea_t
        @param sptr (C++: const  struc_t  *)
        @param offset (C++: ea_t)
        @return: BADADDR  if no next offset

Help on function get_struc_prev_offset in module ida_struct:

get_struc_prev_offset(*args)
    Get offset of member with largest offset less than 'offset'.
    
    get_struc_prev_offset(sptr, offset) -> ea_t
        @param sptr (C++: const  struc_t  *)
        @param offset (C++: ea_t)
        @return: BADADDR  if no prev offset

Help on function get_struc_qty in module ida_struct:

get_struc_qty(*args)
    Get number of known structures.

Help on function get_struc_size in module ida_struct:

get_struc_size(*args)
    Get struct size (also see 'get_struc_size(tid_t)' )
    
    get_struc_size(sptr) -> asize_t
        @param sptr (C++: const  struc_t  *)
    
    
    get_struc_size(id) -> asize_t
        id: tid_t

Help on function is_anonymous_member_name in module ida_struct:

is_anonymous_member_name(*args)
    Is member name prefixed with "anonymous"?
    
    is_anonymous_member_name(name) -> bool
        @param name (C++: const char *)

Help on function is_dummy_member_name in module ida_struct:

is_dummy_member_name(*args)
    Is member name an auto-generated name?
    
    is_dummy_member_name(name) -> bool
        @param name (C++: const char *)

Help on function is_member_id in module ida_struct:

is_member_id(*args)
    Is a member id?
    
    is_member_id(mid) -> bool
        @param mid (C++: tid_t)

Help on function is_special_member in module ida_struct:

is_special_member(*args)
    Is a special member with the name beginning with ' '?
    
    is_special_member(id) -> bool
        @param id (C++: tid_t)

Help on function is_union in module ida_struct:

is_union(*args)
    Is a union?
    
    is_union(id) -> bool
        @param id (C++: tid_t)

Help on function is_varmember in module ida_struct:

is_varmember(*args)
    Is variable size member?
    
    is_varmember(mptr) -> bool
        @param mptr (C++: const  member_t  *)

Help on function is_varstr in module ida_struct:

is_varstr(*args)
    Is variable size structure?
    
    is_varstr(id) -> bool
        @param id (C++: tid_t)

Help on class member_t in module ida_struct:

class member_t(__builtin__.object)
 |  Proxy of C++ member_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> member_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  by_til(self, *args)
 |      Was the member created due to the type system?
 |  
 |  get_soff(self, *args)
 |      Get start offset (for unions - returns 0)
 |  
 |  has_ti(self, *args)
 |      Has type information?
 |  
 |  has_union(self, *args)
 |      Has members of type "union"?
 |  
 |  is_baseclass(self, *args)
 |      Is a base class member?
 |  
 |  is_destructor(self, *args)
 |      Is a virtual destructor?
 |  
 |  is_dupname(self, *args)
 |      Duplicate name was resolved during import?
 |  
 |  unimem(self, *args)
 |      Is a member of a union?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  eoff
 |      member_t_eoff_get(self) -> ea_t
 |  
 |  flag
 |      member_t_flag_get(self) -> flags_t
 |  
 |  id
 |      member_t_id_get(self) -> tid_t
 |  
 |  props
 |      member_t_props_get(self) -> uint32
 |  
 |  soff
 |      member_t_soff_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_member_t>
 |      delete_member_t(self)

Help on function retrieve_member_info in module ida_struct:

retrieve_member_info(*args)
    Get operand type info for member.
    
    retrieve_member_info(buf, mptr) -> opinfo_t
        @param buf (C++: opinfo_t  *)
        @param mptr (C++: const  member_t  *)

Help on function save_struc in module ida_struct:

save_struc(*args)
    Update struct information in the database (internal function)
    
    save_struc(sptr, may_update_ltypes=True)
        @param sptr (C++: struc_t  *)
        @param may_update_ltypes (C++: bool)

Help on function set_member_cmt in module ida_struct:

set_member_cmt(*args)
    Set member comment.
    
    set_member_cmt(mptr, cmt, repeatable) -> bool
        @param mptr (C++: member_t  *)
        @param cmt (C++: const char *)
        @param repeatable (C++: bool)

Help on function set_member_name in module ida_struct:

set_member_name(*args)
    Set name of member at given offset.
    
    set_member_name(sptr, offset, name) -> bool
        @param sptr (C++: struc_t  *)
        @param offset (C++: ea_t)
        @param name (C++: const char *)

Help on function set_member_tinfo in module ida_struct:

set_member_tinfo(*args)
    Set tinfo for given member.
    
    set_member_tinfo(sptr, mptr, memoff, tif, flags) -> smt_code_t
        @param sptr: containing struct (C++: struc_t  *)
        @param mptr: target member (C++: member_t  *)
        @param memoff: offset within member (C++: uval_t)
        @param tif: type info (C++: const  tinfo_t  &)
        @param flags: Set member tinfo flags (C++: int)

Help on function set_member_type in module ida_struct:

set_member_type(*args)
    Set type of member at given offset (also see 'add_struc_member()' )
    
    set_member_type(sptr, offset, flag, mt, nbytes) -> bool
        @param sptr (C++: struc_t  *)
        @param offset (C++: ea_t)
        @param flag (C++: flags_t)
        @param mt (C++: const  opinfo_t  *)
        @param nbytes (C++: asize_t)

Help on function set_struc_align in module ida_struct:

set_struc_align(*args)
    Set structure alignment ( 'SF_ALIGN' )
    
    set_struc_align(sptr, shift) -> bool
        @param sptr (C++: struc_t  *)
        @param shift (C++: int)

Help on function set_struc_cmt in module ida_struct:

set_struc_cmt(*args)
    Set structure comment.
    
    set_struc_cmt(id, cmt, repeatable) -> bool
        @param id (C++: tid_t)
        @param cmt (C++: const char *)
        @param repeatable (C++: bool)

Help on function set_struc_hidden in module ida_struct:

set_struc_hidden(*args)
    Hide/unhide a struct type.
    
    set_struc_hidden(sptr, is_hidden)
        @param sptr (C++: struc_t  *)
        @param is_hidden (C++: bool)

Help on function set_struc_idx in module ida_struct:

set_struc_idx(*args)
    Set internal number of struct. Also see 'get_struc_idx()' ,
    'get_struc_by_idx()' .
    
    set_struc_idx(sptr, idx) -> bool
        @param sptr (C++: const  struc_t  *)
        @param idx (C++: uval_t)

Help on function set_struc_listed in module ida_struct:

set_struc_listed(*args)
    Add/remove a struct type from the struct list.
    
    set_struc_listed(sptr, is_listed)
        @param sptr (C++: struc_t  *)
        @param is_listed (C++: bool)

Help on function set_struc_name in module ida_struct:

set_struc_name(*args)
    Set structure name.
    
    set_struc_name(id, name) -> bool
        @param id (C++: tid_t)
        @param name (C++: const char *)

Help on function stroff_as_size in module ida_struct:

stroff_as_size(*args)
    Should display a structure offset expression as the structure size?
    
    stroff_as_size(plen, sptr, value) -> bool
        @param plen (C++: int)
        @param sptr (C++: const  struc_t  *)
        @param value (C++: asize_t)

Help on class struc_t in module ida_struct:

class struc_t(__builtin__.object)
 |  Proxy of C++ struc_t class.
 |  
 |  Methods defined here:
 |  
 |  __get_members__(self, *args)
 |      __get_members__(self) -> dyn_member_ref_array
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  from_til(self, *args)
 |      Does structure come from a type library?
 |  
 |  get_alignment(self, *args)
 |      See 'SF_ALIGN' .
 |  
 |  get_member(self, index)
 |  
 |  has_union(self, *args)
 |      Has members of type "union"?
 |  
 |  is_choosable(self, *args)
 |      Is included in chooser list? Use 'set_struc_listed' to change the
 |      listed status
 |  
 |  is_frame(self, *args)
 |      Is this structure a function frame?
 |  
 |  is_ghost(self, *args)
 |      Is a ghost copy of a local type?
 |  
 |  is_hidden(self, *args)
 |      Is the structure collapsed? Use 'set_struc_hidden' to change the
 |      hidden status
 |  
 |  is_union(self, *args)
 |      Is a union?
 |  
 |  is_varstr(self, *args)
 |      Is variable size structure?
 |  
 |  set_alignment(self, *args)
 |      Do not use; use 'set_struc_align()'
 |      
 |      set_alignment(self, shift)
 |          @param shift (C++: int)
 |  
 |  set_ghost(self, *args)
 |      set_ghost(self, _is_ghost)
 |          @param _is_ghost (C++: bool)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  age
 |      struc_t_age_get(self) -> ushort
 |  
 |  id
 |      struc_t_id_get(self) -> tid_t
 |  
 |  members
 |      __get_members__(self) -> dyn_member_ref_array
 |  
 |  memqty
 |      struc_t_memqty_get(self) -> uint32
 |  
 |  ordinal
 |      struc_t_ordinal_get(self) -> int32
 |  
 |  props
 |      struc_t_props_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_struc_t>
 |      delete_struc_t(self)

Help on class struct_field_visitor_t in module ida_struct:

class struct_field_visitor_t(__builtin__.object)
 |  Proxy of C++ struct_field_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> struct_field_visitor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_field(self, *args)
 |      visit_field(self, sptr, mptr) -> int
 |          @param sptr (C++: struc_t  *)
 |          @param mptr (C++: member_t  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_struct_field_visitor_t>
 |      delete_struct_field_visitor_t(self)

Help on function visit_stroff_fields in module ida_struct:

visit_stroff_fields(*args)
    Visit structure fields in a stroff expression or in a reference to a
    struct data variable. This function can be used to enumerate all
    components of an expression like 'a.b.c'.
    
    visit_stroff_fields(sfv, path, disp, appzero) -> flags_t
        @param sfv: visitor object (C++: struct_field_visitor_t  &)
        @param path: struct path (path[0] contains the initial struct id)
                     (C++: const  tid_t  *)
        @param disp: offset into structure (C++: adiff_t *)
        @param appzero: should visit field at offset zero? (C++: bool)

=== ida_struct EPYDOC INJECTIONS ===
ida_struct.MF_BASECLASS
"""
a special member representing base class
"""

ida_struct.MF_BYTIL
"""
the member was created due to the type system
"""

ida_struct.MF_DTOR
"""
a special member representing destructor
"""

ida_struct.MF_DUPNAME
"""
duplicate name resolved with _N suffix (N==soff)
"""

ida_struct.MF_HASTI
"""
has type information?
"""

ida_struct.MF_HASUNI
"""
has members of type "union"?
"""

ida_struct.MF_OK
"""
is the member ok? (always yes)
"""

ida_struct.MF_UNIMEM
"""
is a member of a union?
"""

ida_struct.SET_MEMTI_BYTIL
"""
new type was created by the type subsystem
"""

ida_struct.SET_MEMTI_COMPATIBLE
"""
new type must be compatible with the old
"""

ida_struct.SET_MEMTI_FUNCARG
"""
mptr is function argument (cannot create arrays)
"""

ida_struct.SET_MEMTI_MAY_DESTROY
"""
may destroy other members
"""

ida_struct.SET_MEMTI_USERTI
"""
user-specified type
"""

ida_struct.SF_ALIGN
"""
alignment (shift amount: 0..31)
"""

ida_struct.SF_FRAME
"""
the structure is a function frame
"""

ida_struct.SF_GHOST
"""
ghost copy of a local type
"""

ida_struct.SF_HASUNI
"""
has members of type "union"?
"""

ida_struct.SF_HIDDEN
"""
the structure is collapsed
"""

ida_struct.SF_NOLIST
"""
don't include in the chooser list
"""

ida_struct.SF_TYPLIB
"""
the structure comes from type library
"""

ida_struct.SF_UNION
"""
varunions are prohibited!

is a union?
"""

ida_struct.SF_VAR
"""
is variable size structure (varstruct)? a variable size structure is
one with the zero size last member. if the last member is a varstruct,
then the current structure is a varstruct too.
"""

ida_struct.STRNFL_REGEX
"""
apply regular expressions to beautify the name
"""

ida_struct.STRUC_SEPARATOR
"""
structname.fieldname
"""
=== ida_struct EPYDOC INJECTIONS END ===
Help on function add_tryblk in module ida_tryblks:

add_tryblk(*args)
    Add one try block information.
    
    add_tryblk(tb) -> int
        @param tb: try block to add. (C++: const  tryblk_t  &)
        @return: error code; 0 means good

Help on class catch_t in module ida_tryblks:

class catch_t(try_handler_t)
 |  Proxy of C++ catch_t class.
 |  
 |  Method resolution order:
 |      catch_t
 |      try_handler_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> catch_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  obj
 |      catch_t_obj_get(self) -> sval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type_id
 |      catch_t_type_id_get(self) -> sval_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_catch_t>
 |      delete_catch_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from try_handler_t:
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from try_handler_t:
 |  
 |  disp
 |      try_handler_t_disp_get(self) -> sval_t
 |  
 |  fpreg
 |      try_handler_t_fpreg_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> range_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: range_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: range_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: range_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> range_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> range_t
 |          it: qvector< range_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> range_t
 |          first: qvector< range_t >::iterator
 |          last: qvector< range_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> range_t
 |  
 |  find(self, *args)
 |      find(self, x) -> range_t
 |          x: range_t const &
 |      
 |      
 |      find(self, x) -> range_t
 |          x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=range_t())
 |          x: range_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: range_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: range_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> range_t
 |          it: qvector< range_t >::iterator
 |          x: range_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: range_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: range_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< range_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class catchvec_t in module ida_tryblks:

class catchvec_t(__builtin__.object)
 |  Proxy of C++ qvector< catch_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< catch_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> catch_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> catchvec_t
 |          x: qvector< catch_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< catch_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: catch_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: catch_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: catch_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> catch_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> catch_t
 |      begin(self) -> catch_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> catch_t
 |      end(self) -> catch_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> catch_t
 |          it: qvector< catch_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> catch_t
 |          first: qvector< catch_t >::iterator
 |          last: qvector< catch_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> catch_t
 |  
 |  find(self, *args)
 |      find(self, x) -> catch_t
 |          x: catch_t const &
 |      
 |      
 |      find(self, x) -> catch_t
 |          x: catch_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=catch_t())
 |          x: catch_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: catch_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: catch_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> catch_t
 |          it: qvector< catch_t >::iterator
 |          x: catch_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: catch_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: catch_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< catch_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_catchvec_t>
 |      delete_catchvec_t(self)

Help on function del_tryblks in module ida_tryblks:

del_tryblks(*args)
    Delete try block information in the specified range.
    
    del_tryblks(range)
        @param range: the range to be cleared (C++: const  range_t  &)

Help on function find_syseh in module ida_tryblks:

find_syseh(*args)
    Find the start address of the system eh region including the argument.
    
    find_syseh(ea) -> ea_t
        @param ea: search address (C++: ea_t)
        @return: start address of surrounding tryblk, otherwise BADADDR

Help on function get_tryblks in module ida_tryblks:

get_tryblks(*args)
    Retrieve try block information from the specified address range. Try
    blocks are sorted by starting address and their nest levels
    calculated.
    
    get_tryblks(tbv, range) -> size_t
        @param tbv: output buffer; may be NULL (C++: tryblks_t  *)
        @param range: address range to change (C++: const  range_t  &)
        @return: number of found try blocks

Help on class seh_t in module ida_tryblks:

class seh_t(try_handler_t)
 |  Proxy of C++ seh_t class.
 |  
 |  Method resolution order:
 |      seh_t
 |      try_handler_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> seh_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  filter
 |      seh_t_filter_get(self) -> rangevec_t
 |  
 |  seh_code
 |      seh_t_seh_code_get(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_seh_t>
 |      delete_seh_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from try_handler_t:
 |  
 |  disp
 |      try_handler_t_disp_get(self) -> sval_t
 |  
 |  fpreg
 |      try_handler_t_fpreg_get(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> range_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: range_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: range_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: range_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> range_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> range_t
 |          it: qvector< range_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> range_t
 |          first: qvector< range_t >::iterator
 |          last: qvector< range_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> range_t
 |  
 |  find(self, *args)
 |      find(self, x) -> range_t
 |          x: range_t const &
 |      
 |      
 |      find(self, x) -> range_t
 |          x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=range_t())
 |          x: range_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: range_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: range_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> range_t
 |          it: qvector< range_t >::iterator
 |          x: range_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: range_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: range_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< range_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class try_handler_t in module ida_tryblks:

class try_handler_t(ida_range.rangevec_t)
 |  Proxy of C++ try_handler_t class.
 |  
 |  Method resolution order:
 |      try_handler_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> try_handler_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  disp
 |      try_handler_t_disp_get(self) -> sval_t
 |  
 |  fpreg
 |      try_handler_t_fpreg_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_try_handler_t>
 |      delete_try_handler_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> range_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: range_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: range_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: range_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> range_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> range_t
 |          it: qvector< range_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> range_t
 |          first: qvector< range_t >::iterator
 |          last: qvector< range_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> range_t
 |  
 |  find(self, *args)
 |      find(self, x) -> range_t
 |          x: range_t const &
 |      
 |      
 |      find(self, x) -> range_t
 |          x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=range_t())
 |          x: range_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: range_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: range_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> range_t
 |          it: qvector< range_t >::iterator
 |          x: range_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: range_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: range_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< range_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class tryblk_t in module ida_tryblks:

class tryblk_t(ida_range.rangevec_t)
 |  Proxy of C++ tryblk_t class.
 |  
 |  Method resolution order:
 |      tryblk_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tryblk_t
 |          r: tryblk_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  cpp(self, *args)
 |      cpp(self) -> catchvec_t
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  get_kind(self, *args)
 |      get_kind(self) -> uchar
 |  
 |  is_cpp(self, *args)
 |      is_cpp(self) -> bool
 |  
 |  is_seh(self, *args)
 |      is_seh(self) -> bool
 |  
 |  seh(self, *args)
 |      seh(self) -> seh_t
 |  
 |  set_cpp(self, *args)
 |      set_cpp(self) -> catchvec_t
 |  
 |  set_seh(self, *args)
 |      set_seh(self) -> seh_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  level
 |      tryblk_t_level_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_tryblk_t>
 |      delete_tryblk_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> range_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< range_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: range_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: range_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: range_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> range_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> range_t
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  end(self, *args)
 |      end(self) -> range_t
 |      end(self) -> range_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> range_t
 |          it: qvector< range_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> range_t
 |          first: qvector< range_t >::iterator
 |          last: qvector< range_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> range_t
 |  
 |  find(self, *args)
 |      find(self, x) -> range_t
 |          x: range_t const &
 |      
 |      
 |      find(self, x) -> range_t
 |          x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=range_t())
 |          x: range_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: range_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: range_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> range_t
 |          it: qvector< range_t >::iterator
 |          x: range_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: range_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: range_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< range_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class tryblks_t in module ida_tryblks:

class tryblks_t(__builtin__.object)
 |  Proxy of C++ qvector< tryblk_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< tryblk_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> tryblk_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tryblks_t
 |          x: qvector< tryblk_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< tryblk_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: tryblk_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: tryblk_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: tryblk_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> tryblk_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> tryblk_t
 |      begin(self) -> tryblk_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> tryblk_t
 |      end(self) -> tryblk_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> tryblk_t
 |          it: qvector< tryblk_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> tryblk_t
 |          first: qvector< tryblk_t >::iterator
 |          last: qvector< tryblk_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> tryblk_t
 |  
 |  find(self, *args)
 |      find(self, x) -> tryblk_t
 |          x: tryblk_t const &
 |      
 |      
 |      find(self, x) -> tryblk_t
 |          x: tryblk_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=tryblk_t())
 |          x: tryblk_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: tryblk_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: tryblk_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> tryblk_t
 |          it: qvector< tryblk_t >::iterator
 |          x: tryblk_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: tryblk_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: tryblk_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< tryblk_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_tryblks_t>
 |      delete_tryblks_t(self)

=== ida_tryblks EPYDOC INJECTIONS ===
ida_tryblks.TBERR_EMPTY
"""
empty try block
"""

ida_tryblks.TBERR_END
"""
bad end address
"""

ida_tryblks.TBERR_INTERSECT
"""
range would intersect inner tryblk
"""

ida_tryblks.TBERR_KIND
"""
illegal try block kind
"""

ida_tryblks.TBERR_NO_CATCHES
"""
no catch blocks at all
"""

ida_tryblks.TBERR_OK
"""
ok
"""

ida_tryblks.TBERR_ORDER
"""
bad address order
"""

ida_tryblks.TBERR_START
"""
bad start address
"""
=== ida_tryblks EPYDOC INJECTIONS END ===
Help on function add_til in module ida_typeinf:

add_til(*args)
    Load a til file.
    
    add_til(name, flags) -> int
        @param name: til name (C++: const char *)
        @param flags: combination of  Load TIL flags (C++: int)
        @return: one of  Load TIL result codes

Help on function alloc_type_ordinal in module ida_typeinf:

alloc_type_ordinal(*args)
    \call2{alloc_type_ordinals,ti,1}
    
    alloc_type_ordinal(ti) -> uint32
        @param ti (C++: til_t  *)

Help on function alloc_type_ordinals in module ida_typeinf:

alloc_type_ordinals(*args)
    Allocate a range of ordinal numbers for new types.
    
    alloc_type_ordinals(ti, qty) -> uint32
        @param ti: type library (C++: til_t  *)
        @param qty: number of ordinals to allocate (C++: int)
        @return: the first ordinal. 0 means failure.

Help on class aloc_visitor_t in module ida_typeinf:

class aloc_visitor_t(__builtin__.object)
 |  Proxy of C++ aloc_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> aloc_visitor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_location(self, *args)
 |      visit_location(self, v, off, size) -> int
 |          @param v (C++: argloc_t  &)
 |          @param off (C++: int)
 |          @param size (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_aloc_visitor_t>
 |      delete_aloc_visitor_t(self)

Help on function append_abi_opts in module ida_typeinf:

append_abi_opts(*args)
    Add/remove/check ABI option General form of full abi name: abiname-
    opt1-opt2-... or -opt1-opt2-...
    
    append_abi_opts(abi_opts, user_level=False) -> bool
        @param abi_opts: - ABI options to add/remove in form opt1-opt2-...
                         (C++: const char *)
        @param user_level: - initiated by user if TRUE (==SETCOMP_BY_USER)
                           (C++: bool)
        @return: success

Help on function append_argloc in module ida_typeinf:

append_argloc(*args)
    Serialize argument location.
    
    append_argloc(out, vloc) -> bool
        @param out (C++: qtype  *)
        @param vloc (C++: const  argloc_t  &)

Help on function append_tinfo_covered in module ida_typeinf:

append_tinfo_covered(*args)
    append_tinfo_covered(out, typid, offset) -> bool
        out: rangeset_t *
        typid: uint32
        offset: uint64

Help on function apply_callee_tinfo in module ida_typeinf:

apply_callee_tinfo(*args)
    Apply the type of the called function to the calling instruction. This
    function will append parameter comments and rename the local variables
    of the calling function. It also stores information about the
    instructions that initialize call arguments in the database. Use
    'get_arg_addrs()' to retrieve it if necessary. Alternatively it is
    possible to hook to processor_t::arg_addrs_ready event.
    
    apply_callee_tinfo(caller, tif) -> bool
        @param caller: linear address of the calling instruction. must belong
                       to a function. (C++: ea_t)
        @param tif: type info (C++: const  tinfo_t  &)
        @return: success

Help on function apply_cdecl in module ida_typeinf:

apply_cdecl(*args)
    Apply the specified type to the address. This function parses the
    declaration and calls 'apply_tinfo()'
    
    apply_cdecl(til, ea, decl, flags=0) -> bool
        @param til: type library (C++: til_t  *)
        @param ea: linear address (C++: ea_t)
        @param decl: type declaration in C form (C++: const char *)
        @param flags: flags to pass to apply_tinfo ( TINFO_DEFINITE  is always
                      passed) (C++: int)
        @return: success

Help on function apply_named_type in module ida_typeinf:

apply_named_type(*args)
    Apply the specified named type to the address.
    
    apply_named_type(ea, name) -> bool
        @param ea: linear address (C++: ea_t)
        @param name: the type name, e.g. "FILE" (C++: const char *)
        @return: success

Help on function apply_once_tinfo_and_name in module ida_typeinf:

apply_once_tinfo_and_name(*args)
    Apply the specified type and name to the address. This function checks
    if the address already has a type. If the old typedoes not exist or
    the new type is 'better' than the old type, then thenew type will be
    applied. A type is considered better if it has moreinformation (e.g.
    'BTMT_STRUCT' is better than 'BT_INT' ).The same logic is with the
    name: if the address already have a meaningfulname, it will be
    preserved. Only if the old name does not exist or itis a dummy name
    like byte_123, it will be replaced by the new name.
    
    apply_once_tinfo_and_name(dea, tif, name) -> bool
        @param dea: linear address (C++: ea_t)
        @param tif: type string in the internal format (C++: const  tinfo_t
                    &)
        @param name: new name for the address (C++: const char *)
        @return: success

Help on function apply_tinfo in module ida_typeinf:

apply_tinfo(*args)
    Apply the specified type to the specified address. This function sets
    the type and tries to convert the item at the specified address to
    conform the type.
    
    apply_tinfo(ea, tif, flags) -> bool
        @param ea: linear address (C++: ea_t)
        @param tif: type string in internal format (C++: const  tinfo_t  &)
        @param flags: combination of  Apply tinfo flags (C++: uint32)
        @return: success

Help on function apply_tinfo_to_stkarg in module ida_typeinf:

apply_tinfo_to_stkarg(*args)
    Helper function for the processor modules. to be called from
    \ph{use_stkarg_type}
    
    apply_tinfo_to_stkarg(insn, x, v, tif, name) -> bool
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param x (C++: const  op_t  &)
        @param v (C++: uval_t)
        @param tif (C++: const  tinfo_t  &)
        @param name (C++: const char *)

Help on function apply_type in module ida_typeinf:

apply_type(*args)
    apply_type(ti, type, fields, ea, flags) -> bool
    Apply the specified type to the address
    @param ti: Type info library. 'None' can be used.
    @param py_type: type string
    @param py_fields: fields string (may be empty or None)
    @param ea: the address of the object
    @param flags: combination of TINFO_... constants or 0
    @return: Boolean

Help on class argloc_t in module ida_typeinf:

class argloc_t(__builtin__.object)
 |  Proxy of C++ argloc_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> argloc_t
 |          r: argloc_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _consume_rrel(self, *args)
 |      Use 'consume_rrel()'
 |      
 |      _consume_rrel(self, p) -> bool
 |          @param p (C++: rrel_t  *)
 |  
 |  _consume_scattered(self, *args)
 |      Use 'consume_scattered()'
 |      
 |      _consume_scattered(self, p) -> bool
 |          @param p (C++: scattered_aloc_t  *)
 |  
 |  _set_badloc(self, *args)
 |      Use 'set_badloc()'
 |  
 |  _set_biggest(self, *args)
 |      Set biggest element in internal union (careful - this function does
 |      not clean up!)
 |      
 |      _set_biggest(self, ct, data)
 |          @param ct (C++: argloc_type_t)
 |          @param data (C++: biggest_t)
 |  
 |  _set_custom(self, *args)
 |      Set custom argument location (careful - this function does not clean
 |      up!)
 |      
 |      _set_custom(self, ct, pdata)
 |          @param ct (C++: argloc_type_t)
 |          @param pdata (C++: void *)
 |  
 |  _set_ea(self, *args)
 |      Use set_ea
 |      
 |      _set_ea(self, _ea)
 |          @param _ea (C++: ea_t)
 |  
 |  _set_reg1(self, *args)
 |      Use 'set_reg1()'
 |      
 |      _set_reg1(self, reg, off=0)
 |          @param reg (C++: int)
 |          @param off (C++: int)
 |  
 |  _set_reg2(self, *args)
 |      Use 'set_reg2()'
 |      
 |      _set_reg2(self, _reg1, _reg2)
 |          @param _reg1 (C++: int)
 |          @param _reg2 (C++: int)
 |  
 |  _set_stkoff(self, *args)
 |      Use 'set_stkoff()'
 |      
 |      _set_stkoff(self, off)
 |          @param off (C++: sval_t)
 |  
 |  advance(self, *args)
 |      Move the location to point 'delta' bytes further.
 |      
 |      advance(self, delta) -> bool
 |          @param delta (C++: int)
 |  
 |  atype(self, *args)
 |      Get type ( 'Argument location types' )
 |  
 |  calc_offset(self, *args)
 |      Calculate offset that can be used to compare 2 similar arglocs.
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: argloc_t const &
 |  
 |  consume_rrel(self, *args)
 |      Set register-relative location - can't be NULL.
 |      
 |      consume_rrel(self, p)
 |          @param p (C++: rrel_t  *)
 |  
 |  consume_scattered(self, *args)
 |      Set distributed argument location.
 |      
 |      consume_scattered(self, p)
 |          @param p (C++: scattered_aloc_t  *)
 |  
 |  get_biggest(self, *args)
 |      Get largest element in internal union.
 |  
 |  get_custom(self, *args)
 |      Get custom argloc info. Use if 'atype()' == 'ALOC_CUSTOM'
 |  
 |  get_ea(self, *args)
 |      Get the global address. Use when 'atype()' == 'ALOC_STATIC'
 |  
 |  get_reginfo(self, *args)
 |      Get all register info. Use when 'atype()' == 'ALOC_REG1' or
 |      'ALOC_REG2'
 |  
 |  get_rrel(self, *args)
 |      Get register-relative info. Use when 'atype()' == 'ALOC_RREL'
 |  
 |  has_reg(self, *args)
 |      TRUE if argloc has a register part.
 |  
 |  has_stkoff(self, *args)
 |      TRUE if argloc has a stack part.
 |  
 |  is_badloc(self, *args)
 |      See 'ALOC_NONE' .
 |  
 |  is_custom(self, *args)
 |      See 'ALOC_CUSTOM' .
 |  
 |  is_ea(self, *args)
 |      See 'ALOC_STATIC' .
 |  
 |  is_fragmented(self, *args)
 |      'is_scattered()' || 'is_reg2()'
 |  
 |  is_mixed_scattered(self, *args)
 |      mixed scattered: consists of register and stack parts
 |  
 |  is_reg(self, *args)
 |      'is_reg1()' || 'is_reg2()'
 |  
 |  is_reg1(self, *args)
 |      See 'ALOC_REG1' .
 |  
 |  is_reg2(self, *args)
 |      See 'ALOC_REG2' .
 |  
 |  is_rrel(self, *args)
 |      See 'ALOC_RREL' .
 |  
 |  is_scattered(self, *args)
 |      See 'ALOC_DIST' .
 |  
 |  is_stkoff(self, *args)
 |      See 'ALOC_STACK' .
 |  
 |  justify_reg_high(self, *args)
 |      Set register offset to justify it to the upper part of _SLOTSIZE.
 |      
 |      justify_reg_high(self, size, _slotsize)
 |          @param size (C++: size_t)
 |          @param _slotsize (C++: size_t)
 |  
 |  justify_stkoff_right(self, *args)
 |      Set stack offset to right-justify it in _SLOTSIZE.
 |      
 |      justify_stkoff_right(self, size, _slotsize)
 |          @param size (C++: size_t)
 |          @param _slotsize (C++: size_t)
 |  
 |  reg1(self, *args)
 |      Get the register info. Use when 'atype()' == 'ALOC_REG1' or
 |      'ALOC_REG2'
 |  
 |  reg2(self, *args)
 |      Get info for the second register. Use when 'atype()' == 'ALOC_REG2'
 |  
 |  regoff(self, *args)
 |      Get offset from the beginning of the register in bytes. Use when
 |      'atype()' == 'ALOC_REG1'
 |  
 |  scattered(self, *args)
 |      Get scattered argument info. Use when 'atype()' == 'ALOC_DIST'
 |  
 |  set_badloc(self, *args)
 |      Set to invalid location.
 |  
 |  set_ea(self, *args)
 |      Set static ea location.
 |      
 |      set_ea(self, _ea)
 |          @param _ea (C++: ea_t)
 |  
 |  set_reg1(self, *args)
 |      Set register location.
 |      
 |      set_reg1(self, reg, off=0)
 |          @param reg (C++: int)
 |          @param off (C++: int)
 |  
 |  set_reg2(self, *args)
 |      Set secondary register location.
 |      
 |      set_reg2(self, _reg1, _reg2)
 |          @param _reg1 (C++: int)
 |          @param _reg2 (C++: int)
 |  
 |  set_stkoff(self, *args)
 |      Set stack offset location.
 |      
 |      set_stkoff(self, off)
 |          @param off (C++: sval_t)
 |  
 |  stkoff(self, *args)
 |      Get the stack offset. Use if 'atype()' == 'ALOC_STACK'
 |  
 |  swap(self, *args)
 |      Assign this == r and r == this.
 |      
 |      swap(self, r)
 |          @param r (C++: argloc_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_argloc_t>
 |      delete_argloc_t(self)

Help on class argpart_t in module ida_typeinf:

class argpart_t(argloc_t)
 |  Proxy of C++ argpart_t class.
 |  
 |  Method resolution order:
 |      argpart_t
 |      argloc_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, a) -> argpart_t
 |          a: argloc_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: argpart_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  bad_offset(self, *args)
 |      Does this argpart have a valid offset?
 |  
 |  bad_size(self, *args)
 |      Does this argpart have a valid size?
 |  
 |  swap(self, *args)
 |      Assign this = r and r = this.
 |      
 |      swap(self, r)
 |          @param r (C++: argpart_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  off
 |      argpart_t_off_get(self) -> ushort
 |  
 |  size
 |      argpart_t_size_get(self) -> ushort
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_argpart_t>
 |      delete_argpart_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from argloc_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: argloc_t const &
 |  
 |  _consume_rrel(self, *args)
 |      Use 'consume_rrel()'
 |      
 |      _consume_rrel(self, p) -> bool
 |          @param p (C++: rrel_t  *)
 |  
 |  _consume_scattered(self, *args)
 |      Use 'consume_scattered()'
 |      
 |      _consume_scattered(self, p) -> bool
 |          @param p (C++: scattered_aloc_t  *)
 |  
 |  _set_badloc(self, *args)
 |      Use 'set_badloc()'
 |  
 |  _set_biggest(self, *args)
 |      Set biggest element in internal union (careful - this function does
 |      not clean up!)
 |      
 |      _set_biggest(self, ct, data)
 |          @param ct (C++: argloc_type_t)
 |          @param data (C++: biggest_t)
 |  
 |  _set_custom(self, *args)
 |      Set custom argument location (careful - this function does not clean
 |      up!)
 |      
 |      _set_custom(self, ct, pdata)
 |          @param ct (C++: argloc_type_t)
 |          @param pdata (C++: void *)
 |  
 |  _set_ea(self, *args)
 |      Use set_ea
 |      
 |      _set_ea(self, _ea)
 |          @param _ea (C++: ea_t)
 |  
 |  _set_reg1(self, *args)
 |      Use 'set_reg1()'
 |      
 |      _set_reg1(self, reg, off=0)
 |          @param reg (C++: int)
 |          @param off (C++: int)
 |  
 |  _set_reg2(self, *args)
 |      Use 'set_reg2()'
 |      
 |      _set_reg2(self, _reg1, _reg2)
 |          @param _reg1 (C++: int)
 |          @param _reg2 (C++: int)
 |  
 |  _set_stkoff(self, *args)
 |      Use 'set_stkoff()'
 |      
 |      _set_stkoff(self, off)
 |          @param off (C++: sval_t)
 |  
 |  advance(self, *args)
 |      Move the location to point 'delta' bytes further.
 |      
 |      advance(self, delta) -> bool
 |          @param delta (C++: int)
 |  
 |  atype(self, *args)
 |      Get type ( 'Argument location types' )
 |  
 |  calc_offset(self, *args)
 |      Calculate offset that can be used to compare 2 similar arglocs.
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: argloc_t const &
 |  
 |  consume_rrel(self, *args)
 |      Set register-relative location - can't be NULL.
 |      
 |      consume_rrel(self, p)
 |          @param p (C++: rrel_t  *)
 |  
 |  consume_scattered(self, *args)
 |      Set distributed argument location.
 |      
 |      consume_scattered(self, p)
 |          @param p (C++: scattered_aloc_t  *)
 |  
 |  get_biggest(self, *args)
 |      Get largest element in internal union.
 |  
 |  get_custom(self, *args)
 |      Get custom argloc info. Use if 'atype()' == 'ALOC_CUSTOM'
 |  
 |  get_ea(self, *args)
 |      Get the global address. Use when 'atype()' == 'ALOC_STATIC'
 |  
 |  get_reginfo(self, *args)
 |      Get all register info. Use when 'atype()' == 'ALOC_REG1' or
 |      'ALOC_REG2'
 |  
 |  get_rrel(self, *args)
 |      Get register-relative info. Use when 'atype()' == 'ALOC_RREL'
 |  
 |  has_reg(self, *args)
 |      TRUE if argloc has a register part.
 |  
 |  has_stkoff(self, *args)
 |      TRUE if argloc has a stack part.
 |  
 |  is_badloc(self, *args)
 |      See 'ALOC_NONE' .
 |  
 |  is_custom(self, *args)
 |      See 'ALOC_CUSTOM' .
 |  
 |  is_ea(self, *args)
 |      See 'ALOC_STATIC' .
 |  
 |  is_fragmented(self, *args)
 |      'is_scattered()' || 'is_reg2()'
 |  
 |  is_mixed_scattered(self, *args)
 |      mixed scattered: consists of register and stack parts
 |  
 |  is_reg(self, *args)
 |      'is_reg1()' || 'is_reg2()'
 |  
 |  is_reg1(self, *args)
 |      See 'ALOC_REG1' .
 |  
 |  is_reg2(self, *args)
 |      See 'ALOC_REG2' .
 |  
 |  is_rrel(self, *args)
 |      See 'ALOC_RREL' .
 |  
 |  is_scattered(self, *args)
 |      See 'ALOC_DIST' .
 |  
 |  is_stkoff(self, *args)
 |      See 'ALOC_STACK' .
 |  
 |  justify_reg_high(self, *args)
 |      Set register offset to justify it to the upper part of _SLOTSIZE.
 |      
 |      justify_reg_high(self, size, _slotsize)
 |          @param size (C++: size_t)
 |          @param _slotsize (C++: size_t)
 |  
 |  justify_stkoff_right(self, *args)
 |      Set stack offset to right-justify it in _SLOTSIZE.
 |      
 |      justify_stkoff_right(self, size, _slotsize)
 |          @param size (C++: size_t)
 |          @param _slotsize (C++: size_t)
 |  
 |  reg1(self, *args)
 |      Get the register info. Use when 'atype()' == 'ALOC_REG1' or
 |      'ALOC_REG2'
 |  
 |  reg2(self, *args)
 |      Get info for the second register. Use when 'atype()' == 'ALOC_REG2'
 |  
 |  regoff(self, *args)
 |      Get offset from the beginning of the register in bytes. Use when
 |      'atype()' == 'ALOC_REG1'
 |  
 |  scattered(self, *args)
 |      Get scattered argument info. Use when 'atype()' == 'ALOC_DIST'
 |  
 |  set_badloc(self, *args)
 |      Set to invalid location.
 |  
 |  set_ea(self, *args)
 |      Set static ea location.
 |      
 |      set_ea(self, _ea)
 |          @param _ea (C++: ea_t)
 |  
 |  set_reg1(self, *args)
 |      Set register location.
 |      
 |      set_reg1(self, reg, off=0)
 |          @param reg (C++: int)
 |          @param off (C++: int)
 |  
 |  set_reg2(self, *args)
 |      Set secondary register location.
 |      
 |      set_reg2(self, _reg1, _reg2)
 |          @param _reg1 (C++: int)
 |          @param _reg2 (C++: int)
 |  
 |  set_stkoff(self, *args)
 |      Set stack offset location.
 |      
 |      set_stkoff(self, off)
 |          @param off (C++: sval_t)
 |  
 |  stkoff(self, *args)
 |      Get the stack offset. Use if 'atype()' == 'ALOC_STACK'
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from argloc_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class argpartvec_t in module ida_typeinf:

class argpartvec_t(__builtin__.object)
 |  Proxy of C++ qvector< argpart_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< argpart_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> argpart_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> argpartvec_t
 |          x: qvector< argpart_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< argpart_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: argpart_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: argpart_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: argpart_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> argpart_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> argpart_t
 |      begin(self) -> argpart_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> argpart_t
 |      end(self) -> argpart_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> argpart_t
 |          it: qvector< argpart_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> argpart_t
 |          first: qvector< argpart_t >::iterator
 |          last: qvector< argpart_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> argpart_t
 |  
 |  find(self, *args)
 |      find(self, x) -> argpart_t
 |          x: argpart_t const &
 |      
 |      
 |      find(self, x) -> argpart_t
 |          x: argpart_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=argpart_t())
 |          x: argpart_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: argpart_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: argpart_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> argpart_t
 |          it: qvector< argpart_t >::iterator
 |          x: argpart_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: argpart_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: argpart_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< argpart_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_argpartvec_t>
 |      delete_argpartvec_t(self)

Help on class argtinfo_helper_t in module ida_typeinf:

class argtinfo_helper_t(__builtin__.object)
 |  Proxy of C++ argtinfo_helper_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> argtinfo_helper_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  has_delay_slot(self, *args)
 |      The call instruction with a delay slot?.
 |      
 |      has_delay_slot(self, arg0) -> bool
 |          arg0: ea_t
 |  
 |  is_stkarg_load(self, *args)
 |      Is the current insn a stkarg load?. if yes:src: index of the source
 |      operand in \insn_t{ops}dst: index of the destination operand in
 |      \insn_t{ops} \insn_t{ops}[dst].addr is expected to have the stack
 |      offset
 |      
 |      is_stkarg_load(self, insn, src, dst) -> bool
 |          @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
 |          @param src (C++: int *)
 |          @param dst (C++: int *)
 |  
 |  set_op_tinfo(self, *args)
 |      Set the operand type as specified.
 |      
 |      set_op_tinfo(self, insn, x, tif, name) -> bool
 |          @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
 |          @param x (C++: const  op_t  &)
 |          @param tif (C++: const  tinfo_t  &)
 |          @param name (C++: const char *)
 |  
 |  use_arg_tinfos(self, *args)
 |      This function is to be called by the processor module in response to
 |      ev_use_arg_types.
 |      
 |      use_arg_tinfos(self, caller, fti, rargs)
 |          @param caller (C++: ea_t)
 |          @param fti (C++: func_type_data_t  *)
 |          @param rargs (C++: funcargvec_t  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  reserved
 |      argtinfo_helper_t_reserved_get(self) -> size_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_argtinfo_helper_t>
 |      delete_argtinfo_helper_t(self)

Help on class array_type_data_t in module ida_typeinf:

class array_type_data_t(__builtin__.object)
 |  Proxy of C++ array_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, b=0, n=0) -> array_type_data_t
 |          b: size_t
 |          n: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  swap(self, *args)
 |      set this = r and r = this
 |      
 |      swap(self, r)
 |          @param r (C++: array_type_data_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  base
 |      array_type_data_t_base_get(self) -> uint32
 |  
 |  elem_type
 |      array_type_data_t_elem_type_get(self) -> tinfo_t
 |  
 |  nelems
 |      array_type_data_t_nelems_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_array_type_data_t>
 |      delete_array_type_data_t(self)

Help on function begin_type_updating in module ida_typeinf:

begin_type_updating(*args)
    Mark the beginning of a large update operation on the types. Can be
    used with 'add_enum_member()' , add_struc_member, etc... Also see
    'end_type_updating()'
    
    begin_type_updating(utp)
        @param utp (C++: update_type_t)

Help on class bitfield_type_data_t in module ida_typeinf:

class bitfield_type_data_t(__builtin__.object)
 |  Proxy of C++ bitfield_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: bitfield_type_data_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: bitfield_type_data_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: bitfield_type_data_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _nbytes=0, _width=0, _is_unsigned=False) -> bitfield_type_data_t
 |          _nbytes: uchar
 |          _width: uchar
 |          _is_unsigned: bool
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: bitfield_type_data_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: bitfield_type_data_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: bitfield_type_data_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: bitfield_type_data_t const &
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: bitfield_type_data_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  is_unsigned
 |      bitfield_type_data_t_is_unsigned_get(self) -> bool
 |  
 |  nbytes
 |      bitfield_type_data_t_nbytes_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  width
 |      bitfield_type_data_t_width_get(self) -> uchar
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_bitfield_type_data_t>
 |      delete_bitfield_type_data_t(self)

Help on function calc_c_cpp_name in module ida_typeinf:

calc_c_cpp_name(*args)
    Get C or C++ form of the name.
    
    calc_c_cpp_name(name, type, ccn_flags) -> str
        @param name: original (mangled or decorated) name (C++: const char *)
        @param type: name type if known, otherwise NULL (C++: const  tinfo_t
                     *)
        @param ccn_flags: one of  C/C++ naming flags (C++: int)

Help on function calc_number_of_children in module ida_typeinf:

calc_number_of_children(*args)
    Calculate max number of lines of a formatted c data, when expanded (
    'PTV_EXPAND' ).
    
    calc_number_of_children(loc, tif, dont_deref_ptr=False) -> int
        @param loc: location of the data ( ALOC_STATIC  or  ALOC_CUSTOM )
                    (C++: const  argloc_t  &)
        @param tif: type info (C++: const  tinfo_t  &)
        @param dont_deref_ptr: consider 'ea' as the ptr value (C++: bool)
        @retval: 0 - data is not expandable
        @retval: -1 - error, see qerrno
        @retval: else - the max number of lines

Help on function calc_tinfo_gaps in module ida_typeinf:

calc_tinfo_gaps(*args)
    calc_tinfo_gaps(out, typid) -> bool
        out: rangeset_t *
        typid: uint32

Help on function calc_type_size in module ida_typeinf:

calc_type_size(*args)
    calc_type_size(ti, tp) -> PyObject *
    Returns the size of a type
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @return:
        - None on failure
        - The size of the type

Help on class callregs_t in module ida_typeinf:

class callregs_t(__builtin__.object)
 |  Proxy of C++ callregs_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> callregs_t
 |          cc: cm_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  by_slots(self, *args)
 |      by_slots(self) -> bool
 |  
 |  init_regs(self, *args)
 |      Init policy & registers for given CC.
 |      
 |      init_regs(self, cc)
 |          @param cc (C++: cm_t)
 |  
 |  reginds(self, *args)
 |      Get register indexes within GP/FP arrays. (-1 -> is not present in the
 |      corresponding array)
 |      
 |      reginds(self, gp_ind, fp_ind, r) -> bool
 |          @param gp_ind (C++: int *)
 |          @param fp_ind (C++: int *)
 |          @param r (C++: int)
 |  
 |  reset(self, *args)
 |      Set policy and registers to invalid values.
 |  
 |  set(self, *args)
 |      Init policy & registers (arrays are -1-terminated)
 |      
 |      set(self, _policy, gprs, fprs)
 |          @param _policy (C++: argreg_policy_t)
 |          @param gprs (C++: const int *)
 |          @param fprs (C++: const int *)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  regcount(*args)
 |      regcount(cc) -> int
 |          cc: cm_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fpregs
 |      callregs_t_fpregs_get(self) -> intvec_t *
 |  
 |  gpregs
 |      callregs_t_gpregs_get(self) -> intvec_t *
 |  
 |  nregs
 |      callregs_t_nregs_get(self) -> int
 |  
 |  policy
 |      callregs_t_policy_get(self) -> argreg_policy_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_callregs_t>
 |      delete_callregs_t(self)

Help on function callregs_t_regcount in module ida_typeinf:

callregs_t_regcount(*args)
    callregs_t_regcount(cc) -> int
        cc: cm_t

Help on function choose_local_tinfo in module ida_typeinf:

choose_local_tinfo(*args)
    Choose a type from the local type library.
    
    choose_local_tinfo(ti, title, func=None, def_ord=0, ud=None) -> uint32
        @param ti: pointer to til (C++: const  til_t  *)
        @param title: title of listbox to display (C++: const char *)
        @param func: predicate to select types to display (maybe NULL) (C++:
                     local_tinfo_predicate_t  *)
        @param def_ord: ordinal to position cursor before choose (C++: uint32)
        @param ud: user data (C++: void *)
        @return: == 0 means nothing is chosen, otherwise an ordinal number

Help on function choose_local_tinfo_and_delta in module ida_typeinf:

choose_local_tinfo_and_delta(*args)
    Choose a type from the local type library and specify the pointer
    shift value.
    
    choose_local_tinfo_and_delta(delta, ti, title, func=None, def_ord=0, ud=None) -> uint32
        @param delta: pointer shift value (C++: int32  *)
        @param ti: pointer to til (C++: const  til_t  *)
        @param title: title of listbox to display (C++: const char *)
        @param func: predicate to select types to display (maybe NULL) (C++:
                     local_tinfo_predicate_t  *)
        @param def_ord: ordinal to position cursor before choose (C++: uint32)
        @param ud: user data (C++: void *)
        @return: == 0 means nothing is chosen, otherwise an ordinal number

Help on function choose_named_type in module ida_typeinf:

choose_named_type(*args)
    Choose a type from a type library.
    
    choose_named_type(out_sym, root_til, title, ntf_flags, predicate=None) -> bool
        @param out_sym: pointer to be filled with the chosen type (C++:
                        til_symbol_t  *)
        @param root_til: pointer to starting til (the function will inspect
                         the base tils if allowed by flags) (C++: const  til_t
                         *)
        @param title: title of listbox to display (C++: const char *)
        @param ntf_flags: combination of  Flags for named types (C++: int)
        @param predicate: predicate to select types to display (maybe NULL)
                          (C++: predicate_t  *)
        @return: false if nothing is chosen, otherwise true

Help on function clear_tinfo_t in module ida_typeinf:

clear_tinfo_t(*args)
    clear_tinfo_t(_this)
        _this: tinfo_t *

Help on function compact_til in module ida_typeinf:

compact_til(*args)
    Collect garbage in til. Must be called before storing the til.
    
    compact_til(ti) -> bool
        @param ti (C++: til_t  *)
        @return: true if any memory was freed

Help on function compare_tinfo in module ida_typeinf:

compare_tinfo(*args)
    compare_tinfo(t1, t2, tcflags) -> bool
        t1: uint32
        t2: uint32
        tcflags: int

Help on class const_aloc_visitor_t in module ida_typeinf:

class const_aloc_visitor_t(__builtin__.object)
 |  Proxy of C++ const_aloc_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> const_aloc_visitor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  visit_location(self, *args)
 |      visit_location(self, v, off, size) -> int
 |          @param v (C++: const  argloc_t  &)
 |          @param off (C++: int)
 |          @param size (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_const_aloc_visitor_t>
 |      delete_const_aloc_visitor_t(self)

Help on function convert_pt_flags_to_hti in module ida_typeinf:

convert_pt_flags_to_hti(*args)
    Convert 'Type parsing flags' to 'Type formatting flags' . Type parsing
    flags lesser than 0x10 don't have stable meaning and will be ignored
    (more on these flags can be seen in idc.idc)
    
    convert_pt_flags_to_hti(pt_flags) -> int
        @param pt_flags (C++: int)

Help on function copy_named_type in module ida_typeinf:

copy_named_type(*args)
    Copy a named type from one til to another. This function will copy the
    specified type and all dependent types from the source type library to
    the destination library.
    
    copy_named_type(dsttil, srctil, name) -> uint32
        @param dsttil: Destination til. It must have orginal types enabled
                       (C++: til_t  *)
        @param srctil: Source til. (C++: const  til_t  *)
        @param name: name of the type to copy (C++: const char *)
        @return: ordinal number of the copied type. 0 means error

Help on function copy_tinfo_t in module ida_typeinf:

copy_tinfo_t(*args)
    copy_tinfo_t(_this, r)
        _this: tinfo_t *
        r: tinfo_t const &

Help on function create_numbered_type_name in module ida_typeinf:

create_numbered_type_name(*args)
    Create anonymous name for numbered type. This name can be used to
    reference a numbered type by its ordinal Ordinal names have the
    following format: '#' + set_de(ord) Returns: -1 if error, otherwise
    the name length
    
    create_numbered_type_name(ord) -> str
        @param ord (C++: int32)

Help on function create_tinfo in module ida_typeinf:

create_tinfo(*args)
    create_tinfo(_this, bt, bt2, ptr) -> bool
        _this: tinfo_t *
        bt: type_t
        bt2: type_t
        ptr: void *

Help on function default_compiler in module ida_typeinf:

default_compiler(*args)
    Get compiler specified by \varmem{inf,idainfo,cc}.

Help on function del_named_type in module ida_typeinf:

del_named_type(*args)
    Delete information about a symbol.
    
    del_named_type(ti, name, ntf_flags) -> bool
        @param ti: type library (C++: til_t  *)
        @param name: name of symbol (C++: const char *)
        @param ntf_flags: combination of  Flags for named types (C++: int)
        @return: success

Help on function del_numbered_type in module ida_typeinf:

del_numbered_type(*args)
    Delete a numbered type.
    
    del_numbered_type(ti, ordinal) -> bool
        @param ti (C++: til_t  *)
        @param ordinal (C++: uint32)

Help on function del_til in module ida_typeinf:

del_til(*args)
    Unload a til file.
    
    del_til(name) -> bool
        @param name (C++: const char *)

Help on function del_tinfo_attr in module ida_typeinf:

del_tinfo_attr(*args)
    del_tinfo_attr(tif, key, make_copy) -> bool
        tif: tinfo_t *
        key: qstring const &
        make_copy: bool

Help on function deref_ptr in module ida_typeinf:

deref_ptr(*args)
    Dereference a pointer.
    
    deref_ptr(ptr_ea, tif, closure_obj=None) -> bool
        @param ptr_ea: in/out parameter   in: address of the pointer   out:
                       the pointed address (C++: ea_t *)
        @param tif: type of the pointer (C++: const  tinfo_t  &)
        @param closure_obj: closure object (not used yet) (C++: ea_t *)
        @return: success

Help on function deserialize_tinfo in module ida_typeinf:

deserialize_tinfo(*args)
    deserialize_tinfo(tif, til, ptype, pfields, pfldcmts) -> bool
        tif: tinfo_t *
        til: til_t const *
        ptype: type_t const **
        pfields: p_list const **
        pfldcmts: p_list const **

Help on function dstr_tinfo in module ida_typeinf:

dstr_tinfo(*args)
    dstr_tinfo(tif) -> char const *
        tif: tinfo_t const *

Help on function dump_func_type_data in module ida_typeinf:

dump_func_type_data(*args)
    Use 'func_type_data_t::dump()'
    
    dump_func_type_data(fti, praloc_bits) -> str
        @param fti (C++: const  func_type_data_t  &)
        @param praloc_bits (C++: int)

Help on function end_type_updating in module ida_typeinf:

end_type_updating(*args)
    Mark the end of a large update operation on the types (see
    'begin_type_updating()' )
    
    end_type_updating(utp)
        @param utp (C++: update_type_t)

Help on class enum_member_t in module ida_typeinf:

class enum_member_t(__builtin__.object)
 |  Proxy of C++ enum_member_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: enum_member_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_member_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: enum_member_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: enum_member_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      enum_member_t_cmt_get(self) -> qstring *
 |  
 |  name
 |      enum_member_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      enum_member_t_value_get(self) -> uint64
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_enum_member_t>
 |      delete_enum_member_t(self)

Help on class enum_member_vec_t in module ida_typeinf:

class enum_member_vec_t(__builtin__.object)
 |  Proxy of C++ qvector< enum_member_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< enum_member_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> enum_member_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_member_vec_t
 |          x: qvector< enum_member_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< enum_member_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: enum_member_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: enum_member_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: enum_member_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> enum_member_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> enum_member_t
 |      begin(self) -> enum_member_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> enum_member_t
 |      end(self) -> enum_member_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> enum_member_t
 |          it: qvector< enum_member_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> enum_member_t
 |          first: qvector< enum_member_t >::iterator
 |          last: qvector< enum_member_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> enum_member_t
 |  
 |  find(self, *args)
 |      find(self, x) -> enum_member_t
 |          x: enum_member_t const &
 |      
 |      
 |      find(self, x) -> enum_member_t
 |          x: enum_member_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=enum_member_t())
 |          x: enum_member_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: enum_member_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: enum_member_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> enum_member_t
 |          it: qvector< enum_member_t >::iterator
 |          x: enum_member_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: enum_member_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: enum_member_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< enum_member_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_enum_member_vec_t>
 |      delete_enum_member_vec_t(self)

Help on class enum_type_data_t in module ida_typeinf:

class enum_type_data_t(enum_member_vec_t)
 |  Proxy of C++ enum_type_data_t class.
 |  
 |  Method resolution order:
 |      enum_type_data_t
 |      enum_member_vec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _bte=BTE_ALWAYS|BTE_HEX) -> enum_type_data_t
 |          _bte: bte_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  calc_mask(self, *args)
 |      calc_mask(self) -> uint64
 |  
 |  calc_nbytes(self, *args)
 |      calc_nbytes(self) -> int
 |  
 |  is_64bit(self, *args)
 |      is_64bit(self) -> bool
 |  
 |  is_char(self, *args)
 |      is_char(self) -> bool
 |  
 |  is_hex(self, *args)
 |      is_hex(self) -> bool
 |  
 |  is_sdec(self, *args)
 |      is_sdec(self) -> bool
 |  
 |  is_udec(self, *args)
 |      is_udec(self) -> bool
 |  
 |  swap(self, *args)
 |      swap two instances
 |      
 |      swap(self, r)
 |          @param r (C++: enum_type_data_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bte
 |      enum_type_data_t_bte_get(self) -> bte_t
 |  
 |  group_sizes
 |      enum_type_data_t_group_sizes_get(self) -> intvec_t *
 |  
 |  taenum_bits
 |      enum_type_data_t_taenum_bits_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_enum_type_data_t>
 |      delete_enum_type_data_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from enum_member_vec_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< enum_member_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> enum_member_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< enum_member_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: enum_member_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: enum_member_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: enum_member_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> enum_member_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> enum_member_t
 |      begin(self) -> enum_member_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> enum_member_t
 |      end(self) -> enum_member_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> enum_member_t
 |          it: qvector< enum_member_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> enum_member_t
 |          first: qvector< enum_member_t >::iterator
 |          last: qvector< enum_member_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> enum_member_t
 |  
 |  find(self, *args)
 |      find(self, x) -> enum_member_t
 |          x: enum_member_t const &
 |      
 |      
 |      find(self, x) -> enum_member_t
 |          x: enum_member_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=enum_member_t())
 |          x: enum_member_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: enum_member_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: enum_member_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> enum_member_t
 |          it: qvector< enum_member_t >::iterator
 |          x: enum_member_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: enum_member_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: enum_member_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from enum_member_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function extract_argloc in module ida_typeinf:

extract_argloc(*args)
    Deserialize argument location.
    
    extract_argloc(vloc, ptype, is_retval) -> bool
        @param vloc (C++: argloc_t  *)
        @param ptype (C++: const  type_t  **)
        @param is_retval (C++: bool)

Help on function find_tinfo_udt_member in module ida_typeinf:

find_tinfo_udt_member(*args)
    find_tinfo_udt_member(udm, typid, strmem_flags) -> int
        udm: udt_member_t *
        typid: uint32
        strmem_flags: int

Help on function first_named_type in module ida_typeinf:

first_named_type(*args)
    Enumerate types. Returns mangled names. Never returns anonymous types.
    To include it, enumerate types by ordinals.
    
    first_named_type(ti, ntf_flags) -> char const *
        @param ti (C++: const  til_t  *)
        @param ntf_flags (C++: int)

Help on function for_all_arglocs in module ida_typeinf:

for_all_arglocs(*args)
    Compress larger argloc types and initiate the aloc visitor.
    
    for_all_arglocs(vv, vloc, size, off=0) -> int
        @param vv (C++: aloc_visitor_t  &)
        @param vloc (C++: argloc_t  &)
        @param size (C++: int)
        @param off (C++: int)

Help on function for_all_const_arglocs in module ida_typeinf:

for_all_const_arglocs(*args)
    See 'for_all_arglocs()'
    
    for_all_const_arglocs(vv, vloc, size, off=0) -> int
        @param vv (C++: const_aloc_visitor_t  &)
        @param vloc (C++: const  argloc_t  &)
        @param size (C++: int)
        @param off (C++: int)

Help on function free_til in module ida_typeinf:

free_til(*args)
    Free memory allocated by til.
    
    free_til(ti)
        @param ti (C++: til_t  *)

Help on function func_has_stkframe_hole in module ida_typeinf:

func_has_stkframe_hole(*args)
    Looks for a hole at the beginning of the stack arguments. Will make
    use of the IDB's 'func_t' function at that place (if present) to help
    determine the presence of such a hole.
    
    func_has_stkframe_hole(ea, fti) -> bool
        @param ea (C++: ea_t)
        @param fti (C++: const  func_type_data_t  &)

Help on class func_type_data_t in module ida_typeinf:

class func_type_data_t(funcargvec_t)
 |  Proxy of C++ func_type_data_t class.
 |  
 |  Method resolution order:
 |      func_type_data_t
 |      funcargvec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_type_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  dump(self, *args)
 |      Dump information that is not always visible in the function prototype.
 |      (argument locations, return location, total stkarg size)
 |      
 |      dump(self, praloc_bits=0x02) -> bool
 |          @param praloc_bits (C++: int)
 |  
 |  get_call_method(self, *args)
 |      get_call_method(self) -> int
 |  
 |  guess_cc(self, *args)
 |      Guess function calling convention use the following info: argument
 |      locations and 'stkargs'
 |      
 |      guess_cc(self, purged, cc_flags) -> cm_t
 |          @param purged (C++: int)
 |          @param cc_flags (C++: int)
 |  
 |  is_high(self, *args)
 |      is_high(self) -> bool
 |  
 |  is_noret(self, *args)
 |      is_noret(self) -> bool
 |  
 |  is_pure(self, *args)
 |      is_pure(self) -> bool
 |  
 |  is_vararg_cc(self, *args)
 |      is_vararg_cc(self) -> bool
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: func_type_data_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cc
 |      func_type_data_t_cc_get(self) -> cm_t
 |  
 |  flags
 |      func_type_data_t_flags_get(self) -> int
 |  
 |  retloc
 |      func_type_data_t_retloc_get(self) -> argloc_t
 |  
 |  rettype
 |      func_type_data_t_rettype_get(self) -> tinfo_t
 |  
 |  spoiled
 |      func_type_data_t_spoiled_get(self) -> reginfovec_t
 |  
 |  stkargs
 |      func_type_data_t_stkargs_get(self) -> uval_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_func_type_data_t>
 |      delete_func_type_data_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from funcargvec_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< funcarg_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> funcarg_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< funcarg_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: funcarg_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: funcarg_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: funcarg_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> funcarg_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> funcarg_t
 |      begin(self) -> funcarg_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> funcarg_t
 |      end(self) -> funcarg_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> funcarg_t
 |          it: qvector< funcarg_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> funcarg_t
 |          first: qvector< funcarg_t >::iterator
 |          last: qvector< funcarg_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> funcarg_t
 |  
 |  find(self, *args)
 |      find(self, x) -> funcarg_t
 |          x: funcarg_t const &
 |      
 |      
 |      find(self, x) -> funcarg_t
 |          x: funcarg_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=funcarg_t())
 |          x: funcarg_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: funcarg_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: funcarg_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> funcarg_t
 |          it: qvector< funcarg_t >::iterator
 |          x: funcarg_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: funcarg_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: funcarg_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from funcargvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class funcarg_t in module ida_typeinf:

class funcarg_t(__builtin__.object)
 |  Proxy of C++ funcarg_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: funcarg_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> funcarg_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: funcarg_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  argloc
 |      funcarg_t_argloc_get(self) -> argloc_t
 |  
 |  cmt
 |      funcarg_t_cmt_get(self) -> qstring *
 |  
 |  flags
 |      funcarg_t_flags_get(self) -> uint32
 |  
 |  name
 |      funcarg_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      funcarg_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_funcarg_t>
 |      delete_funcarg_t(self)

Help on class funcargvec_t in module ida_typeinf:

class funcargvec_t(__builtin__.object)
 |  Proxy of C++ qvector< funcarg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< funcarg_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> funcarg_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> funcargvec_t
 |          x: qvector< funcarg_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< funcarg_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: funcarg_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: funcarg_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: funcarg_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> funcarg_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> funcarg_t
 |      begin(self) -> funcarg_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> funcarg_t
 |      end(self) -> funcarg_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> funcarg_t
 |          it: qvector< funcarg_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> funcarg_t
 |          first: qvector< funcarg_t >::iterator
 |          last: qvector< funcarg_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> funcarg_t
 |  
 |  find(self, *args)
 |      find(self, x) -> funcarg_t
 |          x: funcarg_t const &
 |      
 |      
 |      find(self, x) -> funcarg_t
 |          x: funcarg_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=funcarg_t())
 |          x: funcarg_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: funcarg_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: funcarg_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> funcarg_t
 |          it: qvector< funcarg_t >::iterator
 |          x: funcarg_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: funcarg_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: funcarg_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< funcarg_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_funcargvec_t>
 |      delete_funcargvec_t(self)

Help on function gcc_layout in module ida_typeinf:

gcc_layout(*args)
    Should use the struct/union layout as done by gcc?

Help on function gen_decorate_name in module ida_typeinf:

gen_decorate_name(*args)
    Generic function for 'decorate_name()' (may be used in IDP modules)
    
    gen_decorate_name(name, mangle, cc, type) -> str
        @param name (C++: const char *)
        @param mangle (C++: bool)
        @param cc (C++: cm_t)
        @param type (C++: const  tinfo_t  *)

Help on function gen_use_arg_tinfos in module ida_typeinf:

gen_use_arg_tinfos(*args)
    gen_use_arg_tinfos(caller, fti, rargs, set_optype, is_stkarg_load, has_delay_slot)
        @param caller (C++: ea_t)
        @param fti (C++: func_type_data_t  *)
        @param rargs (C++: funcargvec_t  *)
        @param set_optype (C++: set_op_tinfo_t *)
        @param is_stkarg_load (C++: is_stkarg_load_t *)
        @param has_delay_slot (C++: has_delay_slot_t *)

Help on function gen_use_arg_tinfos2 in module ida_typeinf:

gen_use_arg_tinfos2(*args)
    Do not call this function directly, use 'argtinfo_helper_t' .
    
    gen_use_arg_tinfos2(_this, caller, fti, rargs)
        @param _this (C++: struct  argtinfo_helper_t  *)
        @param caller (C++: ea_t)
        @param fti (C++: func_type_data_t  *)
        @param rargs (C++: funcargvec_t  *)

Help on function get_abi_name in module ida_typeinf:

get_abi_name(*args)
    Get ABI name.

Help on function get_alias_target in module ida_typeinf:

get_alias_target(*args)
    Find the final alias destination. If the ordinal has not been aliased,
    return the specified ordinal itself If failed, returns 0.
    
    get_alias_target(ti, ordinal) -> uint32
        @param ti (C++: const  til_t  *)
        @param ordinal (C++: uint32)

Help on function get_arg_addrs in module ida_typeinf:

get_arg_addrs(*args)
    get_arg_addrs(caller) -> PyObject *
    Retrieve addresses of argument initialization instructions
    
    @param caller: the address of the call instruction
    @return: list of instruction addresses

Help on function get_base_type in module ida_typeinf:

get_base_type(*args)
    Get get basic type bits ( 'TYPE_BASE_MASK' )
    
    get_base_type(t) -> type_t
        @param t (C++: type_t)

Help on function get_c_header_path in module ida_typeinf:

get_c_header_path(*args)
    Get the include directory path of the target compiler.

Help on function get_c_macros in module ida_typeinf:

get_c_macros(*args)
    Get predefined macros for the target compiler.

Help on function get_comp in module ida_typeinf:

get_comp(*args)
    Get compiler bits.
    
    get_comp(comp) -> comp_t
        @param comp (C++: comp_t)

Help on function get_compiler_abbr in module ida_typeinf:

get_compiler_abbr(*args)
    Get abbreviated compiler name.
    
    get_compiler_abbr(id) -> char const *
        @param id (C++: comp_t)

Help on function get_compiler_name in module ida_typeinf:

get_compiler_name(*args)
    Get full compiler name.
    
    get_compiler_name(id) -> char const *
        @param id (C++: comp_t)

Help on function get_compilers in module ida_typeinf:

get_compilers(*args)
    Get names of all built-in compilers.
    
    get_compilers(ids, names, abbrs)
        @param ids (C++: compvec_t  *)
        @param names (C++: qstrvec_t  *)
        @param abbrs (C++: qstrvec_t  *)

Help on function get_enum_member_expr in module ida_typeinf:

get_enum_member_expr(*args)
    Return a C expression that can be used to represent an enum member. If
    the value does not correspond to any single enum member, this function
    tries to find a bitwise combination of enum members that correspond to
    it. If more than half of value bits do not match any enum members, it
    fails.
    
    get_enum_member_expr(tif, serial, value) -> str
        @param tif: enumeration type (C++: const  tinfo_t  &)
        @param serial: which enumeration member to use (0 means the first with
                       the given value) (C++: int)
        @param value: value to search in the enumeration type. only 32-bit
                      number can be handled yet (C++: uint64)
        @return: success

Help on function get_full_type in module ida_typeinf:

get_full_type(*args)
    Get basic type bits + type flags ( 'TYPE_FULL_MASK' )
    
    get_full_type(t) -> type_t
        @param t (C++: type_t)

Help on function get_idainfo_by_type in module ida_typeinf:

get_idainfo_by_type(*args)
    Extract information from a 'tinfo_t' .
    
    get_idainfo_by_type(tif) -> bool
        @param tif: the type to inspect (C++: const  tinfo_t  &)

Help on function get_idati in module ida_typeinf:

get_idati(*args)
    Pointer to the local type library - this til is private for each IDB
    file Function that accepts til_t* uses local type library instead of
    NULL.

Help on function get_named_type in module ida_typeinf:

get_named_type(*args)
    get_named_type(til, name, ntf_flags) -> PyObject *
    Get a type data by its name.
    @param til: the type library
    @param name: the type name
    @param ntf_flags: a combination of NTF_* constants
    @return:
        None on failure
        tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success

Help on function get_named_type64 in module ida_typeinf:

get_named_type64(*args)
    See 'get_named_type()' above.If the value in the 'ti' library is
    32-bit, it will be sign-extended before being stored in the 'value'
    pointer.
    
    get_named_type64(til, name, ntf_flags) -> PyObject *
        til: til_t const *
        @param name (C++: const char *)
        @param ntf_flags (C++: int)

Help on function get_numbered_type in module ida_typeinf:

get_numbered_type(*args)
    Retrieve a type by its ordinal number.
    
    get_numbered_type(til, ordinal) -> PyObject *
        til: til_t const *
        @param ordinal (C++: uint32)

Help on function get_numbered_type_name in module ida_typeinf:

get_numbered_type_name(*args)
    Get type name (if exists) by its ordinal. If the type is anonymous,
    returns "". If failed, returns NULL
    
    get_numbered_type_name(ti, ordinal) -> char const *
        @param ti (C++: const  til_t  *)
        @param ordinal (C++: uint32)

Help on function get_ordinal_from_idb_type in module ida_typeinf:

get_ordinal_from_idb_type(*args)
    Get ordinal number of an idb type (struct/enum). The 'type' parameter
    is used only to determine the kind of the type (struct or enum) Use
    this function to find out the correspondence between idb types and til
    types
    
    get_ordinal_from_idb_type(name, type) -> int
        @param name (C++: const char *)
        @param type (C++: const  type_t  *)

Help on function get_ordinal_qty in module ida_typeinf:

get_ordinal_qty(*args)
    Get number of allocated ordinals.
    
    get_ordinal_qty(ti) -> uint32
        @param ti (C++: const  til_t  *)
        @return: uint32(-1) if failed

Help on function get_scalar_bt in module ida_typeinf:

get_scalar_bt(*args)
    get_scalar_bt(size) -> type_t
        @param size (C++: int)

Help on function get_stock_tinfo in module ida_typeinf:

get_stock_tinfo(*args)
    get_stock_tinfo(tif, id) -> bool
        tif: tinfo_t *
        id: enum stock_type_id_t

Help on function get_tinfo_attr in module ida_typeinf:

get_tinfo_attr(*args)
    get_tinfo_attr(typid, key, bv, all_attrs) -> bool
        typid: uint32
        key: qstring const &
        bv: bytevec_t *
        all_attrs: bool

Help on function get_tinfo_attrs in module ida_typeinf:

get_tinfo_attrs(*args)
    get_tinfo_attrs(typid, tav, include_ref_attrs) -> bool
        typid: uint32
        tav: type_attrs_t *
        include_ref_attrs: bool

Help on function get_tinfo_details in module ida_typeinf:

get_tinfo_details(*args)
    get_tinfo_details(typid, bt2, buf) -> bool
        typid: uint32
        bt2: type_t
        buf: void *

Help on function get_tinfo_pdata in module ida_typeinf:

get_tinfo_pdata(*args)
    get_tinfo_pdata(outptr, typid, what) -> size_t
        outptr: void *
        typid: uint32
        what: int

Help on function get_tinfo_property in module ida_typeinf:

get_tinfo_property(*args)
    get_tinfo_property(typid, gta_prop) -> size_t
        typid: uint32
        gta_prop: int

Help on function get_tinfo_size in module ida_typeinf:

get_tinfo_size(*args)
    get_tinfo_size(p_effalign, typid, gts_code) -> size_t
        p_effalign: uint32 *
        typid: uint32
        gts_code: int

Help on function get_type_flags in module ida_typeinf:

get_type_flags(*args)
    Get type flags ( 'TYPE_FLAGS_MASK' )
    
    get_type_flags(t) -> type_t
        @param t (C++: type_t)

Help on function get_type_ordinal in module ida_typeinf:

get_type_ordinal(*args)
    Get type ordinal by its name.
    
    get_type_ordinal(ti, name) -> int32
        @param ti (C++: const  til_t  *)
        @param name (C++: const char *)

Help on function guess_func_cc in module ida_typeinf:

guess_func_cc(*args)
    Use 'func_type_data_t::guess_cc()'
    
    guess_func_cc(fti, npurged, cc_flags) -> cm_t
        @param fti (C++: const  func_type_data_t  &)
        @param npurged (C++: int)
        @param cc_flags (C++: int)

Help on function guess_tinfo in module ida_typeinf:

guess_tinfo(*args)
    Generate a type information about the id from the disassembly. id can
    be a structure/union/enum id or an address.
    
    guess_tinfo(tif, id) -> int
        @param tif (C++: tinfo_t  *)
        @param id (C++: tid_t)
        @return: one of  Guess tinfo codes

Help on class ida_lowertype_helper_t in module ida_typeinf:

class ida_lowertype_helper_t(lowertype_helper_t)
 |  Proxy of C++ ida_lowertype_helper_t class.
 |  
 |  Method resolution order:
 |      ida_lowertype_helper_t
 |      lowertype_helper_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _tif, _ea, _pb) -> ida_lowertype_helper_t
 |          _tif: tinfo_t const &
 |          _ea: ea_t
 |          _pb: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  func_has_stkframe_hole(self, *args)
 |      func_has_stkframe_hole(self, candidate, candidate_data) -> bool
 |          @param candidate (C++: const  tinfo_t  &)
 |          @param candidate_data (C++: const  func_type_data_t  &)
 |  
 |  get_func_purged_bytes(self, *args)
 |      get_func_purged_bytes(self, candidate, arg3) -> int
 |          @param candidate (C++: const  tinfo_t  &)
 |          arg3: func_type_data_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ida_lowertype_helper_t>
 |      delete_ida_lowertype_helper_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from lowertype_helper_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function idc_get_local_type in module ida_typeinf:

idc_get_local_type(*args)
    idc_get_local_type(ordinal, flags, buf, maxsize) -> int
        ordinal: int
        flags: int
        buf: char *
        maxsize: size_t

Help on function idc_get_local_type_name in module ida_typeinf:

idc_get_local_type_name(*args)
    idc_get_local_type_name(ordinal) -> str
        ordinal: int

Help on function idc_get_local_type_raw in module ida_typeinf:

idc_get_local_type_raw(*args)
    idc_get_local_type_raw(ordinal) -> PyObject *
        ordinal: int

Help on function idc_get_type in module ida_typeinf:

idc_get_type(*args)
    idc_get_type(ea) -> str
        ea: ea_t

Help on function idc_get_type_raw in module ida_typeinf:

idc_get_type_raw(*args)
    idc_get_type_raw(ea) -> PyObject *
        ea: ea_t

Help on function idc_guess_type in module ida_typeinf:

idc_guess_type(*args)
    idc_guess_type(ea) -> str
        ea: ea_t

Help on function idc_parse_decl in module ida_typeinf:

idc_parse_decl(*args)
    idc_parse_decl(ti, decl, flags) -> PyObject *
        ti: til_t *
        decl: char const *
        flags: int

Help on function idc_parse_types in module ida_typeinf:

idc_parse_types(*args)
    idc_parse_types(input, flags) -> int
        input: char const *
        flags: int

Help on function idc_print_type in module ida_typeinf:

idc_print_type(*args)
    idc_print_type(type, fields, name, flags) -> PyObject *
        type: type_t const *
        fields: p_list const *
        name: char const *
        flags: int

Help on function idc_set_local_type in module ida_typeinf:

idc_set_local_type(*args)
    idc_set_local_type(ordinal, dcl, flags) -> int
        ordinal: int
        dcl: char const *
        flags: int

Help on function import_type in module ida_typeinf:

import_type(*args)
    Copy a named type from til to idb.
    
    import_type(til, idx, name, flags=0) -> tid_t
        @param til: type library (C++: const  til_t  *)
        @param idx: the position of the new type in the list of types
                    (structures or enums). -1 means at the end of the list
                    (C++: int)
        @param name: the type name (C++: const char *)
        @param flags: combination of  Import type flags (C++: int)
        @return: BADNODE  on error

Help on function is_autosync in module ida_typeinf:

is_autosync(*args)
    Is the specified idb type automatically synchronized?
    
    is_autosync(name, type) -> bool
        @param name (C++: const char *)
        @param type (C++: const  type_t  *)
    
    
    is_autosync(name, tif) -> bool
        @param name (C++: const char *)
        tif: tinfo_t const &

Help on function is_code_far in module ida_typeinf:

is_code_far(*args)
    Does the given model specify far code?.
    
    is_code_far(cm) -> bool
        @param cm (C++: cm_t)

Help on function is_comp_unsure in module ida_typeinf:

is_comp_unsure(*args)
    See 'COMP_UNSURE' .
    
    is_comp_unsure(comp) -> comp_t
        @param comp (C++: comp_t)

Help on function is_data_far in module ida_typeinf:

is_data_far(*args)
    Does the given model specify far data?.
    
    is_data_far(cm) -> bool
        @param cm (C++: cm_t)

Help on function is_gcc in module ida_typeinf:

is_gcc(*args)
    Is the target compiler 'COMP_GNU' ?

Help on function is_gcc32 in module ida_typeinf:

is_gcc32(*args)
    Is the target compiler 32 bit gcc?

Help on function is_gcc64 in module ida_typeinf:

is_gcc64(*args)
    Is the target compiler 64 bit gcc?

Help on function is_ordinal_name in module ida_typeinf:

is_ordinal_name(*args)
    Check if the name is an ordinal name. Ordinal names have the following
    format: '#' + set_de(ord)
    
    is_ordinal_name(name, ord=None) -> bool
        @param name (C++: const char *)
        @param ord (C++: uint32  *)

Help on function is_purging_cc in module ida_typeinf:

is_purging_cc(*args)
    Does the calling convention clean the stack arguments upon
    return?.this function is valid only for x86 code
    
    is_purging_cc(cm) -> bool
        @param cm (C++: cm_t)

Help on function is_restype_enum in module ida_typeinf:

is_restype_enum(*args)
    is_restype_enum(til, type) -> bool
        @param til (C++: const  til_t  *)
        @param type (C++: const  type_t  *)

Help on function is_restype_struct in module ida_typeinf:

is_restype_struct(*args)
    is_restype_struct(til, type) -> bool
        @param til (C++: const  til_t  *)
        @param type (C++: const  type_t  *)

Help on function is_restype_struni in module ida_typeinf:

is_restype_struni(*args)
    is_restype_struni(til, type) -> bool
        @param til (C++: const  til_t  *)
        @param type (C++: const  type_t  *)

Help on function is_restype_void in module ida_typeinf:

is_restype_void(*args)
    is_restype_void(til, type) -> bool
        @param til (C++: const  til_t  *)
        @param type (C++: const  type_t  *)

Help on function is_sdacl_byte in module ida_typeinf:

is_sdacl_byte(*args)
    Identify an sdacl byte. The first sdacl byte has the following format:
    11xx000x. The sdacl bytes are appended to udt fields. They indicate
    the start of type attributes (as the tah-bytes do). The sdacl bytes
    are used in the udt headers instead of the tah-byte. This is done for
    compatibility with old databases, they were already using sdacl bytes
    in udt headers and as udt field postfixes. (see "sdacl-typeattrs" in
    the type bit definitions)
    
    is_sdacl_byte(t) -> bool
        @param t (C++: type_t)

Help on function is_tah_byte in module ida_typeinf:

is_tah_byte(*args)
    The TAH byte (type attribute header byte) denotes the start of type
    attributes. (see "tah-typeattrs" in the type bit definitions)
    
    is_tah_byte(t) -> bool
        @param t (C++: type_t)

Help on function is_type_arithmetic in module ida_typeinf:

is_type_arithmetic(*args)
    Is the type an arithmetic type? (floating or integral)
    
    is_type_arithmetic(t) -> bool
        @param t (C++: type_t)

Help on function is_type_array in module ida_typeinf:

is_type_array(*args)
    See 'BT_ARRAY' .
    
    is_type_array(t) -> bool
        @param t (C++: type_t)

Help on function is_type_bitfld in module ida_typeinf:

is_type_bitfld(*args)
    See 'BT_BITFIELD' .
    
    is_type_bitfld(t) -> bool
        @param t (C++: type_t)

Help on function is_type_bool in module ida_typeinf:

is_type_bool(*args)
    See 'BTF_BOOL' .
    
    is_type_bool(t) -> bool
        @param t (C++: type_t)

Help on function is_type_char in module ida_typeinf:

is_type_char(*args)
    Does the type specify a char value? (signed or unsigned, see 'Basic
    type: integer' )
    
    is_type_char(t) -> bool
        @param t (C++: type_t)

Help on function is_type_complex in module ida_typeinf:

is_type_complex(*args)
    See 'BT_COMPLEX' .
    
    is_type_complex(t) -> bool
        @param t (C++: type_t)

Help on function is_type_const in module ida_typeinf:

is_type_const(*args)
    See 'BTM_CONST' .
    
    is_type_const(t) -> bool
        @param t (C++: type_t)

Help on function is_type_double in module ida_typeinf:

is_type_double(*args)
    See 'BTF_DOUBLE' .
    
    is_type_double(t) -> bool
        @param t (C++: type_t)

Help on function is_type_enum in module ida_typeinf:

is_type_enum(*args)
    See 'BTF_ENUM' .
    
    is_type_enum(t) -> bool
        @param t (C++: type_t)

Help on function is_type_ext_arithmetic in module ida_typeinf:

is_type_ext_arithmetic(*args)
    Is the type an extended arithmetic type? (arithmetic or enum)
    
    is_type_ext_arithmetic(t) -> bool
        @param t (C++: type_t)

Help on function is_type_ext_integral in module ida_typeinf:

is_type_ext_integral(*args)
    Is the type an extended integral type? (integral or enum)
    
    is_type_ext_integral(t) -> bool
        @param t (C++: type_t)

Help on function is_type_float in module ida_typeinf:

is_type_float(*args)
    See 'BTF_FLOAT' .
    
    is_type_float(t) -> bool
        @param t (C++: type_t)

Help on function is_type_floating in module ida_typeinf:

is_type_floating(*args)
    Is the type a floating point type?
    
    is_type_floating(t) -> bool
        @param t (C++: type_t)

Help on function is_type_func in module ida_typeinf:

is_type_func(*args)
    See 'BT_FUNC' .
    
    is_type_func(t) -> bool
        @param t (C++: type_t)

Help on function is_type_int in module ida_typeinf:

is_type_int(*args)
    Does the type_t specify one of the basic types in 'Basic type:
    integer' ?
    
    is_type_int(bt) -> bool
        @param bt (C++: type_t)

Help on function is_type_int128 in module ida_typeinf:

is_type_int128(*args)
    Does the type specify a 128-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    is_type_int128(t) -> bool
        @param t (C++: type_t)

Help on function is_type_int16 in module ida_typeinf:

is_type_int16(*args)
    Does the type specify a 16-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    is_type_int16(t) -> bool
        @param t (C++: type_t)

Help on function is_type_int32 in module ida_typeinf:

is_type_int32(*args)
    Does the type specify a 32-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    is_type_int32(t) -> bool
        @param t (C++: type_t)

Help on function is_type_int64 in module ida_typeinf:

is_type_int64(*args)
    Does the type specify a 64-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    is_type_int64(t) -> bool
        @param t (C++: type_t)

Help on function is_type_integral in module ida_typeinf:

is_type_integral(*args)
    Is the type an integral type (char/short/int/long/bool)?
    
    is_type_integral(t) -> bool
        @param t (C++: type_t)

Help on function is_type_ldouble in module ida_typeinf:

is_type_ldouble(*args)
    See 'BTF_LDOUBLE' .
    
    is_type_ldouble(t) -> bool
        @param t (C++: type_t)

Help on function is_type_paf in module ida_typeinf:

is_type_paf(*args)
    Is the type a pointer, array, or function type?
    
    is_type_paf(t) -> bool
        @param t (C++: type_t)

Help on function is_type_partial in module ida_typeinf:

is_type_partial(*args)
    Identifies an unknown or void type with a known size (see 'Basic type:
    unknown & void' )
    
    is_type_partial(t) -> bool
        @param t (C++: type_t)

Help on function is_type_ptr in module ida_typeinf:

is_type_ptr(*args)
    See 'BT_PTR' .
    
    is_type_ptr(t) -> bool
        @param t (C++: type_t)

Help on function is_type_ptr_or_array in module ida_typeinf:

is_type_ptr_or_array(*args)
    Is the type a pointer or array type?
    
    is_type_ptr_or_array(t) -> bool
        @param t (C++: type_t)

Help on function is_type_struct in module ida_typeinf:

is_type_struct(*args)
    See 'BTF_STRUCT' .
    
    is_type_struct(t) -> bool
        @param t (C++: type_t)

Help on function is_type_struni in module ida_typeinf:

is_type_struni(*args)
    Is the type a struct or union?
    
    is_type_struni(t) -> bool
        @param t (C++: type_t)

Help on function is_type_sue in module ida_typeinf:

is_type_sue(*args)
    Is the type a struct/union/enum?
    
    is_type_sue(t) -> bool
        @param t (C++: type_t)

Help on function is_type_tbyte in module ida_typeinf:

is_type_tbyte(*args)
    See 'BTF_FLOAT' .
    
    is_type_tbyte(t) -> bool
        @param t (C++: type_t)

Help on function is_type_typedef in module ida_typeinf:

is_type_typedef(*args)
    See 'BTF_TYPEDEF' .
    
    is_type_typedef(t) -> bool
        @param t (C++: type_t)

Help on function is_type_uchar in module ida_typeinf:

is_type_uchar(*args)
    See 'BTF_UCHAR' .
    
    is_type_uchar(t) -> bool
        @param t (C++: type_t)

Help on function is_type_uint in module ida_typeinf:

is_type_uint(*args)
    See 'BTF_UINT' .
    
    is_type_uint(t) -> bool
        @param t (C++: type_t)

Help on function is_type_uint128 in module ida_typeinf:

is_type_uint128(*args)
    See 'BTF_UINT128' .
    
    is_type_uint128(t) -> bool
        @param t (C++: type_t)

Help on function is_type_uint16 in module ida_typeinf:

is_type_uint16(*args)
    See 'BTF_UINT16' .
    
    is_type_uint16(t) -> bool
        @param t (C++: type_t)

Help on function is_type_uint32 in module ida_typeinf:

is_type_uint32(*args)
    See 'BTF_UINT32' .
    
    is_type_uint32(t) -> bool
        @param t (C++: type_t)

Help on function is_type_uint64 in module ida_typeinf:

is_type_uint64(*args)
    See 'BTF_UINT64' .
    
    is_type_uint64(t) -> bool
        @param t (C++: type_t)

Help on function is_type_union in module ida_typeinf:

is_type_union(*args)
    See 'BTF_UNION' .
    
    is_type_union(t) -> bool
        @param t (C++: type_t)

Help on function is_type_unknown in module ida_typeinf:

is_type_unknown(*args)
    See 'BT_UNKNOWN' .
    
    is_type_unknown(t) -> bool
        @param t (C++: type_t)

Help on function is_type_void in module ida_typeinf:

is_type_void(*args)
    See 'BTF_VOID' .
    
    is_type_void(t) -> bool
        @param t (C++: type_t)

Help on function is_type_volatile in module ida_typeinf:

is_type_volatile(*args)
    See 'BTM_VOLATILE' .
    
    is_type_volatile(t) -> bool
        @param t (C++: type_t)

Help on function is_typeid_last in module ida_typeinf:

is_typeid_last(*args)
    Is the type_t the last byte of type declaration? (there are no
    additional bytes after a basic type, see '_BT_LAST_BASIC' )
    
    is_typeid_last(t) -> bool
        @param t (C++: type_t)

Help on function is_user_cc in module ida_typeinf:

is_user_cc(*args)
    Does the calling convention specify argument locations explicitly?
    
    is_user_cc(cm) -> bool
        @param cm (C++: cm_t)

Help on function is_vararg_cc in module ida_typeinf:

is_vararg_cc(*args)
    Does the calling convention use ellipsis?
    
    is_vararg_cc(cm) -> bool
        @param cm (C++: cm_t)

Help on function lexcompare_tinfo in module ida_typeinf:

lexcompare_tinfo(*args)
    lexcompare_tinfo(t1, t2, arg3) -> int
        t1: uint32
        t2: uint32
        arg3: int

Help on function load_til in module ida_typeinf:

load_til(*args)
    Load til from a file. Failure to load base tils are reported into
    'errbuf'. They do not prevent loading of the main til.
    
    load_til(name, tildir=None) -> til_t
        @param name: filename of the til. If it's an absolute path, tildir is
                     ignored.   NB: the file extension is forced to .til (C++:
                     const char *)
        @param tildir: directory where to load the til from. NULL means
                       default til subdirectories. (C++: const char *)
        @return: pointer to resulting til, NULL if failed and error message is
                 in errbuf

Help on function load_til_header in module ida_typeinf:

load_til_header(*args)
    Get human-readable til description.
    
    load_til_header(tildir, name) -> til_t
        @param tildir (C++: const char *)
        @param name (C++: const char *)

Help on function lower_type in module ida_typeinf:

lower_type(*args)
    Lower type. Inspect the type and lower all function subtypes using
    lower_func_type().We call the prototypes usually encountered in source
    files "high level"They may have implicit arguments, array arguments,
    big structure retvals, etcWe introduce explicit arguments (i.e. 'this'
    pointer) and call the result"low level prototype". See 'FTI_HIGH' .In
    order to improve heuristics for recognition of big structure
    retvals,it is recommended to pass a helper that will be used to make
    decisions.That helper will be used only for lowering 'tif', and not
    for the childrentypes walked through by recursion.
    
    lower_type(til, tif, name=None, _helper=None) -> int
        @param til (C++: til_t  *)
        @param tif (C++: tinfo_t  *)
        @param name (C++: const char *)
        @param _helper (C++: lowertype_helper_t  *)
        @retval: 1 - removed  FTI_HIGH ,
        @retval: 2 - made substantial changes
        @retval: -1 - failure

Help on class lowertype_helper_t in module ida_typeinf:

class lowertype_helper_t(__builtin__.object)
 |  Proxy of C++ lowertype_helper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  func_has_stkframe_hole(self, *args)
 |      func_has_stkframe_hole(self, candidate, candidate_data) -> bool
 |          @param candidate (C++: const  tinfo_t  &)
 |          @param candidate_data (C++: const  func_type_data_t  &)
 |  
 |  get_func_purged_bytes(self, *args)
 |      get_func_purged_bytes(self, candidate, candidate_data) -> int
 |          @param candidate (C++: const  tinfo_t  &)
 |          @param candidate_data (C++: const  func_type_data_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_lowertype_helper_t>
 |      delete_lowertype_helper_t(self)

Help on function new_til in module ida_typeinf:

new_til(*args)
    Initialize a til.
    
    new_til(name, desc) -> til_t
        @param name (C++: const char *)
        @param desc (C++: const char *)

Help on function next_named_type in module ida_typeinf:

next_named_type(*args)
    Enumerate types. Returns mangled names. Never returns anonymous types.
    To include it, enumerate types by ordinals.
    
    next_named_type(ti, name, ntf_flags) -> char const *
        @param ti (C++: const  til_t  *)
        @param name (C++: const char *)
        @param ntf_flags (C++: int)

Help on function optimize_argloc in module ida_typeinf:

optimize_argloc(*args)
    Verify and optimize scattered argloc into simple form. All new arglocs
    must be processed by this function.
    
    optimize_argloc(vloc, size, gaps) -> bool
        @param vloc (C++: argloc_t  *)
        @param size (C++: int)
        @param gaps (C++: const  rangeset_t  *)
        @retval: true - success
        @retval: false - the input argloc was illegal

Help on function pack_idcobj_to_bv in module ida_typeinf:

pack_idcobj_to_bv(*args)
    Write a typed idc object to the byte vector. Byte vector may be non-
    empty, this function will append data to it
    
    pack_idcobj_to_bv(obj, tif, bytes, objoff, pio_flags=0) -> error_t
        @param obj (C++: const  idc_value_t  *)
        @param tif (C++: const  tinfo_t  &)
        @param bytes (C++: relobj_t  *)
        @param objoff (C++: void *)
        @param pio_flags (C++: int)

Help on function pack_idcobj_to_idb in module ida_typeinf:

pack_idcobj_to_idb(*args)
    Write a typed idc object to the database.
    
    pack_idcobj_to_idb(obj, tif, ea, pio_flags=0) -> error_t
        @param obj (C++: const  idc_value_t  *)
        @param tif (C++: const  tinfo_t  &)
        @param ea (C++: ea_t)
        @param pio_flags (C++: int)

Help on function pack_object_to_bv in module ida_typeinf:

pack_object_to_bv(*args)
    pack_object_to_bv(py_obj, ti, type, fields, base_ea, pio_flags=0) -> PyObject *
    Packs a typed object to a string
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @param fields: fields string (may be empty or None)
    @param base_ea: base ea used to relocate the pointers in the packed object
    @param pio_flags: flags used while unpacking
    @return:
        tuple(0, err_code) on failure
        tuple(1, packed_buf) on success

Help on function pack_object_to_idb in module ida_typeinf:

pack_object_to_idb(*args)
    pack_object_to_idb(py_obj, ti, type, fields, ea, pio_flags=0) -> PyObject *
    Write a typed object to the database.
    Raises an exception if wrong parameters were passed or conversion fails
    Returns the error_t returned by idaapi.pack_object_to_idb
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @param fields: fields string (may be empty or None)
    @param ea: ea to be used while packing
    @param pio_flags: flags used while unpacking

Help on function parse_decl in module ida_typeinf:

parse_decl(*args)
    Parse ONE declaration. If the input string contains more than one
    declaration, the first complete type declaration ( 'PT_TYP' ) or the
    last variable declaration ( 'PT_VAR' ) will be used.name & tif may be
    empty after the call!
    
    parse_decl(tif, til, decl, flags) -> str
        @param tif: type info (C++: tinfo_t  *)
        @param til: type library to use. may be NULL (C++: til_t  *)
        @param decl: C declaration to parse (C++: const char *)
        @param flags: combination of  Type parsing flags  bits (C++: int)
        @retval: true - ok
        @retval: false - declaration is bad, the error message is displayed if
                         !PT_SIL

Help on function parse_decls in module ida_typeinf:

parse_decls(*args)
    Parse many declarations and store them in a til. If there are any
    errors, they will be printed using 'printer'. This function uses
    default include path and predefined macros from the database settings.
    It always uses the 'HTI_DCL' bit.
    
    parse_decls(til, input, printer, hti_flags) -> int
        @param til: type library to store the result (C++: til_t  *)
        @param input: input string or file name (see hti_flags) (C++: const
                      char *)
        @param printer: function to output error messages (use msg or NULL or
                        your own callback) (C++: printer_t  *)
        @param hti_flags: combination of  Type formatting flags (C++: int)
        @return: number of errors, 0 means ok.

Help on class predicate_t in module ida_typeinf:

class predicate_t(__builtin__.object)
 |  Proxy of C++ predicate_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> predicate_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  should_display(self, *args)
 |      should_display(self, til, name, type, fields) -> bool
 |          @param til (C++: const  til_t  *)
 |          @param name (C++: const char *)
 |          @param type (C++: const  type_t  *)
 |          @param fields (C++: const  p_list  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_predicate_t>
 |      delete_predicate_t(self)

Help on function print_argloc in module ida_typeinf:

print_argloc(*args)
    Convert an argloc to human readable form.
    
    print_argloc(vloc, size=0, vflags=0) -> str
        @param vloc (C++: const  argloc_t  &)
        @param size (C++: int)
        @param vflags (C++: int)

Help on function print_decls in module ida_typeinf:

print_decls(*args)
    Print types (and possibly their dependencies) in a format suitable for
    use in a header file. This is the reverse 'parse_decls()' .
    
    print_decls(printer, til, py_ordinals, flags) -> PyObject *
        @param printer: a handler for printing text (C++: text_sink_t  &)
        @param til: the type library holding the ordinals (C++: til_t  *)
        py_ordinals: PyObject *
        @param flags: flags for the algorithm. A combination of PDF_*
                      constants (C++: uint32)
        @retval: >0 - the number of types exported
        @retval: 0 - an error occurred
        @retval: <0 - the negated number of types exported. There were minor
                      errors and the resulting output might not be compilable.

Help on function print_tinfo in module ida_typeinf:

print_tinfo(*args)
    print_tinfo(prefix, indent, cmtindent, flags, tif, name, cmt) -> str
        prefix: char const *
        indent: int
        cmtindent: int
        flags: int
        tif: tinfo_t const *
        name: char const *
        cmt: char const *

Help on function print_type in module ida_typeinf:

print_type(*args)
    Get type declaration for the specified address.
    
    print_type(ea, prtype_flags) -> str
        @param ea: address (C++: ea_t)
        @param prtype_flags: combination of  Type printing flags (C++: int)
        @return: success

Help on class ptr_type_data_t in module ida_typeinf:

class ptr_type_data_t(__builtin__.object)
 |  Proxy of C++ ptr_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: ptr_type_data_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, c=tinfo_t(), bps=0, p=tinfo_t(), d=0) -> ptr_type_data_t
 |          c: tinfo_t
 |          bps: uchar
 |          p: tinfo_t
 |          d: int32
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: ptr_type_data_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  is_code_ptr(self, *args)
 |      Are we pointing to code?
 |  
 |  is_shifted(self, *args)
 |      is_shifted(self) -> bool
 |  
 |  swap(self, *args)
 |      Set this = r and r = this.
 |      
 |      swap(self, r)
 |          @param r (C++: ptr_type_data_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  based_ptr_size
 |      ptr_type_data_t_based_ptr_size_get(self) -> uchar
 |  
 |  closure
 |      ptr_type_data_t_closure_get(self) -> tinfo_t
 |  
 |  delta
 |      ptr_type_data_t_delta_get(self) -> int32
 |  
 |  obj_type
 |      ptr_type_data_t_obj_type_get(self) -> tinfo_t
 |  
 |  parent
 |      ptr_type_data_t_parent_get(self) -> tinfo_t
 |  
 |  taptr_bits
 |      ptr_type_data_t_taptr_bits_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_ptr_type_data_t>
 |      delete_ptr_type_data_t(self)

Help on function read_tinfo_bitfield_value in module ida_typeinf:

read_tinfo_bitfield_value(*args)
    read_tinfo_bitfield_value(typid, v, bitoff) -> uint64
        typid: uint32
        v: uint64
        bitoff: int

Help on class reginfovec_t in module ida_typeinf:

class reginfovec_t(__builtin__.object)
 |  Proxy of C++ qvector< reg_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< reg_info_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> reg_info_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reginfovec_t
 |          x: qvector< reg_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< reg_info_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: reg_info_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: reg_info_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: reg_info_t const &
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> reg_info_t
 |      begin(self) -> reg_info_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> reg_info_t
 |      end(self) -> reg_info_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> reg_info_t
 |          it: qvector< reg_info_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> reg_info_t
 |          first: qvector< reg_info_t >::iterator
 |          last: qvector< reg_info_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> reg_info_t
 |  
 |  find(self, *args)
 |      find(self, x) -> reg_info_t
 |          x: reg_info_t const &
 |      
 |      
 |      find(self, x) -> reg_info_t
 |          x: reg_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=reg_info_t())
 |          x: reg_info_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: reg_info_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: reg_info_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> reg_info_t
 |          it: qvector< reg_info_t >::iterator
 |          x: reg_info_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: reg_info_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: reg_info_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< reg_info_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_reginfovec_t>
 |      delete_reginfovec_t(self)

Help on class regobj_t in module ida_typeinf:

class regobj_t(__builtin__.object)
 |  Proxy of C++ regobj_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regobj_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  regidx
 |      regobj_t_regidx_get(self) -> int
 |  
 |  relocate
 |      regobj_t_relocate_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      regobj_t_value_get(self) -> bytevec_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_regobj_t>
 |      delete_regobj_t(self)

Help on class regobjs_t in module ida_typeinf:

class regobjs_t(regobjvec_t)
 |  Proxy of C++ regobjs_t class.
 |  
 |  Method resolution order:
 |      regobjs_t
 |      regobjvec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regobjs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_regobjs_t>
 |      delete_regobjs_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from regobjvec_t:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> regobj_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: regobj_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> regobj_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> regobj_t
 |      begin(self) -> regobj_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> regobj_t
 |      end(self) -> regobj_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> regobj_t
 |          it: qvector< regobj_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> regobj_t
 |          first: qvector< regobj_t >::iterator
 |          last: qvector< regobj_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> regobj_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=regobj_t())
 |          x: regobj_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: regobj_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> regobj_t
 |          it: qvector< regobj_t >::iterator
 |          x: regobj_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: regobj_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: regobj_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< regobj_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from regobjvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class regobjvec_t in module ida_typeinf:

class regobjvec_t(__builtin__.object)
 |  Proxy of C++ qvector< regobj_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> regobj_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regobjvec_t
 |          x: qvector< regobj_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: regobj_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> regobj_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> regobj_t
 |      begin(self) -> regobj_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> regobj_t
 |      end(self) -> regobj_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> regobj_t
 |          it: qvector< regobj_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> regobj_t
 |          first: qvector< regobj_t >::iterator
 |          last: qvector< regobj_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> regobj_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=regobj_t())
 |          x: regobj_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: regobj_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> regobj_t
 |          it: qvector< regobj_t >::iterator
 |          x: regobj_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: regobj_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: regobj_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< regobj_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_regobjvec_t>
 |      delete_regobjvec_t(self)

Help on function remove_abi_opts in module ida_typeinf:

remove_abi_opts(*args)
    remove_abi_opts(abi_opts, user_level=False) -> bool
        @param abi_opts (C++: const char *)
        @param user_level (C++: bool)

Help on function remove_pointer in module ida_typeinf:

remove_pointer(*args)
    'BT_PTR' : If the current type is a pointer, return the pointed
    object. If the current type is not a pointer, return the current type.
    See also get_ptrarr_object() and get_pointed_object()
    
    remove_pointer(tif) -> tinfo_t
        @param tif (C++: const  tinfo_t  &)

Help on function remove_tinfo_pointer in module ida_typeinf:

remove_tinfo_pointer(*args)
    Remove pointer of a type. (i.e. convert "char *" into "char").
    Optionally remove the "lp" (or similar) prefix of the input name. If
    the input type is not a pointer, then fail.
    
    remove_tinfo_pointer(tif, name, til) -> PyObject *
        @param tif (C++: tinfo_t  *)
        name: char const *
        @param til (C++: const  til_t  *)

Help on function replace_ordinal_typerefs in module ida_typeinf:

replace_ordinal_typerefs(*args)
    Replace references to ordinal types by name references. This function
    'unties' the type from the current local type library and makes it
    easier to export it.
    
    replace_ordinal_typerefs(til, tif) -> int
        @param til: type library to use. may be NULL. (C++: til_t  *)
        @param tif: type to modify (in/out) (C++: tinfo_t  *)
        @retval: number - of replaced subtypes, -1 on failure

Help on function resolve_typedef in module ida_typeinf:

resolve_typedef(*args)
    resolve_typedef(til, type) -> type_t const *
        @param til (C++: const  til_t  *)
        @param type (C++: const  type_t  *)

Help on class rrel_t in module ida_typeinf:

class rrel_t(__builtin__.object)
 |  Proxy of C++ rrel_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rrel_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      rrel_t_off_get(self) -> sval_t
 |  
 |  reg
 |      rrel_t_reg_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_rrel_t>
 |      delete_rrel_t(self)

Help on function save_tinfo in module ida_typeinf:

save_tinfo(*args)
    save_tinfo(tif, til, ord, name, ntf_flags) -> tinfo_code_t
        tif: tinfo_t *
        til: til_t *
        ord: size_t
        name: char const *
        ntf_flags: int

Help on class scattered_aloc_t in module ida_typeinf:

class scattered_aloc_t(argpartvec_t)
 |  Proxy of C++ scattered_aloc_t class.
 |  
 |  Method resolution order:
 |      scattered_aloc_t
 |      argpartvec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> scattered_aloc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_scattered_aloc_t>
 |      delete_scattered_aloc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from argpartvec_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< argpart_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> argpart_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< argpart_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: argpart_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: argpart_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: argpart_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> argpart_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> argpart_t
 |      begin(self) -> argpart_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> argpart_t
 |      end(self) -> argpart_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> argpart_t
 |          it: qvector< argpart_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> argpart_t
 |          first: qvector< argpart_t >::iterator
 |          last: qvector< argpart_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> argpart_t
 |  
 |  find(self, *args)
 |      find(self, x) -> argpart_t
 |          x: argpart_t const &
 |      
 |      
 |      find(self, x) -> argpart_t
 |          x: argpart_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=argpart_t())
 |          x: argpart_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: argpart_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: argpart_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> argpart_t
 |          it: qvector< argpart_t >::iterator
 |          x: argpart_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: argpart_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: argpart_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< argpart_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from argpartvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function score_tinfo in module ida_typeinf:

score_tinfo(*args)
    score_tinfo(tif) -> uint32
        tif: tinfo_t const *

Help on function serialize_tinfo in module ida_typeinf:

serialize_tinfo(*args)
    serialize_tinfo(type, fields, fldcmts, tif, sudt_flags) -> bool
        type: qtype *
        fields: qtype *
        fldcmts: qtype *
        tif: tinfo_t const *
        sudt_flags: int

Help on function set_abi_name in module ida_typeinf:

set_abi_name(*args)
    Set abi name (see 'Compiler IDs' )
    
    set_abi_name(abiname, user_level=False) -> bool
        @param abiname (C++: const char *)
        @param user_level (C++: bool)

Help on function set_c_header_path in module ida_typeinf:

set_c_header_path(*args)
    Set include directory path the target compiler.
    
    set_c_header_path(incdir)
        @param incdir (C++: const char *)

Help on function set_c_macros in module ida_typeinf:

set_c_macros(*args)
    Set predefined macros for the target compiler.
    
    set_c_macros(macros)
        @param macros (C++: const char *)

Help on function set_compiler in module ida_typeinf:

set_compiler(*args)
    Change current compiler.
    
    set_compiler(cc, flags, abiname=None) -> bool
        @param cc: compiler to switch to (C++: const  compiler_info_t  &)
        @param flags: Set compiler flags (C++: int)
        @param abiname: ABI name (C++: const char *)
        @return: success

Help on function set_compiler_id in module ida_typeinf:

set_compiler_id(*args)
    Set the compiler id (see 'Compiler IDs' )
    
    set_compiler_id(id, abiname=None) -> bool
        @param id (C++: comp_t)
        @param abiname (C++: const char *)

Help on function set_compiler_string in module ida_typeinf:

set_compiler_string(*args)
    set_compiler_string(compstr, user_level) -> bool
        @param compstr: - compiler description in form <abbr>:<abiname> (C++:
                        const char *)
        @param user_level: - initiated by user if TRUE (C++: bool)
        @return: success

Help on function set_numbered_type in module ida_typeinf:

set_numbered_type(*args)
    Store a type in the til. 'name' may be NULL for anonymous types. The
    specified ordinal must be free (no other type is using it). For
    ntf_flags, only 'NTF_REPLACE' is consulted.
    
    set_numbered_type(ti, ordinal, ntf_flags, name, type, fields=None, cmt=None, fldcmts=None, sclass=None) -> tinfo_code_t
        @param ti (C++: til_t  *)
        @param ordinal (C++: uint32)
        @param ntf_flags (C++: int)
        @param name (C++: const char *)
        @param type (C++: const  type_t  *)
        @param fields (C++: const  p_list  *)
        @param cmt (C++: const char *)
        @param fldcmts (C++: const  p_list  *)
        @param sclass (C++: const  sclass_t  *)

Help on function set_tinfo_attr in module ida_typeinf:

set_tinfo_attr(*args)
    set_tinfo_attr(tif, ta, may_overwrite) -> bool
        tif: tinfo_t *
        ta: type_attr_t const &
        may_overwrite: bool

Help on function set_tinfo_attrs in module ida_typeinf:

set_tinfo_attrs(*args)
    set_tinfo_attrs(tif, ta) -> bool
        tif: tinfo_t *
        ta: type_attrs_t *

Help on function set_tinfo_property in module ida_typeinf:

set_tinfo_property(*args)
    set_tinfo_property(tif, sta_prop, x) -> size_t
        tif: tinfo_t *
        sta_prop: int
        x: size_t

Help on function set_type_alias in module ida_typeinf:

set_type_alias(*args)
    Create a type alias. Redirects all references to source type to the
    destination type. This is equivalent to instantaneous replacement all
    reference to srctype by dsttype.
    
    set_type_alias(ti, src_ordinal, dst_ordinal) -> bool
        @param ti (C++: til_t  *)
        @param src_ordinal (C++: uint32)
        @param dst_ordinal (C++: uint32)

Help on class simd_info_t in module ida_typeinf:

class simd_info_t(__builtin__.object)
 |  Proxy of C++ simd_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, nm=None, sz=0, memt=BTF_UNK) -> simd_info_t
 |          nm: char const *
 |          sz: uint16
 |          memt: type_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  match_pattern(self, *args)
 |      match_pattern(self, pattern) -> bool
 |          @param pattern (C++: const  simd_info_t  *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  memtype
 |      simd_info_t_memtype_get(self) -> type_t
 |  
 |  name
 |      simd_info_t_name_get(self) -> char const *
 |  
 |  size
 |      simd_info_t_size_get(self) -> uint16
 |  
 |  thisown
 |      The membership flag
 |  
 |  tif
 |      simd_info_t_tif_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_simd_info_t>
 |      delete_simd_info_t(self)

Help on function store_til in module ida_typeinf:

store_til(*args)
    Store til to a file. If the til contains garbage, it will be collected
    before storing the til. Your plugin should call 'compact_til()' before
    calling 'store_til()' .
    
    store_til(ti, tildir, name) -> bool
        @param ti: type library to store (C++: til_t  *)
        @param tildir: directory where to store the til. NULL means current
                       directory. (C++: const char *)
        @param name: filename of the til. If it's an absolute path, tildir is
                     ignored.   NB: the file extension is forced to .til (C++:
                     const char *)
        @return: success

Help on class text_sink_t in module ida_typeinf:

class text_sink_t(__builtin__.object)
 |  Proxy of C++ text_sink_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> text_sink_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args)
 |      _print(self, str) -> int
 |          str: char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_text_sink_t>
 |      delete_text_sink_t(self)

Help on class til_symbol_t in module ida_typeinf:

class til_symbol_t(__builtin__.object)
 |  Proxy of C++ til_symbol_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, n=None, t=None) -> til_symbol_t
 |          n: char const *
 |          t: til_t const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      til_symbol_t_name_get(self) -> char const *
 |  
 |  thisown
 |      The membership flag
 |  
 |  til
 |      til_symbol_t_til_get(self) -> til_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_til_symbol_t>
 |      delete_til_symbol_t(self)

Help on class til_t in module ida_typeinf:

class til_t(__builtin__.object)
 |  Proxy of C++ til_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> til_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  base(self, *args)
 |      base(self, n) -> til_t
 |          n: int
 |  
 |  is_dirty(self, *args)
 |      Has the til been modified? ( 'TIL_MOD' )
 |  
 |  set_dirty(self, *args)
 |      Mark the til as modified ( 'TIL_MOD' )
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cc
 |      til_t_cc_get(self) -> compiler_info_t
 |  
 |  desc
 |      til_t_desc_get(self) -> char *
 |  
 |  flags
 |      til_t_flags_get(self) -> uint32
 |  
 |  name
 |      til_t_name_get(self) -> char *
 |  
 |  nbases
 |      til_t_nbases_get(self) -> int
 |  
 |  nrefs
 |      til_t_nrefs_get(self) -> int
 |  
 |  nstreams
 |      til_t_nstreams_get(self) -> int
 |  
 |  streams
 |      til_t_streams_get(self) -> til_stream_t **
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_til_t>
 |      delete_til_t(self)

Help on class tinfo_t in module ida_typeinf:

class tinfo_t(__builtin__.object)
 |  Proxy of C++ tinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: tinfo_t const &
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: tinfo_t const &
 |  
 |  __gt__(self, *args)
 |      __gt__(self, r) -> bool
 |          r: tinfo_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tinfo_t
 |          decl_type: type_t
 |      
 |      
 |      __init__(self, r) -> tinfo_t
 |          r: tinfo_t const &
 |  
 |  __le__(self, *args)
 |      __le__(self, r) -> bool
 |          r: tinfo_t const &
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: tinfo_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: tinfo_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args)
 |      __str__(self) -> qstring
 |  
 |  _print(self, *args)
 |      _print(self, name=None, prtype_flags=0, indent=0, cmtindent=0, prefix=None, cmt=None) -> bool
 |          name: char const *
 |          prtype_flags: int
 |          indent: int
 |          cmtindent: int
 |          prefix: char const *
 |          cmt: char const *
 |  
 |  append_covered(self, *args)
 |      Calculate set of covered bytes for the type
 |      
 |      append_covered(self, out, offset=0) -> bool
 |          @param out: pointer to the output buffer. covered bytes will be
 |                      appended to it. (C++: rangeset_t  *)
 |          @param offset (C++: uint64)
 |  
 |  calc_gaps(self, *args)
 |      Calculate set of padding bytes for the type
 |      
 |      calc_gaps(self, out) -> bool
 |          @param out: pointer to the output buffer; old buffer contents will be
 |                      lost. (C++: rangeset_t  *)
 |  
 |  calc_purged_bytes(self, *args)
 |      'BT_FUNC' : Calculate number of purged bytes
 |  
 |  calc_score(self, *args)
 |      Calculate the type score (the higher - the nicer is the type)
 |  
 |  calc_udt_aligns(self, *args)
 |      Calculate the udt alignments using the field offsets/sizes and the
 |      total udt size This function does not work on typerefs
 |      
 |      calc_udt_aligns(self, sudt_flags=0x0004) -> bool
 |          @param sudt_flags (C++: int)
 |  
 |  change_sign(self, *args)
 |      Change the type sign. Works only for the types that may have sign.
 |      
 |      change_sign(self, sign) -> bool
 |          @param sign (C++: type_sign_t)
 |  
 |  clear(self, *args)
 |      Clear contents of this tinfo, and remove from the type system.
 |  
 |  clr_const(self, *args)
 |      clr_const(self)
 |  
 |  clr_const_volatile(self, *args)
 |      clr_const_volatile(self)
 |  
 |  clr_volatile(self, *args)
 |      clr_volatile(self)
 |  
 |  compare(self, *args)
 |      compare(self, r) -> int
 |          r: tinfo_t const &
 |  
 |  compare_with(self, *args)
 |      Compare two types, based on given flags (see 'tinfo_t comparison
 |      flags' )
 |      
 |      compare_with(self, r, tcflags=0) -> bool
 |          @param r (C++: const  tinfo_t  &)
 |          @param tcflags (C++: int)
 |  
 |  convert_array_to_ptr(self, *args)
 |      Convert an array into a pointer. type[] => type *
 |  
 |  copy(self, *args)
 |      copy(self) -> tinfo_t
 |  
 |  create_array(self, *args)
 |      create_array(self, p, decl_type=BT_ARRAY) -> bool
 |          @param p (C++: const  array_type_data_t  &)
 |          @param decl_type (C++: type_t)
 |      
 |      
 |      create_array(self, tif, nelems=0, base=0, decl_type=BT_ARRAY) -> bool
 |          tif: tinfo_t const &
 |          nelems: uint32
 |          base: uint32
 |          @param decl_type (C++: type_t)
 |  
 |  create_bitfield(self, *args)
 |      create_bitfield(self, p, decl_type=BT_BITFIELD) -> bool
 |          @param p (C++: const  bitfield_type_data_t  &)
 |          @param decl_type (C++: type_t)
 |      
 |      
 |      create_bitfield(self, nbytes, width, is_unsigned=False, decl_type=BT_BITFIELD) -> bool
 |          nbytes: uchar
 |          width: uchar
 |          is_unsigned: bool
 |          @param decl_type (C++: type_t)
 |  
 |  create_enum(self, *args)
 |      create_enum(self, p, decl_type=BTF_ENUM) -> bool
 |          p: enum_type_data_t &
 |          decl_type: type_t
 |  
 |  create_forward_decl(self, *args)
 |      Create a forward declaration. decl_type: 'BTF_STRUCT' , 'BTF_UNION' ,
 |      or 'BTF_ENUM'
 |      
 |      create_forward_decl(self, til, decl_type, name, ntf_flags=0) -> tinfo_code_t
 |          @param til (C++: til_t  *)
 |          @param decl_type (C++: type_t)
 |          @param name (C++: const char *)
 |          @param ntf_flags (C++: int)
 |  
 |  create_func(self, *args)
 |      create_func(self, p, decl_type=BT_FUNC) -> bool
 |          p: func_type_data_t &
 |          decl_type: type_t
 |  
 |  create_ptr(self, *args)
 |      create_ptr(self, p, decl_type=BT_PTR) -> bool
 |          @param p (C++: const  ptr_type_data_t  &)
 |          @param decl_type (C++: type_t)
 |      
 |      
 |      create_ptr(self, tif, bps=0, decl_type=BT_PTR) -> bool
 |          tif: tinfo_t const &
 |          bps: uchar
 |          @param decl_type (C++: type_t)
 |  
 |  create_simple_type(self, *args)
 |      create_simple_type(self, decl_type) -> bool
 |          @param decl_type (C++: type_t)
 |  
 |  create_typedef(self, *args)
 |      create_typedef(self, p, decl_type=BTF_TYPEDEF, try_ordinal=True) -> bool
 |          @param p (C++: const  typedef_type_data_t  &)
 |          @param decl_type (C++: type_t)
 |          @param try_ordinal (C++: bool)
 |      
 |      
 |      create_typedef(self, til, name, decl_type=BTF_TYPEDEF, try_ordinal=True)
 |          til: til_t const *
 |          name: char const *
 |          @param decl_type (C++: type_t)
 |          @param try_ordinal (C++: bool)
 |      
 |      
 |      create_typedef(self, til, ord, decl_type=BTF_TYPEDEF)
 |          til: til_t const *
 |          ord: uint
 |          @param decl_type (C++: type_t)
 |  
 |  create_udt(self, *args)
 |      create_udt(self, p, decl_type) -> bool
 |          p: udt_type_data_t &
 |          decl_type: type_t
 |  
 |  del_attr(self, *args)
 |      Del a type attribute. typerefs cannot be modified by this function.
 |      
 |      del_attr(self, key, make_copy=True) -> bool
 |          @param key (C++: const  qstring  &)
 |          @param make_copy (C++: bool)
 |  
 |  del_attrs(self, *args)
 |      Del all type attributes. typerefs cannot be modified by this function.
 |  
 |  deserialize(self, *args)
 |      Deserialize a type string into a 'tinfo_t' object.
 |      
 |      deserialize(self, til, ptype, pfields=None, pfldcmts=None) -> bool
 |          @param til (C++: const  til_t  *)
 |          @param ptype (C++: const  type_t  **)
 |          @param pfields (C++: const  p_list  **)
 |          @param pfldcmts (C++: const  p_list  **)
 |      
 |      
 |      deserialize(self, til, type, fields, cmts=None) -> bool
 |          @param til (C++: const  til_t  *)
 |          type: type_t const *
 |          fields: p_list const *
 |          cmts: p_list const *
 |  
 |  dstr(self, *args)
 |      Function to facilitate debugging.
 |  
 |  empty(self, *args)
 |      Was 'tinfo_t' initialized with some type info or not?
 |  
 |  equals_to(self, *args)
 |      equals_to(self, r) -> bool
 |          @param r (C++: const  tinfo_t  &)
 |  
 |  find_udt_member(self, *args)
 |      'BTF_STRUCT' , 'BTF_UNION' : Find a udt member.at the specified
 |      offset ( 'STRMEM_OFFSET' )with the specified index ( 'STRMEM_INDEX'
 |      )with the specified type ( 'STRMEM_TYPE' )with the specified name (
 |      'STRMEM_NAME' )
 |      
 |      find_udt_member(self, udm, strmem_flags) -> int
 |          @param udm (C++: struct  udt_member_t  *)
 |          @param strmem_flags (C++: int)
 |          @return: the index of the found member or -1
 |  
 |  get_array_details(self, *args)
 |      Get the array specific info.
 |      
 |      get_array_details(self, ai) -> bool
 |          @param ai (C++: array_type_data_t  *)
 |  
 |  get_array_element(self, *args)
 |      'BT_ARRAY' : get type of array element. See also
 |      'get_ptrarr_object()'
 |  
 |  get_array_nelems(self, *args)
 |      'BT_ARRAY' : get number of elements (-1 means error)
 |  
 |  get_attr(self, *args)
 |      Get a type attribute.
 |      
 |      get_attr(self, key, all_attrs=True) -> PyObject *
 |          @param key (C++: const  qstring  &)
 |          @param all_attrs (C++: bool)
 |  
 |  get_attrs(self, *args)
 |      Get type attributes (all_attrs: include attributes of referenced
 |      types, if any)
 |      
 |      get_attrs(self, tav, all_attrs=False) -> bool
 |          @param tav (C++: type_attrs_t  *)
 |          @param all_attrs (C++: bool)
 |  
 |  get_bitfield_details(self, *args)
 |      Get the bitfield specific info.
 |      
 |      get_bitfield_details(self, bi) -> bool
 |          @param bi (C++: bitfield_type_data_t  *)
 |  
 |  get_declalign(self, *args)
 |      Get declared alignment of the type.
 |  
 |  get_decltype(self, *args)
 |      Get declared type (without resolving type references; they are
 |      returned as is). Obviously this is a very fast function and should be
 |      used instead of 'get_realtype()' if possible.
 |  
 |  get_enum_base_type(self, *args)
 |      Get enum base type (convert enum to integer type) Returns 'BT_UNK' if
 |      failed to convert
 |  
 |  get_enum_details(self, *args)
 |      Get the enum specific info.
 |      
 |      get_enum_details(self, ei) -> bool
 |          @param ei (C++: enum_type_data_t  *)
 |  
 |  get_final_ordinal(self, *args)
 |      Get final type ordinal (0 is none)
 |  
 |  get_final_type_name(self, *args)
 |      Use in the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn).
 |  
 |  get_func_details(self, *args)
 |      Get only the function specific info for this 'tinfo_t' .
 |      
 |      get_func_details(self, fi, gtd=GTD_CALC_ARGLOCS) -> bool
 |          @param fi (C++: func_type_data_t  *)
 |          @param gtd (C++: gtd_func_t)
 |  
 |  get_modifiers(self, *args)
 |      get_modifiers(self) -> type_t
 |  
 |  get_named_type(self, *args)
 |      Create a 'tinfo_t' object for an existing named type.
 |      
 |      get_named_type(self, til, name, decl_type=BTF_TYPEDEF, resolve=True, try_ordinal=True) -> bool
 |          @param til: type library to use (C++: const  til_t  *)
 |          @param name: name of the type to link to (C++: const char *)
 |          @param decl_type: if the reference was explicitly specified with the
 |                            type tag    ( BTF_STRUCT / BTF_UNION / BTF_ENUM )
 |                            you may specify it.    the kernel will accept only
 |                            the specified tag after resolving    the type. If
 |                            the resolved type does not correspond to the
 |                            explicitly specified tag, the type will be
 |                            considered as undefined (C++: type_t)
 |          @param resolve: true: immediately resolve the type and return success
 |                          code. false: return true but do not immediately
 |                          resolve the type (C++: bool)
 |          @param try_ordinal: true: try to replace name reference by an ordinal
 |                              reference (C++: bool)
 |  
 |  get_nargs(self, *args)
 |      'BT_FUNC' or 'BT_PTR'  'BT_FUNC' : Calculate number of arguments (-1
 |      - error)
 |  
 |  get_next_type_name(self, *args)
 |      Use In the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn).
 |  
 |  get_nth_arg(self, *args)
 |      'BT_FUNC' or 'BT_PTR'  'BT_FUNC' : Get type of n-th arg (-1 means
 |      return type, see 'get_rettype()' )
 |      
 |      get_nth_arg(self, n) -> tinfo_t
 |          @param n (C++: int)
 |  
 |  get_numbered_type(self, *args)
 |      Create a 'tinfo_t' object for an existing ordinal type.
 |      
 |      get_numbered_type(self, til, ordinal, decl_type=BTF_TYPEDEF, resolve=True) -> bool
 |          @param til: type library to use (C++: const  til_t  *)
 |          @param ordinal: number of the type to link to (C++: uint32)
 |          @param decl_type: if the reference was explicitly specified with the
 |                            type tag (BTF_STRUCT/BTF_UNION/BTF_ENUM) you may
 |                            specify it. the kernel will accept only the
 |                            specified tag after resolving the type. If the
 |                            resolved type does not correspond to the explicitly
 |                            specified tag, the type will be considered as
 |                            undefined (C++: type_t)
 |          @param resolve: true: immediately resolve the type and return success
 |                          code false: return true but do not immediately resolve
 |                          the type (C++: bool)
 |  
 |  get_onemember_type(self, *args)
 |      For objects consisting of one member entirely: return type of the
 |      member.
 |  
 |  get_ordinal(self, *args)
 |      Get type ordinal (only if the type was created as a numbered type, 0
 |      if none)
 |  
 |  get_pointed_object(self, *args)
 |      'BT_PTR' : get type of pointed object. If the current type is not a
 |      pointer, return empty type info. See also 'get_ptrarr_object()' and
 |      'remove_pointer()'
 |  
 |  get_ptr_details(self, *args)
 |      Get the pointer info.
 |      
 |      get_ptr_details(self, pi) -> bool
 |          @param pi (C++: ptr_type_data_t  *)
 |  
 |  get_ptrarr_object(self, *args)
 |      'BT_PTR' & 'BT_ARRAY' : get the pointed object or array element. If
 |      the current type is not a pointer or array, return empty type info.
 |  
 |  get_ptrarr_objsize(self, *args)
 |      'BT_PTR' & 'BT_ARRAY' : get size of pointed object or array element.
 |      On error returns -1
 |  
 |  get_realtype(self, *args)
 |      Get the resolved base type. Deserialization options:if full=true, the
 |      referenced type will be deserialized fully, this may not always be
 |      desirable (slows down things)if full=false, we just return the base
 |      type, the referenced type will be resolved again later if necessary
 |      (this may lead to multiple resolvings of the same type) imho
 |      full=false is a better approach because it does not perform
 |      unnecessary actions just in case. however, in some cases the caller
 |      knows that it is very likely that full type info will be required. in
 |      those cases full=true makes sense
 |      
 |      get_realtype(self, full=False) -> type_t
 |          @param full (C++: bool)
 |  
 |  get_rettype(self, *args)
 |      'BT_FUNC' or 'BT_PTR'  'BT_FUNC' : Get the function's return type
 |  
 |  get_sign(self, *args)
 |      Get type sign.
 |  
 |  get_size(self, *args)
 |      Get the type size in bytes.
 |      
 |      get_size(self, p_effalign=None, gts_code=0) -> size_t
 |          @param p_effalign: buffer for the alignment value (C++: uint32  *)
 |          @param gts_code: combination of GTS_... constants (C++: int)
 |          @return: BADSIZE  in case of problems
 |  
 |  get_til(self, *args)
 |      Get the type library for 'tinfo_t' .
 |  
 |  get_type_name(self, *args)
 |      Does a type refer to a name?. If yes, fill the provided buffer with
 |      the type name and return true. Names are returned for numbered types
 |      too: either a user-defined nice name or, if a user-provided name does
 |      not exist, an ordinal name (like #xx, see
 |      'create_numbered_type_name()' ).
 |  
 |  get_udt_details(self, *args)
 |      Get the udt specific info.
 |      
 |      get_udt_details(self, udt, gtd=GTD_CALC_LAYOUT) -> bool
 |          @param udt (C++: udt_type_data_t  *)
 |          @param gtd (C++: gtd_udt_t)
 |  
 |  get_udt_nmembers(self, *args)
 |      Get number of udt members. -1-error.
 |  
 |  get_unpadded_size(self, *args)
 |      Get the type size in bytes without the final padding, in bytes. For
 |      some UDTs 'get_unpadded_size()' != 'get_size()'
 |  
 |  has_details(self, *args)
 |      Does this type refer to a nontrivial type?
 |  
 |  has_vftable(self, *args)
 |      Has a vftable?
 |  
 |  is_anonymous_udt(self, *args)
 |      Is an anonymous struct/union? We assume that types with names are
 |      anonymous if the name starts with $
 |  
 |  is_arithmetic(self, *args)
 |      \isreal{is_type_arithmetic}
 |  
 |  is_array(self, *args)
 |      \isreal{is_type_array}
 |  
 |  is_bitfield(self, *args)
 |      \isreal{is_type_bitfld}
 |  
 |  is_bool(self, *args)
 |      \isreal{is_type_bool}
 |  
 |  is_castable_to(self, *args)
 |      is_castable_to(self, target) -> bool
 |          @param target (C++: const  tinfo_t  &)
 |  
 |  is_char(self, *args)
 |      \isreal{is_type_char}
 |  
 |  is_complex(self, *args)
 |      \isreal{is_type_complex}
 |  
 |  is_const(self, *args)
 |      \isreal{is_type_const}
 |  
 |  is_correct(self, *args)
 |      Is the type object correct?. It is possible to create incorrect types.
 |      For example, we can define a function that returns a enum and then
 |      delete the enum type. If this function returns false, the type should
 |      not be used in disassembly. Please note that this function does not
 |      verify all involved types: for example, pointers to undefined types
 |      are permitted.
 |  
 |  is_decl_array(self, *args)
 |      \isdecl{is_type_array}
 |  
 |  is_decl_bitfield(self, *args)
 |      \isdecl{is_type_bitfld}
 |  
 |  is_decl_bool(self, *args)
 |      \isdecl{is_type_bool}
 |  
 |  is_decl_char(self, *args)
 |      \isdecl{is_type_char}
 |  
 |  is_decl_complex(self, *args)
 |      \isdecl{is_type_complex}
 |  
 |  is_decl_const(self, *args)
 |      \isdecl{is_type_const}
 |  
 |  is_decl_double(self, *args)
 |      \isdecl{is_type_double}
 |  
 |  is_decl_enum(self, *args)
 |      \isdecl{is_type_enum}
 |  
 |  is_decl_float(self, *args)
 |      \isdecl{is_type_float}
 |  
 |  is_decl_floating(self, *args)
 |      \isdecl{is_type_floating}
 |  
 |  is_decl_func(self, *args)
 |      \isdecl{is_type_func}
 |  
 |  is_decl_int(self, *args)
 |      \isdecl{is_type_int}
 |  
 |  is_decl_int128(self, *args)
 |      \isdecl{is_type_int128}
 |  
 |  is_decl_int16(self, *args)
 |      \isdecl{is_type_int16}
 |  
 |  is_decl_int32(self, *args)
 |      \isdecl{is_type_int32}
 |  
 |  is_decl_int64(self, *args)
 |      \isdecl{is_type_int64}
 |  
 |  is_decl_last(self, *args)
 |      \isdecl{is_typeid_last}
 |  
 |  is_decl_ldouble(self, *args)
 |      \isdecl{is_type_ldouble}
 |  
 |  is_decl_paf(self, *args)
 |      \isdecl{is_type_paf}
 |  
 |  is_decl_partial(self, *args)
 |      \isdecl{is_type_partial}
 |  
 |  is_decl_ptr(self, *args)
 |      \isdecl{is_type_ptr}
 |  
 |  is_decl_struct(self, *args)
 |      \isdecl{is_type_struct}
 |  
 |  is_decl_sue(self, *args)
 |      \isdecl{is_type_sue}
 |  
 |  is_decl_tbyte(self, *args)
 |      \isdecl{is_type_tbyte}
 |  
 |  is_decl_typedef(self, *args)
 |      \isdecl{is_type_typedef}
 |  
 |  is_decl_uchar(self, *args)
 |      \isdecl{is_type_uchar}
 |  
 |  is_decl_udt(self, *args)
 |      \isdecl{is_type_struni}
 |  
 |  is_decl_uint(self, *args)
 |      \isdecl{is_type_uint}
 |  
 |  is_decl_uint128(self, *args)
 |      \isdecl{is_type_uint128}
 |  
 |  is_decl_uint16(self, *args)
 |      \isdecl{is_type_uint16}
 |  
 |  is_decl_uint32(self, *args)
 |      \isdecl{is_type_uint32}
 |  
 |  is_decl_uint64(self, *args)
 |      \isdecl{is_type_uint64}
 |  
 |  is_decl_union(self, *args)
 |      \isdecl{is_type_union}
 |  
 |  is_decl_unknown(self, *args)
 |      \isdecl{is_type_unknown}
 |  
 |  is_decl_void(self, *args)
 |      \isdecl{is_type_void}
 |  
 |  is_decl_volatile(self, *args)
 |      \isdecl{is_type_volatile}
 |  
 |  is_double(self, *args)
 |      \isreal{is_type_double}
 |  
 |  is_empty_udt(self, *args)
 |      Is an empty struct/union? (has no fields)
 |  
 |  is_enum(self, *args)
 |      \isreal{is_type_enum}
 |  
 |  is_ext_arithmetic(self, *args)
 |      \isreal{is_type_ext_arithmetic}
 |  
 |  is_ext_integral(self, *args)
 |      \isreal{is_type_ext_integral}
 |  
 |  is_float(self, *args)
 |      \isreal{is_type_float}
 |  
 |  is_floating(self, *args)
 |      \isreal{is_type_floating}
 |  
 |  is_forward_decl(self, *args)
 |      Is this a forward declaration?. Forward declarations are placeholders:
 |      the type definition does not exist
 |  
 |  is_from_subtil(self, *args)
 |      Was the named type found in some base type library (not the top level
 |      type library)?. If yes, it usually means that the type comes from some
 |      loaded type library, not the local type library for the database
 |  
 |  is_func(self, *args)
 |      \isreal{is_type_func}
 |  
 |  is_funcptr(self, *args)
 |      Is this pointer to a function?
 |  
 |  is_high_func(self, *args)
 |      'BT_FUNC' : Is high level type?
 |  
 |  is_int(self, *args)
 |      \isreal{is_type_int}
 |  
 |  is_int128(self, *args)
 |      \isreal{is_type_int128}
 |  
 |  is_int16(self, *args)
 |      \isreal{is_type_int16}
 |  
 |  is_int32(self, *args)
 |      \isreal{is_type_int32}
 |  
 |  is_int64(self, *args)
 |      \isreal{is_type_int64}
 |  
 |  is_integral(self, *args)
 |      \isreal{is_type_integral}
 |  
 |  is_ldouble(self, *args)
 |      \isreal{is_type_ldouble}
 |  
 |  is_manually_castable_to(self, *args)
 |      is_manually_castable_to(self, target) -> bool
 |          @param target (C++: const  tinfo_t  &)
 |  
 |  is_one_fpval(self, *args)
 |      Floating value or an object consisting of one floating member
 |      entirely.
 |  
 |  is_paf(self, *args)
 |      \isreal{is_type_paf}
 |  
 |  is_partial(self, *args)
 |      \isreal{is_type_partial}
 |  
 |  is_ptr(self, *args)
 |      \isreal{is_type_ptr}
 |  
 |  is_ptr_or_array(self, *args)
 |      \isreal{is_type_ptr_or_array}
 |  
 |  is_purging_cc(self, *args)
 |      \tinfocc{is_purging_cc}
 |  
 |  is_pvoid(self, *args)
 |      Is "void *"?. This function does not check the pointer attributes and
 |      type modifiers.
 |  
 |  is_scalar(self, *args)
 |      Does the type represent a single number?
 |  
 |  is_shifted_ptr(self, *args)
 |      Is a shifted pointer?
 |  
 |  is_signed(self, *args)
 |      Is this a signed type?
 |  
 |  is_small_udt(self, *args)
 |      Is a small udt? (can fit a register or a pair of registers)
 |  
 |  is_sse_type(self, *args)
 |      Is a SSE vector type?
 |  
 |  is_struct(self, *args)
 |      \isreal{is_type_struct}
 |  
 |  is_sue(self, *args)
 |      \isreal{is_type_sue}
 |  
 |  is_tbyte(self, *args)
 |      \isreal{is_type_tbyte}
 |  
 |  is_typeref(self, *args)
 |      Is this type a type reference?. Type references cannot be modified.
 |      Once created, they do not change. Because of this, the set_...
 |      functions applied to typerefs create a new type id. Other types are
 |      modified directly.
 |  
 |  is_uchar(self, *args)
 |      \isreal{is_type_uchar}
 |  
 |  is_udt(self, *args)
 |      \isreal{is_type_struni}
 |  
 |  is_uint(self, *args)
 |      \isreal{is_type_uint}
 |  
 |  is_uint128(self, *args)
 |      \isreal{is_type_uint128}
 |  
 |  is_uint16(self, *args)
 |      \isreal{is_type_uint16}
 |  
 |  is_uint32(self, *args)
 |      \isreal{is_type_uint32}
 |  
 |  is_uint64(self, *args)
 |      \isreal{is_type_uint64}
 |  
 |  is_union(self, *args)
 |      \isreal{is_type_union}
 |  
 |  is_unknown(self, *args)
 |      \isreal{is_type_unknown}
 |  
 |  is_unsigned(self, *args)
 |      Is this an unsigned type?
 |  
 |  is_user_cc(self, *args)
 |      \tinfocc{is_user_cc}
 |  
 |  is_vararg_cc(self, *args)
 |      \tinfocc{is_vararg_cc}
 |  
 |  is_varstruct(self, *args)
 |      Is a variable-size structure?
 |  
 |  is_vftable(self, *args)
 |      Is a vftable type?
 |  
 |  is_void(self, *args)
 |      \isreal{is_type_void}
 |  
 |  is_volatile(self, *args)
 |      \isreal{is_type_volatile}
 |  
 |  is_well_defined(self, *args)
 |      !( 'empty()' ) && !( 'is_decl_partial()' )
 |  
 |  present(self, *args)
 |      Is the type really present? (not a reference to a missing type, for
 |      example)
 |  
 |  read_bitfield_value(self, *args)
 |      read_bitfield_value(self, v, bitoff) -> uint64
 |          v: uint64
 |          bitoff: int
 |  
 |  remove_ptr_or_array(self, *args)
 |      Replace the current type with the ptr obj or array element. This
 |      function performs one of the following conversions:type[] => typetype*
 |      => type If the conversion is performed successfully, return true
 |  
 |  requires_qualifier(self, *args)
 |      Requires full qualifier? (name is not unique)
 |      
 |      requires_qualifier(self, name, offset) -> bool
 |          @param name: field name (C++: const char *)
 |          @param offset (C++: uint64)
 |          @return: if the name is not unique, returns true
 |  
 |  serialize(self, *args)
 |      Serialize 'tinfo_t' object into a type string.
 |      
 |      serialize(self, sudt_flags=SUDT_FAST|SUDT_TRUNC) -> PyObject *
 |          @param sudt_flags (C++: int)
 |  
 |  set_attr(self, *args)
 |      Set a type attribute. If necessary, a new typid will be created.
 |      
 |      set_attr(self, ta, may_overwrite=True) -> bool
 |          @param ta (C++: const  type_attr_t  &)
 |          @param may_overwrite (C++: bool)
 |  
 |  set_attrs(self, *args)
 |      Set type attributes. If necessary, a new typid will be created. this
 |      function modifies tav! (returns old attributes, if any)
 |      
 |      set_attrs(self, tav) -> bool
 |          @param tav (C++: type_attrs_t  *)
 |          @return: false: bad attributes
 |  
 |  set_const(self, *args)
 |      set_const(self)
 |  
 |  set_declalign(self, *args)
 |      Set declared alignment of the type.
 |      
 |      set_declalign(self, declalign) -> bool
 |          @param declalign (C++: uchar)
 |  
 |  set_modifiers(self, *args)
 |      set_modifiers(self, mod)
 |          mod: type_t
 |  
 |  set_named_type(self, *args)
 |      set_named_type(self, til, name, ntf_flags=0) -> tinfo_code_t
 |          til: til_t *
 |          name: char const *
 |          ntf_flags: int
 |  
 |  set_numbered_type(self, *args)
 |      set_numbered_type(self, til, ord, ntf_flags=0, name=None) -> tinfo_code_t
 |          til: til_t *
 |          ord: uint32
 |          ntf_flags: int
 |          name: char const *
 |  
 |  set_symbol_type(self, *args)
 |      set_symbol_type(self, til, name, ntf_flags=0) -> tinfo_code_t
 |          til: til_t *
 |          name: char const *
 |          ntf_flags: int
 |  
 |  set_volatile(self, *args)
 |      set_volatile(self)
 |  
 |  swap(self, *args)
 |      Assign this = r and r = this.
 |      
 |      swap(self, r)
 |          @param r (C++: tinfo_t  &)
 |  
 |  write_bitfield_value(self, *args)
 |      write_bitfield_value(self, dst, v, bitoff) -> uint64
 |          dst: uint64
 |          v: uint64
 |          bitoff: int
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  get_stock(*args)
 |      get_stock(id) -> tinfo_t
 |          id: enum stock_type_id_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_tinfo_t>
 |      delete_tinfo_t(self)

Help on function tinfo_t_get_stock in module ida_typeinf:

tinfo_t_get_stock(*args)
    tinfo_t_get_stock(id) -> tinfo_t
        id: enum stock_type_id_t

Help on class tinfo_visitor_t in module ida_typeinf:

class tinfo_visitor_t(__builtin__.object)
 |  Proxy of C++ tinfo_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, s=0) -> tinfo_visitor_t
 |          s: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  apply_to(self, *args)
 |      Call this function to initiate the traversal.
 |      
 |      apply_to(self, tif, out=None, name=None, cmt=None) -> int
 |          @param tif (C++: const  tinfo_t  &)
 |          @param out (C++: type_mods_t  *)
 |          @param name (C++: const char *)
 |          @param cmt (C++: const char *)
 |  
 |  prune_now(self, *args)
 |      To refuse to visit children of the current type, use this:
 |  
 |  visit_type(self, *args)
 |      Visit a subtype. this function must be implemented in the derived
 |      class. it may optionally fill out with the new type info. this can be
 |      used to modify types (in this case the 'out' argument of 'apply_to()'
 |      may not be NULL) return 0 to continue the traversal. return !=0 to
 |      stop the traversal.
 |      
 |      visit_type(self, out, tif, name, cmt) -> int
 |          @param out (C++: type_mods_t  *)
 |          @param tif (C++: const  tinfo_t  &)
 |          @param name (C++: const char *)
 |          @param cmt (C++: const char *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  state
 |      tinfo_visitor_t_state_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_tinfo_visitor_t>
 |      delete_tinfo_visitor_t(self)

Help on class type_attr_t in module ida_typeinf:

class type_attr_t(__builtin__.object)
 |  Proxy of C++ type_attr_t class.
 |  
 |  Methods defined here:
 |  
 |  __ge__(self, *args)
 |      __ge__(self, r) -> bool
 |          r: type_attr_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> type_attr_t
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: type_attr_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  key
 |      type_attr_t_key_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      type_attr_t_value_get(self) -> bytevec_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_type_attr_t>
 |      delete_type_attr_t(self)

Help on class type_attrs_t in module ida_typeinf:

class type_attrs_t(__builtin__.object)
 |  Proxy of C++ qvector< type_attr_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> type_attr_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> type_attrs_t
 |          x: qvector< type_attr_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: type_attr_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> type_attr_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> type_attr_t
 |      begin(self) -> type_attr_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> type_attr_t
 |      end(self) -> type_attr_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> type_attr_t
 |          it: qvector< type_attr_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> type_attr_t
 |          first: qvector< type_attr_t >::iterator
 |          last: qvector< type_attr_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> type_attr_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=type_attr_t())
 |          x: type_attr_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: type_attr_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> type_attr_t
 |          it: qvector< type_attr_t >::iterator
 |          x: type_attr_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: type_attr_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: type_attr_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< type_attr_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_type_attrs_t>
 |      delete_type_attrs_t(self)

Help on class type_mods_t in module ida_typeinf:

class type_mods_t(__builtin__.object)
 |  Proxy of C++ type_mods_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> type_mods_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  has_cmt(self, *args)
 |      has_cmt(self) -> bool
 |  
 |  has_info(self, *args)
 |      has_info(self) -> bool
 |  
 |  has_name(self, *args)
 |      has_name(self) -> bool
 |  
 |  has_type(self, *args)
 |      has_type(self) -> bool
 |  
 |  set_new_cmt(self, *args)
 |      set_new_cmt(self, c)
 |          @param c (C++: const  qstring  &)
 |  
 |  set_new_name(self, *args)
 |      set_new_name(self, n)
 |          @param n (C++: const  qstring  &)
 |  
 |  set_new_type(self, *args)
 |      The visit_type() function may optionally save the modified type info.
 |      Use the following functions for that. The new name and comment will be
 |      applied only if the current tinfo element has storage for them.
 |      
 |      set_new_type(self, t)
 |          @param t (C++: const  tinfo_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      type_mods_t_cmt_get(self) -> qstring *
 |  
 |  flags
 |      type_mods_t_flags_get(self) -> int
 |  
 |  name
 |      type_mods_t_name_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type_mods_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_type_mods_t>
 |      delete_type_mods_t(self)

Help on class typedef_type_data_t in module ida_typeinf:

class typedef_type_data_t(__builtin__.object)
 |  Proxy of C++ typedef_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _til, _name, _resolve=False) -> typedef_type_data_t
 |          _til: til_t const *
 |          _name: char const *
 |          _resolve: bool
 |      
 |      
 |      __init__(self, _til, ord, _resolve=False) -> typedef_type_data_t
 |          _til: til_t const *
 |          ord: uint32
 |          _resolve: bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: typedef_type_data_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  is_ordref
 |      typedef_type_data_t_is_ordref_get(self) -> bool
 |  
 |  resolve
 |      typedef_type_data_t_resolve_get(self) -> bool
 |  
 |  thisown
 |      The membership flag
 |  
 |  til
 |      typedef_type_data_t_til_get(self) -> til_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_typedef_type_data_t>
 |      delete_typedef_type_data_t(self)

Help on class udt_member_t in module ida_typeinf:

class udt_member_t(__builtin__.object)
 |  Proxy of C++ udt_member_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: udt_member_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udt_member_t
 |  
 |  __lt__(self, *args)
 |      __lt__(self, r) -> bool
 |          r: udt_member_t const &
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: udt_member_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  begin(self, *args)
 |      begin(self) -> uint64
 |  
 |  clr_baseclass(self, *args)
 |      clr_baseclass(self)
 |  
 |  clr_unaligned(self, *args)
 |      clr_unaligned(self)
 |  
 |  clr_vftable(self, *args)
 |      clr_vftable(self)
 |  
 |  clr_virtbase(self, *args)
 |      clr_virtbase(self)
 |  
 |  end(self, *args)
 |      end(self) -> uint64
 |  
 |  is_anonymous_udm(self, *args)
 |      is_anonymous_udm(self) -> bool
 |  
 |  is_baseclass(self, *args)
 |      is_baseclass(self) -> bool
 |  
 |  is_bitfield(self, *args)
 |      is_bitfield(self) -> bool
 |  
 |  is_unaligned(self, *args)
 |      is_unaligned(self) -> bool
 |  
 |  is_vftable(self, *args)
 |      is_vftable(self) -> bool
 |  
 |  is_virtbase(self, *args)
 |      is_virtbase(self) -> bool
 |  
 |  is_zero_bitfield(self, *args)
 |      is_zero_bitfield(self) -> bool
 |  
 |  set_baseclass(self, *args)
 |      set_baseclass(self)
 |  
 |  set_unaligned(self, *args)
 |      set_unaligned(self)
 |  
 |  set_vftable(self, *args)
 |      set_vftable(self)
 |  
 |  set_virtbase(self, *args)
 |      set_virtbase(self)
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: udt_member_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      udt_member_t_cmt_get(self) -> qstring *
 |  
 |  effalign
 |      udt_member_t_effalign_get(self) -> int
 |  
 |  fda
 |      udt_member_t_fda_get(self) -> uchar
 |  
 |  name
 |      udt_member_t_name_get(self) -> qstring *
 |  
 |  offset
 |      udt_member_t_offset_get(self) -> uint64
 |  
 |  size
 |      udt_member_t_size_get(self) -> uint64
 |  
 |  tafld_bits
 |      udt_member_t_tafld_bits_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      udt_member_t_type_get(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_udt_member_t>
 |      delete_udt_member_t(self)

Help on class udt_type_data_t in module ida_typeinf:

class udt_type_data_t(udtmembervec_t)
 |  Proxy of C++ udt_type_data_t class.
 |  
 |  Method resolution order:
 |      udt_type_data_t
 |      udtmembervec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udt_type_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  is_cppobj(self, *args)
 |      is_cppobj(self) -> bool
 |  
 |  is_last_baseclass(self, *args)
 |      is_last_baseclass(self, idx) -> bool
 |          @param idx (C++: size_t)
 |  
 |  is_msstruct(self, *args)
 |      is_msstruct(self) -> bool
 |  
 |  is_unaligned(self, *args)
 |      is_unaligned(self) -> bool
 |  
 |  is_vftable(self, *args)
 |      is_vftable(self) -> bool
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          @param r (C++: udt_type_data_t  &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  effalign
 |      udt_type_data_t_effalign_get(self) -> uint32
 |  
 |  is_union
 |      udt_type_data_t_is_union_get(self) -> bool
 |  
 |  pack
 |      udt_type_data_t_pack_get(self) -> uchar
 |  
 |  sda
 |      udt_type_data_t_sda_get(self) -> uchar
 |  
 |  taudt_bits
 |      udt_type_data_t_taudt_bits_get(self) -> uint32
 |  
 |  thisown
 |      The membership flag
 |  
 |  total_size
 |      udt_type_data_t_total_size_get(self) -> size_t
 |  
 |  unpadded_size
 |      udt_type_data_t_unpadded_size_get(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_udt_type_data_t>
 |      delete_udt_type_data_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from udtmembervec_t:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< udt_member_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> udt_member_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< udt_member_t > const &
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: udt_member_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: udt_member_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: udt_member_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> udt_member_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> udt_member_t
 |      begin(self) -> udt_member_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> udt_member_t
 |      end(self) -> udt_member_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> udt_member_t
 |          it: qvector< udt_member_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> udt_member_t
 |          first: qvector< udt_member_t >::iterator
 |          last: qvector< udt_member_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> udt_member_t
 |  
 |  find(self, *args)
 |      find(self, x) -> udt_member_t
 |          x: udt_member_t const &
 |      
 |      
 |      find(self, x) -> udt_member_t
 |          x: udt_member_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=udt_member_t())
 |          x: udt_member_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: udt_member_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: udt_member_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> udt_member_t
 |          it: qvector< udt_member_t >::iterator
 |          x: udt_member_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: udt_member_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: udt_member_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from udtmembervec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class udtmembervec_t in module ida_typeinf:

class udtmembervec_t(__builtin__.object)
 |  Proxy of C++ qvector< udt_member_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< udt_member_t > const &
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> udt_member_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udtmembervec_t
 |          x: qvector< udt_member_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< udt_member_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: udt_member_t const &
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: udt_member_t const &
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: udt_member_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> udt_member_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> udt_member_t
 |      begin(self) -> udt_member_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> udt_member_t
 |      end(self) -> udt_member_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> udt_member_t
 |          it: qvector< udt_member_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> udt_member_t
 |          first: qvector< udt_member_t >::iterator
 |          last: qvector< udt_member_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> udt_member_t
 |  
 |  find(self, *args)
 |      find(self, x) -> udt_member_t
 |          x: udt_member_t const &
 |      
 |      
 |      find(self, x) -> udt_member_t
 |          x: udt_member_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=udt_member_t())
 |          x: udt_member_t const &
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: udt_member_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: udt_member_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> udt_member_t
 |          it: qvector< udt_member_t >::iterator
 |          x: udt_member_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: udt_member_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: udt_member_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< udt_member_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_udtmembervec_t>
 |      delete_udtmembervec_t(self)

Help on function unpack_idcobj_from_bv in module ida_typeinf:

unpack_idcobj_from_bv(*args)
    Read a typed idc object from the byte vector.
    
    unpack_idcobj_from_bv(obj, tif, bytes, pio_flags=0) -> error_t
        @param obj (C++: idc_value_t  *)
        @param tif (C++: const  tinfo_t  &)
        @param bytes (C++: const  bytevec_t  &)
        @param pio_flags (C++: int)

Help on function unpack_idcobj_from_idb in module ida_typeinf:

unpack_idcobj_from_idb(*args)
    Collection of register objects.
    
    Read a typed idc object from the database
    
    unpack_idcobj_from_idb(obj, tif, ea, off0, pio_flags=0) -> error_t
        @param obj (C++: idc_value_t  *)
        @param tif (C++: const  tinfo_t  &)
        @param ea (C++: ea_t)
        @param off0 (C++: const  bytevec_t  *)
        @param pio_flags (C++: int)

Help on function unpack_object_from_bv in module ida_typeinf:

unpack_object_from_bv(*args)
    unpack_object_from_bv(ti, type, fields, bytes, pio_flags=0) -> PyObject *
    Unpacks a buffer into an object.
    Returns the error_t returned by idaapi.pack_object_to_idb
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @param fields: fields string (may be empty or None)
    @param bytes: the bytes to unpack
    @param pio_flags: flags used while unpacking
    @return:
        - tuple(0, err) on failure
        - tuple(1, obj) on success

Help on function unpack_object_from_idb in module ida_typeinf:

unpack_object_from_idb(*args)
    unpack_object_from_idb(ti, type, fields, ea, pio_flags=0) -> PyObject *
        ti: til_t *
        type: type_t const *
        fields: p_list const *
        ea: ea_t
        pio_flags: int

Help on class valstr_t in module ida_typeinf:

class valstr_t(__builtin__.object)
 |  Proxy of C++ valstr_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> valstr_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  info
 |      valstr_t_info_get(self) -> valinfo_t *
 |  
 |  length
 |      valstr_t_length_get(self) -> size_t
 |  
 |  members
 |      valstr_t_members_get(self) -> valstrs_t
 |  
 |  oneline
 |      valstr_t_oneline_get(self) -> qstring *
 |  
 |  props
 |      valstr_t_props_get(self) -> int
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_valstr_t>
 |      delete_valstr_t(self)

Help on class valstrs_t in module ida_typeinf:

class valstrs_t(valstrvec_t)
 |  Proxy of C++ valstrs_t class.
 |  
 |  Method resolution order:
 |      valstrs_t
 |      valstrvec_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> valstrs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_valstrs_t>
 |      delete_valstrs_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from valstrvec_t:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> valstr_t
 |          i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: valstr_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> valstr_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> valstr_t
 |      begin(self) -> valstr_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> valstr_t
 |      end(self) -> valstr_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> valstr_t
 |          it: qvector< valstr_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> valstr_t
 |          first: qvector< valstr_t >::iterator
 |          last: qvector< valstr_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> valstr_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=valstr_t())
 |          x: valstr_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: valstr_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> valstr_t
 |          it: qvector< valstr_t >::iterator
 |          x: valstr_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: valstr_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: valstr_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< valstr_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from valstrvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class valstrvec_t in module ida_typeinf:

class valstrvec_t(__builtin__.object)
 |  Proxy of C++ qvector< valstr_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> valstr_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> valstrvec_t
 |          x: qvector< valstr_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: valstr_t const &
 |  
 |  at(self, *args)
 |      at(self, _idx) -> valstr_t
 |          _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> valstr_t
 |      begin(self) -> valstr_t
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> valstr_t
 |      end(self) -> valstr_t
 |  
 |  erase(self, *args)
 |      erase(self, it) -> valstr_t
 |          it: qvector< valstr_t >::iterator
 |      
 |      
 |      erase(self, first, last) -> valstr_t
 |          first: qvector< valstr_t >::iterator
 |          last: qvector< valstr_t >::iterator
 |  
 |  extract(self, *args)
 |      extract(self) -> valstr_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=valstr_t())
 |          x: valstr_t const &
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: valstr_t *
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> valstr_t
 |          it: qvector< valstr_t >::iterator
 |          x: valstr_t const &
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: valstr_t const &
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: valstr_t const &
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< valstr_t > &
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_valstrvec_t>
 |      delete_valstrvec_t(self)

Help on function verify_argloc in module ida_typeinf:

verify_argloc(*args)
    Verify 'argloc_t' .
    
    verify_argloc(vloc, size, gaps) -> int
        @param vloc (C++: const  argloc_t  &)
        @param size: total size of the variable (C++: int)
        @param gaps: if not NULL, specifies gaps in structure definition.
                     these gaps should not map to any argloc, but everything
                     else must be covered (C++: const  rangeset_t  *)
        @return: 0 if ok, otherwise an interr code.

Help on function verify_tinfo in module ida_typeinf:

verify_tinfo(*args)
    verify_tinfo(typid) -> int
        typid: uint32

Help on function visit_subtypes in module ida_typeinf:

visit_subtypes(*args)
    visit_subtypes(visitor, out, tif, name, cmt) -> int
        visitor: tinfo_visitor_t *
        out: type_mods_t *
        tif: tinfo_t const &
        name: char const *
        cmt: char const *

Help on function write_tinfo_bitfield_value in module ida_typeinf:

write_tinfo_bitfield_value(*args)
    write_tinfo_bitfield_value(typid, dst, v, bitoff) -> uint64
        typid: uint32
        dst: uint64
        v: uint64
        bitoff: int

=== ida_typeinf EPYDOC INJECTIONS ===
ida_typeinf.ADDTIL_ABORTED
"""
til was not loaded (incompatible til rejected by user)
"""

ida_typeinf.ADDTIL_COMP
"""
ok, but til is not compatible with the current compiler
"""

ida_typeinf.ADDTIL_DEFAULT
"""
default behavior
"""

ida_typeinf.ADDTIL_FAILED
"""
something bad, the warning is displayed
"""

ida_typeinf.ADDTIL_INCOMP
"""
load incompatible tils
"""

ida_typeinf.ADDTIL_OK
"""
ok, til is loaded
"""

ida_typeinf.ADDTIL_SILENT
"""
do not ask any questions
"""

ida_typeinf.CC_ALLOW_ARGPERM
"""
disregard argument order?
"""

ida_typeinf.CC_ALLOW_REGHOLES
"""
allow holes in register argument list?
"""

ida_typeinf.CC_CDECL_OK
"""
can use __cdecl calling convention?
"""

ida_typeinf.CC_HAS_ELLIPSIS
"""
function has a variable list of arguments?
"""

ida_typeinf.FAH_BYTE
"""
function argument attribute header byte
"""

ida_typeinf.FAI_ARRAY
"""
was initially an array see "__org_typedef" or "__org_arrdim" type
attributes to determine the original type
"""

ida_typeinf.FAI_HIDDEN
"""
hidden argument
"""

ida_typeinf.FAI_RETPTR
"""
pointer to return value. implies hidden
"""

ida_typeinf.FAI_STRUCT
"""
was initially a structure
"""

ida_typeinf.FTI_ALL
"""
all defined bits
"""

ida_typeinf.FTI_ARGLOCS
"""
(stkargs and retloc too)

info about argument locations has been calculated
"""

ida_typeinf.FTI_CALLTYPE
"""
mask for FTI_*CALL
"""

ida_typeinf.FTI_DEFCALL
"""
default call
"""

ida_typeinf.FTI_FARCALL
"""
far call
"""

ida_typeinf.FTI_HIGH
"""
high level prototype (with possibly hidden args)
"""

ida_typeinf.FTI_INTCALL
"""
interrupt call
"""

ida_typeinf.FTI_NEARCALL
"""
near call
"""

ida_typeinf.FTI_NORET
"""
noreturn
"""

ida_typeinf.FTI_PURE
"""
__pure
"""

ida_typeinf.FTI_SPOILED
"""
information about spoiled registers is present
"""

ida_typeinf.FTI_STATIC
"""
static
"""

ida_typeinf.FTI_VIRTUAL
"""
virtual
"""

ida_typeinf.GUESS_FUNC_FAILED
"""
couldn't guess the function type
"""

ida_typeinf.GUESS_FUNC_OK
"""
ok, some non-trivial information is gathered
"""

ida_typeinf.GUESS_FUNC_TRIVIAL
"""
the function type doesn't have interesting info
"""

ida_typeinf.HTI_CPP
"""
C++ mode (not implemented)
"""

ida_typeinf.HTI_DCL
"""
don't complain about redeclarations
"""

ida_typeinf.HTI_EXT
"""
debug: print external representation of types
"""

ida_typeinf.HTI_FIL
"""
otherwise "input" contains a C declaration

"input" is file name,
"""

ida_typeinf.HTI_HIGH
"""
(with hidden args, etc)

assume high level prototypes
"""

ida_typeinf.HTI_INT
"""
debug: print internal representation of types
"""

ida_typeinf.HTI_LEX
"""
debug: print tokens
"""

ida_typeinf.HTI_LOWER
"""
lower the function prototypes
"""

ida_typeinf.HTI_MAC
"""
define macros from the base tils
"""

ida_typeinf.HTI_NDC
"""
don't decorate names
"""

ida_typeinf.HTI_NER
"""
ignore all errors but display them
"""

ida_typeinf.HTI_NWR
"""
no warning messages
"""

ida_typeinf.HTI_PAK
"""
explicit structure pack value (#pragma pack)
"""

ida_typeinf.HTI_PAK1
"""
#pragma pack(1)
"""

ida_typeinf.HTI_PAK16
"""
#pragma pack(16)
"""

ida_typeinf.HTI_PAK2
"""
#pragma pack(2)
"""

ida_typeinf.HTI_PAK4
"""
#pragma pack(4)
"""

ida_typeinf.HTI_PAK8
"""
#pragma pack(8)
"""

ida_typeinf.HTI_PAKDEF
"""
default pack value
"""

ida_typeinf.HTI_PAK_SHIFT
"""
shift for 'HTI_PAK' . This field should be used if you want to
remember an explicit pack value for each structure/union type. See
'HTI_PAK' ... definitions
"""

ida_typeinf.HTI_RAWARGS
"""
leave argument names unchanged (do not remove underscores)
"""

ida_typeinf.HTI_TST
"""
test mode: discard the result
"""

ida_typeinf.HTI_UNP
"""
debug: check the result by unpacking it
"""

ida_typeinf.IMPTYPE_LOCAL
"""
the type is local, the struct/enum won't be marked as til type. there
is no need to specify this bit if til==idati, the kernel will set it
automatically
"""

ida_typeinf.IMPTYPE_OVERRIDE
"""
override existing type
"""

ida_typeinf.IMPTYPE_VERBOSE
"""
more verbose output (dialog boxes may appear)
"""

ida_typeinf.MAX_FUNC_ARGS
"""
max number of function arguments
"""

ida_typeinf.NTF_64BIT
"""
value is 64bit
"""

ida_typeinf.NTF_CHKSYNC
"""
(set_numbered_type, set_named_type)

check that synchronization to IDB passed OK
"""

ida_typeinf.NTF_FIXNAME
"""
(set_named_type, set_numbered_type only)

force-validate the name of the type when setting
"""

ida_typeinf.NTF_IDBENC
"""
the name is given in the IDB encoding; non-ASCII bytes will be decoded
accordingly (set_named_type, set_numbered_type only)
"""

ida_typeinf.NTF_NOBASE
"""
don't inspect base tils (for get_named_type)
"""

ida_typeinf.NTF_NOCUR
"""
don't inspect current til file (for get_named_type)
"""

ida_typeinf.NTF_REPLACE
"""
replace original type (for set_named_type)
"""

ida_typeinf.NTF_SYMM
"""
only one of 'NTF_TYPE' and 'NTF_SYMU' , 'NTF_SYMM' can be used

symbol, name is mangled ('_func')
"""

ida_typeinf.NTF_SYMU
"""
symbol, name is unmangled ('func')
"""

ida_typeinf.NTF_TYPE
"""
type name
"""

ida_typeinf.NTF_UMANGLED
"""
name is unmangled (don't use this flag)
"""

ida_typeinf.PCN_CHR
"""
character
"""

ida_typeinf.PCN_DEC
"""
decimal
"""

ida_typeinf.PCN_DECSEXT
"""
automatically extend sign of signed decimal numbers
"""

ida_typeinf.PCN_HEX
"""
hexadecimal
"""

ida_typeinf.PCN_LZHEX
"""
print leading zeroes for hexdecimal number
"""

ida_typeinf.PCN_NEGSIGN
"""
print negated value (-N) for negative numbers
"""

ida_typeinf.PCN_OCT
"""
octal
"""

ida_typeinf.PCN_RADIX
"""
number base to use
"""

ida_typeinf.PCN_UNSIGNED
"""
add 'u' suffix
"""

ida_typeinf.PDF_DEF_BASE
"""
Include base types: __int8, __int16, etc..
"""

ida_typeinf.PDF_DEF_FWD
"""
Allow forward declarations.
"""

ida_typeinf.PDF_HEADER_CMT
"""
Prepend output with a descriptive comment.
"""

ida_typeinf.PDF_INCL_DEPS
"""
Include all type dependencies.
"""

ida_typeinf.PIO_IGNORE_PTRS
"""
do not follow pointers
"""

ida_typeinf.PIO_NOATTR_FAIL
"""
missing attributes are not ok
"""

ida_typeinf.PRALOC_STKOFF
"""
print stack offsets
"""

ida_typeinf.PRALOC_VERIFY
"""
interr if illegal argloc
"""

ida_typeinf.PRTYPE_1LINE
"""
print to one line
"""

ida_typeinf.PRTYPE_COLORED
"""
add color tag COLOR_SYMBOL for any parentheses, commas and colons
"""

ida_typeinf.PRTYPE_CPP
"""
use c++ name (only for 'print_type()' )
"""

ida_typeinf.PRTYPE_DEF
"""
'tinfo_t' : print definition, if available
"""

ida_typeinf.PRTYPE_MULTI
"""
print to many lines
"""

ida_typeinf.PRTYPE_NOARGS
"""
'tinfo_t' : do not print function argument names
"""

ida_typeinf.PRTYPE_NOARRS
"""
'tinfo_t' : print arguments with 'FAI_ARRAY' as pointers
"""

ida_typeinf.PRTYPE_NOREGEX
"""
do not apply regular expressions to beautify name
"""

ida_typeinf.PRTYPE_NORES
"""
'tinfo_t' : never resolve types (meaningful with PRTYPE_DEF)
"""

ida_typeinf.PRTYPE_PRAGMA
"""
print pragmas for alignment
"""

ida_typeinf.PRTYPE_RESTORE
"""
'tinfo_t' : print restored types for 'FAI_ARRAY' and 'FAI_STRUCT'
"""

ida_typeinf.PRTYPE_SEMI
"""
append ; to the end
"""

ida_typeinf.PRTYPE_TYPE
"""
print type declaration (not variable declaration)
"""

ida_typeinf.PT_HIGH
"""
(with hidden args, etc)

assume high level prototypes
"""

ida_typeinf.PT_LOWER
"""
lower the function prototypes
"""

ida_typeinf.PT_NDC
"""
don't decorate names
"""

ida_typeinf.PT_PACKMASK
"""
mask for pack alignment values
"""

ida_typeinf.PT_RAWARGS
"""
leave argument names unchanged (do not remove underscores)
"""

ida_typeinf.PT_REPLACE
"""
replace the old type (used in idc)
"""

ida_typeinf.PT_SIL
"""
silent, no messages
"""

ida_typeinf.PT_TYP
"""
return declared type information
"""

ida_typeinf.PT_VAR
"""
return declared object information
"""

ida_typeinf.RESERVED_BYTE
"""
multifunctional purpose
"""

ida_typeinf.SETCOMP_BY_USER
"""
invoked by user, cannot be replaced by module/loader
"""

ida_typeinf.SETCOMP_ONLY_ABI
"""
ignore cc field complete, use only abiname
"""

ida_typeinf.SETCOMP_ONLY_ID
"""
cc has only 'id' field the rest will be set to defaults corresponding
to the program bitness
"""

ida_typeinf.SETCOMP_OVERRIDE
"""
may override old compiler info
"""

ida_typeinf.STRMEM_ANON
"""
can be combined with 'STRMEM_NAME' : look inside anonymous members
too.
"""

ida_typeinf.STRMEM_AUTO
"""
get member by offset if struct, or get member by index if union - nb:
union: index is stored in the udm->offset field!nb: struct: offset is
in bytes (not in bits)!
"""

ida_typeinf.STRMEM_CASTABLE_TO
"""
can be combined with 'STRMEM_TYPE' : member type must be castable to
the specified type
"""

ida_typeinf.STRMEM_INDEX
"""
get member by number- in: udm->offset - is a member number
"""

ida_typeinf.STRMEM_MAXS
"""
get biggest member by size.
"""

ida_typeinf.STRMEM_MINS
"""
get smallest member by size.
"""

ida_typeinf.STRMEM_NAME
"""
get member by name- in: udm->name - the desired member name.
"""

ida_typeinf.STRMEM_OFFSET
"""
get member by offset- in: udm->offset - is a member offset in bits
"""

ida_typeinf.STRMEM_SIZE
"""
get member by size.- in: udm->size - the desired member size.
"""

ida_typeinf.STRMEM_SKIP_EMPTY
"""
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' skip empty
members (i.e. having zero size) only last empty member can be returned
"""

ida_typeinf.STRMEM_TYPE
"""
get member by type. - in: udm->type - the desired member type. member
types are compared with tinfo_t::equals_to()
"""

ida_typeinf.STRMEM_VFTABLE
"""
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' get vftable
instead of the base class
"""

ida_typeinf.SUDT_ALIGN
"""
to match the offsets and size info

recalculate field alignments, struct packing, etc
"""

ida_typeinf.SUDT_CONST
"""
only for serialize_udt: make type const
"""

ida_typeinf.SUDT_FAST
"""
serialize without verifying offsets and alignments
"""

ida_typeinf.SUDT_GAPS
"""
allow to fill gaps with additional members (_BYTE[])
"""

ida_typeinf.SUDT_SORT
"""
fields are not sorted by offset, sort them first
"""

ida_typeinf.SUDT_TRUNC
"""
serialize: truncate useless strings from fields, fldcmts
"""

ida_typeinf.SUDT_UNEX
"""
references to nonexistent member types are acceptable in this case it
is better to set the corresponding 'udt_member_t::fda' field to the
type alignment. if this field is not set, ida will try to guess the
alignment.
"""

ida_typeinf.SUDT_VOLATILE
"""
only for serialize_udt: make type volatile
"""

ida_typeinf.TAENUM_64BIT
"""
enum: store 64-bit values
"""

ida_typeinf.TAENUM_SIGNED
"""
enum: signed
"""

ida_typeinf.TAENUM_UNSIGNED
"""
enum: unsigned
"""

ida_typeinf.TAFLD_BASECLASS
"""
field: do not include but inherit from the current field
"""

ida_typeinf.TAFLD_UNALIGNED
"""
field: unaligned field
"""

ida_typeinf.TAFLD_VFTABLE
"""
field: ptr to virtual function table
"""

ida_typeinf.TAFLD_VIRTBASE
"""
field: virtual base (not supported yet)
"""

ida_typeinf.TAH_ALL
"""
all defined bits
"""

ida_typeinf.TAH_BYTE
"""
type attribute header byte
"""

ida_typeinf.TAH_HASATTRS
"""
has extended attributes
"""

ida_typeinf.TAPTR_PTR32
"""
ptr: __ptr32
"""

ida_typeinf.TAPTR_PTR64
"""
ptr: __ptr64
"""

ida_typeinf.TAPTR_RESTRICT
"""
ptr: __restrict
"""

ida_typeinf.TAPTR_SHIFTED
"""
ptr: __shifted(parent_struct, delta)
"""

ida_typeinf.TAUDT_CPPOBJ
"""
struct: a c++ object, not simple pod type
"""

ida_typeinf.TAUDT_MSSTRUCT
"""
struct: gcc msstruct attribute
"""

ida_typeinf.TAUDT_UNALIGNED
"""
struct: unaligned struct
"""

ida_typeinf.TAUDT_VFTABLE
"""
struct: is virtual function table
"""

ida_typeinf.TA_FORMAT
"""
info about the 'format' argument 3 times pack_dd: 'format_functype_t'
, argument number of 'format', argument number of '...'
"""

ida_typeinf.TA_ORG_ARRDIM
"""
the original array dimension (pack_dd)
"""

ida_typeinf.TA_ORG_TYPEDEF
"""
the original typedef name (simple string)
"""

ida_typeinf.TCMP_ANYBASE
"""
accept any base class when casting
"""

ida_typeinf.TCMP_AUTOCAST
"""
can t1 be cast into t2 automatically?
"""

ida_typeinf.TCMP_CALL
"""
can t1 be called with t2 type?
"""

ida_typeinf.TCMP_DECL
"""
compare declarations without resolving them
"""

ida_typeinf.TCMP_DELPTR
"""
remove pointer from types before comparing
"""

ida_typeinf.TCMP_EQUAL
"""
are types equal?
"""

ida_typeinf.TCMP_IGNMODS
"""
ignore const/volatile modifiers
"""

ida_typeinf.TCMP_MANCAST
"""
can t1 be cast into t2 manually?
"""

ida_typeinf.TCMP_SKIPTHIS
"""
skip the first function argument in comparison
"""

ida_typeinf.TIL_ADD_ALREADY
"""
the base til was already added
"""

ida_typeinf.TIL_ADD_FAILED
"""
see errbuf
"""

ida_typeinf.TIL_ADD_OK
"""
some tils were added
"""

ida_typeinf.TIL_ALI
"""
type aliases are present (this bit is used only on the disk)
"""

ida_typeinf.TIL_ESI
"""
extended sizeof info (short, long, longlong)
"""

ida_typeinf.TIL_MAC
"""
til has macro table
"""

ida_typeinf.TIL_MOD
"""
til has been modified, should be saved
"""

ida_typeinf.TIL_ORD
"""
type ordinal numbers are present
"""

ida_typeinf.TIL_SLD
"""
sizeof(long double)
"""

ida_typeinf.TIL_STM
"""
til has extra streams
"""

ida_typeinf.TIL_UNI
"""
universal til for any compiler
"""

ida_typeinf.TIL_ZIP
"""
pack buckets using zip
"""

ida_typeinf.TINFO_DEFINITE
"""
this is a definite type
"""

ida_typeinf.TINFO_DELAYFUNC
"""
if type is a function and no function exists at ea, schedule its
creation and argument renaming to auto-analysis otherwise try to
create it immediately
"""

ida_typeinf.TINFO_GUESSED
"""
this is a guessed type
"""

ida_typeinf.TINFO_STRICT
"""
never convert given type to another one before applying
"""

ida_typeinf.TVIS_CMT
"""
new comment is present
"""

ida_typeinf.TVIS_NAME
"""
new name is present
"""

ida_typeinf.TVIS_TYPE
"""
new type info is present
"""

ida_typeinf.TVST_DEF
"""
visit type definition (meaningful for typerefs)
"""

ida_typeinf.TVST_PRUNE
"""
don't visit children of current type
"""

ida_typeinf.VALSTR_OPEN
"""
printed opening curly brace '{'
"""
=== ida_typeinf EPYDOC INJECTIONS END ===
Help on function calc_dataseg in module ida_ua:

calc_dataseg(*args)
    Get data segment for the instruction operand. 'opnum' and 'rgnum' are
    meaningful only if the processor has segment registers.
    
    calc_dataseg(insn, n=-1, rgnum=-1) -> ea_t
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param n (C++: int)
        @param rgnum (C++: int)

Help on function can_decode in module ida_ua:

can_decode(*args)
    Can the bytes at address 'ea' be decoded as instruction?
    
    can_decode(ea) -> bool
        @param ea: linear address (C++: ea_t)
        @return: whether or not the contents at that address could be a valid
                 instruction

Help on function construct_macro in module ida_ua:

construct_macro(*args)
    construct_macro(insn, enable, build_macro) -> bool
    See ua.hpp's construct_macro().

Help on function construct_macro2 in module ida_ua:

construct_macro2(*args)
    construct_macro2(_this, insn, enable) -> bool
        @param _this (C++: macro_constructor_t  *)
        @param insn (C++: insn_t  *)
        @param enable (C++: bool)

Help on function create_insn in module ida_ua:

create_insn(*args)
    Create an instruction at the specified address. This function checks
    if an instruction is present at the specified address and will try to
    create one if there is none. It will fail if there is a data item or
    other items hindering the creation of the new instruction. This
    function will also fill the 'out' structure.
    
    create_insn(ea, out=None) -> int
        @param ea: linear address (C++: ea_t)
        @param out: the resulting instruction (C++: insn_t  *)
        @return: the length of the instruction or 0

Help on function create_outctx in module ida_ua:

create_outctx(*args)
    Create a new output context. To delete it, just use "delete pctx"
    
    create_outctx(ea, F=0, suspop=0) -> outctx_base_t
        @param ea (C++: ea_t)
        @param F (C++: flags_t)
        @param suspop (C++: int)

Help on function decode_insn in module ida_ua:

decode_insn(*args)
    Analyze the specified address and fill 'out'. This function does not
    modify the database. It just tries to interpret the specified address
    as an instruction and fills the 'out' structure.
    
    decode_insn(out, ea) -> int
        @param out: the resulting instruction (C++: insn_t  *)
        @param ea: linear address (C++: ea_t)
        @return: the length of the (possible) instruction or 0

Help on function decode_preceding_insn in module ida_ua:

decode_preceding_insn(*args)
    decode_preceding_insn(out, ea) -> PyObject *
    Decodes the preceding instruction. Please check ua.hpp / decode_preceding_insn()
    @param ea: current ea
    @param out: instruction storage
    @return: tuple(preceeding_ea or BADADDR, farref = Boolean)

Help on function decode_prev_insn in module ida_ua:

decode_prev_insn(*args)
    Decode previous instruction if it exists, fill 'out'.
    
    decode_prev_insn(out, ea) -> ea_t
        @param out: the resulting instruction (C++: insn_t  *)
        @param ea: the address to decode the previous instruction from (C++:
                   ea_t)
        @return: the previous instruction address ( BADADDR -no such insn)

Help on function get_dtype_by_size in module ida_ua:

get_dtype_by_size(*args)
    Get 'op_t::dtype' from size.
    
    get_dtype_by_size(size) -> int
        @param size (C++: asize_t)

Help on function get_dtype_flag in module ida_ua:

get_dtype_flag(*args)
    Get flags for 'op_t::dtype' field.
    
    get_dtype_flag(dtype) -> flags_t
        @param dtype (C++: op_dtype_t)

Help on function get_dtype_size in module ida_ua:

get_dtype_size(*args)
    Get size of opt_::dtype field.
    
    get_dtype_size(dtype) -> size_t
        @param dtype (C++: op_dtype_t)

Help on function get_immvals in module ida_ua:

get_immvals(*args)
    Get immediate values at the specified address. This function decodes
    instruction at the specified address or inspects the data item. It
    finds immediate values and copies them to 'out'. This function will
    store the original value of the operands in 'out', unless the last
    bits of 'F' are "...0 11111111", in which case the transformed values
    (as needed for printing) will be stored instead.
    
    get_immvals(ea, n, F=0) -> PyObject *
        @param ea: address to analyze (C++: ea_t)
        @param n: number of operand (0.. UA_MAXOP -1), -1 means all operands
                  (C++: int)
        @param F: flags for the specified address (C++: flags_t)
        @return: number of immediate values (0..2* UA_MAXOP )

Help on function get_lookback in module ida_ua:

get_lookback(*args)
    Number of instructions to look back. This variable is not used by the
    kernel. Its value may be specified in ida.cfg: LOOKBACK = <number>.
    IDP may use it as you like it. (TMS module uses it)

Help on function get_printable_immvals in module ida_ua:

get_printable_immvals(*args)
    Get immediate ready-to-print values at the specified address
    
    get_printable_immvals(ea, n, F=0) -> PyObject *
        @param ea: address to analyze (C++: ea_t)
        @param n: number of operand (0.. UA_MAXOP -1), -1 means all operands
                  (C++: int)
        @param F: flags for the specified address (C++: flags_t)
        @return: number of immediate values (0..2* UA_MAXOP )

Help on function guess_table_address in module ida_ua:

guess_table_address(*args)
    Guess the jump table address (ibm pc specific)
    
    guess_table_address(insn) -> ea_t
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)

Help on function guess_table_size in module ida_ua:

guess_table_size(*args)
    Guess the jump table size.
    
    guess_table_size(insn, jump_table) -> asize_t
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param jump_table (C++: ea_t)

Help on function insn_add_cref in module ida_ua:

insn_add_cref(*args)
    insn_add_cref(insn, to, opoff, type)
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        to: ea_t
        opoff: int
        type: enum cref_t

Help on function insn_add_dref in module ida_ua:

insn_add_dref(*args)
    insn_add_dref(insn, to, opoff, type)
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        to: ea_t
        opoff: int
        type: enum dref_t

Help on function insn_add_off_drefs in module ida_ua:

insn_add_off_drefs(*args)
    insn_add_off_drefs(insn, x, type, outf) -> ea_t
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        x: op_t const &
        type: enum dref_t
        outf: int

Help on function insn_create_stkvar in module ida_ua:

insn_create_stkvar(*args)
    insn_create_stkvar(insn, x, v, flags) -> bool
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        x: op_t const &
        v: adiff_t
        flags: int

Help on class insn_t in module ida_ua:

class insn_t(__builtin__.object)
 |  Proxy of C++ insn_t class.
 |  
 |  Methods defined here:
 |  
 |  __get_auxpref__(self, *args)
 |      __get_auxpref__(self) -> uint32
 |  
 |  __get_operand__(self, *args)
 |      __get_operand__(self, n) -> op_t
 |          n: int
 |  
 |  __get_ops__(self, *args)
 |      __get_ops__(self) -> operands_array
 |  
 |  __getitem__(self, idx)
 |      Operands can be accessed directly as indexes
 |      @return op_t: Returns an operand of type op_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> insn_t
 |  
 |  __iter__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __set_auxpref__(self, *args)
 |      __set_auxpref__(self, v)
 |          v: uint32
 |  
 |  add_cref(self, *args)
 |      Add a code cross-reference from the instruction.
 |      
 |      add_cref(self, to, opoff, type)
 |          @param to: target linear address (C++: ea_t)
 |          @param opoff: offset of the operand from the start of instruction. if
 |                        the offset is unknown, then 0. (C++: int)
 |          @param type: type of xref (C++: cref_t)
 |  
 |  add_dref(self, *args)
 |      Add a data cross-reference from the instruction. See 'add_off_drefs()'
 |      - usually it can be used in most cases.
 |      
 |      add_dref(self, to, opoff, type)
 |          @param to: target linear address (C++: ea_t)
 |          @param opoff: offset of the operand from the start of instruction if
 |                        the offset is unknown, then 0 (C++: int)
 |          @param type: type of xref (C++: dref_t)
 |  
 |  add_off_drefs(self, *args)
 |      Add xrefs for an operand of the instruction. This function creates all
 |      cross references for 'enum', 'offset' and 'structure offset' operands.
 |      Use 'add_off_drefs()' in the presence of negative offsets.
 |      
 |      add_off_drefs(self, x, type, outf) -> ea_t
 |          @param x: reference to operand (C++: const  op_t  &)
 |          @param type: type of xref (C++: dref_t)
 |          @param outf: out_value() flags. These flags should match the flags
 |                       used to output the operand (C++: int)
 |          @return: if  is_off() : the reference target address (the same as
 |                   calc_reference_data). if  is_stroff() :  BADADDR  because for
 |                   stroffs the target address is unknown else:  BADADDR  because
 |                   enums do not represent addresses
 |  
 |  assign(self, *args)
 |      assign(self, other)
 |          other: an ida_ua.insn_t, or an address (C++: const insn_t &)
 |  
 |  create_op_data(self, *args)
 |      create_op_data(self, ea_, opoff, dtype) -> bool
 |          ea_: ea_t
 |          opoff: int
 |          dtype: op_dtype_t
 |      
 |      
 |      create_op_data(self, ea_, op) -> bool
 |          ea_: ea_t
 |          op: op_t const &
 |  
 |  create_stkvar(self, *args)
 |      create_stkvar(self, x, v, flags_) -> bool
 |          x: op_t const &
 |          v: adiff_t
 |          flags_: int
 |  
 |  get_canon_feature(self, *args)
 |      see 'instruc_t::feature'
 |      
 |      get_canon_feature(self, ph) -> uint32
 |          @param ph (C++: const  processor_t  &)
 |  
 |  get_canon_mnem(self, *args)
 |      see 'instruc_t::name'
 |      
 |      get_canon_mnem(self, ph) -> char const
 |          @param ph (C++: const  processor_t  &)
 |  
 |  get_next_byte(self, *args)
 |      get_next_byte(self) -> uint8
 |  
 |  get_next_dword(self, *args)
 |      get_next_dword(self) -> uint32
 |  
 |  get_next_qword(self, *args)
 |      get_next_qword(self) -> uint64
 |  
 |  get_next_word(self, *args)
 |      get_next_word(self) -> uint16
 |  
 |  is_64bit(self, *args)
 |      Belongs to a 64bit segment?
 |  
 |  is_canon_insn(self, *args)
 |      see \ph{ 'is_canon_insn()' }
 |      
 |      is_canon_insn(self, ph) -> bool
 |          @param ph (C++: const  processor_t  &)
 |  
 |  is_macro(self, *args)
 |      Is a macro instruction?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  Op1
 |  
 |  Op2
 |  
 |  Op3
 |  
 |  Op4
 |  
 |  Op5
 |  
 |  Op6
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  auxpref
 |      __get_auxpref__(self) -> uint32
 |  
 |  cs
 |      insn_t_cs_get(self) -> ea_t
 |  
 |  ea
 |      insn_t_ea_get(self) -> ea_t
 |  
 |  flags
 |      insn_t_flags_get(self) -> int16
 |  
 |  insnpref
 |      insn_t_insnpref_get(self) -> char
 |  
 |  ip
 |      insn_t_ip_get(self) -> ea_t
 |  
 |  itype
 |      insn_t_itype_get(self) -> uint16
 |  
 |  ops
 |      __get_ops__(self) -> operands_array
 |  
 |  segpref
 |      insn_t_segpref_get(self) -> char
 |  
 |  size
 |      insn_t_size_get(self) -> uint16
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_insn_t>
 |      delete_insn_t(self)

Help on function insn_t__from_ptrval__ in module ida_ua:

insn_t__from_ptrval__(*args)
    insn_t__from_ptrval__(ptrval) -> insn_t
        ptrval: size_t

Help on function is_floating_dtype in module ida_ua:

is_floating_dtype(*args)
    Is a floating type operand?
    
    is_floating_dtype(dtype) -> bool
        @param dtype (C++: op_dtype_t)

Help on class macro_constructor_t in module ida_ua:

class macro_constructor_t(__builtin__.object)
 |  Proxy of C++ macro_constructor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> macro_constructor_t
 |          self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  build_macro(self, *args)
 |      Try to extend the instruction.
 |      
 |      build_macro(self, insn, may_go_forward) -> bool
 |          @param insn: Instruction to modify, usually the first instruction of
 |                       the macro (C++: insn_t  *)
 |          @param may_go_forward: Is it ok to consider the next instruction for
 |                                 the macro? This argument may be false, for
 |                                 example, if there is a cross reference to the
 |                                 end of INSN. In this case creating a macro is
 |                                 not desired. However, it may still be useful to
 |                                 perform minor tweaks to the instruction using
 |                                 the information about the surrounding
 |                                 instructions. (C++: bool)
 |          @return: true if created an macro instruction. This function may
 |                   modify 'insn' and return false; these changes will be
 |                   accepted by the kernel but the instruction will not be
 |                   considered as a macro.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  reserved
 |      macro_constructor_t_reserved_get(self) -> size_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_macro_constructor_t>
 |      delete_macro_constructor_t(self)

Help on function map_code_ea in module ida_ua:

map_code_ea(*args)
    Map a code address. This function takes into account the segment
    translations.
    
    map_code_ea(insn, addr, opnum) -> ea_t
        @param insn: the current instruction  - an ida_ua.insn_t, or an
                     address (C++: const insn_t &)
        @param addr: the referenced address to map (C++: ea_t)
        @param opnum: operand number (C++: int)
    
    
    map_code_ea(insn, op) -> ea_t
        @param insn: the current instruction  - an ida_ua.insn_t, or an
                     address (C++: const insn_t &)
        op: op_t const &

Help on function map_data_ea in module ida_ua:

map_data_ea(*args)
    Map a data address.
    
    map_data_ea(insn, addr, opnum=-1) -> ea_t
        @param insn: the current instruction  - an ida_ua.insn_t, or an
                     address (C++: const insn_t &)
        @param addr: the referenced address to map (C++: ea_t)
        @param opnum: operand number (C++: int)
    
    
    map_data_ea(insn, op) -> ea_t
        @param insn: the current instruction  - an ida_ua.insn_t, or an
                     address (C++: const insn_t &)
        op: op_t const &

Help on function map_ea in module ida_ua:

map_ea(*args)
    map_ea(insn, op, iscode) -> ea_t
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param op (C++: const  op_t  &)
        @param iscode (C++: bool)
    
    
    map_ea(insn, addr, opnum, iscode) -> ea_t
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        addr: ea_t
        opnum: int
        @param iscode (C++: bool)

Help on class op_t in module ida_ua:

class op_t(__builtin__.object)
 |  Proxy of C++ op_t class.
 |  
 |  Methods defined here:
 |  
 |  __get_addr__(self, *args)
 |      __get_addr__(self) -> ea_t
 |  
 |  __get_reg_phrase__(self, *args)
 |      __get_reg_phrase__(self) -> uint16
 |  
 |  __get_specval__(self, *args)
 |      __get_specval__(self) -> ea_t
 |  
 |  __get_value__(self, *args)
 |      __get_value__(self) -> ea_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> op_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __set_addr__(self, *args)
 |      __set_addr__(self, v)
 |          v: ea_t
 |  
 |  __set_reg_phrase__(self, *args)
 |      __set_reg_phrase__(self, r)
 |          r: uint16
 |  
 |  __set_specval__(self, *args)
 |      __set_specval__(self, v)
 |          v: ea_t
 |  
 |  __set_value__(self, *args)
 |      __set_value__(self, v)
 |          v: ea_t
 |  
 |  assign(self, *args)
 |      assign(self, other)
 |          other: op_t const &
 |  
 |  clr_shown(self, *args)
 |      Set operand to hidden.
 |  
 |  has_reg(self, r)
 |      Checks if the operand accesses the given processor register
 |  
 |  is_imm(self, *args)
 |      Is immediate operand?
 |      
 |      is_imm(self, v) -> bool
 |          @param v (C++: uval_t)
 |  
 |  is_reg(self, *args)
 |      Is register operand?
 |      
 |      is_reg(self, r) -> bool
 |          @param r (C++: int)
 |  
 |  set_shown(self, *args)
 |      Set operand to be shown.
 |  
 |  shown(self, *args)
 |      Is operand set to be shown?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  addr
 |      __get_addr__(self) -> ea_t
 |  
 |  dtype
 |      op_t_dtype_get(self) -> op_dtype_t
 |  
 |  flags
 |      op_t_flags_get(self) -> uchar
 |  
 |  n
 |      op_t_n_get(self) -> uchar
 |  
 |  offb
 |      op_t_offb_get(self) -> char
 |  
 |  offo
 |      op_t_offo_get(self) -> char
 |  
 |  phrase
 |      __get_reg_phrase__(self) -> uint16
 |  
 |  reg
 |      __get_reg_phrase__(self) -> uint16
 |  
 |  specflag1
 |      op_t_specflag1_get(self) -> char
 |  
 |  specflag2
 |      op_t_specflag2_get(self) -> char
 |  
 |  specflag3
 |      op_t_specflag3_get(self) -> char
 |  
 |  specflag4
 |      op_t_specflag4_get(self) -> char
 |  
 |  specval
 |      __get_specval__(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      op_t_type_get(self) -> optype_t
 |  
 |  value
 |      __get_value__(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_op_t>
 |      delete_op_t(self)

Help on function op_t__from_ptrval__ in module ida_ua:

op_t__from_ptrval__(*args)
    op_t__from_ptrval__(ptrval) -> op_t
        ptrval: size_t

Help on class operands_array in module ida_ua:

class operands_array(__builtin__.object)
 |  Proxy of C++ wrapped_array_t< op_t,8 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> op_t
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> operands_array
 |          data: op_t (&)[8]
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args)
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: op_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  data
 |      operands_array_data_get(self) -> op_t (&)[8]
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_operands_array>
 |      delete_operands_array(self)

Help on class outctx_base_t in module ida_ua:

class outctx_base_t(__builtin__.object)
 |  Proxy of C++ outctx_base_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  close_comment(self, *args)
 |      close_comment(self)
 |  
 |  clr_gen_label(self, *args)
 |      clr_gen_label(self)
 |  
 |  display_voids(self, *args)
 |      display_voids(self) -> bool
 |  
 |  flush_buf(self, *args)
 |      Append contents of 'buf' to the line array. Behaves like flush_outbuf
 |      but accepts an arbitrary buffer
 |      
 |      flush_buf(self, buf, indent=-1) -> bool
 |          @param buf (C++: const char *)
 |          @param indent (C++: int)
 |  
 |  flush_outbuf(self, *args)
 |      Functions to populate the output line array (lnar) Move the contents
 |      of the output buffer to the line array (outbuf->lnar) The kernel
 |      augments the outbuf contents with additional text like the line
 |      prefix, user-defined comments, xrefs, etc at this call.
 |      
 |      flush_outbuf(self, indent=-1) -> bool
 |          @param indent (C++: int)
 |  
 |  forbid_annotations(self, *args)
 |      forbid_annotations(self) -> int
 |  
 |  force_code(self, *args)
 |      force_code(self) -> bool
 |  
 |  gen_block_cmt(self, *args)
 |      Generate big non-indented comment lines.
 |      
 |      gen_block_cmt(self, cmt, color) -> bool
 |          @param cmt: comment text. may contain \n characters to denote new
 |                      lines. should not contain comment character (;) (C++:
 |                      const char *)
 |          @param color: color of comment text (one of  Color tags ) (C++:
 |                        color_t)
 |          @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_border_line(self, *args)
 |      Generate thin border line. This function does nothing if generation of
 |      border lines is disabled.
 |      
 |      gen_border_line(self, solid=False) -> bool
 |          @param solid: generate solid border line (with =), otherwise with -
 |                        (C++: bool)
 |          @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_cmt_line(self, *args)
 |      Generate one non-indented comment line, colored with 'COLOR_AUTOCMT' .
 |      
 |      gen_cmt_line(self, format) -> bool
 |          @param format: printf() style format line. The resulting comment line
 |                         should not include comment character (;) (C++: const
 |                         char *)
 |          @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_collapsed_line(self, *args)
 |      Generate one non-indented comment line, colored with 'COLOR_COLLAPSED'
 |      .
 |      
 |      gen_collapsed_line(self, format) -> bool
 |          @param format: printf() style format line. The resulting comment line
 |                         should not include comment character (;) (C++: const
 |                         char *)
 |          @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_empty_line(self, *args)
 |      Generate empty line. This function does nothing if generation of empty
 |      lines is disabled.
 |  
 |  gen_empty_line_without_annotations(self, *args)
 |      gen_empty_line_without_annotations(self)
 |  
 |  gen_printf(self, *args)
 |      printf-like function to add lines to the line array.
 |      
 |      gen_printf(self, indent, format) -> bool
 |          @param indent: indention of the line. if indent == -1, the kernel will
 |                         indent the line at \inf{indent}. if indent < 0, -indent
 |                         will be used for indention. The first line printed with
 |                         indent < 0 is considered as the most important line at
 |                         the current address. Usually it is the line with the
 |                         instruction itself. This line will be displayed in the
 |                         cross-reference lists and other places. If you need to
 |                         output an additional line before the main line then
 |                         pass DEFAULT_INDENT instead of -1. The kernel will know
 |                         that your line is not the most important one. (C++:
 |                         int)
 |          @param format: printf style colored line to generate (C++: const char
 |                         *)
 |          @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_xref_lines(self, *args)
 |      gen_xref_lines(self) -> bool
 |  
 |  get_stkvar(self, *args)
 |      get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
 |          arg2: op_t const &
 |          arg3: uval_t
 |          arg4: sval_t *
 |          arg5: int *
 |  
 |  init_lines_array(self, *args)
 |      init_lines_array(self, answers, maxsize)
 |          @param answers (C++: qstrvec_t  *)
 |          @param maxsize (C++: int)
 |  
 |  multiline(self, *args)
 |      multiline(self) -> bool
 |  
 |  only_main_line(self, *args)
 |      only_main_line(self) -> bool
 |  
 |  out_addr_tag(self, *args)
 |      Output "address" escape sequence.
 |      
 |      out_addr_tag(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  out_btoa(self, *args)
 |      Output a number with the specified base (binary, octal, decimal, hex)
 |      The number is output without color codes. see also 'out_long()'
 |      
 |      out_btoa(self, Word, radix=0)
 |          @param Word (C++: uval_t)
 |          @param radix (C++: char)
 |  
 |  out_char(self, *args)
 |      Output one character. The character is output without color codes. see
 |      also 'out_symbol()'
 |      
 |      out_char(self, c)
 |          @param c (C++: char)
 |  
 |  out_chars(self, *args)
 |      Append a character multiple times.
 |      
 |      out_chars(self, c, n)
 |          @param c (C++: char)
 |          @param n (C++: int)
 |  
 |  out_colored_register_line(self, *args)
 |      Output a colored line with register names in it. The register names
 |      will be substituted by user-defined names ( 'regvar_t' ) Please note
 |      that out_tagoff tries to make substitutions too (when called with
 |      COLOR_REG)
 |      
 |      out_colored_register_line(self, str)
 |          @param str (C++: const char *)
 |  
 |  out_keyword(self, *args)
 |      Output a string with 'COLOR_KEYWORD' color.
 |      
 |      out_keyword(self, str)
 |          @param str (C++: const char *)
 |  
 |  out_line(self, *args)
 |      Output a string with the specified color.
 |      
 |      out_line(self, str, color=0)
 |          @param str (C++: const char *)
 |          @param color (C++: color_t)
 |  
 |  out_long(self, *args)
 |      Output a number with appropriate color. Low level function. Use
 |      'out_value()' if you can. if 'suspop' is set then this function uses
 |      'COLOR_VOIDOP' instead of 'COLOR_NUMBER' . 'suspop' is initialized:in
 |      out_one_operand()in ..\ida\gl.cpp (before calling \ph{d_out()})
 |      
 |      out_long(self, v, radix)
 |          @param v (C++: sval_t)
 |          @param radix (C++: char)
 |  
 |  out_name_expr(self, *args)
 |      Output a name expression.
 |      
 |      out_name_expr(self, x, ea, off=BADADDR) -> bool
 |          @param x: instruction operand referencing the name expression (C++:
 |                    const  op_t  &)
 |          @param ea: address to convert to name expression (C++: ea_t)
 |          @param off: the value of name expression. this parameter is used only
 |                      to check that the name expression will have the wanted
 |                      value. You may pass  BADADDR  for this parameter but I
 |                      discourage it because it prohibits checks. (C++: adiff_t)
 |          @return: true if the name expression has been produced
 |  
 |  out_printf(self, *args)
 |      Functions to append text to the current output buffer (outbuf) Append
 |      a formatted string to the output string.
 |      
 |      out_printf(self, format)
 |          @param format (C++: const char *)
 |          @return: the number of characters appended
 |  
 |  out_register(self, *args)
 |      Output a character with 'COLOR_REG' color.
 |      
 |      out_register(self, str)
 |          @param str (C++: const char *)
 |  
 |  out_spaces(self, *args)
 |      Appends spaces to outbuf until its tag_strlen becomes 'len'.
 |      
 |      out_spaces(self, len)
 |          @param len (C++: ssize_t)
 |  
 |  out_symbol(self, *args)
 |      Output a character with 'COLOR_SYMBOL' color.
 |      
 |      out_symbol(self, c)
 |          @param c (C++: char)
 |  
 |  out_tagoff(self, *args)
 |      Output "turn color off" escape sequence.
 |      
 |      out_tagoff(self, tag)
 |          @param tag (C++: color_t)
 |  
 |  out_tagon(self, *args)
 |      Output "turn color on" escape sequence.
 |      
 |      out_tagon(self, tag)
 |          @param tag (C++: color_t)
 |  
 |  out_value(self, *args)
 |      Output immediate value. Try to use this function to output all
 |      constants of instruction operands. This function outputs a number from
 |      x.addr or x.value in the form determined by ::uFlag. It outputs a
 |      colored text.-1 is output with 'COLOR_ERROR' 0 is output as a number
 |      or character or segment
 |      
 |      out_value(self, x, outf=0) -> flags_t
 |          @param x (C++: const  op_t  &)
 |          @param outf (C++: int)
 |          @return: flags of the output value
 |  
 |  print_label_now(self, *args)
 |      print_label_now(self) -> bool
 |  
 |  restore_ctxflags(self, *args)
 |      restore_ctxflags(self, saved_flags)
 |          @param saved_flags (C++: int)
 |  
 |  retrieve_cmt(self, *args)
 |      retrieve_cmt(self) -> ssize_t
 |  
 |  retrieve_name(self, *args)
 |      retrieve_name(self, arg2, arg3) -> ssize_t
 |          arg2: qstring *
 |          arg3: color_t *
 |  
 |  set_comment_addr(self, *args)
 |      set_comment_addr(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  set_dlbind_opnd(self, *args)
 |      set_dlbind_opnd(self)
 |  
 |  set_gen_cmt(self, *args)
 |      set_gen_cmt(self, on=True)
 |          @param on (C++: bool)
 |  
 |  set_gen_demangled_label(self, *args)
 |      set_gen_demangled_label(self)
 |  
 |  set_gen_label(self, *args)
 |      set_gen_label(self)
 |  
 |  set_gen_xrefs(self, *args)
 |      set_gen_xrefs(self, on=True)
 |          @param on (C++: bool)
 |  
 |  setup_outctx(self, *args)
 |      Initialization; normally used only by the kernel.
 |      
 |      setup_outctx(self, prefix, makeline_flags)
 |          @param prefix (C++: const char *)
 |          @param makeline_flags (C++: int)
 |  
 |  stack_view(self, *args)
 |      stack_view(self) -> bool
 |  
 |  term_outctx(self, *args)
 |      Finalize the output context.
 |      
 |      term_outctx(self, prefix=None) -> int
 |          @param prefix (C++: const char *)
 |          @return: the number of generated lines.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  default_lnnum
 |      outctx_base_t_default_lnnum_get(self) -> int
 |  
 |  insn_ea
 |      outctx_base_t_insn_ea_get(self) -> ea_t
 |  
 |  outbuf
 |      outctx_base_t_outbuf_get(self) -> qstring *
 |  
 |  thisown
 |      The membership flag

Help on function outctx_base_t__from_ptrval__ in module ida_ua:

outctx_base_t__from_ptrval__(*args)
    outctx_base_t__from_ptrval__(ptrval) -> outctx_base_t
        ptrval: size_t

Help on class outctx_t in module ida_ua:

class outctx_t(outctx_base_t)
 |  Proxy of C++ outctx_t class.
 |  
 |  Method resolution order:
 |      outctx_t
 |      outctx_base_t
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  gen_func_footer(self, *args)
 |      gen_func_footer(self, pfn)
 |          @param pfn (C++: const  func_t  *)
 |  
 |  gen_func_header(self, *args)
 |      gen_func_header(self, pfn)
 |          @param pfn (C++: func_t  *)
 |  
 |  gen_header(self, *args)
 |      gen_header(self, flags=((1 << 0)|(1 << 1)), proc_name=None, proc_flavour=None)
 |          @param flags (C++: int)
 |          @param proc_name (C++: const char *)
 |          @param proc_flavour (C++: const char *)
 |  
 |  gen_header_extra(self, *args)
 |      gen_header_extra(self)
 |  
 |  gen_xref_lines(self, *args)
 |      gen_xref_lines(self) -> bool
 |  
 |  out_custom_mnem(self, *args)
 |      Output custom mnemonic for 'insn'. E.g. if it should differ from the
 |      one in 'ph.instruc'. This function outputs colored text. See
 |      'out_mnem'
 |      
 |      out_custom_mnem(self, mnem, width=8, postfix=None)
 |          @param mnem: custom mnemonic (C++: const char *)
 |          @param width: width of field with mnemonic. if < 0, then 'postfix'
 |                        will be output before the mnemonic, i.e. as a prefix
 |                        (C++: int)
 |          @param postfix: optional postfix added to 'mnem' (C++: const char *)
 |  
 |  out_data(self, *args)
 |      out_data(self, analyze_only)
 |          @param analyze_only (C++: bool)
 |  
 |  out_immchar_cmts(self, *args)
 |      Print all operand values as commented character constants. This
 |      function is used to comment void operands with their representation in
 |      the form of character constants. This function outputs a colored text.
 |  
 |  out_mnem(self, *args)
 |      Output instruction mnemonic for 'insn' using information in
 |      'ph.instruc' array. This function outputs a colored text. It should be
 |      called from \ph{ev_out_insn()} or \ph{ev_out_mnem()} handler. It will
 |      output at least one space after the instruction. mnemonic even if the
 |      specified 'width' is not enough.
 |      
 |      out_mnem(self, width=8, postfix=None)
 |          @param width: width of field with mnemonic. if < 0, then 'postfix'
 |                        will be output before the mnemonic, i.e. as a prefix
 |                        (C++: int)
 |          @param postfix: optional postfix added to the instruction mnemonic
 |                          (C++: const char *)
 |  
 |  out_mnemonic(self, *args)
 |      Output instruction mnemonic using information in 'insn'. It should be
 |      called from \ph{ev_out_insn()} and it will call \ph{ev_out_mnem()} or
 |      'out_mnem' . This function outputs a colored text.
 |  
 |  out_one_operand(self, *args)
 |      Use this function to output an operand of an instruction. This
 |      function checks for the existence of a manually defined operand and
 |      will output it if it exists. It should be called from
 |      \ph{ev_out_insn()} and it will call \ph{ev_out_operand()}. This
 |      function outputs a colored text.
 |      
 |      out_one_operand(self, n) -> bool
 |          @param n: number of operand (C++: int)
 |          @retval: 1 - operand is displayed
 |          @retval: 0 - operand is hidden
 |  
 |  out_specea(self, *args)
 |      out_specea(self, segtype) -> bool
 |          @param segtype (C++: uchar)
 |  
 |  retrieve_cmt(self, *args)
 |      retrieve_cmt(self) -> ssize_t
 |  
 |  retrieve_name(self, *args)
 |      retrieve_name(self, arg2, arg3) -> ssize_t
 |          arg2: qstring *
 |          arg3: color_t *
 |  
 |  set_bin_state(self, *args)
 |      set_bin_state(self, value)
 |          @param value (C++: int)
 |  
 |  setup_outctx(self, *args)
 |      Initialization; normally used only by the kernel.
 |      
 |      setup_outctx(self, prefix, flags)
 |          @param prefix (C++: const char *)
 |          flags: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ash
 |      outctx_t_ash_get(self) -> asm_t
 |  
 |  bin_ea
 |      outctx_t_bin_ea_get(self) -> ea_t
 |  
 |  bin_state
 |      outctx_t_bin_state_get(self) -> char
 |  
 |  bin_width
 |      outctx_t_bin_width_get(self) -> int
 |  
 |  curlabel
 |      outctx_t_curlabel_get(self) -> qstring *
 |  
 |  gl_bpsize
 |      outctx_t_gl_bpsize_get(self) -> int
 |  
 |  insn
 |      outctx_t_insn_get(self) -> insn_t
 |  
 |  ph
 |      outctx_t_ph_get(self) -> processor_t
 |  
 |  procmod
 |      outctx_t_procmod_get(self) -> procmod_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  wif
 |      outctx_t_wif_get(self) -> printop_t
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from outctx_base_t:
 |  
 |  close_comment(self, *args)
 |      close_comment(self)
 |  
 |  clr_gen_label(self, *args)
 |      clr_gen_label(self)
 |  
 |  display_voids(self, *args)
 |      display_voids(self) -> bool
 |  
 |  flush_buf(self, *args)
 |      Append contents of 'buf' to the line array. Behaves like flush_outbuf
 |      but accepts an arbitrary buffer
 |      
 |      flush_buf(self, buf, indent=-1) -> bool
 |          @param buf (C++: const char *)
 |          @param indent (C++: int)
 |  
 |  flush_outbuf(self, *args)
 |      Functions to populate the output line array (lnar) Move the contents
 |      of the output buffer to the line array (outbuf->lnar) The kernel
 |      augments the outbuf contents with additional text like the line
 |      prefix, user-defined comments, xrefs, etc at this call.
 |      
 |      flush_outbuf(self, indent=-1) -> bool
 |          @param indent (C++: int)
 |  
 |  forbid_annotations(self, *args)
 |      forbid_annotations(self) -> int
 |  
 |  force_code(self, *args)
 |      force_code(self) -> bool
 |  
 |  gen_block_cmt(self, *args)
 |      Generate big non-indented comment lines.
 |      
 |      gen_block_cmt(self, cmt, color) -> bool
 |          @param cmt: comment text. may contain \n characters to denote new
 |                      lines. should not contain comment character (;) (C++:
 |                      const char *)
 |          @param color: color of comment text (one of  Color tags ) (C++:
 |                        color_t)
 |          @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_border_line(self, *args)
 |      Generate thin border line. This function does nothing if generation of
 |      border lines is disabled.
 |      
 |      gen_border_line(self, solid=False) -> bool
 |          @param solid: generate solid border line (with =), otherwise with -
 |                        (C++: bool)
 |          @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_cmt_line(self, *args)
 |      Generate one non-indented comment line, colored with 'COLOR_AUTOCMT' .
 |      
 |      gen_cmt_line(self, format) -> bool
 |          @param format: printf() style format line. The resulting comment line
 |                         should not include comment character (;) (C++: const
 |                         char *)
 |          @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_collapsed_line(self, *args)
 |      Generate one non-indented comment line, colored with 'COLOR_COLLAPSED'
 |      .
 |      
 |      gen_collapsed_line(self, format) -> bool
 |          @param format: printf() style format line. The resulting comment line
 |                         should not include comment character (;) (C++: const
 |                         char *)
 |          @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_empty_line(self, *args)
 |      Generate empty line. This function does nothing if generation of empty
 |      lines is disabled.
 |  
 |  gen_empty_line_without_annotations(self, *args)
 |      gen_empty_line_without_annotations(self)
 |  
 |  gen_printf(self, *args)
 |      printf-like function to add lines to the line array.
 |      
 |      gen_printf(self, indent, format) -> bool
 |          @param indent: indention of the line. if indent == -1, the kernel will
 |                         indent the line at \inf{indent}. if indent < 0, -indent
 |                         will be used for indention. The first line printed with
 |                         indent < 0 is considered as the most important line at
 |                         the current address. Usually it is the line with the
 |                         instruction itself. This line will be displayed in the
 |                         cross-reference lists and other places. If you need to
 |                         output an additional line before the main line then
 |                         pass DEFAULT_INDENT instead of -1. The kernel will know
 |                         that your line is not the most important one. (C++:
 |                         int)
 |          @param format: printf style colored line to generate (C++: const char
 |                         *)
 |          @return: overflow, lnar_maxsize has been reached
 |  
 |  get_stkvar(self, *args)
 |      get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
 |          arg2: op_t const &
 |          arg3: uval_t
 |          arg4: sval_t *
 |          arg5: int *
 |  
 |  init_lines_array(self, *args)
 |      init_lines_array(self, answers, maxsize)
 |          @param answers (C++: qstrvec_t  *)
 |          @param maxsize (C++: int)
 |  
 |  multiline(self, *args)
 |      multiline(self) -> bool
 |  
 |  only_main_line(self, *args)
 |      only_main_line(self) -> bool
 |  
 |  out_addr_tag(self, *args)
 |      Output "address" escape sequence.
 |      
 |      out_addr_tag(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  out_btoa(self, *args)
 |      Output a number with the specified base (binary, octal, decimal, hex)
 |      The number is output without color codes. see also 'out_long()'
 |      
 |      out_btoa(self, Word, radix=0)
 |          @param Word (C++: uval_t)
 |          @param radix (C++: char)
 |  
 |  out_char(self, *args)
 |      Output one character. The character is output without color codes. see
 |      also 'out_symbol()'
 |      
 |      out_char(self, c)
 |          @param c (C++: char)
 |  
 |  out_chars(self, *args)
 |      Append a character multiple times.
 |      
 |      out_chars(self, c, n)
 |          @param c (C++: char)
 |          @param n (C++: int)
 |  
 |  out_colored_register_line(self, *args)
 |      Output a colored line with register names in it. The register names
 |      will be substituted by user-defined names ( 'regvar_t' ) Please note
 |      that out_tagoff tries to make substitutions too (when called with
 |      COLOR_REG)
 |      
 |      out_colored_register_line(self, str)
 |          @param str (C++: const char *)
 |  
 |  out_keyword(self, *args)
 |      Output a string with 'COLOR_KEYWORD' color.
 |      
 |      out_keyword(self, str)
 |          @param str (C++: const char *)
 |  
 |  out_line(self, *args)
 |      Output a string with the specified color.
 |      
 |      out_line(self, str, color=0)
 |          @param str (C++: const char *)
 |          @param color (C++: color_t)
 |  
 |  out_long(self, *args)
 |      Output a number with appropriate color. Low level function. Use
 |      'out_value()' if you can. if 'suspop' is set then this function uses
 |      'COLOR_VOIDOP' instead of 'COLOR_NUMBER' . 'suspop' is initialized:in
 |      out_one_operand()in ..\ida\gl.cpp (before calling \ph{d_out()})
 |      
 |      out_long(self, v, radix)
 |          @param v (C++: sval_t)
 |          @param radix (C++: char)
 |  
 |  out_name_expr(self, *args)
 |      Output a name expression.
 |      
 |      out_name_expr(self, x, ea, off=BADADDR) -> bool
 |          @param x: instruction operand referencing the name expression (C++:
 |                    const  op_t  &)
 |          @param ea: address to convert to name expression (C++: ea_t)
 |          @param off: the value of name expression. this parameter is used only
 |                      to check that the name expression will have the wanted
 |                      value. You may pass  BADADDR  for this parameter but I
 |                      discourage it because it prohibits checks. (C++: adiff_t)
 |          @return: true if the name expression has been produced
 |  
 |  out_printf(self, *args)
 |      Functions to append text to the current output buffer (outbuf) Append
 |      a formatted string to the output string.
 |      
 |      out_printf(self, format)
 |          @param format (C++: const char *)
 |          @return: the number of characters appended
 |  
 |  out_register(self, *args)
 |      Output a character with 'COLOR_REG' color.
 |      
 |      out_register(self, str)
 |          @param str (C++: const char *)
 |  
 |  out_spaces(self, *args)
 |      Appends spaces to outbuf until its tag_strlen becomes 'len'.
 |      
 |      out_spaces(self, len)
 |          @param len (C++: ssize_t)
 |  
 |  out_symbol(self, *args)
 |      Output a character with 'COLOR_SYMBOL' color.
 |      
 |      out_symbol(self, c)
 |          @param c (C++: char)
 |  
 |  out_tagoff(self, *args)
 |      Output "turn color off" escape sequence.
 |      
 |      out_tagoff(self, tag)
 |          @param tag (C++: color_t)
 |  
 |  out_tagon(self, *args)
 |      Output "turn color on" escape sequence.
 |      
 |      out_tagon(self, tag)
 |          @param tag (C++: color_t)
 |  
 |  out_value(self, *args)
 |      Output immediate value. Try to use this function to output all
 |      constants of instruction operands. This function outputs a number from
 |      x.addr or x.value in the form determined by ::uFlag. It outputs a
 |      colored text.-1 is output with 'COLOR_ERROR' 0 is output as a number
 |      or character or segment
 |      
 |      out_value(self, x, outf=0) -> flags_t
 |          @param x (C++: const  op_t  &)
 |          @param outf (C++: int)
 |          @return: flags of the output value
 |  
 |  print_label_now(self, *args)
 |      print_label_now(self) -> bool
 |  
 |  restore_ctxflags(self, *args)
 |      restore_ctxflags(self, saved_flags)
 |          @param saved_flags (C++: int)
 |  
 |  set_comment_addr(self, *args)
 |      set_comment_addr(self, ea)
 |          @param ea (C++: ea_t)
 |  
 |  set_dlbind_opnd(self, *args)
 |      set_dlbind_opnd(self)
 |  
 |  set_gen_cmt(self, *args)
 |      set_gen_cmt(self, on=True)
 |          @param on (C++: bool)
 |  
 |  set_gen_demangled_label(self, *args)
 |      set_gen_demangled_label(self)
 |  
 |  set_gen_label(self, *args)
 |      set_gen_label(self)
 |  
 |  set_gen_xrefs(self, *args)
 |      set_gen_xrefs(self, on=True)
 |          @param on (C++: bool)
 |  
 |  stack_view(self, *args)
 |      stack_view(self) -> bool
 |  
 |  term_outctx(self, *args)
 |      Finalize the output context.
 |      
 |      term_outctx(self, prefix=None) -> int
 |          @param prefix (C++: const char *)
 |          @return: the number of generated lines.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from outctx_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  default_lnnum
 |      outctx_base_t_default_lnnum_get(self) -> int
 |  
 |  insn_ea
 |      outctx_base_t_insn_ea_get(self) -> ea_t
 |  
 |  outbuf
 |      outctx_base_t_outbuf_get(self) -> qstring *

Help on function outctx_t__from_ptrval__ in module ida_ua:

outctx_t__from_ptrval__(*args)
    outctx_t__from_ptrval__(ptrval) -> outctx_t
        ptrval: size_t

Help on function print_insn_mnem in module ida_ua:

print_insn_mnem(*args)
    Print instruction mnemonics.
    
    print_insn_mnem(ea) -> str
        @param ea: linear address of the instruction (C++: ea_t)
        @return: success

Help on function print_operand in module ida_ua:

print_operand(*args)
    Generate text representation for operand #n. This function will
    generate the text representation of the specified operand (includes
    color codes.)
    
    print_operand(ea, n, getn_flags=0, newtype=None) -> str
        @param ea: the item address (instruction or data) (C++: ea_t)
        @param n: operand number (0,1,2...). meaningful only for instructions
                  (C++: int)
        @param getn_flags (C++: int)
        @param newtype: if specified, print the operand using the specified
                        type (C++: struct  printop_t  *)
        @return: success

=== ida_ua EPYDOC INJECTIONS ===
ida_ua.FCBF_CONT
"""
don't stop on decoding, or any other kind of error
"""

ida_ua.FCBF_DELIM
"""
add the 'ash'-specified delimiters around the generated data. Note: if
those are not defined and the INFFL_ALLASM is not set,
'format_charlit()' will return an error
"""

ida_ua.FCBF_ERR_REPL
"""
of a hex representation of the problematic byte

in case of an error, use a CP_REPLCHAR instead
"""

ida_ua.FCBF_FF_LIT
"""
in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER
Y WITH DIAERESIS) If both this, and FCBF_REPL are specified, this will
take precedence
"""

ida_ua.INSN_64BIT
"""
belongs to 64bit segment?
"""

ida_ua.INSN_MACRO
"""
macro instruction
"""

ida_ua.INSN_MODMAC
"""
may modify the database to make room for the macro insn
"""

ida_ua.OF_NO_BASE_DISP
"""
base displacement doesn't exist. meaningful only for 'o_displ' type.
if set, base displacement ( 'op_t::addr' ) doesn't exist.
"""

ida_ua.OF_NUMBER
"""
the operand can be converted to a number only
"""

ida_ua.OF_OUTER_DISP
"""
outer displacement exists. meaningful only for 'o_displ' type. if set,
outer displacement ( 'op_t::value' ) exists.
"""

ida_ua.OF_SHOW
"""
should the operand be displayed?
"""

ida_ua.OOFS_IFSIGN
"""
output sign if needed
"""

ida_ua.OOFS_NEEDSIGN
"""
always out sign (+-)
"""

ida_ua.OOFS_NOSIGN
"""
don't output sign, forbid the user to change the sign
"""

ida_ua.OOFW_16
"""
16 bit width
"""

ida_ua.OOFW_24
"""
24 bit width
"""

ida_ua.OOFW_32
"""
32 bit width
"""

ida_ua.OOFW_64
"""
64 bit width
"""

ida_ua.OOFW_8
"""
8 bit width
"""

ida_ua.OOFW_IMM
"""
take from x.dtype
"""

ida_ua.OOF_ADDR
"""
output x.addr, otherwise x.value
"""

ida_ua.OOF_ANYSERIAL
"""
if enum: select first available serial
"""

ida_ua.OOF_NOBNOT
"""
prohibit use of binary not
"""

ida_ua.OOF_NUMBER
"""
always as a number
"""

ida_ua.OOF_OUTER
"""
output outer operand
"""

ida_ua.OOF_SIGNED
"""
output as signed if < 0
"""

ida_ua.OOF_SIGNMASK
"""
sign symbol (+/-) output
"""

ida_ua.OOF_SPACES
"""
currently works only for floating point numbers

do not suppress leading spaces
"""

ida_ua.OOF_WIDTHMASK
"""
width of value in bits
"""

ida_ua.OOF_ZSTROFF
"""
meaningful only if is_stroff(uFlag) append a struct field name if the
field offset is zero? if 'AFL_ZSTROFF' is set, then this flag is
ignored.
"""

ida_ua.PACK_FORM_DEF
"""
(! 'o_reg' + 'dt_packreal' )

packed factor defined.
"""

ida_ua.dt_bitfild
"""
bit field (mc680x0)
"""

ida_ua.dt_byte
"""
8 bit integer
"""

ida_ua.dt_byte16
"""
128 bit integer
"""

ida_ua.dt_byte32
"""
256 bit integer
"""

ida_ua.dt_byte64
"""
512 bit integer
"""

ida_ua.dt_code
"""
ptr to code (not used?)
"""

ida_ua.dt_double
"""
8 byte floating point
"""

ida_ua.dt_dword
"""
32 bit integer
"""

ida_ua.dt_float
"""
4 byte floating point
"""

ida_ua.dt_fword
"""
48 bit
"""

ida_ua.dt_half
"""
2-byte floating point
"""

ida_ua.dt_ldbl
"""
long double (which may be different from tbyte)
"""

ida_ua.dt_packreal
"""
packed real format for mc68040
"""

ida_ua.dt_qword
"""
64 bit integer
"""

ida_ua.dt_string
"""
pointer to asciiz string
"""

ida_ua.dt_tbyte
"""
variable size (\\ph{tbyte_size}) floating point
"""

ida_ua.dt_unicode
"""
pointer to unicode string
"""

ida_ua.dt_void
"""
none
"""

ida_ua.dt_word
"""
16 bit integer
"""
=== ida_ua EPYDOC INJECTIONS END ===
Help on function add_cref in module ida_xref:

add_cref(*args)
    Create a code cross-reference.
    
    add_cref(frm, to, type) -> bool
        @param frm: linear address of referencing instruction (C++: ea_t)
        @param to: linear address of referenced instruction (C++: ea_t)
        @param type: cross-reference type (C++: cref_t)
        @return: success

Help on function add_dref in module ida_xref:

add_dref(*args)
    Create a data cross-reference.
    
    add_dref(frm, to, type) -> bool
        @param frm: linear address of referencing instruction or data (C++:
                    ea_t)
        @param to: linear address of referenced data (C++: ea_t)
        @param type: cross-reference type (C++: dref_t)
        @return: success (may fail if user-defined xref exists from->to)

Help on function calc_switch_cases in module ida_xref:

calc_switch_cases(*args)
    calc_switch_cases(ea, si) -> cases_and_targets_t
    Get information about a switch's cases.
    
    The returned information can be used as follows:
    
        for idx in range(len(results.cases)):
            cur_case = results.cases[idx]
            for cidx in range(len(cur_case)):
                print("case: %d" % cur_case[cidx])
            print("  goto 0x%x" % results.targets[idx])
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: a structure with 2 members: 'cases', and 'targets'.

Help on class cases_and_targets_t in module ida_xref:

class cases_and_targets_t(__builtin__.object)
 |  Proxy of C++ cases_and_targets_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cases_and_targets_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cases
 |      cases_and_targets_t_cases_get(self) -> casevec_t
 |  
 |  targets
 |      cases_and_targets_t_targets_get(self) -> eavec_t *
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_cases_and_targets_t>
 |      delete_cases_and_targets_t(self)

Help on class casevec_t in module ida_xref:

class casevec_t(__builtin__.object)
 |  Proxy of C++ qvector< qvector< sval_t > > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args)
 |      __eq__(self, r) -> bool
 |          r: qvector< qvector< signed-ea-like-numeric-type > > const &↗
 |  
 |  __getitem__(self, *args)
 |      __getitem__(self, i) -> qvector< signed-ea-like-numeric-type > const &↗
 |          i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> casevec_t
 |          x: qvector< qvector< signed-ea-like-numeric-type > > const &↗
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args)
 |  
 |  __ne__(self, *args)
 |      __ne__(self, r) -> bool
 |          r: qvector< qvector< signed-ea-like-numeric-type > > const &↗
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args)
 |      __setitem__(self, i, v)
 |          i: size_t
 |          v: qvector< signed-ea-like-numeric-type > const &↗
 |  
 |  _del(self, *args)
 |      _del(self, x) -> bool
 |          x: qvector< signed-ea-like-numeric-type > const &↗
 |  
 |  add_unique(self, *args)
 |      add_unique(self, x) -> bool
 |          x: qvector< signed-ea-like-numeric-type > const &↗
 |  
 |  append = push_back(self, *args)
 |  
 |  at = __getitem__(self, *args)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args)
 |      begin(self) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |      begin(self) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator↗
 |  
 |  capacity(self, *args)
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args)
 |      clear(self)
 |  
 |  empty(self, *args)
 |      empty(self) -> bool
 |  
 |  end(self, *args)
 |      end(self) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |      end(self) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator↗
 |  
 |  erase(self, *args)
 |      erase(self, it) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |          it: qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |      
 |      
 |      erase(self, first, last) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |          first: qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |          last: qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |  
 |  extract(self, *args)
 |      extract(self) -> qvector< signed-ea-like-numeric-type > *↗
 |  
 |  find(self, *args)
 |      find(self, x) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |          x: qvector< signed-ea-like-numeric-type > const &↗
 |      
 |      
 |      find(self, x) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator↗
 |          x: qvector< signed-ea-like-numeric-type > const &↗
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args)
 |      grow(self, x=qvector< signed-ea-like-numeric-type >())↗
 |          x: qvector< signed-ea-like-numeric-type > const &↗
 |  
 |  has(self, *args)
 |      has(self, x) -> bool
 |          x: qvector< signed-ea-like-numeric-type > const &↗
 |  
 |  inject(self, *args)
 |      inject(self, s, len)
 |          s: qvector< signed-ea-like-numeric-type > *↗
 |          len: size_t
 |  
 |  insert(self, *args)
 |      insert(self, it, x) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |          it: qvector< qvector< signed-ea-like-numeric-type > >::iterator↗
 |          x: qvector< signed-ea-like-numeric-type > const &↗
 |  
 |  pop_back(self, *args)
 |      pop_back(self)
 |  
 |  push_back(self, *args)
 |      push_back(self, x)
 |          x: qvector< signed-ea-like-numeric-type > const &↗
 |  
 |  qclear(self, *args)
 |      qclear(self)
 |  
 |  reserve(self, *args)
 |      reserve(self, cnt)
 |          cnt: size_t
 |  
 |  resize(self, *args)
 |      resize(self, _newsize, x)
 |          _newsize: size_t
 |          x: qvector< signed-ea-like-numeric-type > const &↗
 |      
 |      
 |      resize(self, _newsize)
 |          _newsize: size_t
 |  
 |  size(self, *args)
 |      size(self) -> size_t
 |  
 |  swap(self, *args)
 |      swap(self, r)
 |          r: qvector< qvector< signed-ea-like-numeric-type > > &↗
 |  
 |  truncate(self, *args)
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_casevec_t>
 |      delete_casevec_t(self)

Help on function create_switch_table in module ida_xref:

create_switch_table(*args)
    create_switch_table(ea, si) -> bool
    Create switch table from the switch information
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: Boolean

Help on function create_switch_xrefs in module ida_xref:

create_switch_xrefs(*args)
    create_switch_xrefs(ea, si) -> bool
    This function creates xrefs from the indirect jump.
    
    Usually there is no need to call this function directly because the kernel
    will call it for switch tables
    
    Note: Custom switch information are not supported yet.
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: Boolean

Help on function del_cref in module ida_xref:

del_cref(*args)
    Delete a code cross-reference.
    
    del_cref(frm, to, expand) -> bool
        @param frm: linear address of referencing instruction (C++: ea_t)
        @param to: linear address of referenced instruction (C++: ea_t)
        @param expand: policy to delete the referenced instruction   1: plan
                       to delete the referenced instruction if it has no more
                       references.   0: don't delete the referenced
                       instruction even if no more cross-references point to
                       it (C++: bool)
        @retval: true - if the referenced instruction will be deleted

Help on function del_dref in module ida_xref:

del_dref(*args)
    Delete a data cross-reference.
    
    del_dref(frm, to)
        @param frm: linear address of referencing instruction or data (C++:
                    ea_t)
        @param to: linear address of referenced data (C++: ea_t)

Help on function delete_switch_table in module ida_xref:

delete_switch_table(*args)
    delete_switch_table(jump_ea, si)
        jump_ea: ea_t
        si: switch_info_t const &

Help on function get_first_cref_from in module ida_xref:

get_first_cref_from(*args)
    Get first instruction referenced from the specified instruction. If
    the specified instruction passes execution to the next instruction
    then the next instruction is returned. Otherwise the lowest referenced
    address is returned (remember that xrefs are kept sorted!).
    
    get_first_cref_from(frm) -> ea_t
        @param frm: linear address of referencing instruction (C++: ea_t)
        @return: first referenced address. If the specified instruction
                 doesn't reference to other instructions then returns  BADADDR
                 .

Help on function get_first_cref_to in module ida_xref:

get_first_cref_to(*args)
    Get first instruction referencing to the specified instruction. If the
    specified instruction may be executed immediately after its previous
    instruction then the previous instruction is returned. Otherwise the
    lowest referencing address is returned. (remember that xrefs are kept
    sorted!).
    
    get_first_cref_to(to) -> ea_t
        @param to: linear address of referenced instruction (C++: ea_t)
        @return: linear address of the first referencing instruction or
                 BADADDR .

Help on function get_first_dref_from in module ida_xref:

get_first_dref_from(*args)
    Get first data referenced from the specified address.
    
    get_first_dref_from(frm) -> ea_t
        @param frm: linear address of referencing instruction or data (C++:
                    ea_t)
        @return: linear address of first (lowest) data referenced from the
                 specified address. Return  BADADDR  if the specified
                 instruction/data doesn't reference to anything.

Help on function get_first_dref_to in module ida_xref:

get_first_dref_to(*args)
    Get address of instruction/data referencing to the specified data.
    
    get_first_dref_to(to) -> ea_t
        @param to: linear address of referencing instruction or data (C++:
                   ea_t)
        @return: BADADDR  if nobody refers to the specified data.

Help on function get_first_fcref_from in module ida_xref:

get_first_fcref_from(*args)
    get_first_fcref_from(frm) -> ea_t
        @param frm (C++: ea_t)

Help on function get_first_fcref_to in module ida_xref:

get_first_fcref_to(*args)
    get_first_fcref_to(to) -> ea_t
        @param to (C++: ea_t)

Help on function get_next_cref_from in module ida_xref:

get_next_cref_from(*args)
    Get next instruction referenced from the specified instruction.
    
    get_next_cref_from(frm, current) -> ea_t
        @param frm: linear address of referencing instruction (C++: ea_t)
        @param current: linear address of current referenced instruction This
                        value is returned by  get_first_cref_from()  or
                        previous call to  get_next_cref_from()  functions.
                        (C++: ea_t)
        @return: next referenced address or  BADADDR .

Help on function get_next_cref_to in module ida_xref:

get_next_cref_to(*args)
    Get next instruction referencing to the specified instruction.
    
    get_next_cref_to(to, current) -> ea_t
        @param to: linear address of referenced instruction (C++: ea_t)
        @param current: linear address of current referenced instruction This
                        value is returned by  get_first_cref_to()  or previous
                        call to  get_next_cref_to()  functions. (C++: ea_t)
        @return: linear address of the next referencing instruction or
                 BADADDR .

Help on function get_next_dref_from in module ida_xref:

get_next_dref_from(*args)
    Get next data referenced from the specified address.
    
    get_next_dref_from(frm, current) -> ea_t
        @param frm: linear address of referencing instruction or data (C++:
                    ea_t)
        @param current: linear address of current referenced data. This value
                        is returned by  get_first_dref_from()  or previous
                        call to  get_next_dref_from()  functions. (C++: ea_t)
        @return: linear address of next data or  BADADDR .

Help on function get_next_dref_to in module ida_xref:

get_next_dref_to(*args)
    Get address of instruction/data referencing to the specified data
    
    get_next_dref_to(to, current) -> ea_t
        @param to: linear address of referencing instruction or data (C++:
                   ea_t)
        @param current: current linear address. This value is returned by
                        get_first_dref_to()  or previous call to
                        get_next_dref_to()  functions. (C++: ea_t)
        @return: BADADDR  if nobody refers to the specified data.

Help on function get_next_fcref_from in module ida_xref:

get_next_fcref_from(*args)
    get_next_fcref_from(frm, current) -> ea_t
        @param frm (C++: ea_t)
        @param current (C++: ea_t)

Help on function get_next_fcref_to in module ida_xref:

get_next_fcref_to(*args)
    get_next_fcref_to(to, current) -> ea_t
        @param to (C++: ea_t)
        @param current (C++: ea_t)

Help on function has_external_refs in module ida_xref:

has_external_refs(*args)
    Has a location external to the function references?
    
    has_external_refs(pfn, ea) -> bool
        @param pfn (C++: func_t  *)
        @param ea (C++: ea_t)

Help on class xrefblk_t in module ida_xref:

class xrefblk_t(__builtin__.object)
 |  Proxy of C++ xrefblk_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> xrefblk_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  first_from(self, *args)
 |      first_from(self, _from, flags) -> bool
 |          _from: ea_t
 |          flags: int
 |  
 |  first_to(self, *args)
 |      first_to(self, _to, flags) -> bool
 |          _to: ea_t
 |          flags: int
 |  
 |  next_from(self, *args)
 |      next_from(self) -> bool
 |          _from: ea_t
 |          _to: ea_t
 |          flags: int
 |  
 |  next_to(self, *args)
 |      next_to(self) -> bool
 |          _from: ea_t
 |          _to: ea_t
 |          flags: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  frm
 |      xrefblk_t_frm_get(self) -> ea_t
 |  
 |  iscode
 |      xrefblk_t_iscode_get(self) -> uchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  to
 |      xrefblk_t_to_get(self) -> ea_t
 |  
 |  type
 |      xrefblk_t_type_get(self) -> uchar
 |  
 |  user
 |      xrefblk_t_user_get(self) -> uchar
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __swig_destroy__ = <built-in function delete_xrefblk_t>
 |      delete_xrefblk_t(self)

Help on function xrefchar in module ida_xref:

xrefchar(*args)
    Get character describing the xref type.
    
    xrefchar(xrtype) -> char
        @param xrtype: combination of  Cross-Reference type flags  and a
                       cref_t  of  dref_t  value (C++: char)

=== ida_xref EPYDOC INJECTIONS ===
ida_xref.XREF_ALL
"""
return all references
"""

ida_xref.XREF_BASE
"""
Reference to the base part of an offset.
"""

ida_xref.XREF_DATA
"""
return data references only
"""

ida_xref.XREF_FAR
"""
don't return ordinary flow xrefs
"""

ida_xref.XREF_MASK
"""
Mask to get xref type.
"""

ida_xref.XREF_PASTEND
"""
Reference is past item. This bit may be passed to 'add_dref()'
functions but it won't be saved in the database. It will prevent the
destruction of eventual alignment directives.
"""

ida_xref.XREF_TAIL
"""
Reference to tail byte in extrn symbols.
"""

ida_xref.XREF_USER
"""
User specified xref. This xref will not be deleted by IDA. This bit
should be combined with the existing xref types ( 'cref_t' & 'dref_t'
) Cannot be used for fl_F xrefs
"""
=== ida_xref EPYDOC INJECTIONS END ===
Help on function AddSeg in module idc:

AddSeg(startea, endea, base, use32, align, comb)

Help on function AutoMark in module idc:

AutoMark(ea, qtype)
    Plan to analyze an address

Help on class DeprecatedIDCError in module idc:

class DeprecatedIDCError(exceptions.Exception)
 |  Exception for deprecated function calls
 |  
 |  Method resolution order:
 |      DeprecatedIDCError
 |      exceptions.Exception
 |      exceptions.BaseException
 |      __builtin__.object
 |  
 |  Data descriptors defined here:
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from exceptions.Exception:
 |  
 |  __init__(...)
 |      x.__init__(...) initializes x; see help(type(x)) for signature
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from exceptions.Exception:
 |  
 |  __new__ = <built-in method __new__ of type object>
 |      T.__new__(S, ...) -> a new object with type S, a subtype of T
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from exceptions.BaseException:
 |  
 |  __delattr__(...)
 |      x.__delattr__('name') <==> del x.name
 |  
 |  __getattribute__(...)
 |      x.__getattribute__('name') <==> x.name
 |  
 |  __getitem__(...)
 |      x.__getitem__(y) <==> x[y]
 |  
 |  __getslice__(...)
 |      x.__getslice__(i, j) <==> x[i:j]
 |      
 |      Use of negative indices is not supported.
 |  
 |  __reduce__(...)
 |  
 |  __repr__(...)
 |      x.__repr__() <==> repr(x)
 |  
 |  __setattr__(...)
 |      x.__setattr__('name', value) <==> x.name = value
 |  
 |  __setstate__(...)
 |  
 |  __str__(...)
 |      x.__str__() <==> str(x)
 |  
 |  __unicode__(...)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from exceptions.BaseException:
 |  
 |  __dict__
 |  
 |  args
 |  
 |  message

Help on function EVAL_FAILURE in module idc:

EVAL_FAILURE(code)
    Check the result of eval_idc() for evaluation failures
    
    @param code: result of eval_idc()
    
    @return: True if there was an evaluation error

Help on function get_cmt in module ida_bytes:

get_cmt(*args)
    Get an indented comment.
    
    get_cmt(ea, rptble) -> str
        @param ea: linear address. may point to tail byte, the function will
                   find start of the item (C++: ea_t)
        @param rptble: get repeatable comment? (C++: bool)
        @return: size of comment or -1

Help on function GetDisasm in module idc:

GetDisasm(ea)
    Get disassembly line
    
    @param ea: linear address of instruction
    
    @return: "" - could not decode instruction at the specified location
    
    @note: this function may not return exactly the same mnemonics
           as you see on the screen.

Help on function GetDouble in module idc:

GetDouble(ea)
    Get value of a floating point number (8 bytes)
    This function assumes number stored using IEEE format
    and in the same endianness as integers.
    
    @param ea: linear address
    
    @return: double

Help on function GetFloat in module idc:

GetFloat(ea)
    Get value of a floating point number (4 bytes)
    This function assumes number stored using IEEE format
    and in the same endianness as integers.
    
    @param ea: linear address
    
    @return: float

Help on function GetLocalType in module idc:

GetLocalType(ordinal, flags)
    Retrieve a local type declaration
    @param flags: any of PRTYPE_* constants
    @return: local type as a C declaration or ""

Help on function LoadFile in module idc:

LoadFile(filepath, pos, ea, size)
    Load file into IDA database
    
    @param filepath: path to input file
    @param pos: position in the file
    @param ea: linear address to load
    @param size: number of bytes to load
    
    @return: 0 - error, 1 - ok

Help on function MakeVar in module idc:

MakeVar(ea)

Help on function SaveFile in module idc:

SaveFile(filepath, pos, ea, size)
    Save from IDA database to file
    
    @param filepath: path to output file
    @param pos: position in the file
    @param ea: linear address to save from
    @param size: number of bytes to save
    
    @return: 0 - error, 1 - ok

Help on function SetPrcsr in module idc:

SetPrcsr(processor)

Help on function SetType in module idc:

SetType(ea, newtype)
    Set type of function/variable
    
    @param ea: the address of the object
    @param newtype: the type string in C declaration form.
                Must contain the closing ';'
                if specified as an empty string, then the
                item associated with 'ea' will be deleted.
    
    @return: 1-ok, 0-failed.

Help on function SizeOf in module idc:

SizeOf(typestr)
    Returns the size of the type. It is equivalent to IDC's sizeof().
    Use name, tp, fld = idc.parse_decl() ; SizeOf(tp) to retrieve the size
    @return: -1 if typestring is not valid otherwise the size of the type

Help on function _IDC_GetAttr in module idc:

_IDC_GetAttr(obj, attrmap, attroffs)
    Internal function to generically get object attributes
    Do not use unless you know what you are doing

Help on function _IDC_SetAttr in module idc:

_IDC_SetAttr(obj, attrmap, attroffs, value)
    Internal function to generically set object attributes
    Do not use unless you know what you are doing

Help on function __DbgValue in module idc:

__DbgValue(ea, len)

Help on function __GetArrayById in module idc:

__GetArrayById(array_id)
    Get an array, by its ID.
    
    This (internal) wrapper around 'idaaip.netnode(array_id)'
    will ensure a certain safety around the retrieval of
    arrays (by catching quite unexpect[ed|able] exceptions,
    and making sure we don't create & use `transient' netnodes).
    
    @param array_id: A positive, valid array ID.

Help on class __dummy_netnode in module idc:

class __dummy_netnode(__builtin__.object)
 |  Implements, in an "always failing" fashion, the
 |  netnode functions that are necessary for the
 |  array-related functions.
 |  
 |  The sole purpose of this singleton class is to
 |  serve as a placeholder for netnode-manipulating
 |  functions, that don't want to each have to perform
 |  checks on the existence of the netnode.
 |  (..in other words: it avoids a bunch of if/else's).
 |  
 |  See __GetArrayById() for more info.
 |  
 |  Methods defined here:
 |  
 |  altdel(self, *args)
 |  
 |  altfirst(self, *args)
 |  
 |  altlast(self, *args)
 |  
 |  altnext(self, *args)
 |  
 |  altprev(self, *args)
 |  
 |  altset(self, *args)
 |  
 |  altval(self, *args)
 |  
 |  hashdel(self, *args)
 |  
 |  hashfirst(self, *args)
 |  
 |  hashlast(self, *args)
 |  
 |  hashnext(self, *args)
 |  
 |  hashprev(self, *args)
 |  
 |  hashset(self, *args)
 |  
 |  hashset_buf(self, *args)
 |  
 |  hashset_idx(self, *args)
 |  
 |  hashstr(self, *args)
 |  
 |  hashstr_buf(self, *args)
 |  
 |  hashval(self, *args)
 |  
 |  hashval_long(self, *args)
 |  
 |  index(self, *args)
 |  
 |  kill(self, *args)
 |  
 |  rename(self, *args)
 |  
 |  supdel(self, *args)
 |  
 |  supfirst(self, *args)
 |  
 |  suplast(self, *args)
 |  
 |  supnext(self, *args)
 |  
 |  supprev(self, *args)
 |  
 |  supset(self, *args)
 |  
 |  supval(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  instance = <idc.__dummy_netnode object>

Help on function __l2m1 in module idc:

__l2m1(v)
    Long to minus 1: If the 'v' appears to be the
    'signed long' version of -1, then return -1.
    Otherwise, return 'v'.

Help on function __warn_once_deprecated_proto_confusion in module idc:

__warn_once_deprecated_proto_confusion(what, alternative)

Help on function _get_modules in module idc:

_get_modules()
    INTERNAL: Enumerate process modules

Help on function _import_module_flag_sets in module idc:

_import_module_flag_sets(module, prefixes)

Help on function add_auto_stkpnt in module idc:

add_auto_stkpnt(func_ea, ea, delta)
    Add automatical SP register change point
    @param func_ea: function start
    @param ea: linear address where SP changes
               usually this is the end of the instruction which
               modifies the stack pointer (insn.ea+insn.size)
    @param delta: difference between old and new values of SP
    @return: 1-ok, 0-failed

Help on function add_bpt in module ida_dbg:

add_bpt(*args)
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous
    function)}Only one breakpoint can exist at a given address.
    
    add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
        @param ea: any address in the process memory space. Depending on the
                   architecture, hardware breakpoints always be setup at
                   random address. For example, on x86, hardware breakpoints
                   should be aligned depending on their size. Moreover, on the
                   x86 architecture, it is impossible to setup more than 4
                   hardware breakpoints. (C++: ea_t)
        @param size: size of the breakpoint (irrelevant for software
                     breakpoints): As for the address, hardware breakpoints
                     can't always be setup with random size. (C++: asize_t)
        @param type: type of the breakpoint ( BPT_SOFT  for software
                     breakpoint) special case  BPT_DEFAULT  ( BPT_SOFT |
                     BPT_EXEC ): try to add instruction breakpoint of the
                     appropriate type as follows: software bpt if supported,
                     hwbpt otherwise (C++: bpttype_t)
    
    
    add_bpt(bpt) -> bool
        bpt: bpt_t const &

Help on function add_cref in module ida_xref:

add_cref(*args)
    Create a code cross-reference.
    
    add_cref(frm, to, type) -> bool
        @param frm: linear address of referencing instruction (C++: ea_t)
        @param to: linear address of referenced instruction (C++: ea_t)
        @param type: cross-reference type (C++: cref_t)
        @return: success

Help on function add_default_til in module idc:

add_default_til(name)
    Load a type library
    
    @param name: name of type library.
    @return: 1-ok, 0-failed.

Help on function add_dref in module ida_xref:

add_dref(*args)
    Create a data cross-reference.
    
    add_dref(frm, to, type) -> bool
        @param frm: linear address of referencing instruction or data (C++:
                    ea_t)
        @param to: linear address of referenced data (C++: ea_t)
        @param type: cross-reference type (C++: dref_t)
        @return: success (may fail if user-defined xref exists from->to)

Help on function add_entry in module ida_entry:

add_entry(*args)
    Add an entry point to the list of entry points.
    
    add_entry(ord, ea, name, makecode, flags=0) -> bool
        @param ord: ordinal number if ordinal number is equal to 'ea' then
                    ordinal is not used (C++: uval_t)
        @param ea: linear address (C++: ea_t)
        @param name: name of entry point. If the specified location already
                     has a name, the old name will be appended to the regular
                     comment. If name == NULL, then the old name will be
                     retained. (C++: const char *)
        @param makecode: should the kernel convert bytes at the entry point to
                         instruction(s) (C++: bool)
        @param flags: See AEF_* (C++: int)
        @return: success (currently always true)

Help on function add_enum in module idc:

add_enum(idx, name, flag)
    Add a new enum type
    
    @param idx: serial number of the new enum.
            If another enum with the same serial number
            exists, then all enums with serial
            numbers >= the specified idx get their
            serial numbers incremented (in other words,
            the new enum is put in the middle of the list of enums).
    
            If idx >= get_enum_qty() or idx == idaapi.BADNODE
            then the new enum is created at the end of
            the list of enums.
    
    @param name: name of the enum.
    @param flag: flags for representation of numeric constants
                 in the definition of enum.
    
    @return: id of new enum or BADADDR

Help on function add_enum_member in module idc:

add_enum_member(enum_id, name, value, bmask)
    Add a member of enum - a symbolic constant
    
    @param enum_id: id of enum
    @param name: name of symbolic constant. Must be unique in the program.
    @param value: value of symbolic constant.
    @param bmask: bitmask of the constant
        ordinary enums accept only ida_enum.DEFMASK as a bitmask
        all bits set in value should be set in bmask too
    
    @return: 0-ok, otherwise error code (one of ENUM_MEMBER_ERROR_*)

Help on function add_func in module ida_funcs:

add_func(*args)
    Add a new function. If the function end address is 'BADADDR' , then
    IDA will try to determine the function bounds by calling
    find_func_bounds(..., 'FIND_FUNC_DEFINE' ).
    
    add_func(ea1, ea2=BADADDR) -> bool
        @param ea1: start address (C++: ea_t)
        @param ea2: end address (C++: ea_t)
        @return: success

Help on function add_hidden_range in module ida_bytes:

add_hidden_range(*args)
    Mark a range of addresses as hidden. The range will be created in the
    invisible state with the default color
    
    add_hidden_range(ea1, ea2, description, header, footer, color) -> bool
        @param ea1: linear address of start of the address range (C++: ea_t)
        @param ea2: linear address of end of the address range (C++: ea_t)
        @param description: range parameters (C++: const char *)
        @param header: range parameters (C++: const char *)
        @param footer: range parameters (C++: const char *)
        @param color (C++: bgcolor_t)
        @return: success

Help on function add_idc_hotkey in module ida_kernwin:

add_idc_hotkey(*args)
    Add hotkey for IDC function ( 'ui_add_idckey' ).
    
    add_idc_hotkey(hotkey, idcfunc) -> int
        @param hotkey: hotkey name (C++: const char *)
        @param idcfunc: IDC function name (C++: const char *)
        @return: IDC hotkey error codes

Help on function add_segm_ex in module idc:

add_segm_ex(startea, endea, base, use32, align, comb, flags)
    Create a new segment
    
    @param startea: linear address of the start of the segment
    @param endea: linear address of the end of the segment
               this address will not belong to the segment
               'endea' should be higher than 'startea'
    @param base: base paragraph or selector of the segment.
               a paragraph is 16byte memory chunk.
               If a selector value is specified, the selector should be
               already defined.
    @param use32: 0: 16bit segment, 1: 32bit segment, 2: 64bit segment
    @param align: segment alignment. see below for alignment values
    @param comb: segment combination. see below for combination values.
    @param flags: combination of ADDSEG_... bits
    
    @return: 0-failed, 1-ok

Help on function add_sourcefile in module ida_lines:

add_sourcefile(*args)
    Mark a range of address as belonging to a source file. An address
    range may belong only to one source file. A source file may be
    represented by several address ranges.
    
    add_sourcefile(ea1, ea2, filename) -> bool
        @param ea1: linear address of start of the address range (C++: ea_t)
        @param ea2: linear address of end of the address range (excluded)
                    (C++: ea_t)
        @param filename: name of source file. (C++: const char *)
        @return: success

Help on function add_struc in module idc:

add_struc(index, name, is_union)
    Define a new structure type
    
    @param index: index of new structure type
                  If another structure has the specified index,
                  then index of that structure and all other
                  structures will be incremented, freeing the specifed
                  index. If index is == -1, then the biggest index
                  number will be used.
                  See get_first_struc_idx() for the explanation of
                  structure indices and IDs.
    @param name: name of the new structure type.
    @param is_union: 0: structure
                     1: union
    
    @return: -1 if can't define structure type because of
             bad structure name: the name is ill-formed or is
             already used in the program.
             otherwise returns ID of the new structure type

Help on function add_struc_member in module idc:

add_struc_member(sid, name, offset, flag, typeid, nbytes, target=-1, tdelta=0, reftype=2)
    Add structure member
    
    @param sid: structure type ID
    @param name: name of the new member
    @param offset: offset of the new member
                   -1 means to add at the end of the structure
    @param flag: type of the new member. Should be one of
                 FF_BYTE..FF_PACKREAL (see above) combined with FF_DATA
    @param typeid: if is_struct(flag) then typeid specifies the structure id for the member
                   if is_off0(flag) then typeid specifies the offset base.
                   if is_strlit(flag) then typeid specifies the string type (STRTYPE_...).
                   if is_stroff(flag) then typeid specifies the structure id
                   if is_enum(flag) then typeid specifies the enum id
                   if is_custom(flags) then typeid specifies the dtid and fid: dtid|(fid<<16)
                   Otherwise typeid should be -1.
    @param nbytes: number of bytes in the new member
    
    @param target: target address of the offset expr. You may specify it as
                   -1, ida will calculate it itself
    @param tdelta: offset target delta. usually 0
    @param reftype: see REF_... definitions
    
    @note: The remaining arguments are allowed only if is_off0(flag) and you want
           to specify a complex offset expression
    
    @return: 0 - ok, otherwise error code (one of STRUC_ERROR_*)

Help on function add_user_stkpnt in module ida_frame:

add_user_stkpnt(*args)
    Add user-defined SP register change point.
    
    add_user_stkpnt(ea, delta) -> bool
        @param ea: linear address where SP changes (C++: ea_t)
        @param delta: difference between old and new values of SP (C++:
                      sval_t)
        @return: success

Help on function append_func_tail in module idc:

append_func_tail(funcea, ea1, ea2)
    Append a function chunk to the function
    
    @param funcea: any address in the function
    @param ea1: start of function tail
    @param ea2: end of function tail
    @return: 0 if failed, 1 if success
    
    @note: If a chunk exists at the specified addresses, it must have exactly
           the specified boundaries

Help on function apply_type in module idc:

apply_type(ea, py_type, flags=1)
    Apply the specified type to the address
    
    @param ea: the address of the object
    @param py_type: typeinfo tuple (type, fields) as get_tinfo() returns
                 or tuple (name, type, fields) as parse_decl() returns
                 or None
                if specified as None, then the
                item associated with 'ea' will be deleted.
    @param flags: combination of TINFO_... constants or 0
    @return: Boolean

Help on function ask_seg in module ida_kernwin:

ask_seg(defval, format)
    # ----------------------------------------------------------------------

Help on function ask_yn in module ida_kernwin:

ask_yn(*args)
    Display a dialog box and get choice from "Yes", "No", "Cancel".
    
    ask_yn(deflt, format) -> int
        @param deflt: default choice: one of  Button IDs (C++: int)
        @param format: The question in printf() style format (C++: const char
                       *)
        @return: the selected button (one of  Button IDs ). Esc key returns
                 ASKBTN_CANCEL .

Help on function atoa in module idc:

atoa(ea)
    Convert address value to a string
    Return address in the form 'seg000:1234'
    (the same as in line prefixes)
    
    @param ea: address to format

Help on function atol in module idc:

atol(s)

Help on function attach_process in module ida_dbg:

attach_process(*args)
    Attach the debugger to a running process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_attach'
    }This function shouldn't be called as a request if 'NO_PROCESS' is
    used.
    
    attach_process(pid=pid_t(-1), event_id=-1) -> int
        @param pid: PID of the process to attach to. If  NO_PROCESS , a dialog
                    box will interactively ask the user for the process to
                    attach to. (C++: pid_t)
        @param event_id (C++: int)
        @retval: -4 - debugger was not inited
        @retval: -3 - the attaching is not supported
        @retval: -2 - impossible to find a compatible process
        @retval: -1 - impossible to attach to the given process (process died,
                      privilege needed, not supported by the debugger plugin,
                      ...)
        @retval: 0 - the user cancelled the attaching to the process
        @retval: 1 - the debugger properly attached to the process

Help on function auto_mark_range in module ida_auto:

auto_mark_range(*args)
    Put range of addresses into a queue. 'start' may be higher than 'end',
    the kernel will swap them in this case. 'end' doesn't belong to the
    range.
    
    auto_mark_range(start, end, type)
        @param start (C++: ea_t)
        @param end (C++: ea_t)
        @param type (C++: atype_t)

Help on function auto_unmark in module ida_auto:

auto_unmark(*args)
    Remove range of addresses from a queue. 'start' may be higher than
    'end', the kernel will swap them in this case. 'end' doesn't belong to
    the range.
    
    auto_unmark(start, end, type)
        @param start (C++: ea_t)
        @param end (C++: ea_t)
        @param type (C++: atype_t)

Help on function auto_wait in module ida_auto:

auto_wait(*args)
    Process everything in the queues and return true.

Help on function batch in module idc:

batch(batch)
    Enable/disable batch mode of operation
    
    @param batch: batch mode
            0 - ida will display dialog boxes and wait for the user input
            1 - ida will not display dialog boxes, warnings, etc.
    
    @return: old balue of batch flag

Help on function byte_value in module idc:

byte_value(F)
    Get byte value from flags
    Get value of byte provided that the byte is initialized.
    This macro works ok only for 8-bit byte machines.

Help on function calc_gtn_flags in module ida_name:

calc_gtn_flags(fromaddr, ea)
    Calculate flags for get_ea_name() function
    
    @param fromaddr: the referring address. May be BADADDR.
    @param ea: linear address
    
    @return: flags

Help on function call_system in module idc:

call_system(command)
    Execute an OS command.
    
    @param command: command line to execute
    
    @return: error code from OS
    
    @note:
    IDA will wait for the started program to finish.
    In order to start the command in parallel, use OS methods.
    For example, you may start another program in parallel using
    "start" command.

Help on function can_exc_continue in module idc:

can_exc_continue()
    Can it continue after EXCEPTION event?
    
    @return: boolean

Help on function check_bpt in module ida_dbg:

check_bpt(*args)
    Check the breakpoint at the specified address.
    
    check_bpt(ea) -> int
        @param ea (C++: ea_t)
        @return: one of  Breakpoint status codes

Help on function choose_func in module idc:

choose_func(title)
    Ask the user to select a function
    
    Arguments:
    
    @param title: title of the dialog box
    
    @return: -1 - user refused to select a function
             otherwise returns the selected function start address

Help on function clear_trace in module idc:

clear_trace(filename)
    Clear the current trace buffer

Help on function create_align in module ida_bytes:

create_align(*args)
    Alignment: 0 or 2..32. If it is 0, is will be calculated.
    
    create_align(ea, length, alignment) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param alignment (C++: int)

Help on function create_array in module idc:

create_array(name)
    Create array.
    
    @param name: The array name.
    
    @return: -1 in case of failure, a valid array_id otherwise.

Help on function create_byte in module idc:

create_byte(ea)
    Convert the current item to a byte
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_custdata in module ida_bytes:

create_custdata(*args)
    Convert to custom data type.
    
    create_custdata(ea, length, dtid, fid, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param dtid (C++: int)
        @param fid (C++: int)
        @param force (C++: bool)

Help on function create_data in module ida_bytes:

create_data(*args)
    Convert to data (byte, word, dword, etc). This function may be used to
    create arrays.
    
    create_data(ea, dataflag, size, tid) -> bool
        @param ea: linear address (C++: ea_t)
        @param dataflag: type of data. Value of function  byte_flag() ,
                         word_flag() , etc. (C++: flags_t)
        @param size: size of array in bytes. should be divisible by the size
                     of one item of the specified type. for variable sized
                     items it can be specified as 0, and the kernel will try
                     to calculate the size. (C++: asize_t)
        @param tid: type id. If the specified type is a structure, then tid is
                    structure id. Otherwise should be  BADNODE . (C++: tid_t)
        @return: success

Help on function create_double in module idc:

create_double(ea)
    Convert the current item to a double floating point (8 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_dword in module idc:

create_dword(ea)
    Convert the current item to a double word (4 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_float in module idc:

create_float(ea)
    Convert the current item to a floating point (4 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_insn in module ida_ua:

create_insn(*args)
    Create an instruction at the specified address. This function checks
    if an instruction is present at the specified address and will try to
    create one if there is none. It will fail if there is a data item or
    other items hindering the creation of the new instruction. This
    function will also fill the 'out' structure.
    
    create_insn(ea, out=None) -> int
        @param ea: linear address (C++: ea_t)
        @param out: the resulting instruction (C++: insn_t  *)
        @return: the length of the instruction or 0

Help on function create_oword in module idc:

create_oword(ea)
    Convert the current item to an octa word (16 bytes/128 bits)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_pack_real in module idc:

create_pack_real(ea)
    Convert the current item to a packed real (10 or 12 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_qword in module idc:

create_qword(ea)
    Convert the current item to a quadro word (8 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_strlit in module idc:

create_strlit(ea, endea)
    Create a string.
    
    This function creates a string (the string type is determined by the
    value of get_inf_attr(INF_STRTYPE))
    
    @param ea: linear address
    @param endea: ending address of the string (excluded)
        if endea == BADADDR, then length of string will be calculated
        by the kernel
    
    @return: 1-ok, 0-failure
    
    @note: The type of an existing string is returned by get_str_type()

Help on function create_struct in module idc:

create_struct(ea, size, strname)
    Convert the current item to a structure instance
    
    @param ea: linear address
    @param size: structure size in bytes. -1 means that the size
        will be calculated automatically
    @param strname: name of a structure type
    
    @return: 1-ok, 0-failure

Help on function create_tbyte in module idc:

create_tbyte(ea)
    Convert the current item to a tbyte (10 or 12 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_word in module idc:

create_word(ea)
    Convert the current item to a word (2 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_yword in module idc:

create_yword(ea)
    Convert the current item to a ymm word (32 bytes/256 bits)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function define_exception in module ida_dbg:

define_exception(*args)
    Convenience function: define new exception code.
    
    define_exception(code, name, desc, flags) -> char const *
        @param code: exception code (cannot be 0) (C++: uint)
        @param name: exception name (cannot be empty or NULL) (C++: const char
                     *)
        @param desc: exception description (maybe NULL) (C++: const char *)
        @param flags: combination of  Exception info flags (C++: int)
        @return: failure message or NULL. You must call  store_exceptions()
                 if this function succeeds

Help on function define_local_var in module idc:

define_local_var(start, end, location, name)
    Create a local variable
    
    @param start: start of address range for the local variable
    @param end: end of address range for the local variable
    @param location: the variable location in the "[bp+xx]" form where xx is
                     a number. The location can also be specified as a
                     register name.
    @param name: name of the local variable
    
    @return: 1-ok, 0-failure
    
    @note: For the stack variables the end address is ignored.
           If there is no function at 'start' then this function.
           will fail.

Help on function del_array_element in module idc:

del_array_element(tag, array_id, idx)
    Delete an array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of an element.
    
    @return: 1 in case of success, 0 otherwise.

Help on function del_bpt in module ida_dbg:

del_bpt(*args)
    Delete an existing breakpoint in the debugged process. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    del_bpt(ea) -> bool
        @param ea: any address in the breakpoint range (C++: ea_t)
    
    
    del_bpt(bptloc) -> bool
        bptloc: bpt_location_t const &

Help on function del_cref in module ida_xref:

del_cref(*args)
    Delete a code cross-reference.
    
    del_cref(frm, to, expand) -> bool
        @param frm: linear address of referencing instruction (C++: ea_t)
        @param to: linear address of referenced instruction (C++: ea_t)
        @param expand: policy to delete the referenced instruction   1: plan
                       to delete the referenced instruction if it has no more
                       references.   0: don't delete the referenced
                       instruction even if no more cross-references point to
                       it (C++: bool)
        @retval: true - if the referenced instruction will be deleted

Help on function del_dref in module ida_xref:

del_dref(*args)
    Delete a data cross-reference.
    
    del_dref(frm, to)
        @param frm: linear address of referencing instruction or data (C++:
                    ea_t)
        @param to: linear address of referenced data (C++: ea_t)

Help on function del_enum in module ida_enum:

del_enum(*args)
    Delete an enum type.
    
    del_enum(id)
        @param id (C++: enum_t)

Help on function del_enum_member in module idc:

del_enum_member(enum_id, value, serial, bmask)
    Delete a member of enum - a symbolic constant
    
    @param enum_id: id of enum
    @param value: value of symbolic constant.
    @param serial: serial number of the constant in the
        enumeration. See op_enum() for for details.
    @param bmask: bitmask of the constant ordinary enums accept
        only ida_enum.DEFMASK as a bitmask
    
    @return: 1-ok, 0-failed

Help on function del_extra_cmt in module ida_lines:

del_extra_cmt(*args)
    del_extra_cmt(ea, what)
        ea: ea_t
        what: int

Help on function del_fixup in module ida_fixup:

del_fixup(*args)
    Delete fixup information.
    
    del_fixup(source)
        @param source (C++: ea_t)

Help on function del_func in module ida_funcs:

del_func(*args)
    Delete a function.
    
    del_func(ea) -> bool
        @param ea: any address in the function entry chunk (C++: ea_t)
        @return: success

Help on function del_hash_string in module idc:

del_hash_string(hash_id, key)
    Delete a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element
    
    @return: 1 upon success, 0 otherwise.

Help on function del_hidden_range in module ida_bytes:

del_hidden_range(*args)
    Delete hidden range.
    
    del_hidden_range(ea) -> bool
        @param ea: any address in the hidden range (C++: ea_t)
        @return: success

Help on function del_idc_hotkey in module ida_kernwin:

del_idc_hotkey(*args)
    Delete IDC function hotkey ( 'ui_del_idckey' ).
    
    del_idc_hotkey(hotkey) -> bool
        @param hotkey: hotkey name (C++: const char *)
        @retval: 1 - ok
        @retval: 0 - failed

Help on function del_items in module ida_bytes:

del_items(*args)
    Convert item (instruction/data) to unexplored bytes. The whole item
    (including the head and tail bytes) will be destroyed. It is allowed
    to pass any address in the item to this function
    
    del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool
        @param ea: any address within the first item to delete (C++: ea_t)
        @param flags: combination of  Unexplored byte conversion flags (C++:
                      int)
        @param nbytes: number of bytes in the range to be undefined (C++:
                       asize_t)
        @param may_destroy: optional routine invoked before deleting a head
                            item. If callback returns false then item has not
                            to be deleted and operation fails (C++:
                            may_destroy_cb_t  *)
        @return: true on sucessful operation, otherwise false

Help on function del_segm in module ida_segment:

del_segm(*args)
    Delete a segment.
    
    del_segm(ea, flags) -> bool
        @param ea: any address belonging to the segment (C++: ea_t)
        @param flags: Segment modification flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, no segment at 'ea'.

Help on function del_selector in module ida_segment:

del_selector(*args)
    Delete mapping of a selector. Be wary of deleting selectors that are
    being used in the program, this can make a mess in the segments.
    
    del_selector(selector)
        @param selector: number of selector to remove from the translation
                         table (C++: sel_t)

Help on function del_source_linnum in module ida_nalt:

del_source_linnum(*args)
    del_source_linnum(ea)
        @param ea (C++: ea_t)

Help on function del_sourcefile in module ida_lines:

del_sourcefile(*args)
    Delete information about the source file.
    
    del_sourcefile(ea) -> bool
        @param ea: linear address (C++: ea_t)
        @return: success

Help on function del_stkpnt in module idc:

del_stkpnt(func_ea, ea)
    Delete SP register change point
    
    @param func_ea: function start
    @param ea: linear address
    @return: 1-ok, 0-failed

Help on function del_struc in module idc:

del_struc(sid)
    Delete a structure type
    
    @param sid: structure type ID
    
    @return: 0 if bad structure type ID is passed
             1 otherwise the structure type is deleted. All data
             and other structure types referencing to the
             deleted structure type will be displayed as array
             of bytes.

Help on function del_struc_member in module idc:

del_struc_member(sid, member_offset)
    Delete structure member
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    
    @return: != 0 - ok.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.

Help on function delete_all_segments in module idc:

delete_all_segments()
    Delete all segments, instructions, comments, i.e. everything
    except values of bytes.

Help on function delete_array in module idc:

delete_array(array_id)
    Delete array, by its ID.
    
    @param array_id: The ID of the array to delete.

Help on function demangle_name in module idc:

demangle_name(name, disable_mask)
    demangle_name a name
    
    @param name: name to demangle
    @param disable_mask: a mask that tells how to demangle the name
            it is a good idea to get this mask using
            get_inf_attr(INF_SHORT_DN) or get_inf_attr(INF_LONG_DN)
    
    @return: a demangled name
        If the input name cannot be demangled, returns None

Help on function detach_process in module ida_dbg:

detach_process(*args)
    Detach the debugger from the debugged process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_detach' }

Help on function diff_trace_file in module ida_dbg:

diff_trace_file(*args)
    Show difference between the current trace and the one from 'filename'.
    
    diff_trace_file(filename) -> bool
        @param filename (C++: const char *)

Help on function enable_bpt in module ida_dbg:

enable_bpt(*args)
    enable_bpt(ea, enable=True) -> bool
        @param ea (C++: ea_t)
        @param enable (C++: bool)
    
    
    enable_bpt(bptloc, enable=True) -> bool
        bptloc: bpt_location_t const &
        @param enable (C++: bool)

Help on function enable_tracing in module idc:

enable_tracing(trace_level, enable)
    Enable step tracing
    
    @param trace_level:  what kind of trace to modify
    @param enable: 0: turn off, 1: turn on
    
    @return: success

Help on function error in module ida_kernwin:

error(*args)
    error(format)
    Display a fatal message in a message box and quit IDA
    
    @param format: message to print

Help on function eval_idc in module idc:

eval_idc(expr)
    Evaluate an IDC expression
    
    @param expr: an expression
    
    @return: the expression value. If there are problems, the returned value will be "IDC_FAILURE: xxx"
             where xxx is the error description
    
    @note: Python implementation evaluates IDC only, while IDC can call other registered languages

Help on function exit_process in module ida_dbg:

exit_process(*args)
    Terminate the debugging of the current process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_exit' }

Help on function expand_struc in module idc:

expand_struc(sid, offset, delta, recalc)
    Expand or shrink a structure type
    @param id: structure type ID
    @param offset: offset in the structure
    @param delta: how many bytes to add or remove
    @param recalc: recalculate the locations where the structure
                               type is used
    @return: != 0 - ok

Help on function fclose in module idc:

fclose(handle)

Help on function fgetc in module idc:

fgetc(handle)

Help on function filelength in module idc:

filelength(handle)

Help on function find_binary in module idc:

find_binary(ea, flag, searchstr, radix=16, from_bc695=False)

Help on function find_code in module ida_search:

find_code(*args)
    Find next code address.
    
    find_code(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_data in module ida_search:

find_data(*args)
    Find next data address.
    
    find_data(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_defined in module ida_search:

find_defined(*args)
    Find next ea that is the start of an instruction or data.
    
    find_defined(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_func_end in module idc:

find_func_end(ea)
    Determine a new function boundaries
    
    @param ea: starting address of a new function
    
    @return: if a function already exists, then return its end address.
            If a function end cannot be determined, the return BADADDR
            otherwise return the end address of the new function

Help on function find_imm in module ida_search:

find_imm(*args)
    Find next immediate operand with the given value.
    
    find_imm(ea, sflag, search_value) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)
        @param search_value (C++: uval_t)

Help on function find_selector in module idc:

find_selector(val)
    Find a selector which has the specifed value
    
    @param val: value to search for
    
    @return: the selector number if found,
             otherwise the input value (val & 0xFFFF)
    
    @note: selector values are always in paragraphs

Help on function find_suspop in module ida_search:

find_suspop(*args)
    Find next suspicious operand.
    
    find_suspop(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function find_text in module idc:

find_text(ea, flag, y, x, searchstr, from_bc695=False)

Help on function find_unknown in module ida_search:

find_unknown(*args)
    Find next unexplored address.
    
    find_unknown(ea, sflag) -> ea_t
        @param ea (C++: ea_t)
        @param sflag (C++: int)

Help on function first_func_chunk in module idc:

first_func_chunk(funcea)
    Get the first function chunk of the specified function
    
    @param funcea: any address in the function
    
    @return: the function entry point or BADADDR
    
    @note: This function returns the first (main) chunk of the specified function

Help on function fopen in module idc:

fopen(f, mode)
    #----------------------------------------------------------------------------
    #                            F I L E   I / O
    #----------------------------------------------------------------------------

Help on function force_bl_call in module idc:

force_bl_call(ea)
    Force BL instruction to be a call
    
    @param ea: address of the BL instruction
    
    @return: 1-ok, 0-failed

Help on function force_bl_jump in module idc:

force_bl_jump(ea)
    Some ARM compilers in Thumb mode use BL (branch-and-link)
    instead of B (branch) for long jumps, since BL has more range.
    By default, IDA tries to determine if BL is a jump or a call.
    You can override IDA's decision using commands in Edit/Other menu
    (Force BL call/Force BL jump) or the following two functions.
    
    Force BL instruction to be a jump
    
    @param ea: address of the BL instruction
    
    @return: 1-ok, 0-failed

Help on function form in module idc:

form(format, *args)

Help on function fprintf in module idc:

fprintf(handle, format, *args)

Help on function fputc in module idc:

fputc(byte, handle)

Help on function fseek in module idc:

fseek(handle, offset, origin)

Help on function ftell in module idc:

ftell(handle)

Help on function func_contains in module idc:

func_contains(func_ea, ea)
    Does the given function contain the given address?
    
    @param func_ea: any address belonging to the function
    @param ea: linear address
    
    @return:  success

Help on function gen_file in module idc:

gen_file(filetype, path, ea1, ea2, flags)
    Generate an output file
    
    @param filetype:  type of output file. One of OFILE_... symbols. See below.
    @param path:  the output file path (will be overwritten!)
    @param ea1:   start address. For some file types this argument is ignored
    @param ea2:   end address. For some file types this argument is ignored
    @param flags: bit combination of GENFLG_...
    
    @returns: number of the generated lines.
                -1 if an error occurred
                OFILE_EXE: 0-can't generate exe file, 1-ok

Help on function gen_flow_graph in module idc:

gen_flow_graph(outfile, title, ea1, ea2, flags)
    Generate a flow chart GDL file
    
    @param outfile: output file name. GDL extension will be used
    @param title: graph title
    @param ea1: beginning of the range to flow chart
    @param ea2: end of the range to flow chart.
    @param flags: combination of CHART_... constants
    
    @note: If ea2 == BADADDR then ea1 is treated as an address within a function.
           That function will be flow charted.

Help on function gen_simple_call_chart in module idc:

gen_simple_call_chart(outfile, title, flags)
    Generate a function call graph GDL file
    
    @param outfile: output file name. GDL extension will be used
    @param title:   graph title
    @param flags:   combination of CHART_GEN_GDL, CHART_WINGRAPH, CHART_NOLIBFUNCS

Help on function generate_disasm_line in module idc:

generate_disasm_line(ea, flags)
    Get disassembly line
    
    @param ea: linear address of instruction
    
    @param flags: combination of the GENDSM_ flags, or 0
    
    @return: "" - could not decode instruction at the specified location
    
    @note: this function may not return exactly the same mnemonics
           as you see on the screen.

Help on function get_array_element in module idc:

get_array_element(tag, array_id, idx)
    Get value of array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of an element.
    
    @return: Value of the specified array element. Note that
             this function may return char or long result. Unexistent
             array elements give zero as a result.

Help on function get_array_id in module idc:

get_array_id(name)
    Get array array_id, by name.
    
    @param name: The array name.
    
    @return: -1 in case of failure (i.e., no array with that
             name exists), a valid array_id otherwise.

Help on function get_bmask_cmt in module idc:

get_bmask_cmt(enum_id, bmask, repeatable)
    Get bitmask comment (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    @param repeatable: type of comment, 0-regular, 1-repeatable
    
    @return: comment attached to bitmask or None

Help on function get_bmask_name in module idc:

get_bmask_name(enum_id, bmask)
    Get bitmask name (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    
    @return: name of bitmask or None

Help on function get_marked_pos in module ida_idc:

get_marked_pos(*args)
    get_marked_pos(slot) -> ea_t
        slot: int32

Help on function get_mark_comment in module ida_idc:

get_mark_comment(*args)
    get_mark_comment(slot) -> PyObject *
        slot: int32

Help on function get_bpt_attr in module idc:

get_bpt_attr(ea, bptattr)
    Get the characteristics of a breakpoint
    
    @param ea: any address in the breakpoint range
    @param bptattr: the desired attribute code, one of BPTATTR_... constants
    
    @return: the desired attribute value or -1

Help on function get_bpt_ea in module idc:

get_bpt_ea(n)
    Get breakpoint address
    
    @param n: number of breakpoint, is in range 0..get_bpt_qty()-1
    
    @return: address of the breakpoint or BADADDR

Help on function get_bpt_qty in module ida_dbg:

get_bpt_qty(*args)
    Get number of breakpoints. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function get_bpt_tev_ea in module ida_dbg:

get_bpt_tev_ea(*args)
    Get the address associated to a read, read/write or execution trace
    event. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}Usually, a breakpoint is associated with a read, read/write
    or execution trace event. However, the returned address could be any
    address in the range of this breakpoint. If the breakpoint was deleted
    after the trace event, the address no longer corresponds to a valid
    breakpoint.
    
    get_bpt_tev_ea(n) -> ea_t
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @return: BADADDR  if not a read, read/write or execution trace event.

Help on function get_bytes in module idc:

get_bytes(ea, size, use_dbg=False)
    Return the specified number of bytes of the program
    
    @param ea: linear address
    
    @param size: size of buffer in normal 8-bit bytes
    
    @param use_dbg: if True, use debugger memory, otherwise just the database
    
    @return: None on failure
             otherwise a string containing the read bytes

Help on function get_call_tev_callee in module ida_dbg:

get_call_tev_callee(*args)
    Get the called function from a function call trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    get_call_tev_callee(n) -> ea_t
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @return: BADADDR  if not a function call event.

Help on function get_color in module idc:

get_color(ea, what)
    Get item color
    
    @param ea: address of the item
    @param what: type of the item (one of  CIC_* constants)
    
    @return: color code in RGB (hex 0xBBGGRR)

Help on function get_curline in module idc:

get_curline()
    Get the disassembly line at the cursor
    
    @return: string

Help on function get_current_thread in module ida_dbg:

get_current_thread(*args)
    Get current thread ID. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}

Help on function get_db_byte in module ida_bytes:

get_db_byte(*args)
    Get one byte (8-bit) of the program at 'ea' from the database. Works
    even if the debugger is active. See also 'get_dbg_byte()' to read the
    process memory directly. This function works only for 8bit byte
    processors.
    
    get_db_byte(ea) -> uchar
        @param ea (C++: ea_t)

Help on function get_debugger_event_cond in module ida_dbg:

get_debugger_event_cond(*args)
    get_debugger_event_cond() -> char const *

Help on function get_entry in module ida_entry:

get_entry(*args)
    Get entry point address by its ordinal
    
    get_entry(ord) -> ea_t
        @param ord: ordinal number of entry point (C++: uval_t)
        @return: address or  BADADDR

Help on function get_entry_name in module ida_entry:

get_entry_name(*args)
    Get name of the entry point by its ordinal.
    
    get_entry_name(ord) -> str
        @param ord: ordinal number of entry point (C++: uval_t)
        @return: size of entry name or -1

Help on function get_entry_ordinal in module ida_entry:

get_entry_ordinal(*args)
    Get ordinal number of an entry point.
    
    get_entry_ordinal(idx) -> uval_t
        @param idx: internal number of entry point. Should be in the range 0..
                    get_entry_qty() -1 (C++: size_t)
        @return: ordinal number or 0.

Help on function get_entry_qty in module ida_entry:

get_entry_qty(*args)
    Get number of entry points.

Help on function get_enum in module ida_enum:

get_enum(*args)
    Get enum by name.
    
    get_enum(name) -> enum_t
        @param name (C++: const char *)

Help on function get_enum_cmt in module ida_enum:

get_enum_cmt(*args)
    Get enum comment.
    
    get_enum_cmt(id, repeatable) -> str
        @param id (C++: enum_t)
        @param repeatable (C++: bool)

Help on function get_enum_flag in module ida_enum:

get_enum_flag(*args)
    Get flags determining the representation of the enum. (currently they
    define the numeric base: octal, decimal, hex, bin) and signness.
    
    get_enum_flag(id) -> flags_t
        @param id (C++: enum_t)

Help on function get_enum_idx in module ida_enum:

get_enum_idx(*args)
    Get the index in the list of enums.
    
    get_enum_idx(id) -> uval_t
        @param id (C++: enum_t)

Help on function get_enum_member in module idc:

get_enum_member(enum_id, value, serial, bmask)
    Get id of constant
    
    @param enum_id: id of enum
    @param value: value of constant
    @param serial: serial number of the constant in the
              enumeration. See op_enum() for details.
    @param bmask: bitmask of the constant
              ordinary enums accept only ida_enum.DEFMASK as a bitmask
    
    @return: id of constant or -1 if error

Help on function get_enum_member_bmask in module ida_enum:

get_enum_member_bmask(*args)
    Get bitmask of an enum member.
    
    get_enum_member_bmask(id) -> bmask_t
        @param id (C++: const_t)

Help on function get_enum_member_by_name in module ida_enum:

get_enum_member_by_name(*args)
    Get a reference to an enum member by its name.
    
    get_enum_member_by_name(name) -> const_t
        @param name (C++: const char *)

Help on function get_enum_member_cmt in module idc:

get_enum_member_cmt(const_id, repeatable)
    Get comment of a constant
    
    @param const_id: id of const
    @param repeatable: 0:get regular comment, 1:get repeatable comment
    
    @return: comment string

Help on function get_enum_member_enum in module ida_enum:

get_enum_member_enum(*args)
    Get the parent enum of an enum member.
    
    get_enum_member_enum(id) -> enum_t
        @param id (C++: const_t)

Help on function get_enum_member_name in module idc:

get_enum_member_name(const_id)
    Get name of a constant
    
    @param const_id: id of const
    
    Returns: name of constant

Help on function get_enum_member_value in module ida_enum:

get_enum_member_value(*args)
    Get value of an enum member.
    
    get_enum_member_value(id) -> uval_t
        @param id (C++: const_t)

Help on function get_enum_name in module ida_enum:

get_enum_name(*args)
    Get name of enum.
    
    get_enum_name(id) -> str
        @param id (C++: enum_t)

Help on function get_enum_qty in module ida_enum:

get_enum_qty(*args)
    Get number of declared 'enum_t' types.

Help on function get_enum_size in module ida_enum:

get_enum_size(*args)
    Get the number of the members of the enum.
    
    get_enum_size(id) -> size_t
        @param id (C++: enum_t)

Help on function get_enum_width in module ida_enum:

get_enum_width(*args)
    Get the width of a enum element allowed values: 0
    (unspecified),1,2,4,8,16,32,64
    
    get_enum_width(id) -> size_t
        @param id (C++: enum_t)

Help on function get_event_bpt_hea in module idc:

get_event_bpt_hea()
    Get hardware address for BREAKPOINT event
    
    @return: hardware address

Help on function get_event_ea in module idc:

get_event_ea()
    Get ea for debug event
    
    @return: ea

Help on function get_event_exc_code in module idc:

get_event_exc_code()
    Get exception code for EXCEPTION event
    
    @return: exception code

Help on function get_event_exc_ea in module idc:

get_event_exc_ea()
    Get address for EXCEPTION event
    
    @return: adress of exception

Help on function get_event_exc_info in module idc:

get_event_exc_info()
    Get info for EXCEPTION event
    
    @return: info string

Help on function get_event_exit_code in module idc:

get_event_exit_code()
    Get exit code for debug event
    
    @return: exit code for PROCESS_EXITED, THREAD_EXITED events

Help on function get_event_id in module idc:

get_event_id()
    Get ID of debug event
    
    @return: event ID

Help on function get_event_info in module idc:

get_event_info()
    Get debug event info
    
    @return: event info: for THREAD_STARTED (thread name)
                         for LIB_UNLOADED (unloaded library name)
                         for INFORMATION (message to display)

Help on function get_event_module_base in module idc:

get_event_module_base()
    Get module base for debug event
    
    @return: module base

Help on function get_event_module_name in module idc:

get_event_module_name()
    Get module name for debug event
    
    @return: module name

Help on function get_event_module_size in module idc:

get_event_module_size()
    Get module size for debug event
    
    @return: module size

Help on function get_event_pid in module idc:

get_event_pid()
    Get process ID for debug event
    
    @return: process ID

Help on function get_event_tid in module idc:

get_event_tid()
    Get type ID for debug event
    
    @return: type ID

Help on function get_extra_cmt in module ida_lines:

get_extra_cmt(*args)
    get_extra_cmt(ea, what) -> ssize_t
        ea: ea_t
        what: int

Help on function get_fchunk_attr in module idc:

get_fchunk_attr(ea, attr)
    Get a function chunk attribute
    
    @param ea: any address in the chunk
    @param attr: one of: FUNCATTR_START, FUNCATTR_END, FUNCATTR_OWNER, FUNCATTR_REFQTY
    
    @return: desired attribute or -1

Help on function get_fchunk_referer in module ida_funcs:

get_fchunk_referer(*args)
    get_fchunk_referer(ea, idx) -> ea_t
        ea: ea_t
        idx: size_t

Help on function get_first_bmask in module ida_enum:

get_first_bmask(*args)
    Get first bitmask in the enum (bitfield)
    
    get_first_bmask(id) -> bmask_t
        @param id (C++: enum_t)
        @return: the smallest bitmask for enum, or DEFMASK

Help on function get_first_cref_from in module ida_xref:

get_first_cref_from(*args)
    Get first instruction referenced from the specified instruction. If
    the specified instruction passes execution to the next instruction
    then the next instruction is returned. Otherwise the lowest referenced
    address is returned (remember that xrefs are kept sorted!).
    
    get_first_cref_from(frm) -> ea_t
        @param frm: linear address of referencing instruction (C++: ea_t)
        @return: first referenced address. If the specified instruction
                 doesn't reference to other instructions then returns  BADADDR
                 .

Help on function get_first_cref_to in module ida_xref:

get_first_cref_to(*args)
    Get first instruction referencing to the specified instruction. If the
    specified instruction may be executed immediately after its previous
    instruction then the previous instruction is returned. Otherwise the
    lowest referencing address is returned. (remember that xrefs are kept
    sorted!).
    
    get_first_cref_to(to) -> ea_t
        @param to: linear address of referenced instruction (C++: ea_t)
        @return: linear address of the first referencing instruction or
                 BADADDR .

Help on function get_first_dref_from in module ida_xref:

get_first_dref_from(*args)
    Get first data referenced from the specified address.
    
    get_first_dref_from(frm) -> ea_t
        @param frm: linear address of referencing instruction or data (C++:
                    ea_t)
        @return: linear address of first (lowest) data referenced from the
                 specified address. Return  BADADDR  if the specified
                 instruction/data doesn't reference to anything.

Help on function get_first_dref_to in module ida_xref:

get_first_dref_to(*args)
    Get address of instruction/data referencing to the specified data.
    
    get_first_dref_to(to) -> ea_t
        @param to: linear address of referencing instruction or data (C++:
                   ea_t)
        @return: BADADDR  if nobody refers to the specified data.

Help on function get_first_enum_member in module idc:

get_first_enum_member(enum_id, bmask)
    Get first constant in the enum
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant (ordinary enums accept only ida_enum.DEFMASK as a bitmask)
    
    @return: value of constant or idaapi.BADNODE no constants are defined
             All constants are sorted by their values as unsigned longs.

Help on function get_first_fcref_from in module ida_xref:

get_first_fcref_from(*args)
    get_first_fcref_from(frm) -> ea_t
        @param frm (C++: ea_t)

Help on function get_first_fcref_to in module ida_xref:

get_first_fcref_to(*args)
    get_first_fcref_to(to) -> ea_t
        @param to (C++: ea_t)

Help on function get_first_hash_key in module idc:

get_first_hash_key(hash_id)
    Get the first key in the hash.
    
    @param hash_id: The hash ID.
    
    @return: the key, 0 otherwise.

Help on function get_first_index in module idc:

get_first_index(tag, array_id)
    Get index of the first existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    
    @return: -1 if the array is empty, otherwise index of first array
             element of given type.

Help on function get_first_member in module idc:

get_first_member(sid)
    Get offset of the first member of a structure
    
    @param sid: structure type ID
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if structure has no members,
             otherwise returns offset of the first member.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_first_module in module idc:

get_first_module()
    Enumerate process modules
    
    @return: first module's base address or None on failure

Help on function get_first_seg in module idc:

get_first_seg()
    Get first segment
    
    @return: address of the start of the first segment
        BADADDR - no segments are defined

Help on function get_first_struc_idx in module ida_struct:

get_first_struc_idx(*args)
    Get index of first structure.

Help on function get_fixup_target_dis in module idc:

get_fixup_target_dis(ea)
    Get fixup target displacement
    
    @param ea: address to get information about
    
    @return: 0 - no fixup at the specified address
                 otherwise returns fixup target displacement

Help on function get_fixup_target_flags in module idc:

get_fixup_target_flags(ea)
    Get fixup target flags
    
    @param ea: address to get information about
    
    @return: 0 - no fixup at the specified address
                 otherwise returns fixup target flags

Help on function get_fixup_target_off in module idc:

get_fixup_target_off(ea)
    Get fixup target offset
    
    @param ea: address to get information about
    
    @return: BADADDR - no fixup at the specified address
                       otherwise returns fixup target offset

Help on function get_fixup_target_sel in module idc:

get_fixup_target_sel(ea)
    Get fixup target selector
    
    @param ea: address to get information about
    
    @return: BADSEL - no fixup at the specified address
                      otherwise returns fixup target selector

Help on function get_fixup_target_type in module idc:

get_fixup_target_type(ea)
    Get fixup target type
    
    @param ea: address to get information about
    
    @return: 0 - no fixup at the specified address
                 otherwise returns fixup type

Help on function get_forced_operand in module ida_bytes:

get_forced_operand(*args)
    Get forced operand.
    
    get_forced_operand(ea, n) -> str
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, 2) (C++: int)
        @return: size of forced operand or -1

Help on function get_frame_args_size in module idc:

get_frame_args_size(ea)
    Get size of arguments in function frame which are purged upon return
    
    @param ea: any address belonging to the function
    
    @return: Size of function arguments in bytes.
             If the function doesn't have a frame, return 0
             If the function does't exist, return -1

Help on function get_frame_id in module idc:

get_frame_id(ea)
    Get ID of function frame structure
    
    @param ea: any address belonging to the function
    
    @return: ID of function frame or None In order to access stack variables
             you need to use structure member manipulaion functions with the
             obtained ID.

Help on function get_frame_lvar_size in module idc:

get_frame_lvar_size(ea)
    Get size of local variables in function frame
    
    @param ea: any address belonging to the function
    
    @return: Size of local variables in bytes.
             If the function doesn't have a frame, return 0
             If the function does't exist, return None

Help on function get_frame_regs_size in module idc:

get_frame_regs_size(ea)
    Get size of saved registers in function frame
    
    @param ea: any address belonging to the function
    
    @return: Size of saved registers in bytes.
             If the function doesn't have a frame, return 0
             This value is used as offset for BP (if FUNC_FRAME is set)
             If the function does't exist, return None

Help on function get_frame_size in module idc:

get_frame_size(ea)
    Get full size of function frame
    
    @param ea: any address belonging to the function
    @returns: Size of function frame in bytes.
                This function takes into account size of local
                variables + size of saved registers + size of
                return address + size of function arguments
                If the function doesn't have a frame, return size of
                function return address in the stack.
                If the function does't exist, return 0

Help on function get_full_flags in module ida_bytes:

get_full_flags(*args)
    Get flags value for address 'ea'.
    
    get_full_flags(ea) -> flags_t
        @param ea (C++: ea_t)
        @return: 0 if address is not present in the program

Help on function get_func_attr in module idc:

get_func_attr(ea, attr)
    Get a function attribute
    
    @param ea: any address belonging to the function
    @param attr: one of FUNCATTR_... constants
    
    @return: BADADDR - error otherwise returns the attribute value

Help on function get_func_cmt in module idc:

get_func_cmt(ea, repeatable)
    Retrieve function comment
    
    @param ea: any address belonging to the function
    @param repeatable: 1: get repeatable comment
            0: get regular comment
    
    @return: function comment string

Help on function get_func_flags in module idc:

get_func_flags(ea)
    Retrieve function flags
    
    @param ea: any address belonging to the function
    
    @return: -1 - function doesn't exist otherwise returns the flags

Help on function get_func_name in module idc:

get_func_name(ea)
    Retrieve function name
    
    @param ea: any address belonging to the function
    
    @return: null string - function doesn't exist
            otherwise returns function name

Help on function get_func_off_str in module idc:

get_func_off_str(ea)
    Convert address to 'funcname+offset' string
    
    @param ea: address to convert
    
    @return: if the address belongs to a function then return a string
             formed as 'name+offset' where 'name' is a function name
             'offset' is offset within the function else return null string

Help on function get_hash_long in module idc:

get_hash_long(hash_id, key)
    Gets the long value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    
    @return: the 32bit or 64bit value of the element, or 0 if no such
             element.

Help on function get_hash_string in module idc:

get_hash_string(hash_id, key)
    Gets the string value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    
    @return: the string value of the element, or None if no such
             element.

Help on function get_idb_path in module idc:

get_idb_path()
    Get IDB full path
    
    This function returns full path of the current IDB database

Help on function get_inf_attr in module idc:

get_inf_attr(attr)
    Deprecated. Please ida_ida.inf_get_* instead.

Help on function get_input_file_path in module ida_nalt:

get_input_file_path(*args)
    Get full path of the input file.

Help on function get_item_end in module ida_bytes:

get_item_end(*args)
    Get the end address of the item at 'ea'. The returned address doesn't
    belong to the current item. Unexplored bytes are counted as 1 byte
    entities.
    
    get_item_end(ea) -> ea_t
        @param ea (C++: ea_t)

Help on function get_item_head in module ida_bytes:

get_item_head(*args)
    Get the start address of the item at 'ea'. If there is no current
    item, then 'ea' will be returned (see definition at the end of
    'bytes.hpp' source)
    
    get_item_head(ea) -> ea_t
        @param ea (C++: ea_t)

Help on function get_item_size in module idc:

get_item_size(ea)
    Get size of instruction or data item in bytes
    
    @param ea: linear address
    
    @return: 1..n

Help on function get_last_bmask in module ida_enum:

get_last_bmask(*args)
    Get last bitmask in the enum (bitfield)
    
    get_last_bmask(id) -> bmask_t
        @param id (C++: enum_t)
        @return: the biggest bitmask for enum, or DEFMASK

Help on function get_last_enum_member in module idc:

get_last_enum_member(enum_id, bmask)
    Get last constant in the enum
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant (ordinary enums accept only ida_enum.DEFMASK as a bitmask)
    
    @return: value of constant or idaapi.BADNODE no constants are defined
             All constants are sorted by their values
             as unsigned longs.

Help on function get_last_hash_key in module idc:

get_last_hash_key(hash_id)
    Get the last key in the hash.
    
    @param hash_id: The hash ID.
    
    @return: the key, 0 otherwise.

Help on function get_last_index in module idc:

get_last_index(tag, array_id)
    Get index of last existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    
    @return: -1 if the array is empty, otherwise index of first array
             element of given type.

Help on function get_last_member in module idc:

get_last_member(sid)
    Get offset of the last member of a structure
    
    @param sid: structure type ID
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if structure has no members,
             otherwise returns offset of the last member.
    
    @note: IDA allows 'holes' between members of a
          structure. It treats these 'holes'
          as unnamed arrays of bytes.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_last_struc_idx in module ida_struct:

get_last_struc_idx(*args)
    Get index of last structure.

Help on function get_local_tinfo in module idc:

get_local_tinfo(ordinal)
    Get local type information as 'typeinfo' object
    
    @param ordinal:  slot number (1...NumberOfLocalTypes)
    @return: None on failure, or (type, fields) tuple.

Help on function get_manual_insn in module ida_bytes:

get_manual_insn(*args)
    Retrieve the user-specified string for the manual instruction.
    
    get_manual_insn(ea) -> str
        @param ea: linear address of the instruction or data item (C++: ea_t)
        @return: size of manual instruction or -1

Help on function get_member_cmt in module idc:

get_member_cmt(sid, member_offset, repeatable)
    Get comment of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    @param repeatable: 1: get repeatable comment
                       0: get regular comment
    
    @return: None if bad structure type ID is passed
             or no such member in the structure
             otherwise returns comment of the specified member.

Help on function get_member_flag in module idc:

get_member_flag(sid, member_offset)
    Get type of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    
    @return: -1 if bad structure type ID is passed
             or no such member in the structure
             otherwise returns type of the member, see bit
             definitions above. If the member type is a structure
             then function GetMemberStrid() should be used to
             get the structure type id.

Help on function get_member_id in module idc:

get_member_id(sid, member_offset)
    @param sid: structure type ID
    @param member_offset:. The offset can be
    any offset in the member. For example,
    is a member is 4 bytes long and starts
    at offset 2, then 2,3,4,5 denote
    the same structure member.
    
    @return: -1 if bad structure type ID is passed or there is
    no member at the specified offset.
    otherwise returns the member id.

Help on function get_member_name in module idc:

get_member_name(sid, member_offset)
    Get name of a member of a structure
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    
    @return: None if bad structure type ID is passed
             or no such member in the structure
             otherwise returns name of the specified member.

Help on function get_member_offset in module idc:

get_member_offset(sid, member_name)
    Get offset of a member of a structure by the member name
    
    @param sid: structure type ID
    @param member_name: name of structure member
    
    @return: -1 if bad structure type ID is passed
             or no such member in the structure
             otherwise returns offset of the specified member.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_member_qty in module idc:

get_member_qty(sid)
    Get number of members of a structure
    
    @param sid: structure type ID
    
    @return: -1 if bad structure type ID is passed otherwise
             returns number of members.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_member_size in module idc:

get_member_size(sid, member_offset)
    Get size of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    
    @return: None if bad structure type ID is passed,
             or no such member in the structure
             otherwise returns size of the specified
             member in bytes.

Help on function get_member_strid in module idc:

get_member_strid(sid, member_offset)
    Get structure id of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    @return: -1 if bad structure type ID is passed
             or no such member in the structure
             otherwise returns structure id of the member.
             If the current member is not a structure, returns -1.

Help on function get_min_spd_ea in module idc:

get_min_spd_ea(func_ea)
    Return the address with the minimal spd (stack pointer delta)
    If there are no SP change points, then return BADADDR.
    
    @param func_ea: function start
    @return: BADDADDR - no such function

Help on function get_module_name in module idc:

get_module_name(base)
    Get process module name
    
    @param base: the base address of the module
    
    @return: required info or None

Help on function get_module_size in module idc:

get_module_size(base)
    Get process module size
    
    @param base: the base address of the module
    
    @return: required info or -1

Help on function get_name in module idc:

get_name(ea, gtn_flags=0)
    Get name at the specified address
    
    @param ea: linear address
    @param gtn_flags: how exactly the name should be retrieved.
                      combination of GN_ bits
    
    @return: "" - byte has no name

Help on function get_name_ea in module ida_name:

get_name_ea(*args)
    Get address of the name. Dummy names (like byte_xxxx where xxxx are
    hex digits) are parsed by this function to obtain the address. The
    database is not consulted for them. This function works only with
    regular names.
    
    get_name_ea(_from, name) -> ea_t
        @param _from: linear address where the name is used. if not
                      applicable, then should be  BADADDR . (C++: ea_t)
        @param name: any name in the program or NULL (C++: const char *)
        @return: address of the name or  BADADDR

Help on function get_name_ea_simple in module idc:

get_name_ea_simple(name)
    Get linear address of a name
    
    @param name: name of program byte
    
    @return: address of the name
             BADADDR - No such name

Help on function get_next_bmask in module ida_enum:

get_next_bmask(*args)
    Get next bitmask in the enum (bitfield)
    
    get_next_bmask(id, bmask) -> bmask_t
        @param id (C++: enum_t)
        @param bmask (C++: bmask_t)
        @return: value of a bitmask with value higher than the specified
                 value, or DEFMASK

Help on function get_next_cref_from in module ida_xref:

get_next_cref_from(*args)
    Get next instruction referenced from the specified instruction.
    
    get_next_cref_from(frm, current) -> ea_t
        @param frm: linear address of referencing instruction (C++: ea_t)
        @param current: linear address of current referenced instruction This
                        value is returned by  get_first_cref_from()  or
                        previous call to  get_next_cref_from()  functions.
                        (C++: ea_t)
        @return: next referenced address or  BADADDR .

Help on function get_next_cref_to in module ida_xref:

get_next_cref_to(*args)
    Get next instruction referencing to the specified instruction.
    
    get_next_cref_to(to, current) -> ea_t
        @param to: linear address of referenced instruction (C++: ea_t)
        @param current: linear address of current referenced instruction This
                        value is returned by  get_first_cref_to()  or previous
                        call to  get_next_cref_to()  functions. (C++: ea_t)
        @return: linear address of the next referencing instruction or
                 BADADDR .

Help on function get_next_dref_from in module ida_xref:

get_next_dref_from(*args)
    Get next data referenced from the specified address.
    
    get_next_dref_from(frm, current) -> ea_t
        @param frm: linear address of referencing instruction or data (C++:
                    ea_t)
        @param current: linear address of current referenced data. This value
                        is returned by  get_first_dref_from()  or previous
                        call to  get_next_dref_from()  functions. (C++: ea_t)
        @return: linear address of next data or  BADADDR .

Help on function get_next_dref_to in module ida_xref:

get_next_dref_to(*args)
    Get address of instruction/data referencing to the specified data
    
    get_next_dref_to(to, current) -> ea_t
        @param to: linear address of referencing instruction or data (C++:
                   ea_t)
        @param current: current linear address. This value is returned by
                        get_first_dref_to()  or previous call to
                        get_next_dref_to()  functions. (C++: ea_t)
        @return: BADADDR  if nobody refers to the specified data.

Help on function get_next_enum_member in module idc:

get_next_enum_member(enum_id, value, bmask)
    Get next constant in the enum
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant ordinary enums accept only ida_enum.DEFMASK as a bitmask
    @param value: value of the current constant
    
    @return: value of a constant with value higher than the specified
             value. idaapi.BADNODE no such constants exist.
             All constants are sorted by their values as unsigned longs.

Help on function get_next_fchunk in module idc:

get_next_fchunk(ea)
    Get next function chunk
    
    @param ea: any address
    
    @return:  the starting address of the next function chunk or BADADDR
    
    @note: This function enumerates all chunks of all functions in the database

Help on function get_next_fcref_from in module ida_xref:

get_next_fcref_from(*args)
    get_next_fcref_from(frm, current) -> ea_t
        @param frm (C++: ea_t)
        @param current (C++: ea_t)

Help on function get_next_fcref_to in module ida_xref:

get_next_fcref_to(*args)
    get_next_fcref_to(to, current) -> ea_t
        @param to (C++: ea_t)
        @param current (C++: ea_t)

Help on function get_next_fixup_ea in module ida_fixup:

get_next_fixup_ea(*args)
    Find next address with fixup information
    
    get_next_fixup_ea(ea) -> ea_t
        @param ea: current address (C++: ea_t)
        @return: the next address with fixup information, or BADADDR

Help on function get_next_func in module idc:

get_next_func(ea)
    Find next function
    
    @param ea: any address belonging to the function
    
    @return:        BADADDR - no more functions
            otherwise returns the next function start address

Help on function get_next_hash_key in module idc:

get_next_hash_key(hash_id, key)
    Get the next key in the hash.
    
    @param hash_id: The hash ID.
    @param key: The current key.
    
    @return: the next key, 0 otherwise

Help on function get_next_index in module idc:

get_next_index(tag, array_id, idx)
    Get index of the next existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of the current element.
    
    @return: -1 if no more elements, otherwise returns index of the
             next array element of given type.

Help on function get_next_module in module idc:

get_next_module(base)
    Enumerate process modules
    
    @param base: previous module's base address
    
    @return: next module's base address or None on failure

Help on function get_next_offset in module idc:

get_next_offset(sid, offset)
    Get next offset in a structure
    
    @param sid:     structure type ID
    @param offset: current offset
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if no (more) offsets in the structure,
             otherwise returns next offset in a structure.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.
           This function returns a member offset or a hole offset.
           It will return size of the structure if input
           'offset' belongs to the last member of the structure.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_next_seg in module idc:

get_next_seg(ea)
    Get next segment
    
    @param ea: linear address
    
    @return: start of the next segment
             BADADDR - no next segment

Help on function get_next_struc_idx in module ida_struct:

get_next_struc_idx(*args)
    Get next struct index.
    
    get_next_struc_idx(idx) -> uval_t
        @param idx (C++: uval_t)
        @return: BADADDR  if resulting index is out of bounds, otherwise idx++

Help on function get_numbered_type_name in module idc:

get_numbered_type_name(ordinal)
    Retrieve a local type name
    
    @param ordinal:  slot number (1...NumberOfLocalTypes)
    
    returns: local type name or None

Help on function get_operand_type in module idc:

get_operand_type(ea, n)
    Get type of instruction operand
    
    @param ea: linear address of instruction
    @param n: number of operand:
        0 - the first operand
        1 - the second operand
    
    @return: any of o_* constants or -1 on error

Help on function get_operand_value in module idc:

get_operand_value(ea, n)
    Get number used in the operand
    
    This function returns an immediate number used in the operand
    
    @param ea: linear address of instruction
    @param n: the operand number
    
    @return: value
        operand is an immediate value  => immediate value
        operand has a displacement     => displacement
        operand is a direct memory ref => memory address
        operand is a register          => register number
        operand is a register phrase   => phrase number
        otherwise                      => -1

Help on function get_ordinal_qty in module idc:

get_ordinal_qty()
    Get number of local types + 1
    
    @return: value >= 1. 1 means that there are no local types.

Help on function get_original_byte in module ida_bytes:

get_original_byte(*args)
    Get original byte value (that was before patching). This function
    works for wide byte processors too.
    
    get_original_byte(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_prev_bmask in module ida_enum:

get_prev_bmask(*args)
    Get prev bitmask in the enum (bitfield)
    
    get_prev_bmask(id, bmask) -> bmask_t
        @param id (C++: enum_t)
        @param bmask (C++: bmask_t)
        @return: value of a bitmask with value lower than the specified value,
                 or DEFMASK

Help on function get_prev_enum_member in module idc:

get_prev_enum_member(enum_id, value, bmask)
    Get prev constant in the enum
    
    @param enum_id: id of enum
    @param bmask  : bitmask of the constant
              ordinary enums accept only ida_enum.DEFMASK as a bitmask
    @param value: value of the current constant
    
    @return: value of a constant with value lower than the specified
        value. idaapi.BADNODE no such constants exist.
        All constants are sorted by their values as unsigned longs.

Help on function get_prev_fchunk in module idc:

get_prev_fchunk(ea)
    Get previous function chunk
    
    @param ea: any address
    
    @return: the starting address of the function chunk or BADADDR
    
    @note: This function enumerates all chunks of all functions in the database

Help on function get_prev_fixup_ea in module ida_fixup:

get_prev_fixup_ea(*args)
    Find previous address with fixup information
    
    get_prev_fixup_ea(ea) -> ea_t
        @param ea: current address (C++: ea_t)
        @return: the previous address with fixup information, or BADADDR

Help on function get_prev_func in module idc:

get_prev_func(ea)
    Find previous function
    
    @param ea: any address belonging to the function
    
    @return: BADADDR - no more functions
            otherwise returns the previous function start address

Help on function get_prev_hash_key in module idc:

get_prev_hash_key(hash_id, key)
    Get the previous key in the hash.
    
    @param hash_id: The hash ID.
    @param key: The current key.
    
    @return: the previous key, 0 otherwise

Help on function get_prev_index in module idc:

get_prev_index(tag, array_id, idx)
    Get index of the previous existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of the current element.
    
    @return: -1 if no more elements, otherwise returns index of the
             previous array element of given type.

Help on function get_prev_offset in module idc:

get_prev_offset(sid, offset)
    Get previous offset in a structure
    
    @param sid: structure type ID
    @param offset: current offset
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if no (more) offsets in the structure,
             otherwise returns previous offset in a structure.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.
           This function returns a member offset or a hole offset.
           It will return size of the structure if input
           'offset' is bigger than the structure size.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_prev_struc_idx in module ida_struct:

get_prev_struc_idx(*args)
    Get previous struct index.
    
    get_prev_struc_idx(idx) -> uval_t
        @param idx (C++: uval_t)
        @return: BADADDR  if resulting index is negative, otherwise idx - 1

Help on function get_process_state in module ida_dbg:

get_process_state(*args)
    Return the state of the currently debugged process. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

Help on function get_processes in module ida_dbg:

get_processes(*args)
    Take a snapshot of running processes and return their description.
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    get_processes(proclist) -> ssize_t
        @param proclist (C++: procinfo_vec_t  *)
        @return: number of processes or -1 on error

Help on function get_qword in module ida_bytes:

get_qword(*args)
    Get one qword (64-bit) of the program at 'ea'. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    works only for 8bit byte processors.
    
    get_qword(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_reg_val in module ida_dbg:

get_reg_val(*args)
    Read a register value from the current thread. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    get_reg_val(regname, regval) -> bool
        @param regname (C++: const char *)
        @param regval (C++: regval_t  *)
    
    
    get_reg_val(regname, ival) -> bool
        @param regname (C++: const char *)
        ival: uint64 *
    
    
    get_reg_val(regname) -> PyObject *
        @param regname (C++: const char *)

Help on function get_ret_tev_return in module ida_dbg:

get_ret_tev_return(*args)
    Get the return address from a function return trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    get_ret_tev_return(n) -> ea_t
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @return: BADADDR  if not a function return event.

Help on function get_root_filename in module ida_nalt:

get_root_filename(*args)
    Get file name only of the input file.

Help on function get_screen_ea in module ida_kernwin:

get_screen_ea(*args)
    Get the address at the screen cursor ( 'ui_screenea' )

Help on function get_segm_attr in module idc:

get_segm_attr(segea, attr)
    Get segment attribute
    
    @param segea: any address within segment
    @param attr: one of SEGATTR_... constants

Help on function get_segm_by_sel in module idc:

get_segm_by_sel(base)
    Get segment by segment base
    
    @param base: segment base paragraph or selector
    
    @return: linear address of the start of the segment or BADADDR
             if no such segment

Help on function get_segm_end in module idc:

get_segm_end(ea)
    Get end address of a segment
    
    @param ea: any address in the segment
    
    @return: end of segment (an address past end of the segment)
             BADADDR - the specified address doesn't belong to any segment

Help on function get_segm_name in module idc:

get_segm_name(ea)
    Get name of a segment
    
    @param ea: any address in the segment
    
    @return: "" - no segment at the specified address

Help on function get_segm_start in module idc:

get_segm_start(ea)
    Get start address of a segment
    
    @param ea: any address in the segment
    
    @return: start of segment
             BADADDR - the specified address doesn't belong to any segment

Help on function get_source_linnum in module ida_nalt:

get_source_linnum(*args)
    get_source_linnum(ea) -> uval_t
        @param ea (C++: ea_t)

Help on function get_sourcefile in module ida_lines:

get_sourcefile(*args)
    Get name of source file occupying the given address.
    
    get_sourcefile(ea, bounds=None) -> char const *
        @param ea: linear address (C++: ea_t)
        @param bounds: pointer to the output buffer with the address range for
                       the current file. May be NULL. (C++: range_t  *)
        @return: NULL if source file information is not found, otherwise
                 returns pointer to file name

Help on function get_sp_delta in module idc:

get_sp_delta(ea)
    Get modification of SP made by the instruction
    
    @param ea: end address of the instruction
               i.e.the last address of the instruction+1
    
    @return: Get modification of SP made at the specified location
             If the specified location doesn't contain a SP change point, return 0
             Otherwise return delta of SP modification

Help on function get_spd in module idc:

get_spd(ea)
    Get current delta for the stack pointer
    
    @param ea: end address of the instruction
               i.e.the last address of the instruction+1
    
    @return: The difference between the original SP upon
             entering the function and SP for the specified address

Help on function get_sreg in module idc:

get_sreg(ea, reg)
    Get value of segment register at the specified address
    
    @param ea: linear address
    @param reg: name of segment register
    
    @return: the value of the segment register or -1 on error
    
    @note: The segment registers in 32bit program usually contain selectors,
           so to get paragraph pointed to by the segment register you need to
           call sel2para() function.

Help on function get_step_trace_options in module ida_dbg:

get_step_trace_options(*args)
    Get current step tracing options. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function get_str_type in module idc:

get_str_type(ea)
    Get string type
    
    @param ea: linear address
    
    @return: One of STRTYPE_... constants

Help on function get_strlit_contents in module idc:

get_strlit_contents(ea, length=-1, strtype=0)
    Get string contents
    @param ea: linear address
    @param length: string length. -1 means to calculate the max string length
    @param strtype: the string type (one of STRTYPE_... constants)
    
    @return: string contents or empty string

Help on function get_struc_by_idx in module ida_struct:

get_struc_by_idx(*args)
    Get struct id by struct number.
    
    get_struc_by_idx(idx) -> tid_t
        @param idx (C++: uval_t)

Help on function get_struc_cmt in module ida_struct:

get_struc_cmt(*args)
    Get struct comment.
    
    get_struc_cmt(id, repeatable) -> str
        @param id (C++: tid_t)
        @param repeatable (C++: bool)

Help on function get_struc_id in module ida_struct:

get_struc_id(*args)
    Get struct id by name.
    
    get_struc_id(name) -> tid_t
        @param name (C++: const char *)

Help on function get_struc_idx in module ida_struct:

get_struc_idx(*args)
    Get internal number of the structure.
    
    get_struc_idx(id) -> uval_t
        @param id (C++: tid_t)

Help on function get_struc_name in module ida_struct:

get_struc_name(*args)
    Get struct name by id
    
    get_struc_name(id, flags=0) -> str
        @param id: struct id (C++: tid_t)
        @param flags: Struct name flags (C++: int)

Help on function get_struc_qty in module ida_struct:

get_struc_qty(*args)
    Get number of known structures.

Help on function get_struc_size in module ida_struct:

get_struc_size(*args)
    Get struct size (also see 'get_struc_size(tid_t)' )
    
    get_struc_size(sptr) -> asize_t
        @param sptr (C++: const  struc_t  *)
    
    
    get_struc_size(id) -> asize_t
        id: tid_t

Help on function get_tev_ea in module ida_dbg:

get_tev_ea(*args)
    get_tev_ea(n) -> ea_t
        @param n (C++: int)

Help on function get_tev_reg_mem in module ida_dbg:

get_tev_reg_mem(tev, idx)

Help on function get_tev_reg_mem_ea in module ida_dbg:

get_tev_reg_mem_ea(tev, idx)

Help on function get_tev_reg_mem_qty in module ida_dbg:

get_tev_reg_mem_qty(tev)

Help on function get_tev_qty in module ida_dbg:

get_tev_qty(*args)
    Get number of trace events available in trace buffer. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

Help on function get_tev_reg_val in module ida_dbg:

get_tev_reg_val(tev, reg)

Help on function get_tev_tid in module ida_dbg:

get_tev_tid(*args)
    get_tev_tid(n) -> int
        @param n (C++: int)

Help on function get_tev_type in module ida_dbg:

get_tev_type(*args)
    get_tev_type(n) -> int
        @param n (C++: int)

Help on function get_thread_qty in module ida_dbg:

get_thread_qty(*args)
    Get number of threads. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}

Help on function get_tinfo in module idc:

get_tinfo(ea)
    Get type information of function/variable as 'typeinfo' object
    
    @param ea: the address of the object
    @return: None on failure, or (type, fields) tuple.

Help on function get_trace_file_desc in module ida_dbg:

get_trace_file_desc(*args)
    Get the file header of the specified trace file.
    
    get_trace_file_desc(filename) -> str
        @param filename (C++: const char *)

Help on function get_type in module idc:

get_type(ea)
    Get type of function/variable
    
    @param ea: the address of the object
    
    @return: type string or None if failed

Help on function get_wide_byte in module ida_bytes:

get_wide_byte(*args)
    Get one wide byte of the program at 'ea'. Some processors may access
    more than 8bit quantity at an address. These processors have 32-bit
    byte organization from the IDA's point of view.
    
    get_wide_byte(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_wide_dword in module ida_bytes:

get_wide_dword(*args)
    Get two wide words (4 'bytes') of the program at 'ea'. Some processors
    may access more than 8bit quantity at an address. These processors
    have 32-bit byte organization from the IDA's point of view. This
    function takes into account order of bytes specified in
    \inf{is_be()}this function works incorrectly if \ph{nbits} > 16
    
    get_wide_dword(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_wide_word in module ida_bytes:

get_wide_word(*args)
    Get one wide word (2 'byte') of the program at 'ea'. Some processors
    may access more than 8bit quantity at an address. These processors
    have 32-bit byte organization from the IDA's point of view. This
    function takes into account order of bytes specified in \inf{is_be()}
    
    get_wide_word(ea) -> uint64
        @param ea (C++: ea_t)

Help on function get_xref_type in module idc:

get_xref_type()
    Return type of the last xref obtained by
    [RD]first/next[B0] functions.
    
    @return: constants fl_* or dr_*

Help on function getn_enum in module ida_enum:

getn_enum(*args)
    Get enum by its index in the list of enums (0.. 'get_enum_qty()' -1).
    
    getn_enum(idx) -> enum_t
        @param idx (C++: size_t)

Help on function getn_thread in module ida_dbg:

getn_thread(*args)
    Get the ID of a thread. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    getn_thread(n) -> thid_t
        @param n: number of thread, is in range 0.. get_thread_qty() -1 (C++:
                  int)
        @return: NO_THREAD  if the thread doesn't exist.

Help on function getn_thread_name in module ida_dbg:

getn_thread_name(*args)
    Get the NAME of a thread \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    getn_thread_name(n) -> char const *
        @param n: number of thread, is in range 0.. get_thread_qty() -1 or -1
                  for the current thread (C++: int)
        @return: thread name or NULL if the thread doesn't exist.

Help on function guess_type in module idc:

guess_type(ea)
    Guess type of function/variable
    
    @param ea: the address of the object, can be the structure member id too
    
    @return: type string or None if failed

Help on function hasName in module idc:

hasName(F)

Help on function hasUserName in module idc:

hasUserName(F)

Help on function has_value in module idc:

has_value(F)

Help on function here in module idc:

here()
    # Convenience functions:

Help on function idadir in module idc:

idadir()
    Get IDA directory
    
    This function returns the directory where IDA.EXE resides

Help on function import_type in module idc:

import_type(idx, type_name)
    Copy information from type library to database
    Copy structure, union, or enum definition from the type library
    to the IDA database.
    
    @param idx: the position of the new type in the list of
                types (structures or enums) -1 means at the end of the list
    @param type_name: name of type to copy
    
    @return: BADNODE-failed, otherwise the type id (structure id or enum id)

Help on function isBin0 in module idc:

isBin0(F)

Help on function isBin1 in module idc:

isBin1(F)

Help on function isDec0 in module idc:

isDec0(F)

Help on function isDec1 in module idc:

isDec1(F)

Help on function isExtra in module idc:

isExtra(F)

Help on function isHex0 in module idc:

isHex0(F)

Help on function isHex1 in module idc:

isHex1(F)

Help on function isOct0 in module idc:

isOct0(F)

Help on function isOct1 in module idc:

isOct1(F)

Help on function isRef in module idc:

isRef(F)

Help on function is_align in module idc:

is_align(F)

Help on function is_bf in module ida_enum:

is_bf(*args)
    Is enum a bitfield? (otherwise - plain enum, no bitmasks except for
    'DEFMASK' are allowed)
    
    is_bf(id) -> bool
        @param id (C++: enum_t)

Help on function is_byte in module idc:

is_byte(F)

Help on function is_char0 in module idc:

is_char0(F)

Help on function is_char1 in module idc:

is_char1(F)

Help on function is_code in module idc:

is_code(F)

Help on function is_data in module idc:

is_data(F)

Help on function is_defarg0 in module idc:

is_defarg0(F)

Help on function is_defarg1 in module idc:

is_defarg1(F)

Help on function is_double in module idc:

is_double(F)

Help on function is_dword in module idc:

is_dword(F)

Help on function is_enum0 in module idc:

is_enum0(F)

Help on function is_enum1 in module idc:

is_enum1(F)

Help on function is_event_handled in module idc:

is_event_handled()
    Is the debug event handled?
    
    @return: boolean

Help on function is_float in module idc:

is_float(F)

Help on function is_flow in module idc:

is_flow(F)

Help on function is_head in module idc:

is_head(F)

Help on function is_loaded in module idc:

is_loaded(ea)
    Is the byte initialized?

Help on function is_manual0 in module idc:

is_manual0(F)

Help on function is_manual1 in module idc:

is_manual1(F)

Help on function is_mapped in module idc:

is_mapped(ea)

Help on function is_off0 in module idc:

is_off0(F)

Help on function is_off1 in module idc:

is_off1(F)

Help on function is_oword in module idc:

is_oword(F)

Help on function is_pack_real in module idc:

is_pack_real(F)

Help on function is_qword in module idc:

is_qword(F)

Help on function is_seg0 in module idc:

is_seg0(F)

Help on function is_seg1 in module idc:

is_seg1(F)

Help on function is_stkvar0 in module idc:

is_stkvar0(F)

Help on function is_stkvar1 in module idc:

is_stkvar1(F)

Help on function is_strlit in module idc:

is_strlit(F)

Help on function is_stroff0 in module idc:

is_stroff0(F)

Help on function is_stroff1 in module idc:

is_stroff1(F)

Help on function is_struct in module idc:

is_struct(F)

Help on function is_tail in module idc:

is_tail(F)

Help on function is_tbyte in module idc:

is_tbyte(F)

Help on function is_union in module idc:

is_union(sid)
    Is a structure a union?
    
    @param sid: structure type ID
    
    @return: 1: yes, this is a union id
             0: no
    
    @note: Unions are a special kind of structures

Help on function is_unknown in module idc:

is_unknown(F)

Help on function is_valid_trace_file in module ida_dbg:

is_valid_trace_file(*args)
    Is the specified file a valid trace file for the current database?
    
    is_valid_trace_file(filename) -> bool
        @param filename (C++: const char *)

Help on function is_word in module idc:

is_word(F)

Help on function jumpto in module ida_kernwin:

jumpto(*args)
    Jump to the specified address ( 'ui_jumpto' ).
    
    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
        @param ea: destination (C++: ea_t)
        @param opnum: -1: don't change x coord (C++: int)
        @param uijmp_flags: Jump flags (C++: int)
        @return: success
    
    
    jumpto(custom_viewer, place, x, y) -> bool
        custom_viewer: TWidget *
        place: place_t *
        x: int
        y: int
        @return: success

Help on function load_and_run_plugin in module ida_loader:

load_and_run_plugin(*args)
    Load & run a plugin.
    
    load_and_run_plugin(name, arg) -> bool
        @param name (C++: const char *)
        @param arg (C++: size_t)

Help on function load_debugger in module ida_dbg:

load_debugger(*args)
    load_debugger(dbgname, use_remote) -> bool
        @param dbgname (C++: const char *)
        @param use_remote (C++: bool)

Help on function load_trace_file in module ida_dbg:

load_trace_file(*args)
    Load a recorded trace file in the trace window. If the call succeeds
    and 'buf' is not null, the description of the trace stored in the
    binary trace file will be returned in 'buf'
    
    load_trace_file(filename) -> str
        @param filename (C++: const char *)

Help on function loadfile in module idc:

loadfile(filepath, pos, ea, size)

Help on function ltoa in module idc:

ltoa(n, radix)

Help on function make_array in module idc:

make_array(ea, nitems)
    Create an array.
    
    @param ea: linear address
    @param nitems: size of array in items
    
    @note: This function will create an array of the items with the same type as
    the type of the item at 'ea'. If the byte at 'ea' is undefined, then
    this function will create an array of bytes.

Help on function move_segm in module idc:

move_segm(ea, to, flags)
    Move a segment to a new address
    This function moves all information to the new address
    It fixes up address sensitive information in the kernel
    The total effect is equal to reloading the segment to the target address
    
    @param ea: any address within the segment to move
    @param to: new segment start address
    @param flags: combination MFS_... constants
    
    @returns: MOVE_SEGM_... error code

Help on function msg in module ida_kernwin:

msg(*args)
    msg(o) -> PyObject *
    Display an UTF-8 string in the message window
    
    The result of the stringification of the arguments
    will be treated as an UTF-8 string.
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts

Help on function next_addr in module ida_bytes:

next_addr(*args)
    Get next address in the program (i.e. next address which has flags).
    
    next_addr(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if no such address exist.

Help on function next_func_chunk in module idc:

next_func_chunk(funcea, tailea)
    Get the next function chunk of the specified function
    
    @param funcea: any address in the function
    @param tailea: any address in the current chunk
    
    @return: the starting address of the next function chunk or BADADDR
    
    @note: This function returns the next chunk of the specified function

Help on function next_head in module idc:

next_head(ea, maxea=BADADDR)↗
    Get next defined item (instruction or data) in the program
    
    @param ea: linear address to start search from
    @param maxea: the search will stop at the address
        maxea is not included in the search range
    
    @return: BADADDR - no (more) defined items

Help on function next_not_tail in module ida_bytes:

next_not_tail(*args)
    Get address of next non-tail byte.
    
    next_not_tail(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if none exists.

Help on function op_bin in module ida_bytes:

op_bin(*args)
    set op type to 'bin_flag()'
    
    op_bin(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_chr in module ida_bytes:

op_chr(*args)
    set op type to 'char_flag()'
    
    op_chr(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_dec in module ida_bytes:

op_dec(*args)
    set op type to 'dec_flag()'
    
    op_dec(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_enum in module ida_bytes:

op_enum(*args)
    Set operand representation to be 'enum_t'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    op_enum(ea, n, id, serial) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @param id: id of enum (C++: enum_t)
        @param serial: the serial number of the constant in the enumeration,
                       usually 0. the serial numbers are used if the
                       enumeration contains several constants with the same
                       value (C++: uchar)
        @return: success

Help on function op_flt in module ida_bytes:

op_flt(*args)
    set op type to 'flt_flag()'
    
    op_flt(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_hex in module ida_bytes:

op_hex(*args)
    set op type to 'hex_flag()'
    
    op_hex(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function set_forced_operand in module ida_bytes:

set_forced_operand(*args)
    Set forced operand.
    
    set_forced_operand(ea, n, op) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, 2) (C++: int)
        @param op: text of operand   nullptr: do nothing (return 0)   "" :
                   delete forced operand (C++: const char *)
        @return: success

Help on function op_num in module ida_bytes:

op_num(*args)
    set op type to 'num_flag()'
    
    op_num(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_oct in module ida_bytes:

op_oct(*args)
    set op type to 'oct_flag()'
    
    op_oct(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function op_offset in module ida_offset:

op_offset(*args)
    See 'op_offset_ex()'
    
    op_offset(ea, n, type, target=BADADDR, base=0, tdelta=0) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param type (C++: reftype_t)
        @param target (C++: ea_t)
        @param base (C++: ea_t)
        @param tdelta (C++: adiff_t)

Help on function op_offset_high16 in module idc:

op_offset_high16(ea, n, target)
    Convert operand to a high offset
    High offset is the upper 16bits of an offset.
    This type is used by TMS320C6 processors (and probably by other
    RISC processors too)
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands
    @param target: the full value (all 32bits) of the offset

Help on function op_plain_offset in module idc:

op_plain_offset(ea, n, base)
    Convert operand to an offset
    (for the explanations of 'ea' and 'n' please see op_bin())
    
    Example:
    ========
    
        seg000:2000 dw      1234h
    
        and there is a segment at paragraph 0x1000 and there is a data item
        within the segment at 0x1234:
    
        seg000:1234 MyString        db 'Hello, world!',0
    
        Then you need to specify a linear address of the segment base to
        create a proper offset:
    
        op_plain_offset(["seg000",0x2000],0,0x10000);
    
        and you will have:
    
        seg000:2000 dw      offset MyString
    
    Motorola 680x0 processor have a concept of "outer offsets".
    If you want to create an outer offset, you need to combine number
    of the operand with the following bit:
    
    Please note that the outer offsets are meaningful only for
    Motorola 680x0.
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands
    @param base: base of the offset as a linear address
        If base == BADADDR then the current operand becomes non-offset

Help on function op_seg in module ida_bytes:

op_seg(*args)
    Set operand representation to be 'segment'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    op_seg(ea, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: success

Help on function op_stkvar in module ida_bytes:

op_stkvar(*args)
    Set operand representation to be 'stack variable'. Should be applied
    to an instruction within a function. Should be applied after creating
    a stack var using 'insn_t::create_stkvar()' .
    
    op_stkvar(ea, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: success

Help on function op_stroff in module idc:

op_stroff(ea, n, strid, delta)
    Convert operand to an offset in a structure
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands
    @param strid: id of a structure type
    @param delta: struct offset delta. usually 0. denotes the difference
                    between the structure base and the pointer into the structure.

Help on function parse_decl in module idc:

parse_decl(inputtype, flags)
    Parse type declaration
    
    @param inputtype: file name or C declarations (depending on the flags)
    @param flags: combination of PT_... constants or 0
    
    @return: None on failure or (name, type, fields) tuple

Help on function parse_decls in module idc:

parse_decls(inputtype, flags=0)
    Parse type declarations
    
    @param inputtype: file name or C declarations (depending on the flags)
    @param flags: combination of PT_... constants or 0
    
    @return: number of parsing errors (0 no errors)

Help on function patch_byte in module ida_bytes:

patch_byte(*args)
    Patch a byte of the program. The original value of the byte is saved
    and can be obtained by 'get_original_byte()' . This function works for
    wide byte processors too.
    
    patch_byte(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.

Help on function put_dbg_byte in module ida_dbg:

put_dbg_byte(*args)
    Change one byte of the debugged process memory.
    
    put_dbg_byte(ea, x) -> bool
        @param ea: linear address (C++: ea_t)
        @param x: byte value (C++: uint32)
        @return: true if the process memory has been modified

Help on function patch_dword in module ida_bytes:

patch_dword(*args)
    Patch a dword of the program. The original value of the dword is saved
    and can be obtained by 'get_original_dword()' . This function DOESN'T
    work for wide byte processors. This function takes into account order
    of bytes specified in \inf{is_be()}
    
    patch_dword(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.

Help on function patch_qword in module ida_bytes:

patch_qword(*args)
    Patch a qword of the program. The original value of the qword is saved
    and can be obtained by 'get_original_qword()' . This function DOESN'T
    work for wide byte processors. This function takes into account order
    of bytes specified in \inf{is_be()}
    
    patch_qword(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.

Help on function patch_word in module ida_bytes:

patch_word(*args)
    Patch a word of the program. The original value of the word is saved
    and can be obtained by 'get_original_word()' . This function works for
    wide byte processors too. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    patch_word(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.

Help on function plan_and_wait in module idc:

plan_and_wait(sEA, eEA, final_pass=True)
    Perform full analysis of the range
    
    @param sEA: starting linear address
    @param eEA: ending linear address (excluded)
    @param final_pass: make the final pass over the specified range
    
    @return: 1-ok, 0-Ctrl-Break was pressed.

Help on function plan_to_apply_idasgn in module ida_funcs:

plan_to_apply_idasgn(*args)
    Add a signature file to the list of planned signature files.
    
    plan_to_apply_idasgn(fname) -> int
        @param fname: file name. should not contain directory part. (C++:
                      const char *)
        @return: 0 if failed, otherwise number of planned (and applied)
                 signatures

Help on function prev_addr in module ida_bytes:

prev_addr(*args)
    Get previous address in the program.
    
    prev_addr(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if no such address exist.

Help on function prev_head in module idc:

prev_head(ea, minea=0)
    Get previous defined item (instruction or data) in the program
    
    @param ea: linear address to start search from
    @param minea: the search will stop at the address
            minea is included in the search range
    
    @return: BADADDR - no (more) defined items

Help on function prev_not_tail in module ida_bytes:

prev_not_tail(*args)
    Get address of previous non-tail byte.
    
    prev_not_tail(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if none exists.

Help on function print_decls in module idc:

print_decls(ordinals, flags)
    Print types in a format suitable for use in a header file
    
    @param ordinals: comma-separated list of type ordinals
    @param flags: combination of PDF_... constants or 0
    
    @return: string containing the type definitions

Help on instance of _Feature in module __future__:

class _Feature
 |  Methods defined here:
 |  
 |  __init__(self, optionalRelease, mandatoryRelease, compiler_flag)
 |  
 |  __repr__(self)
 |  
 |  getMandatoryRelease(self)
 |      Return release in which this feature will become mandatory.
 |      
 |      This is a 5-tuple, of the same form as sys.version_info, or, if
 |      the feature was dropped, is None.
 |  
 |  getOptionalRelease(self)
 |      Return first release in which this feature was recognized.
 |      
 |      This is a 5-tuple, of the same form as sys.version_info.

Help on function print_insn_mnem in module idc:

print_insn_mnem(ea)
    Get instruction mnemonics
    
    @param ea: linear address of instruction
    
    @return: "" - no instruction at the specified location
    
    @note: this function may not return exactly the same mnemonics
    as you see on the screen.

Help on function print_operand in module idc:

print_operand(ea, n)
    Get operand of an instruction or data
    
    @param ea: linear address of the item
    @param n: number of operand:
        0 - the first operand
        1 - the second operand
    
    @return: the current text representation of operand or ""

Help on function process_config_line in module idc:

process_config_line(directive)
    Obsolete. Please use ida_idp.process_config_directive().

Help on function process_ui_action in module idc:

process_ui_action(name, flags=0)
    Invokes an IDA UI action by name
    
    @param name: Command name
    @param flags: Reserved. Must be zero
    @return: Boolean

Help on function mark_position in module ida_idc:

mark_position(*args)
    mark_position(ea, lnnum, x, y, slot, comment)
        ea: ea_t
        lnnum: int
        x: short
        y: short
        slot: int32
        comment: char const *

Help on function qexit in module ida_pro:

qexit(*args)
    Call qatexit functions, shut down UI and kernel, and exit.
    
    qexit(code)
        @param code: exit code (C++: int)

Help on function qsleep in module idc:

qsleep(milliseconds)
    qsleep the specified number of milliseconds
    This function suspends IDA for the specified amount of time
    
    @param milliseconds: time to sleep

Help on function read_dbg_byte in module idc:

read_dbg_byte(ea)
    Get value of program byte using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function read_dbg_dword in module idc:

read_dbg_dword(ea)
    Get value of program double-word using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function dbg_read_memory in module ida_idd:

dbg_read_memory(*args)
    dbg_read_memory(ea, sz) -> PyObject *
    Reads from the debugee's memory at the specified ea
    @return:
        - The read buffer (as a string)
        - Or None on failure

Help on function read_dbg_qword in module idc:

read_dbg_qword(ea)
    Get value of program quadro-word using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function read_dbg_word in module idc:

read_dbg_word(ea)
    Get value of program word using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function read_selection_end in module idc:

read_selection_end()
    Get end address of the selected range
    
    @return: BADADDR - the user has not selected an range

Help on function read_selection_start in module idc:

read_selection_start()
    Get start address of the selected range
    returns BADADDR - the user has not selected an range

Help on function readlong in module idc:

readlong(handle, mostfirst)

Help on function readshort in module idc:

readshort(handle, mostfirst)

Help on function readstr in module idc:

readstr(handle)

Help on function rebase_program in module ida_segment:

rebase_program(*args)
    Rebase the whole program by 'delta' bytes.
    
    rebase_program(delta, flags) -> int
        @param delta: number of bytes to move the program (C++: adiff_t)
        @param flags: Move segment flags  it is recommended to use
                      MSF_FIXONCE  so that the loader takes care of global
                      variables it stored in the database (C++: int)
        @return: Move segment result codes

Help on function recalc_spd in module ida_frame:

recalc_spd(*args)
    Recalculate SP delta for an instruction that stops execution. The next
    instruction is not reached from the current instruction. We need to
    recalculate SP for the next instruction.This function will create a
    new automatic SP register change point if necessary. It should be
    called from the emulator (emu.cpp) when auto_state == 'AU_USED' if the
    current instruction doesn't pass the execution flow to the next
    instruction.
    
    recalc_spd(cur_ea) -> bool
        @param cur_ea: linear address of the current instruction (C++: ea_t)
        @retval: 1 - new stkpnt is added
        @retval: 0 - nothing is changed

Help on function refresh_debugger_memory in module ida_dbg:

refresh_debugger_memory(*args)
    refresh_debugger_memory() -> PyObject *
    Refreshes the debugger memory
    @return: Nothing

Help on function refresh_idaview_anyway in module ida_kernwin:

refresh_idaview_anyway(*args)
    Refresh all disassembly views ( 'ui_refresh' ), forces an immediate
    refresh. Please consider 'request_refresh()' instead

Help on function refresh_choosers in module ida_kernwin:

refresh_choosers(*args)
    refresh_choosers()

Help on function remove_fchunk in module idc:

remove_fchunk(funcea, tailea)
    Remove a function chunk from the function
    
    @param funcea: any address in the function
    @param tailea: any address in the function chunk to remove
    
    @return: 0 if failed, 1 if success

Help on function rename_array in module idc:

rename_array(array_id, newname)
    Rename array, by its ID.
    
    @param id: The ID of the array to rename.
    @param newname: The new name of the array.
    
    @return: 1 in case of success, 0 otherwise

Help on function rename_entry in module ida_entry:

rename_entry(*args)
    Rename entry point.
    
    rename_entry(ord, name, flags=0) -> bool
        @param ord: ordinal number of the entry point (C++: uval_t)
        @param name: name of entry point. If the specified location already
                     has a name, the old name will be appended to a repeatable
                     comment. (C++: const char *)
        @param flags: See AEF_* (C++: int)
        @return: success

Help on function resume_process in module idc:

resume_process()

Help on function resume_thread in module ida_dbg:

resume_thread(*args)
    Resume thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    resume_thread(tid) -> int
        @param tid: thread id (C++: thid_t)
        @retval: -1 - network error
        @retval: 0 - failed
        @retval: 1 - ok

Help on function retrieve_input_file_md5 in module ida_nalt:

retrieve_input_file_md5(*args)
    Get input file md5.

Help on function rotate_byte in module idc:

rotate_byte(x, count)

Help on function rotate_dword in module idc:

rotate_dword(x, count)

Help on function rotate_left in module idc:

rotate_left(value, count, nbits, offset)
    Rotate a value to the left (or right)
    
    @param value: value to rotate
    @param count: number of times to rotate. negative counter means
                  rotate to the right
    @param nbits: number of bits to rotate
    @param offset: offset of the first bit to rotate
    
    @return: the value with the specified field rotated
             all other bits are not modified

Help on function rotate_word in module idc:

rotate_word(x, count)

Help on function run_to in module ida_dbg:

run_to(*args)
    Execute the process until the given address is reached. If no process
    is active, a new process is started. Technically, the debugger sets up
    a temporary breakpoint at the given address, and continues (or starts)
    the execution of the whole process. So, all threads continue their
    execution! \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_run_to' }
    
    run_to(ea, pid=pid_t(-1), tid=0) -> bool
        @param ea: target address (C++: ea_t)
        @param pid: not used yet. please do not specify this parameter. (C++:
                    pid_t)
        @param tid: not used yet. please do not specify this parameter. (C++:
                    thid_t)

Help on function save_database in module idc:

save_database(idbname, flags=0)
    Save current database to the specified idb file
    
    @param idbname: name of the idb file. if empty, the current idb
                    file will be used.
    @param flags: combination of ida_loader.DBFL_... bits or 0

Help on function save_trace_file in module ida_dbg:

save_trace_file(*args)
    Save the current trace in the specified file.
    
    save_trace_file(filename, description) -> bool
        @param filename (C++: const char *)
        @param description (C++: const char *)

Help on function savefile in module idc:

savefile(filepath, pos, ea, size)

Help on function sel2para in module idc:

sel2para(sel)
    Get a selector value
    
    @param sel: the selector number
    
    @return: selector value if found
             otherwise the input value (sel)
    
    @note: selector values are always in paragraphs

Help on function select_thread in module ida_dbg:

select_thread(*args)
    Select the given thread as the current debugged thread. All thread
    related execution functions will work on this thread. The process must
    be suspended to select a new thread. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    select_thread(tid) -> bool
        @param tid: ID of the thread to select (C++: thid_t)
        @return: false if the thread doesn't exist.

Help on function selector_by_name in module idc:

selector_by_name(segname)
    Get segment selector by name
    
    @param segname: name of segment
    
    @return: segment selector or BADADDR

Help on function send_dbg_command in module idc:

send_dbg_command(cmd)
    Sends a command to the debugger module and returns the output string.
    An exception will be raised if the debugger is not running or the current debugger does not export
    the 'send_dbg_command' IDC command.

Help on function set_array_long in module idc:

set_array_long(array_id, idx, value)
    Sets the long value of an array element.
    
    @param array_id: The array ID.
    @param idx: Index of an element.
    @param value: 32bit or 64bit value to store in the array
    
    @return: 1 in case of success, 0 otherwise

Help on function set_array_params in module idc:

set_array_params(ea, flags, litems, align)
    Set array representation format
    
    @param ea: linear address
    @param flags: combination of AP_... constants or 0
    @param litems: number of items per line. 0 means auto
    @param align: element alignment
                  - -1: do not align
                  - 0:  automatic alignment
                  - other values: element width
    
    @return: 1-ok, 0-failure

Help on function set_array_string in module idc:

set_array_string(array_id, idx, value)
    Sets the string value of an array element.
    
    @param array_id: The array ID.
    @param idx: Index of an element.
    @param value: String value to store in the array
    
    @return: 1 in case of success, 0 otherwise

Help on function set_bmask_cmt in module idc:

set_bmask_cmt(enum_id, bmask, cmt, repeatable)
    Set bitmask comment (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    @param cmt: comment
    repeatable - type of comment, 0-regular, 1-repeatable
    
    @return: 1-ok, 0-failed

Help on function set_bmask_name in module idc:

set_bmask_name(enum_id, bmask, name)
    Set bitmask name (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    @param name: name of bitmask
    
    @return: 1-ok, 0-failed

Help on function set_bpt_attr in module idc:

set_bpt_attr(address, bptattr, value)
        modifiable characteristics of a breakpoint
    
    @param address: any address in the breakpoint range
    @param bptattr: the attribute code, one of BPTATTR_* constants
                    BPTATTR_CND is not allowed, see set_bpt_cond()
    @param value: the attibute value
    
    @return: success

Help on function set_bpt_cond in module idc:

set_bpt_cond(ea, cnd, is_lowcnd=0)
    Set breakpoint condition
    
    @param ea: any address in the breakpoint range
    @param cnd: breakpoint condition
    @param is_lowcnd: 0 - regular condition, 1 - low level condition
    
    @return: success

Help on function set_cmt in module ida_bytes:

set_cmt(*args)
    Set an indented comment.
    
    set_cmt(ea, comm, rptble) -> bool
        @param ea: linear address (C++: ea_t)
        @param comm: comment string   nullptr: do nothing (return 0)   "" :
                     delete comment (C++: const char *)
        @param rptble: is repeatable? (C++: bool)
        @return: success

Help on function set_color in module idc:

set_color(ea, what, color)
    Set item color
    
    @param ea: address of the item
    @param what: type of the item (one of CIC_* constants)
    @param color: new color code in RGB (hex 0xBBGGRR)
    
    @return: success (True or False)

Help on function set_debugger_event_cond in module ida_dbg:

set_debugger_event_cond(*args)
    set_debugger_event_cond(evcond)
        @param evcond (C++: const char *)

Help on function set_debugger_options in module ida_dbg:

set_debugger_options(*args)
    Set debugger options. Replaces debugger options with the specification
    combination 'Debugger options'
    
    set_debugger_options(options) -> uint
        @param options (C++: uint)
        @return: the old debugger options

Help on function set_default_sreg_value in module idc:

set_default_sreg_value(ea, reg, value)
    Set default segment register value for a segment
    
    @param ea: any address in the segment
               if no segment is present at the specified address
               then all segments will be affected
    @param reg: name of segment register
    @param value: default value of the segment register. -1-undefined.

Help on function set_enum_bf in module ida_enum:

set_enum_bf(*args)
    Set 'bitfield' bit of enum (i.e. convert it to a bitfield)
    
    set_enum_bf(id, bf) -> bool
        @param id (C++: enum_t)
        @param bf (C++: bool)

Help on function set_enum_cmt in module ida_enum:

set_enum_cmt(*args)
    Set comment for enum type.
    
    set_enum_cmt(id, cmt, repeatable) -> bool
        @param id (C++: enum_t)
        @param cmt (C++: const char *)
        @param repeatable (C++: bool)

Help on function set_enum_flag in module ida_enum:

set_enum_flag(*args)
    Set data representation flags.
    
    set_enum_flag(id, flag) -> bool
        @param id (C++: enum_t)
        @param flag (C++: flags_t)

Help on function set_enum_idx in module ida_enum:

set_enum_idx(*args)
    Set serial number of enum. Also see 'get_enum_idx()' .
    
    set_enum_idx(id, idx) -> bool
        @param id (C++: enum_t)
        @param idx (C++: size_t)

Help on function set_enum_member_cmt in module ida_enum:

set_enum_member_cmt(*args)
    Set comment for enum member.
    
    set_enum_member_cmt(id, cmt, repeatable) -> bool
        @param id (C++: const_t)
        @param cmt (C++: const char *)
        @param repeatable (C++: bool)

Help on function set_enum_member_name in module ida_enum:

set_enum_member_name(*args)
    Set name of enum member.
    
    set_enum_member_name(id, name) -> bool
        @param id (C++: const_t)
        @param name (C++: const char *)

Help on function set_enum_name in module ida_enum:

set_enum_name(*args)
    Set name of enum type.
    
    set_enum_name(id, name) -> bool
        @param id (C++: enum_t)
        @param name (C++: const char *)

Help on function set_enum_width in module ida_enum:

set_enum_width(*args)
    See comment for 'get_enum_width()'
    
    set_enum_width(id, width) -> bool
        @param id (C++: enum_t)
        @param width (C++: int)

Help on function set_fchunk_attr in module idc:

set_fchunk_attr(ea, attr, value)
    Set a function chunk attribute
    
    @param ea: any address in the chunk
    @param attr: only FUNCATTR_START, FUNCATTR_END, FUNCATTR_OWNER
    @param value: desired value
    
    @return: 0 if failed, 1 if success

Help on function set_fixup in module idc:

set_fixup(ea, fixuptype, fixupflags, targetsel, targetoff, displ)
    Set fixup information
    
    @param ea: address to set fixup information about
    @param fixuptype:  fixup type. see get_fixup_target_type()
                       for possible fixup types.
    @param fixupflags: fixup flags. see get_fixup_target_flags()
                       for possible fixup types.
    @param targetsel:  target selector
    @param targetoff:  target offset
    @param displ:      displacement
    
    @return:        none

Help on function set_flag in module idc:

set_flag(off, bit, value)
    #--------------------------------------------------------------------------

Help on function set_frame_size in module idc:

set_frame_size(ea, lvsize, frregs, argsize)
    Make function frame
    
    @param ea: any address belonging to the function
    @param lvsize: size of function local variables
    @param frregs: size of saved registers
    @param argsize: size of function arguments
    
    @return: ID of function frame or -1
             If the function did not have a frame, the frame
             will be created. Otherwise the frame will be modified

Help on function set_func_attr in module idc:

set_func_attr(ea, attr, value)
    Set a function attribute
    
    @param ea: any address belonging to the function
    @param attr: one of FUNCATTR_... constants
    @param value: new value of the attribute
    
    @return: 1-ok, 0-failed

Help on function set_func_cmt in module idc:

set_func_cmt(ea, cmt, repeatable)
    Set function comment
    
    @param ea: any address belonging to the function
    @param cmt: a function comment line
    @param repeatable: 1: get repeatable comment
            0: get regular comment

Help on function set_func_end in module ida_funcs:

set_func_end(*args)
    Move function chunk end address.
    
    set_func_end(ea, newend) -> bool
        @param ea: any address in the function (C++: ea_t)
        @param newend: new end address of the function (C++: ea_t)
        @return: success

Help on function set_func_flags in module idc:

set_func_flags(ea, flags)
    Change function flags
    
    @param ea: any address belonging to the function
    @param flags: see get_func_flags() for explanations
    
    @return: !=0 - ok

Help on function set_hash_long in module idc:

set_hash_long(hash_id, key, value)
    Sets the long value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    @param value: 32bit or 64bit value to store in the hash
    
    @return: 1 in case of success, 0 otherwise

Help on function set_hash_string in module idc:

set_hash_string(hash_id, key, value)
    Sets the string value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    @param value: string value to store in the hash
    
    @return: 1 in case of success, 0 otherwise

Help on function set_ida_state in module ida_auto:

set_ida_state(*args)
    Change IDA status indicator value
    
    set_ida_state(st) -> idastate_t
        @param st: - new indicator status (C++: idastate_t)
        @return: old indicator status

Help on function set_inf_attr in module idc:

set_inf_attr(attr, value)
    Deprecated. Please ida_ida.inf_set_* instead.

Help on function set_local_type in module idc:

set_local_type(ordinal, input, flags)
    Parse one type declaration and store it in the specified slot
    
    @param ordinal:  slot number (1...NumberOfLocalTypes)
                     -1 means allocate new slot or reuse the slot
                     of the existing named type
    @param input:  C declaration. Empty input empties the slot
    @param flags:  combination of PT_... constants or 0
    
    @return: slot number or 0 if error

Help on function set_manual_insn in module ida_bytes:

set_manual_insn(*args)
    Set manual instruction string.
    
    set_manual_insn(ea, manual_insn)
        @param ea: linear address of the instruction or data item (C++: ea_t)
        @param manual_insn: "" - delete manual string. nullptr - do nothing
                            (C++: const char *)

Help on function set_member_cmt in module idc:

set_member_cmt(sid, member_offset, comment, repeatable)
    Change structure member comment
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    @param comment: new comment of the structure member
    @param repeatable: 1: change repeatable comment
                       0: change regular comment
    
    @return: != 0 - ok

Help on function set_member_name in module idc:

set_member_name(sid, member_offset, name)
    Change structure member name
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    @param name: new name of the member
    
    @return: != 0 - ok.

Help on function set_member_type in module idc:

set_member_type(sid, member_offset, flag, typeid, nitems, target=-1, tdelta=0, reftype=2)
    Change structure member type
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    @param flag: new type of the member. Should be one of
                 FF_BYTE..FF_PACKREAL (see above) combined with FF_DATA
    @param typeid: if is_struct(flag) then typeid specifies the structure id for the member
                   if is_off0(flag) then typeid specifies the offset base.
                   if is_strlit(flag) then typeid specifies the string type (STRTYPE_...).
                   if is_stroff(flag) then typeid specifies the structure id
                   if is_enum(flag) then typeid specifies the enum id
                   if is_custom(flags) then typeid specifies the dtid and fid: dtid|(fid<<16)
                   Otherwise typeid should be -1.
    @param nitems: number of items in the member
    
    @param target: target address of the offset expr. You may specify it as
                   -1, ida will calculate it itself
    @param tdelta: offset target delta. usually 0
    @param reftype: see REF_... definitions
    
    @note: The remaining arguments are allowed only if is_off0(flag) and you want
           to specify a complex offset expression
    
    @return: !=0 - ok.

Help on function set_name in module idc:

set_name(ea, name, flags=0)
    Rename an address
    
    @param ea: linear address
    @param name: new name of address. If name == "", then delete old name
    @param flags: combination of SN_... constants
    
    @return: 1-ok, 0-failure

Help on function set_processor_type in module ida_idp:

set_processor_type(*args)
    Set target processor type. Once a processor module is loaded, it
    cannot be replaced until we close the idb.
    
    set_processor_type(procname, level) -> bool
        @param procname: name of processor type (one of names present in
                         \ph{psnames}) (C++: const char *)
        @param level: SETPROC_ (C++: setproc_level_t)
        @return: success

Help on function set_reg_value in module idc:

set_reg_value(value, name)
    Set register value
    
    @param name: the register name
    @param value: new register value
    
    @note: The debugger should be running
           It is not necessary to use this function to set register values.
           A register name in the left side of an assignment will do too.

Help on function set_remote_debugger in module ida_dbg:

set_remote_debugger(*args)
    Set remote debugging options. Should be used before starting the
    debugger.
    
    set_remote_debugger(host, _pass, port=-1)
        @param host: If empty, IDA will use local debugger. If NULL, the host
                     will not be set. (C++: const char *)
        pass: char const *
        @param port: If -1, the default port number will be used (C++: int)

Help on function set_root_filename in module ida_nalt:

set_root_filename(*args)
    Set full path of the input file.
    
    set_root_filename(file)
        @param file (C++: const char *)

Help on function set_segm_addressing in module idc:

set_segm_addressing(ea, bitness)
    Change segment addressing
    
    @param ea: any address in the segment
    @param bitness: 0: 16bit, 1: 32bit, 2: 64bit
    
    @return: success (boolean)

Help on function set_segm_alignment in module idc:

set_segm_alignment(ea, alignment)
    Change alignment of the segment
    
    @param ea: any address in the segment
    @param alignment: new alignment of the segment (one of the sa... constants)
    
    @return: success (boolean)

Help on function set_segm_attr in module idc:

set_segm_attr(segea, attr, value)
    Set segment attribute
    
    @param segea: any address within segment
    @param attr: one of SEGATTR_... constants
    
    @note: Please note that not all segment attributes are modifiable.
           Also some of them should be modified using special functions
           like set_segm_addressing, etc.

Help on function set_segm_class in module idc:

set_segm_class(ea, segclass)
    Change class of the segment
    
    @param ea: any address in the segment
    @param segclass: new class of the segment
    
    @return: success (boolean)

Help on function set_segm_combination in module idc:

set_segm_combination(segea, comb)
    Change combination of the segment
    
    @param segea: any address in the segment
    @param comb: new combination of the segment (one of the sc... constants)
    
    @return: success (boolean)

Help on function set_segm_name in module idc:

set_segm_name(ea, name)
    Change name of the segment
    
    @param ea: any address in the segment
    @param name: new name of the segment
    
    @return: success (boolean)

Help on function set_segm_type in module idc:

set_segm_type(segea, segtype)
    Set segment type
    
    @param segea: any address within segment
    @param segtype: new segment type:
    
    @return: !=0 - ok

Help on function set_segment_bounds in module idc:

set_segment_bounds(ea, startea, endea, flags)
    Change segment boundaries
    
    @param ea: any address in the segment
    @param startea: new start address of the segment
    @param endea: new end address of the segment
    @param flags: combination of SEGMOD_... flags
    
    @return: boolean success

Help on function set_selector in module ida_segment:

set_selector(*args)
    Set mapping of selector to a paragraph. You should call this
    functionbeforecreating a segment which uses the selector, otherwise
    the creation of the segment will fail.
    
    set_selector(selector, paragraph) -> int
        @param selector: number of selector to map   if selector ==  BADSEL ,
                         then return 0 (fail)   if the selector has had a
                         mapping, old mapping is destroyed   if the selector
                         number is equal to paragraph value, then the mapping
                         is destroyed because we don't need to keep trivial
                         mappings. (C++: sel_t)
        @param paragraph: paragraph to map selector (C++: ea_t)
        @retval: 1 - ok
        @retval: 0 - failure (bad selector or too many mappings)

Help on function set_source_linnum in module ida_nalt:

set_source_linnum(*args)
    set_source_linnum(ea, lnnum)
        @param ea (C++: ea_t)
        @param lnnum (C++: uval_t)

Help on function set_step_trace_options in module ida_dbg:

set_step_trace_options(*args)
    Modify step tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    set_step_trace_options(options)
        @param options (C++: int)

Help on function change_storage_type in module ida_bytes:

change_storage_type(*args)
    Change flag storage type for address range.
    
    change_storage_type(start_ea, end_ea, stt) -> error_t
        @param start_ea: should be lower than end_ea. (C++: ea_t)
        @param end_ea: does not belong to the range. (C++: ea_t)
        @param stt: storage_type_t (C++: storage_type_t)
        @return: error code

Help on function set_struc_cmt in module ida_struct:

set_struc_cmt(*args)
    Set structure comment.
    
    set_struc_cmt(id, cmt, repeatable) -> bool
        @param id (C++: tid_t)
        @param cmt (C++: const char *)
        @param repeatable (C++: bool)

Help on function set_struc_idx in module idc:

set_struc_idx(sid, index)
    Change structure index
    
    @param sid: structure type ID
    @param index: new index of the structure
    
    @return: != 0 - ok
    
    @note: See get_first_struc_idx() for the explanation of
           structure indices and IDs.

Help on function set_struc_name in module ida_struct:

set_struc_name(*args)
    Set structure name.
    
    set_struc_name(id, name) -> bool
        @param id (C++: tid_t)
        @param name (C++: const char *)

Help on function set_tail_owner in module idc:

set_tail_owner(tailea, funcea)
    Change the function chunk owner
    
    @param tailea: any address in the function chunk
    @param funcea: the starting address of the new owner
    
    @return: False if failed, True if success
    
    @note: The new owner must already have the chunk appended before the call

Help on function set_target_assembler in module ida_idp:

set_target_assembler(*args)
    Set target assembler.
    
    set_target_assembler(asmnum) -> bool
        @param asmnum: number of assembler in the current processor module
                       (C++: int)
        @return: success

Help on function set_trace_file_desc in module ida_dbg:

set_trace_file_desc(*args)
    Change the description of the specified trace file.
    
    set_trace_file_desc(filename, description) -> bool
        @param filename (C++: const char *)
        @param description (C++: const char *)

Help on function split_sreg_range in module idc:

split_sreg_range(ea, reg, value, tag=2)
    Set value of a segment register.
    
    @param ea: linear address
    @param reg: name of a register, like "cs", "ds", "es", etc.
    @param value: new value of the segment register.
    @param tag: of SR_... constants
    
    @note: IDA keeps tracks of all the points where segment register change their
           values. This function allows you to specify the correct value of a segment
           register if IDA is not able to find the corrent value.

Help on function start_process in module ida_dbg:

start_process(*args)
    Start a process in the debugger. \sq{Type, Asynchronous function -
    available as Request, Notification, 'dbg_process_start' }You can also
    use the 'run_to()' function to easily start the execution of a process
    until a given address is reached.For all parameters, a NULL value
    indicates the debugger will take the value from the defined Process
    Options.
    
    start_process(path=None, args=None, sdir=None) -> int
        @param path: path to the executable to start (C++: const char *)
        @param args: arguments to pass to process (C++: const char *)
        @param sdir: starting directory for the process (C++: const char *)
        @retval: -1 - impossible to create the process
        @retval: 0 - the starting of the process was cancelled by the user
        @retval: 1 - the process was properly started

Help on function step_into in module ida_dbg:

step_into(*args)
    Execute one instruction in the current thread. Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_into' }

Help on function step_over in module ida_dbg:

step_over(*args)
    Execute one instruction in the current thread, but without entering
    into functions. Others threads keep suspended. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_step_over' }

Help on function step_until_ret in module ida_dbg:

step_until_ret(*args)
    Execute instructions in the current thread until a function return
    instruction is executed (aka "step out"). Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_until_ret' }

Help on function strlen in module idc:

strlen(s)

Help on function strstr in module idc:

strstr(s1, s2)

Help on function substr in module idc:

substr(s, x1, x2)

Help on function suspend_process in module ida_dbg:

suspend_process(*args)
    Suspend the process in the debugger. \sq{ Type,Synchronous function
    (if in a notification handler)Asynchronous function (everywhere
    else)available as Request, Notification,none (if in a notification
    handler) 'dbg_suspend_process' (everywhere else) }The
    'suspend_process()' function can be called from a notification handler
    to force the stopping of the process. In this case, no notification
    will be generated. When you suspend a process, the running command is
    always aborted.

Help on function suspend_thread in module ida_dbg:

suspend_thread(*args)
    Suspend thread. Suspending a thread may deadlock the whole application
    if the suspended was owning some synchronization objects. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    suspend_thread(tid) -> int
        @param tid: thread id (C++: thid_t)
        @retval: -1 - network error
        @retval: 0 - failed
        @retval: 1 - ok

Help on function take_memory_snapshot in module ida_segment:

take_memory_snapshot(*args)
    Take a memory snapshot of the running process.
    
    take_memory_snapshot(only_loader_segs) -> bool
        @param only_loader_segs: only is_loader_segm() segments will be
                                 affected (C++: bool)
        @return: success

Help on function to_ea in module idc:

to_ea(seg, off)
    Return value of expression: ((seg<<4) + off)

Help on function toggle_bnot in module idc:

toggle_bnot(ea, n)
    Toggle the bitwise not operator for the operand
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands

Help on function toggle_sign in module ida_bytes:

toggle_sign(*args)
    Toggle sign of n-th operand. allowed values of n: 0-first operand,
    1-other operands
    
    toggle_sign(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)

Help on function update_extra_cmt in module ida_lines:

update_extra_cmt(*args)
    update_extra_cmt(ea, what, str)
        ea: ea_t
        what: int
        str: char const *

Help on function update_hidden_range in module idc:

update_hidden_range(ea, visible)
    Set hidden range state
    
    @param ea:      any address belonging to the hidden range
    @param visible: new state of the range
    
    @return: != 0 - ok

Help on function validate_idb_names in module idc:

validate_idb_names(do_repair=0)
    check consistency of IDB name records
    @param do_repair: try to repair netnode header it TRUE
    @return: number of inconsistent name records

Help on function value_is_float in module idc:

value_is_float(var)

Help on function value_is_func in module idc:

value_is_func(var)

Help on function value_is_int64 in module idc:

value_is_int64(var)

Help on function value_is_long in module idc:

value_is_long(var)

Help on function value_is_pvoid in module idc:

value_is_pvoid(var)

Help on function value_is_string in module idc:

value_is_string(var)
    #         List of built-in functions
    #         --------------------------
    #
    # The following conventions are used in this list:
    #   'ea' is a linear address
    #   'success' is 0 if a function failed, 1 otherwise
    #   'void' means that function returns no meaningful value (always 0)
    #
    #  All function parameter conversions are made automatically.
    #
    # ----------------------------------------------------------------------------
    #                       M I S C E L L A N E O U S
    # ----------------------------------------------------------------------------

Help on function wait_for_next_event in module ida_dbg:

wait_for_next_event(*args)
    Wait for the next event.This function (optionally) resumes the process
    execution, and waits for a debugger event until a possible timeout
    occurs.
    
    wait_for_next_event(wfne, timeout) -> dbg_event_code_t
        @param wfne: combination of  Wait for debugger event flags  constants
                     (C++: int)
        @param timeout: number of seconds to wait, -1-infinity (C++: int)
        @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <=
                 0)

Help on function warning in module ida_kernwin:

warning(*args)
    warning(format)
    Display a message in a message box
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts
    The user will be able to hide messages if they appear twice in a row on
    the screen

Help on function write_dbg_memory in module idc:

write_dbg_memory(ea, data)
    Write to debugger memory.
    
    @param ea: linear address
    @param data: string to write
    @return: number of written bytes (-1 - network/debugger error)
    
    Thread-safe function (may be called only from the main thread and debthread)

Help on function writelong in module idc:

writelong(handle, dword, mostfirst)

Help on function writeshort in module idc:

writeshort(handle, word, mostfirst)

Help on function writestr in module idc:

writestr(handle, s)

Help on function xtol in module idc:

xtol(s)

